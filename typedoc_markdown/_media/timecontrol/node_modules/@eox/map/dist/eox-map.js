const X0 = globalThis, Ha = X0.ShadowRoot && (X0.ShadyCSS === void 0 || X0.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, m1 = Symbol(), yh = /* @__PURE__ */ new WeakMap();
let F3 = class {
  constructor(t, e, n) {
    if (this._$cssResult$ = !0, n !== m1) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (Ha && t === void 0) {
      const n = e !== void 0 && e.length === 1;
      n && (t = yh.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), n && yh.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const O3 = (i) => new F3(typeof i == "string" ? i : i + "", void 0, m1), G3 = (i, t) => {
  if (Ha) i.adoptedStyleSheets = t.map(((e) => e instanceof CSSStyleSheet ? e : e.styleSheet));
  else for (const e of t) {
    const n = document.createElement("style"), r = X0.litNonce;
    r !== void 0 && n.setAttribute("nonce", r), n.textContent = e.cssText, i.appendChild(n);
  }
}, vh = Ha ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const n of t.cssRules) e += n.cssText;
  return O3(e);
})(i) : i;
const { is: N3, defineProperty: D3, getOwnPropertyDescriptor: z3, getOwnPropertyNames: j3, getOwnPropertySymbols: U3, getPrototypeOf: B3 } = Object, Do = globalThis, xh = Do.trustedTypes, V3 = xh ? xh.emptyScript : "", $3 = Do.reactiveElementPolyfillSupport, ys = (i, t) => i, ha = { toAttribute(i, t) {
  switch (t) {
    case Boolean:
      i = i ? V3 : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, t) {
  let e = i;
  switch (t) {
    case Boolean:
      e = i !== null;
      break;
    case Number:
      e = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(i);
      } catch {
        e = null;
      }
  }
  return e;
} }, p1 = (i, t) => !N3(i, t), Ch = { attribute: !0, type: String, converter: ha, reflect: !1, useDefault: !1, hasChanged: p1 };
Symbol.metadata ??= Symbol("metadata"), Do.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
let er = class extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ??= []).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = Ch) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(t) && ((e = Object.create(e)).wrapped = !0), this.elementProperties.set(t, e), !e.noAccessor) {
      const n = Symbol(), r = this.getPropertyDescriptor(t, n, e);
      r !== void 0 && D3(this.prototype, t, r);
    }
  }
  static getPropertyDescriptor(t, e, n) {
    const { get: r, set: s } = z3(this.prototype, t) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get: r, set(o) {
      const a = r?.call(this);
      s?.call(this, o), this.requestUpdate(t, a, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? Ch;
  }
  static _$Ei() {
    if (this.hasOwnProperty(ys("elementProperties"))) return;
    const t = B3(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(ys("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(ys("properties"))) {
      const e = this.properties, n = [...j3(e), ...U3(e)];
      for (const r of n) this.createProperty(r, e[r]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0) for (const [n, r] of e) this.elementProperties.set(n, r);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, n] of this.elementProperties) {
      const r = this._$Eu(e, n);
      r !== void 0 && this._$Eh.set(r, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const n = new Set(t.flat(1 / 0).reverse());
      for (const r of n) e.unshift(vh(r));
    } else t !== void 0 && e.push(vh(t));
    return e;
  }
  static _$Eu(t, e) {
    const n = e.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise(((t) => this.enableUpdating = t)), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach(((t) => t(this)));
  }
  addController(t) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t), this.renderRoot !== void 0 && this.isConnected && t.hostConnected?.();
  }
  removeController(t) {
    this._$EO?.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const n of e.keys()) this.hasOwnProperty(n) && (t.set(n, this[n]), delete this[n]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return G3(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach(((t) => t.hostConnected?.()));
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    this._$EO?.forEach(((t) => t.hostDisconnected?.()));
  }
  attributeChangedCallback(t, e, n) {
    this._$AK(t, n);
  }
  _$ET(t, e) {
    const n = this.constructor.elementProperties.get(t), r = this.constructor._$Eu(t, n);
    if (r !== void 0 && n.reflect === !0) {
      const s = (n.converter?.toAttribute !== void 0 ? n.converter : ha).toAttribute(e, n.type);
      this._$Em = t, s == null ? this.removeAttribute(r) : this.setAttribute(r, s), this._$Em = null;
    }
  }
  _$AK(t, e) {
    const n = this.constructor, r = n._$Eh.get(t);
    if (r !== void 0 && this._$Em !== r) {
      const s = n.getPropertyOptions(r), o = typeof s.converter == "function" ? { fromAttribute: s.converter } : s.converter?.fromAttribute !== void 0 ? s.converter : ha;
      this._$Em = r;
      const a = o.fromAttribute(e, s.type);
      this[r] = a ?? this._$Ej?.get(r) ?? a, this._$Em = null;
    }
  }
  requestUpdate(t, e, n) {
    if (t !== void 0) {
      const r = this.constructor, s = this[t];
      if (n ??= r.getPropertyOptions(t), !((n.hasChanged ?? p1)(s, e) || n.useDefault && n.reflect && s === this._$Ej?.get(t) && !this.hasAttribute(r._$Eu(t, n)))) return;
      this.C(t, e, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(t, e, { useDefault: n, reflect: r, wrapped: s }, o) {
    n && !(this._$Ej ??= /* @__PURE__ */ new Map()).has(t) && (this._$Ej.set(t, o ?? e ?? this[t]), s !== !0 || o !== void 0) || (this._$AL.has(t) || (this.hasUpdated || n || (e = void 0), this._$AL.set(t, e)), r === !0 && this._$Em !== t && (this._$Eq ??= /* @__PURE__ */ new Set()).add(t));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [r, s] of this._$Ep) this[r] = s;
        this._$Ep = void 0;
      }
      const n = this.constructor.elementProperties;
      if (n.size > 0) for (const [r, s] of n) {
        const { wrapped: o } = s, a = this[r];
        o !== !0 || this._$AL.has(r) || a === void 0 || this.C(r, void 0, s, a);
      }
    }
    let t = !1;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), this._$EO?.forEach(((n) => n.hostUpdate?.())), this.update(e)) : this._$EM();
    } catch (n) {
      throw t = !1, this._$EM(), n;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    this._$EO?.forEach(((e) => e.hostUpdated?.())), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Eq &&= this._$Eq.forEach(((e) => this._$ET(e, this[e]))), this._$EM();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
er.elementStyles = [], er.shadowRootOptions = { mode: "open" }, er[ys("elementProperties")] = /* @__PURE__ */ new Map(), er[ys("finalized")] = /* @__PURE__ */ new Map(), $3?.({ ReactiveElement: er }), (Do.reactiveElementVersions ??= []).push("2.1.1");
const Ka = globalThis, no = Ka.trustedTypes, bh = no ? no.createPolicy("lit-html", { createHTML: (i) => i }) : void 0, _1 = "$lit$", Fi = `lit$${Math.random().toFixed(9).slice(2)}$`, y1 = "?" + Fi, W3 = `<${y1}>`, Sn = document, As = () => Sn.createComment(""), Fs = (i) => i === null || typeof i != "object" && typeof i != "function", qa = Array.isArray, Y3 = (i) => qa(i) || typeof i?.[Symbol.iterator] == "function", v2 = `[ 	
\f\r]`, Qr = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, wh = /-->/g, Eh = />/g, ln = RegExp(`>|${v2}(?:([^\\s"'>=/]+)(${v2}*=${v2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Sh = /'/g, Mh = /"/g, v1 = /^(?:script|style|textarea|title)$/i, X3 = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e }), gn = X3(1), Sr = Symbol.for("lit-noChange"), kt = Symbol.for("lit-nothing"), Th = /* @__PURE__ */ new WeakMap(), mn = Sn.createTreeWalker(Sn, 129);
function x1(i, t) {
  if (!qa(i) || !i.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return bh !== void 0 ? bh.createHTML(t) : t;
}
const Z3 = (i, t) => {
  const e = i.length - 1, n = [];
  let r, s = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", o = Qr;
  for (let a = 0; a < e; a++) {
    const l = i[a];
    let h, c, d = -1, u = 0;
    for (; u < l.length && (o.lastIndex = u, c = o.exec(l), c !== null); ) u = o.lastIndex, o === Qr ? c[1] === "!--" ? o = wh : c[1] !== void 0 ? o = Eh : c[2] !== void 0 ? (v1.test(c[2]) && (r = RegExp("</" + c[2], "g")), o = ln) : c[3] !== void 0 && (o = ln) : o === ln ? c[0] === ">" ? (o = r ?? Qr, d = -1) : c[1] === void 0 ? d = -2 : (d = o.lastIndex - c[2].length, h = c[1], o = c[3] === void 0 ? ln : c[3] === '"' ? Mh : Sh) : o === Mh || o === Sh ? o = ln : o === wh || o === Eh ? o = Qr : (o = ln, r = void 0);
    const f = o === ln && i[a + 1].startsWith("/>") ? " " : "";
    s += o === Qr ? l + W3 : d >= 0 ? (n.push(h), l.slice(0, d) + _1 + l.slice(d) + Fi + f) : l + Fi + (d === -2 ? a : f);
  }
  return [x1(i, s + (i[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), n];
};
class Os {
  constructor({ strings: t, _$litType$: e }, n) {
    let r;
    this.parts = [];
    let s = 0, o = 0;
    const a = t.length - 1, l = this.parts, [h, c] = Z3(t, e);
    if (this.el = Os.createElement(h, n), mn.currentNode = this.el.content, e === 2 || e === 3) {
      const d = this.el.content.firstChild;
      d.replaceWith(...d.childNodes);
    }
    for (; (r = mn.nextNode()) !== null && l.length < a; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes()) for (const d of r.getAttributeNames()) if (d.endsWith(_1)) {
          const u = c[o++], f = r.getAttribute(d).split(Fi), g = /([.?@])?(.*)/.exec(u);
          l.push({ type: 1, index: s, name: g[2], strings: f, ctor: g[1] === "." ? K3 : g[1] === "?" ? q3 : g[1] === "@" ? J3 : zo }), r.removeAttribute(d);
        } else d.startsWith(Fi) && (l.push({ type: 6, index: s }), r.removeAttribute(d));
        if (v1.test(r.tagName)) {
          const d = r.textContent.split(Fi), u = d.length - 1;
          if (u > 0) {
            r.textContent = no ? no.emptyScript : "";
            for (let f = 0; f < u; f++) r.append(d[f], As()), mn.nextNode(), l.push({ type: 2, index: ++s });
            r.append(d[u], As());
          }
        }
      } else if (r.nodeType === 8) if (r.data === y1) l.push({ type: 2, index: s });
      else {
        let d = -1;
        for (; (d = r.data.indexOf(Fi, d + 1)) !== -1; ) l.push({ type: 7, index: s }), d += Fi.length - 1;
      }
      s++;
    }
  }
  static createElement(t, e) {
    const n = Sn.createElement("template");
    return n.innerHTML = t, n;
  }
}
function Mr(i, t, e = i, n) {
  if (t === Sr) return t;
  let r = n !== void 0 ? e._$Co?.[n] : e._$Cl;
  const s = Fs(t) ? void 0 : t._$litDirective$;
  return r?.constructor !== s && (r?._$AO?.(!1), s === void 0 ? r = void 0 : (r = new s(i), r._$AT(i, e, n)), n !== void 0 ? (e._$Co ??= [])[n] = r : e._$Cl = r), r !== void 0 && (t = Mr(i, r._$AS(i, t.values), r, n)), t;
}
let H3 = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: n } = this._$AD, r = (t?.creationScope ?? Sn).importNode(e, !0);
    mn.currentNode = r;
    let s = mn.nextNode(), o = 0, a = 0, l = n[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let h;
        l.type === 2 ? h = new Ja(s, s.nextSibling, this, t) : l.type === 1 ? h = new l.ctor(s, l.name, l.strings, this, t) : l.type === 6 && (h = new Q3(s, this, t)), this._$AV.push(h), l = n[++a];
      }
      o !== l?.index && (s = mn.nextNode(), o++);
    }
    return mn.currentNode = Sn, r;
  }
  p(t) {
    let e = 0;
    for (const n of this._$AV) n !== void 0 && (n.strings !== void 0 ? (n._$AI(t, n, e), e += n.strings.length - 2) : n._$AI(t[e])), e++;
  }
}, Ja = class C1 {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t, e, n, r) {
    this.type = 2, this._$AH = kt, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = n, this.options = r, this._$Cv = r?.isConnected ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && t?.nodeType === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = Mr(this, t, e), Fs(t) ? t === kt || t == null || t === "" ? (this._$AH !== kt && this._$AR(), this._$AH = kt) : t !== this._$AH && t !== Sr && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Y3(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== kt && Fs(this._$AH) ? this._$AA.nextSibling.data = t : this.T(Sn.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    const { values: e, _$litType$: n } = t, r = typeof n == "number" ? this._$AC(t) : (n.el === void 0 && (n.el = Os.createElement(x1(n.h, n.h[0]), this.options)), n);
    if (this._$AH?._$AD === r) this._$AH.p(e);
    else {
      const s = new H3(r, this), o = s.u(this.options);
      s.p(e), this.T(o), this._$AH = s;
    }
  }
  _$AC(t) {
    let e = Th.get(t.strings);
    return e === void 0 && Th.set(t.strings, e = new Os(t)), e;
  }
  k(t) {
    qa(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let n, r = 0;
    for (const s of t) r === e.length ? e.push(n = new C1(this.O(As()), this.O(As()), this, this.options)) : n = e[r], n._$AI(s), r++;
    r < e.length && (this._$AR(n && n._$AB.nextSibling, r), e.length = r);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    for (this._$AP?.(!1, !0, e); t !== this._$AB; ) {
      const n = t.nextSibling;
      t.remove(), t = n;
    }
  }
  setConnected(t) {
    this._$AM === void 0 && (this._$Cv = t, this._$AP?.(t));
  }
};
class zo {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, n, r, s) {
    this.type = 1, this._$AH = kt, this._$AN = void 0, this.element = t, this.name = e, this._$AM = r, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = kt;
  }
  _$AI(t, e = this, n, r) {
    const s = this.strings;
    let o = !1;
    if (s === void 0) t = Mr(this, t, e, 0), o = !Fs(t) || t !== this._$AH && t !== Sr, o && (this._$AH = t);
    else {
      const a = t;
      let l, h;
      for (t = s[0], l = 0; l < s.length - 1; l++) h = Mr(this, a[n + l], e, l), h === Sr && (h = this._$AH[l]), o ||= !Fs(h) || h !== this._$AH[l], h === kt ? t = kt : t !== kt && (t += (h ?? "") + s[l + 1]), this._$AH[l] = h;
    }
    o && !r && this.j(t);
  }
  j(t) {
    t === kt ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class K3 extends zo {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === kt ? void 0 : t;
  }
}
let q3 = class extends zo {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== kt);
  }
};
class J3 extends zo {
  constructor(t, e, n, r, s) {
    super(t, e, n, r, s), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = Mr(this, t, e, 0) ?? kt) === Sr) return;
    const n = this._$AH, r = t === kt && n !== kt || t.capture !== n.capture || t.once !== n.once || t.passive !== n.passive, s = t !== kt && (n === kt || r);
    r && this.element.removeEventListener(this.name, this, n), s && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, t) : this._$AH.handleEvent(t);
  }
}
class Q3 {
  constructor(t, e, n) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Mr(this, t);
  }
}
const tf = Ka.litHtmlPolyfillSupport;
tf?.(Os, Ja), (Ka.litHtmlVersions ??= []).push("3.3.1");
const ef = (i, t, e) => {
  const n = e?.renderBefore ?? t;
  let r = n._$litPart$;
  if (r === void 0) {
    const s = e?.renderBefore ?? null;
    n._$litPart$ = r = new Ja(t.insertBefore(As(), s), s, void 0, e ?? {});
  }
  return r._$AI(i), r;
};
const Qa = globalThis;
class bn extends er {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const t = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t.firstChild, t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = ef(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(!0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(!1);
  }
  render() {
    return Sr;
  }
}
bn._$litElement$ = !0, bn.finalized = !0, Qa.litElementHydrateSupport?.({ LitElement: bn });
const nf = Qa.litElementPolyfillSupport;
nf?.({ LitElement: bn });
(Qa.litElementVersions ??= []).push("4.2.1");
const Yt = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, Mn = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
}, V = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
class jo {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
function rf(i, t, e) {
  let n, r;
  e = e || ei;
  let s = 0, o = i.length, a = !1;
  for (; s < o; )
    n = s + (o - s >> 1), r = +e(i[n], t), r < 0 ? s = n + 1 : (o = n, a = !r);
  return a ? s : ~s;
}
function ei(i, t) {
  return i > t ? 1 : i < t ? -1 : 0;
}
function sf(i, t) {
  return i < t ? 1 : i > t ? -1 : 0;
}
function Uo(i, t, e) {
  if (i[0] <= t)
    return 0;
  const n = i.length;
  if (t <= i[n - 1])
    return n - 1;
  if (typeof e == "function") {
    for (let r = 1; r < n; ++r) {
      const s = i[r];
      if (s === t)
        return r;
      if (s < t)
        return e(t, i[r - 1], s) > 0 ? r - 1 : r;
    }
    return n - 1;
  }
  if (e > 0) {
    for (let r = 1; r < n; ++r)
      if (i[r] < t)
        return r - 1;
    return n - 1;
  }
  if (e < 0) {
    for (let r = 1; r < n; ++r)
      if (i[r] <= t)
        return r;
    return n - 1;
  }
  for (let r = 1; r < n; ++r) {
    if (i[r] == t)
      return r;
    if (i[r] < t)
      return i[r - 1] - t < t - i[r] ? r - 1 : r;
  }
  return n - 1;
}
function of(i, t, e) {
  for (; t < e; ) {
    const n = i[t];
    i[t] = i[e], i[e] = n, ++t, --e;
  }
}
function ot(i, t) {
  const e = Array.isArray(t) ? t : [t], n = e.length;
  for (let r = 0; r < n; r++)
    i[i.length] = e[r];
}
function Ci(i, t) {
  const e = i.length;
  if (e !== t.length)
    return !1;
  for (let n = 0; n < e; n++)
    if (i[n] !== t[n])
      return !1;
  return !0;
}
function af(i, t, e) {
  const n = t || ei;
  return i.every(function(r, s) {
    if (s === 0)
      return !0;
    const o = n(i[s - 1], r);
    return !(o > 0 || o === 0);
  });
}
function Tr() {
  return !0;
}
function zr() {
  return !1;
}
function Gs() {
}
function b1(i) {
  let t, e, n;
  return function() {
    const r = Array.prototype.slice.call(arguments);
    return (!e || this !== n || !Ci(r, e)) && (n = this, e = r, t = i.apply(this, arguments)), t;
  };
}
function w1(i) {
  function t() {
    let e;
    try {
      e = i();
    } catch (n) {
      return Promise.reject(n);
    }
    return e instanceof Promise ? e : Promise.resolve(e);
  }
  return t();
}
function t0(i) {
  for (const t in i)
    delete i[t];
}
function Zi(i) {
  let t;
  for (t in i)
    return !1;
  return !t;
}
class ve {
  /**
   * @param {string} type Type.
   */
  constructor(t) {
    this.propagationStopped, this.defaultPrevented, this.type = t, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
function lf(i) {
  i.stopPropagation();
}
class e0 extends jo {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(t) {
    super(), this.eventTarget_ = t, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(t, e) {
    if (!t || !e)
      return;
    const n = this.listeners_ || (this.listeners_ = {}), r = n[t] || (n[t] = []);
    r.includes(e) || r.push(e);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(t) {
    const e = typeof t == "string", n = e ? t : t.type, r = this.listeners_ && this.listeners_[n];
    if (!r)
      return;
    const s = e ? new ve(t) : (
      /** @type {Event} */
      t
    );
    s.target || (s.target = this.eventTarget_ || this);
    const o = this.dispatching_ || (this.dispatching_ = {}), a = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    n in o || (o[n] = 0, a[n] = 0), ++o[n];
    let l;
    for (let h = 0, c = r.length; h < c; ++h)
      if ("handleEvent" in r[h] ? l = /** @type {import("../events.js").ListenerObject} */
      r[h].handleEvent(s) : l = /** @type {import("../events.js").ListenerFunction} */
      r[h].call(this, s), l === !1 || s.propagationStopped) {
        l = !1;
        break;
      }
    if (--o[n] === 0) {
      let h = a[n];
      for (delete a[n]; h--; )
        this.removeEventListener(n, Gs);
      delete o[n];
    }
    return l;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.listeners_ && t0(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(t) {
    return this.listeners_ && this.listeners_[t] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(t) {
    return this.listeners_ ? t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(t, e) {
    if (!this.listeners_)
      return;
    const n = this.listeners_[t];
    if (!n)
      return;
    const r = n.indexOf(e);
    r !== -1 && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (n[r] = Gs, ++this.pendingRemovals_[t]) : (n.splice(r, 1), n.length === 0 && delete this.listeners_[t]));
  }
}
function Q(i, t, e, n, r) {
  if (r) {
    const o = e;
    e = function(a) {
      return i.removeEventListener(t, e), o.call(n ?? this, a);
    };
  } else n && n !== i && (e = e.bind(n));
  const s = {
    target: i,
    type: t,
    listener: e
  };
  return i.addEventListener(t, e), s;
}
function Ns(i, t, e, n) {
  return Q(i, t, e, n, !0);
}
function dt(i) {
  i && i.target && (i.target.removeEventListener(i.type, i.listener), t0(i));
}
class i0 extends e0 {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(V.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(t, e) {
    if (Array.isArray(t)) {
      const n = t.length, r = new Array(n);
      for (let s = 0; s < n; ++s)
        r[s] = Q(this, t[s], e);
      return r;
    }
    return Q(
      this,
      /** @type {string} */
      t,
      e
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(t, e) {
    let n;
    if (Array.isArray(t)) {
      const r = t.length;
      n = new Array(r);
      for (let s = 0; s < r; ++s)
        n[s] = Ns(this, t[s], e);
    } else
      n = Ns(
        this,
        /** @type {string} */
        t,
        e
      );
    return e.ol_key = n, n;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(t, e) {
    const n = (
      /** @type {Object} */
      e.ol_key
    );
    if (n)
      hf(n);
    else if (Array.isArray(t))
      for (let r = 0, s = t.length; r < s; ++r)
        this.removeEventListener(t[r], e);
    else
      this.removeEventListener(t, e);
  }
}
i0.prototype.on;
i0.prototype.once;
i0.prototype.un;
function hf(i) {
  if (Array.isArray(i))
    for (let t = 0, e = i.length; t < e; ++t)
      dt(i[t]);
  else
    dt(
      /** @type {import("./events.js").EventsKey} */
      i
    );
}
function X() {
  throw new Error("Unimplemented abstract method.");
}
let cf = 0;
function Y(i) {
  return i.ol_uid || (i.ol_uid = String(++cf));
}
class Rh extends ve {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(t, e, n) {
    super(t), this.key = e, this.oldValue = n;
  }
}
class De extends i0 {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, Y(this), this.values_ = null, t !== void 0 && this.setProperties(t);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(t) {
    let e;
    return this.values_ && this.values_.hasOwnProperty(t) && (e = this.values_[t]), e;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(t, e) {
    let n;
    n = `change:${t}`, this.hasListener(n) && this.dispatchEvent(new Rh(n, t, e)), n = Mn.PROPERTYCHANGE, this.hasListener(n) && this.dispatchEvent(new Rh(n, t, e));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(t, e) {
    this.addEventListener(`change:${t}`, e);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(t, e) {
    this.removeEventListener(`change:${t}`, e);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(t, e, n) {
    const r = this.values_ || (this.values_ = {});
    if (n)
      r[t] = e;
    else {
      const s = r[t];
      r[t] = e, s !== e && this.notify(t, s);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(t, e) {
    for (const n in t)
      this.set(n, t[n], e);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(t) {
    t.values_ && Object.assign(this.values_ || (this.values_ = {}), t.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(t, e) {
    if (this.values_ && t in this.values_) {
      const n = this.values_[t];
      delete this.values_[t], Zi(this.values_) && (this.values_ = null), e || this.notify(t, n);
    }
  }
}
const Ph = {
  LENGTH: "length"
};
class w0 extends ve {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(t, e, n) {
    super(t), this.element = e, this.index = n;
  }
}
class Dt extends De {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(t, e) {
    if (super(), this.on, this.once, this.un, e = e || {}, this.unique_ = !!e.unique, this.array_ = t ?? [], this.unique_)
      for (let n = 1, r = this.array_.length; n < r; ++n)
        this.assertUnique_(this.array_[n], n);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(t) {
    for (let e = 0, n = t.length; e < n; ++e)
      this.push(t[e]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(t) {
    const e = this.array_;
    for (let n = 0, r = e.length; n < r; ++n)
      t(e[n], n, e);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(t) {
    return this.array_[t];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(Ph.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(t, e) {
    if (t < 0 || t > this.getLength())
      throw new Error("Index out of bounds: " + t);
    this.unique_ && this.assertUnique_(e), this.array_.splice(t, 0, e), this.updateLength_(), this.dispatchEvent(
      new w0(Yt.ADD, e, t)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(t) {
    const e = this.getLength();
    return this.insertAt(e, t), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(t) {
    const e = this.array_;
    for (let n = 0, r = e.length; n < r; ++n)
      if (e[n] === t)
        return this.removeAt(n);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(t) {
    if (t < 0 || t >= this.getLength())
      return;
    const e = this.array_[t];
    return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new w0(Yt.REMOVE, e, t)
    ), e;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(t, e) {
    const n = this.getLength();
    if (t >= n) {
      this.insertAt(t, e);
      return;
    }
    if (t < 0)
      throw new Error("Index out of bounds: " + t);
    this.unique_ && this.assertUnique_(e, t);
    const r = this.array_[t];
    this.array_[t] = e, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new w0(Yt.REMOVE, r, t)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new w0(Yt.ADD, e, t)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(Ph.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(t, e) {
    const n = this.array_;
    for (let r = 0, s = n.length; r < s; ++r)
      if (n[r] === t && r !== e)
        throw new Error("Duplicate item added to a unique collection");
  }
}
class ir extends ve {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(t, e, n) {
    super(t), this.map = e, this.frameState = n !== void 0 ? n : null;
  }
}
class fi extends ir {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(t, e, n, r, s, o) {
    super(t, e, s), this.originalEvent = n, this.pixel_ = null, this.coordinate_ = null, this.dragging = r !== void 0 ? r : !1, this.activePointers = o;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
  }
  set pixel(t) {
    this.pixel_ = t;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
  }
  set coordinate(t) {
    this.coordinate_ = t;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   * @override
   */
  preventDefault() {
    super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   * @override
   */
  stopPropagation() {
    super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }
}
const rt = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: V.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: V.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
}, Tn = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", df = Tn.includes("safari") && !Tn.includes("chrom");
df && (Tn.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(Tn));
const uf = Tn.includes("webkit") && !Tn.includes("edge"), tl = Tn.includes("macintosh"), ff = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, ye = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, el = typeof Image < "u" && Image.prototype.decode, E1 = typeof createImageBitmap == "function", S1 = (function() {
  let i = !1;
  try {
    const t = Object.defineProperty({}, "passive", {
      get: function() {
        i = !0;
      }
    });
    window.addEventListener("_", null, t), window.removeEventListener("_", null, t);
  } catch {
  }
  return i;
})(), Qe = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROUT: "pointerout"
};
class gf extends e0 {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(t, e) {
    super(t), this.map_ = t, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = e === void 0 ? 1 : e, this.down_ = null;
    const n = this.map_.getViewport();
    this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = n, this.pointerdownListenerKey_ = Q(
      n,
      Qe.POINTERDOWN,
      this.handlePointerDown_,
      this
    ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = Q(
      n,
      Qe.POINTERMOVE,
      this.relayMoveEvent_,
      this
    ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
      V.TOUCHMOVE,
      this.boundHandleTouchMove_,
      S1 ? { passive: !1 } : !1
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(t) {
    let e = new fi(
      rt.CLICK,
      this.map_,
      t
    );
    this.dispatchEvent(e), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, e = new fi(
      rt.DBLCLICK,
      this.map_,
      t
    ), this.dispatchEvent(e)) : this.clickTimeoutId_ = setTimeout(() => {
      this.clickTimeoutId_ = void 0;
      const n = new fi(
        rt.SINGLECLICK,
        this.map_,
        t
      );
      this.dispatchEvent(n);
    }, 250);
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(t) {
    const e = t, n = e.pointerId;
    if (e.type == rt.POINTERUP || e.type == rt.POINTERCANCEL) {
      delete this.trackedTouches_[n];
      for (const r in this.trackedTouches_)
        if (this.trackedTouches_[r].target !== e.target) {
          delete this.trackedTouches_[r];
          break;
        }
    } else (e.type == rt.POINTERDOWN || e.type == rt.POINTERMOVE) && (this.trackedTouches_[n] = e);
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(t) {
    this.updateActivePointers_(t);
    const e = new fi(
      rt.POINTERUP,
      this.map_,
      t,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(e), this.emulateClicks_ && !e.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(t) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(dt), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(t) {
    return t.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(t) {
    this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(t);
    const e = new fi(
      rt.POINTERDOWN,
      this.map_,
      t,
      void 0,
      void 0,
      this.activePointers_
    );
    if (this.dispatchEvent(e), this.down_ = new PointerEvent(t.type, t), Object.defineProperty(this.down_, "target", {
      writable: !1,
      value: t.target
    }), this.dragListenerKeys_.length === 0) {
      const n = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        Q(
          n,
          rt.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        Q(n, rt.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        Q(
          this.element_,
          rt.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      ), this.element_.getRootNode && this.element_.getRootNode() !== n && this.dragListenerKeys_.push(
        Q(
          this.element_.getRootNode(),
          rt.POINTERUP,
          this.handlePointerUp_,
          this
        )
      );
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(t) {
    if (this.isMoving_(t)) {
      this.updateActivePointers_(t), this.dragging_ = !0;
      const e = new fi(
        rt.POINTERDRAG,
        this.map_,
        t,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(e);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(t) {
    this.originalPointerMoveEvent_ = t;
    const e = !!(this.down_ && this.isMoving_(t));
    this.dispatchEvent(
      new fi(
        rt.POINTERMOVE,
        this.map_,
        t,
        e
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(t) {
    const e = this.originalPointerMoveEvent_;
    (!e || e.defaultPrevented) && (typeof t.cancelable != "boolean" || t.cancelable === !0) && t.preventDefault();
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(t) {
    return this.dragging_ || Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.relayedListenerKey_ && (dt(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
      V.TOUCHMOVE,
      this.boundHandleTouchMove_
    ), this.pointerdownListenerKey_ && (dt(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(dt), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
  }
}
const Je = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
}, Et = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
}, F = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
function at(i, t) {
  if (!i)
    throw new Error(t);
}
const ro = 1 / 0;
class mf {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(t, e) {
    this.priorityFunction_ = t, this.keyFunction_ = e, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0, this.priorities_.length = 0, t0(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const t = this.elements_, e = this.priorities_, n = t[0];
    t.length == 1 ? (t.length = 0, e.length = 0) : (t[0] = /** @type {T} */
    t.pop(), e[0] = /** @type {number} */
    e.pop(), this.siftUp_(0));
    const r = this.keyFunction_(n);
    return delete this.queuedElements_[r], n;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(t) {
    at(
      !(this.keyFunction_(t) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const e = this.priorityFunction_(t);
    return e != ro ? (this.elements_.push(t), this.priorities_.push(e), this.queuedElements_[this.keyFunction_(t)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(t) {
    return t * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(t) {
    return t * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(t) {
    return t - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let t;
    for (t = (this.elements_.length >> 1) - 1; t >= 0; t--)
      this.siftUp_(t);
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(t) {
    return t in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(t) {
    return this.isKeyQueued(this.keyFunction_(t));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(t) {
    const e = this.elements_, n = this.priorities_, r = e.length, s = e[t], o = n[t], a = t;
    for (; t < r >> 1; ) {
      const l = this.getLeftChildIndex_(t), h = this.getRightChildIndex_(t), c = h < r && n[h] < n[l] ? h : l;
      e[t] = e[c], n[t] = n[c], t = c;
    }
    e[t] = s, n[t] = o, this.siftDown_(a, t);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(t, e) {
    const n = this.elements_, r = this.priorities_, s = n[e], o = r[e];
    for (; e > t; ) {
      const a = this.getParentIndex_(e);
      if (r[a] > o)
        n[e] = n[a], r[e] = r[a], e = a;
      else
        break;
    }
    n[e] = s, r[e] = o;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const t = this.priorityFunction_, e = this.elements_, n = this.priorities_;
    let r = 0;
    const s = e.length;
    let o, a, l;
    for (a = 0; a < s; ++a)
      o = e[a], l = t(o), l == ro ? delete this.queuedElements_[this.keyFunction_(o)] : (n[r] = l, e[r++] = o);
    e.length = r, n.length = r, this.heapify_();
  }
}
class pf extends mf {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(t, e) {
    super(
      (n) => t.apply(null, n),
      (n) => n[0].getKey()
    ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = e, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {TileQueueElement} element Element.
   * @return {boolean} The element was added to the queue.
   * @override
   */
  enqueue(t) {
    const e = super.enqueue(t);
    return e && t[0].addEventListener(V.CHANGE, this.boundHandleTileChange_), e;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(t) {
    const e = (
      /** @type {import("./Tile.js").default} */
      t.target
    ), n = e.getState();
    if (n === F.LOADED || n === F.ERROR || n === F.EMPTY) {
      n !== F.ERROR && e.removeEventListener(V.CHANGE, this.boundHandleTileChange_);
      const r = e.getKey();
      r in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[r], --this.tilesLoading_), this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(t, e) {
    let n = 0;
    for (; this.tilesLoading_ < t && n < e && this.getCount() > 0; ) {
      const r = this.dequeue()[0], s = r.getKey();
      r.getState() === F.IDLE && !(s in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[s] = !0, ++this.tilesLoading_, ++n, r.load());
    }
  }
}
function _f(i, t, e, n, r) {
  if (!i || !(e in i.wantedTiles) || !i.wantedTiles[e][t.getKey()])
    return ro;
  const s = i.viewState.center, o = n[0] - s[0], a = n[1] - s[1];
  return 65536 * Math.log(r) + Math.sqrt(o * o + a * a) / r;
}
const mt = {
  ANIMATING: 0,
  INTERACTING: 1
}, me = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};
function ft(i, t, e) {
  return Math.min(Math.max(i, t), e);
}
function yf(i, t, e, n, r, s) {
  const o = r - e, a = s - n;
  if (o !== 0 || a !== 0) {
    const l = ((i - e) * o + (t - n) * a) / (o * o + a * a);
    l > 1 ? (e = r, n = s) : l > 0 && (e += o * l, n += a * l);
  }
  return mi(i, t, e, n);
}
function mi(i, t, e, n) {
  const r = e - i, s = n - t;
  return r * r + s * s;
}
function vf(i) {
  const t = i.length;
  for (let n = 0; n < t; n++) {
    let r = n, s = Math.abs(i[n][n]);
    for (let a = n + 1; a < t; a++) {
      const l = Math.abs(i[a][n]);
      l > s && (s = l, r = a);
    }
    if (s === 0)
      return null;
    const o = i[r];
    i[r] = i[n], i[n] = o;
    for (let a = n + 1; a < t; a++) {
      const l = -i[a][n] / i[n][n];
      for (let h = n; h < t + 1; h++)
        n == h ? i[a][h] = 0 : i[a][h] += l * i[n][h];
    }
  }
  const e = new Array(t);
  for (let n = t - 1; n >= 0; n--) {
    e[n] = i[n][t] / i[n][n];
    for (let r = n - 1; r >= 0; r--)
      i[r][t] -= i[r][n] * e[n];
  }
  return e;
}
function so(i) {
  return i * 180 / Math.PI;
}
function ie(i) {
  return i * Math.PI / 180;
}
function wn(i, t) {
  const e = i % t;
  return e * t < 0 ? e + t : e;
}
function pe(i, t, e) {
  return i + e * (t - i);
}
function jr(i, t) {
  const e = Math.pow(10, t);
  return Math.round(i * e) / e;
}
function Ih(i, t) {
  return Math.round(jr(i, t));
}
function ar(i, t) {
  return Math.floor(jr(i, t));
}
function Gi(i, t) {
  return Math.ceil(jr(i, t));
}
function ca(i, t, e) {
  if (i >= t && i < e)
    return i;
  const n = e - t;
  return ((i - t) % n + n) % n + t;
}
function kh(i, t, e) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    (function(n, r, s, o, a) {
      if (!n)
        return;
      if (!r && !t)
        return n;
      const l = t ? 0 : s[0] * r, h = t ? 0 : s[1] * r, c = a ? a[0] : 0, d = a ? a[1] : 0;
      let u = i[0] + l / 2 + c, f = i[2] - l / 2 + c, g = i[1] + h / 2 + d, p = i[3] - h / 2 + d;
      u > f && (u = (f + u) / 2, f = u), g > p && (g = (p + g) / 2, p = g);
      let m = ft(n[0], u, f), _ = ft(n[1], g, p);
      if (o && e && r) {
        const y = 30 * r;
        m += -y * Math.log(1 + Math.max(0, u - n[0]) / y) + y * Math.log(1 + Math.max(0, n[0] - f) / y), _ += -y * Math.log(1 + Math.max(0, g - n[1]) / y) + y * Math.log(1 + Math.max(0, n[1] - p) / y);
      }
      return [m, _];
    })
  );
}
function xf(i) {
  return i;
}
const Ot = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function Gt(i) {
  const t = ne();
  for (let e = 0, n = i.length; e < n; ++e)
    xs(t, i[e]);
  return t;
}
function Cf(i, t, e) {
  const n = Math.min.apply(null, i), r = Math.min.apply(null, t), s = Math.max.apply(null, i), o = Math.max.apply(null, t);
  return ii(n, r, s, o, e);
}
function Ie(i, t, e) {
  return e ? (e[0] = i[0] - t, e[1] = i[1] - t, e[2] = i[2] + t, e[3] = i[3] + t, e) : [
    i[0] - t,
    i[1] - t,
    i[2] + t,
    i[3] + t
  ];
}
function M1(i, t) {
  return t ? (t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t) : i.slice();
}
function Gn(i, t, e) {
  let n, r;
  return t < i[0] ? n = i[0] - t : i[2] < t ? n = t - i[2] : n = 0, e < i[1] ? r = i[1] - e : i[3] < e ? r = e - i[3] : r = 0, n * n + r * r;
}
function Rn(i, t) {
  return il(i, t[0], t[1]);
}
function Be(i, t) {
  return i[0] <= t[0] && t[2] <= i[2] && i[1] <= t[1] && t[3] <= i[3];
}
function il(i, t, e) {
  return i[0] <= t && t <= i[2] && i[1] <= e && e <= i[3];
}
function da(i, t) {
  const e = i[0], n = i[1], r = i[2], s = i[3], o = t[0], a = t[1];
  let l = Ot.UNKNOWN;
  return o < e ? l = l | Ot.LEFT : o > r && (l = l | Ot.RIGHT), a < n ? l = l | Ot.BELOW : a > s && (l = l | Ot.ABOVE), l === Ot.UNKNOWN && (l = Ot.INTERSECTING), l;
}
function ne() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function ii(i, t, e, n, r) {
  return r ? (r[0] = i, r[1] = t, r[2] = e, r[3] = n, r) : [i, t, e, n];
}
function Ur(i) {
  return ii(1 / 0, 1 / 0, -1 / 0, -1 / 0, i);
}
function vs(i, t) {
  const e = i[0], n = i[1];
  return ii(e, n, e, n, t);
}
function nl(i, t, e, n, r) {
  const s = Ur(r);
  return T1(s, i, t, e, n);
}
function Hi(i, t) {
  return i[0] == t[0] && i[2] == t[2] && i[1] == t[1] && i[3] == t[3];
}
function Ds(i, t) {
  return t[0] < i[0] && (i[0] = t[0]), t[2] > i[2] && (i[2] = t[2]), t[1] < i[1] && (i[1] = t[1]), t[3] > i[3] && (i[3] = t[3]), i;
}
function xs(i, t) {
  t[0] < i[0] && (i[0] = t[0]), t[0] > i[2] && (i[2] = t[0]), t[1] < i[1] && (i[1] = t[1]), t[1] > i[3] && (i[3] = t[1]);
}
function T1(i, t, e, n, r) {
  for (; e < n; e += r)
    bf(i, t[e], t[e + 1]);
  return i;
}
function bf(i, t, e) {
  i[0] = Math.min(i[0], t), i[1] = Math.min(i[1], e), i[2] = Math.max(i[2], t), i[3] = Math.max(i[3], e);
}
function rl(i, t) {
  let e;
  return e = t(Rr(i)), e || (e = t(Br(i)), e) || (e = t(n0(i)), e) || (e = t(Xe(i)), e) ? e : !1;
}
function oo(i) {
  let t = 0;
  return Qi(i) || (t = it(i) * Rt(i)), t;
}
function Rr(i) {
  return [i[0], i[1]];
}
function Br(i) {
  return [i[2], i[1]];
}
function ni(i) {
  return [(i[0] + i[2]) / 2, (i[1] + i[3]) / 2];
}
function wf(i, t) {
  let e;
  if (t === "bottom-left")
    e = Rr(i);
  else if (t === "bottom-right")
    e = Br(i);
  else if (t === "top-left")
    e = Xe(i);
  else if (t === "top-right")
    e = n0(i);
  else
    throw new Error("Invalid corner");
  return e;
}
function zs(i, t, e, n, r) {
  const [s, o, a, l, h, c, d, u] = R1(
    i,
    t,
    e,
    n
  );
  return ii(
    Math.min(s, a, h, d),
    Math.min(o, l, c, u),
    Math.max(s, a, h, d),
    Math.max(o, l, c, u),
    r
  );
}
function R1(i, t, e, n) {
  const r = t * n[0] / 2, s = t * n[1] / 2, o = Math.cos(e), a = Math.sin(e), l = r * o, h = r * a, c = s * o, d = s * a, u = i[0], f = i[1];
  return [
    u - l + d,
    f - h - c,
    u - l - d,
    f - h + c,
    u + l - d,
    f + h + c,
    u + l + d,
    f + h - c,
    u - l + d,
    f - h - c
  ];
}
function Rt(i) {
  return i[3] - i[1];
}
function Ve(i, t, e) {
  const n = e || ne();
  return bt(i, t) ? (i[0] > t[0] ? n[0] = i[0] : n[0] = t[0], i[1] > t[1] ? n[1] = i[1] : n[1] = t[1], i[2] < t[2] ? n[2] = i[2] : n[2] = t[2], i[3] < t[3] ? n[3] = i[3] : n[3] = t[3]) : Ur(n), n;
}
function Xe(i) {
  return [i[0], i[3]];
}
function n0(i) {
  return [i[2], i[3]];
}
function it(i) {
  return i[2] - i[0];
}
function bt(i, t) {
  return i[0] <= t[2] && i[2] >= t[0] && i[1] <= t[3] && i[3] >= t[1];
}
function Qi(i) {
  return i[2] < i[0] || i[3] < i[1];
}
function Ef(i, t) {
  return t ? (t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t) : i;
}
function Sf(i, t) {
  const e = (i[2] - i[0]) / 2 * (t - 1), n = (i[3] - i[1]) / 2 * (t - 1);
  i[0] -= e, i[2] += e, i[1] -= n, i[3] += n;
}
function Mf(i, t, e) {
  let n = !1;
  const r = da(i, t), s = da(i, e);
  if (r === Ot.INTERSECTING || s === Ot.INTERSECTING)
    n = !0;
  else {
    const o = i[0], a = i[1], l = i[2], h = i[3], c = t[0], d = t[1], u = e[0], f = e[1], g = (f - d) / (u - c);
    let p, m;
    s & Ot.ABOVE && !(r & Ot.ABOVE) && (p = u - (f - h) / g, n = p >= o && p <= l), !n && s & Ot.RIGHT && !(r & Ot.RIGHT) && (m = f - (u - l) * g, n = m >= a && m <= h), !n && s & Ot.BELOW && !(r & Ot.BELOW) && (p = u - (f - a) / g, n = p >= o && p <= l), !n && s & Ot.LEFT && !(r & Ot.LEFT) && (m = f - (u - o) * g, n = m >= a && m <= h);
  }
  return n;
}
function Tf(i, t, e, n) {
  if (Qi(i))
    return Ur(e);
  let r = [];
  if (n > 1) {
    const a = i[2] - i[0], l = i[3] - i[1];
    for (let h = 0; h < n; ++h)
      r.push(
        i[0] + a * h / n,
        i[1],
        i[2],
        i[1] + l * h / n,
        i[2] - a * h / n,
        i[3],
        i[0],
        i[3] - l * h / n
      );
  } else
    r = [
      i[0],
      i[1],
      i[2],
      i[1],
      i[2],
      i[3],
      i[0],
      i[3]
    ];
  t(r, r, 2);
  const s = [], o = [];
  for (let a = 0, l = r.length; a < l; a += 2)
    s.push(r[a]), o.push(r[a + 1]);
  return Cf(s, o, e);
}
function P1(i, t) {
  const e = t.getExtent(), n = ni(i);
  if (t.canWrapX() && (n[0] < e[0] || n[0] >= e[2])) {
    const r = it(e), o = Math.floor(
      (n[0] - e[0]) / r
    ) * r;
    i[0] -= o, i[2] -= o;
  }
  return i;
}
function I1(i, t, e) {
  if (t.canWrapX()) {
    const n = t.getExtent();
    if (!isFinite(i[0]) || !isFinite(i[2]))
      return [[n[0], i[1], n[2], i[3]]];
    P1(i, t);
    const r = it(n);
    if (it(i) > r && !e)
      return [[n[0], i[1], n[2], i[3]]];
    if (i[0] < n[0])
      return [
        [i[0] + r, i[1], n[2], i[3]],
        [n[0], i[1], i[2], i[3]]
      ];
    if (i[2] > n[2])
      return [
        [i[0], i[1], n[2], i[3]],
        [n[0], i[1], i[2] - r, i[3]]
      ];
  }
  return [i];
}
function sl(i, t) {
  const e = ("" + i).split("."), n = ("" + t).split(".");
  for (let r = 0; r < Math.max(e.length, n.length); r++) {
    const s = parseInt(e[r] || "0", 10), o = parseInt(n[r] || "0", 10);
    if (s > o)
      return 1;
    if (o > s)
      return -1;
  }
  return 0;
}
function Rf(i, t) {
  return i[0] += +t[0], i[1] += +t[1], i;
}
function ol(i, t) {
  const e = i[0], n = i[1], r = t[0], s = t[1], o = r[0], a = r[1], l = s[0], h = s[1], c = l - o, d = h - a, u = c === 0 && d === 0 ? 0 : (c * (e - o) + d * (n - a)) / (c * c + d * d || 0);
  let f, g;
  return u <= 0 ? (f = o, g = a) : u >= 1 ? (f = l, g = h) : (f = o + u * c, g = a + u * d), [f, g];
}
function $t(i, t) {
  let e = !0;
  for (let n = i.length - 1; n >= 0; --n)
    if (i[n] != t[n]) {
      e = !1;
      break;
    }
  return e;
}
function al(i, t) {
  const e = Math.cos(t), n = Math.sin(t), r = i[0] * e - i[1] * n, s = i[1] * e + i[0] * n;
  return i[0] = r, i[1] = s, i;
}
function Pf(i, t) {
  return i[0] *= t, i[1] *= t, i;
}
function Pr(i, t) {
  const e = i[0] - t[0], n = i[1] - t[1];
  return e * e + n * n;
}
function lr(i, t) {
  return Math.sqrt(Pr(i, t));
}
function If(i, t) {
  return Pr(i, ol(i, t));
}
function Bo(i, t) {
  if (t.canWrapX()) {
    const e = it(t.getExtent()), n = k1(i, t, e);
    n && (i[0] -= n * e);
  }
  return i;
}
function k1(i, t, e) {
  const n = t.getExtent();
  let r = 0;
  return t.canWrapX() && (i[0] < n[0] || i[0] > n[2]) && (e = e || it(n), r = Math.floor(
    (i[0] - n[0]) / e
  )), r;
}
function L1(i) {
  return Math.pow(i, 3);
}
function Nn(i) {
  return 1 - L1(1 - i);
}
function kf(i) {
  return 3 * i * i - 2 * i * i * i;
}
function Lf(i) {
  return i;
}
const Vo = 63710088e-1;
function ua(i, t, e) {
  e = e || Vo;
  const n = ie(i[1]), r = ie(t[1]), s = (r - n) / 2, o = ie(t[0] - i[0]) / 2, a = Math.sin(s) * Math.sin(s) + Math.sin(o) * Math.sin(o) * Math.cos(n) * Math.cos(r);
  return 2 * e * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
function x2(i, t) {
  let e = 0;
  for (let n = 0, r = i.length; n < r - 1; ++n)
    e += ua(i[n], i[n + 1], t);
  return e;
}
function A1(i, t) {
  t = t || {};
  const e = t.radius || Vo, n = t.projection || "EPSG:3857", r = i.getType();
  r !== "GeometryCollection" && (i = i.clone().transform(n, "EPSG:4326"));
  let s = 0, o, a, l, h, c, d;
  switch (r) {
    case "Point":
    case "MultiPoint":
      break;
    case "LineString":
    case "LinearRing": {
      o = /** @type {import("./geom/SimpleGeometry.js").default} */
      i.getCoordinates(), s = x2(o, e);
      break;
    }
    case "MultiLineString":
    case "Polygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      i.getCoordinates(), l = 0, h = o.length; l < h; ++l)
        s += x2(o[l], e);
      break;
    }
    case "MultiPolygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      i.getCoordinates(), l = 0, h = o.length; l < h; ++l)
        for (a = o[l], c = 0, d = a.length; c < d; ++c)
          s += x2(a[c], e);
      break;
    }
    case "GeometryCollection": {
      const u = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        i.getGeometries()
      );
      for (l = 0, h = u.length; l < h; ++l)
        s += A1(u[l], t);
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + r);
  }
  return s;
}
function E0(i, t) {
  let e = 0;
  const n = i.length;
  let r = i[n - 1][0], s = i[n - 1][1];
  for (let o = 0; o < n; o++) {
    const a = i[o][0], l = i[o][1];
    e += ie(a - r) * (2 + Math.sin(ie(s)) + Math.sin(ie(l))), r = a, s = l;
  }
  return e * t * t / 2;
}
function F1(i, t) {
  t = t || {};
  const e = t.radius || Vo, n = t.projection || "EPSG:3857", r = i.getType();
  r !== "GeometryCollection" && (i = i.clone().transform(n, "EPSG:4326"));
  let s = 0, o, a, l, h, c, d;
  switch (r) {
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
    case "LinearRing":
      break;
    case "Polygon": {
      for (o = /** @type {import("./geom/Polygon.js").default} */
      i.getCoordinates(), s = Math.abs(E0(o[0], e)), l = 1, h = o.length; l < h; ++l)
        s -= Math.abs(E0(o[l], e));
      break;
    }
    case "MultiPolygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      i.getCoordinates(), l = 0, h = o.length; l < h; ++l)
        for (a = o[l], s += Math.abs(E0(a[0], e)), c = 1, d = a.length; c < d; ++c)
          s -= Math.abs(E0(a[c], e));
      break;
    }
    case "GeometryCollection": {
      const u = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        i.getGeometries()
      );
      for (l = 0, h = u.length; l < h; ++l)
        s += F1(u[l], t);
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + r);
  }
  return s;
}
function Af(i, t, e, n) {
  n = n || Vo;
  const r = ie(i[1]), s = ie(i[0]), o = t / n, a = Math.asin(
    Math.sin(r) * Math.cos(o) + Math.cos(r) * Math.sin(o) * Math.cos(e)
  ), l = s + Math.atan2(
    Math.sin(e) * Math.sin(o) * Math.cos(r),
    Math.cos(o) - Math.sin(r) * Math.sin(a)
  );
  return [so(l), so(a)];
}
function O1(...i) {
  console.warn(...i);
}
const Ir = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
let r0 = class {
  /**
   * @param {Options} options Projection options.
   */
  constructor(t) {
    this.code_ = t.code, this.units_ = /** @type {import("./Units.js").Units} */
    t.units, this.extent_ = t.extent !== void 0 ? t.extent : null, this.worldExtent_ = t.worldExtent !== void 0 ? t.worldExtent : null, this.axisOrientation_ = t.axisOrientation !== void 0 ? t.axisOrientation : "enu", this.global_ = t.global !== void 0 ? t.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || Ir[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(t) {
    this.global_ = t, this.canWrapX_ = !!(t && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(t) {
    this.defaultTileGrid_ = t;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(t) {
    this.extent_ = t, this.canWrapX_ = !!(this.global_ && t);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(t) {
    this.worldExtent_ = t;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(t) {
    this.getPointResolutionFunc_ = t;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {GetPointResolution|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
};
const s0 = 6378137, hr = Math.PI * s0, Ff = [-hr, -hr, hr, hr], Of = [-180, -85, 180, 85], S0 = s0 * Math.log(Math.tan(Math.PI / 2));
class Xn extends r0 {
  /**
   * @param {string} code Code.
   */
  constructor(t) {
    super({
      code: t,
      units: "m",
      extent: Ff,
      global: !0,
      worldExtent: Of,
      getPointResolution: function(e, n) {
        return e / Math.cosh(n[1] / s0);
      }
    });
  }
}
const Lh = [
  new Xn("EPSG:3857"),
  new Xn("EPSG:102100"),
  new Xn("EPSG:102113"),
  new Xn("EPSG:900913"),
  new Xn("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new Xn("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function Gf(i, t, e, n) {
  const r = i.length;
  e = e > 1 ? e : 2, n = n ?? e, t === void 0 && (e > 2 ? t = i.slice() : t = new Array(r));
  for (let s = 0; s < r; s += n) {
    t[s] = hr * i[s] / 180;
    let o = s0 * Math.log(Math.tan(Math.PI * (+i[s + 1] + 90) / 360));
    o > S0 ? o = S0 : o < -S0 && (o = -S0), t[s + 1] = o;
  }
  return t;
}
function Nf(i, t, e, n) {
  const r = i.length;
  e = e > 1 ? e : 2, n = n ?? e, t === void 0 && (e > 2 ? t = i.slice() : t = new Array(r));
  for (let s = 0; s < r; s += n)
    t[s] = 180 * i[s] / hr, t[s + 1] = 360 * Math.atan(Math.exp(i[s + 1] / s0)) / Math.PI - 90;
  return t;
}
const Df = 6378137, Ah = [-180, -90, 180, 90], zf = Math.PI * Df / 180;
class hn extends r0 {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(t, e) {
    super({
      code: t,
      units: "degrees",
      extent: Ah,
      axisOrientation: e,
      global: !0,
      metersPerUnit: zf,
      worldExtent: Ah
    });
  }
}
const Fh = [
  new hn("CRS:84"),
  new hn("EPSG:4326", "neu"),
  new hn("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new hn("urn:ogc:def:crs:OGC:2:84"),
  new hn("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new hn("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new hn("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let fa = {};
function mr(i) {
  return fa[i] || fa[i.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function jf(i, t) {
  fa[i] = t;
}
let pr = {};
function Pn(i, t, e) {
  const n = i.getCode(), r = t.getCode();
  n in pr || (pr[n] = {}), pr[n][r] = e;
}
function Z0(i, t) {
  return i in pr && t in pr[i] ? pr[i][t] : null;
}
const ao = 0.9996, ke = 669438e-8, $o = ke * ke, Wo = $o * ke, pn = ke / (1 - ke), Oh = Math.sqrt(1 - ke), kr = (1 - Oh) / (1 + Oh), G1 = kr * kr, ll = G1 * kr, hl = ll * kr, N1 = hl * kr, D1 = 1 - ke / 4 - 3 * $o / 64 - 5 * Wo / 256, Uf = 3 * ke / 8 + 3 * $o / 32 + 45 * Wo / 1024, Bf = 15 * $o / 256 + 45 * Wo / 1024, Vf = 35 * Wo / 3072, $f = 3 / 2 * kr - 27 / 32 * ll + 269 / 512 * N1, Wf = 21 / 16 * G1 - 55 / 32 * hl, Yf = 151 / 96 * ll - 417 / 128 * N1, Xf = 1097 / 512 * hl, lo = 6378137;
function Zf(i, t, e) {
  const n = i - 5e5, o = (e.north ? t : t - 1e7) / ao / (lo * D1), a = o + $f * Math.sin(2 * o) + Wf * Math.sin(4 * o) + Yf * Math.sin(6 * o) + Xf * Math.sin(8 * o), l = Math.sin(a), h = l * l, c = Math.cos(a), d = l / c, u = d * d, f = u * u, g = 1 - ke * h, p = Math.sqrt(1 - ke * h), m = lo / p, _ = (1 - ke) / g, y = pn * c ** 2, x = y * y, v = n / (m * ao), C = v * v, b = C * v, w = b * v, E = w * v, S = E * v, R = a - d / _ * (C / 2 - w / 24 * (5 + 3 * u + 10 * y - 4 * x - 9 * pn)) + S / 720 * (61 + 90 * u + 298 * y + 45 * f - 252 * pn - 3 * x);
  let I = (v - b / 6 * (1 + 2 * u + y) + E / 120 * (5 - 2 * y + 28 * u - 3 * x + 8 * pn + 24 * f)) / c;
  return I = ca(
    I + ie(z1(e.number)),
    -Math.PI,
    Math.PI
  ), [so(I), so(R)];
}
const Gh = -80, Nh = 84, Hf = -180, Kf = 180;
function qf(i, t, e) {
  i = ca(i, Hf, Kf), t < Gh ? t = Gh : t > Nh && (t = Nh);
  const n = ie(t), r = Math.sin(n), s = Math.cos(n), o = r / s, a = o * o, l = a * a, h = ie(i), c = z1(e.number), d = ie(c), u = lo / Math.sqrt(1 - ke * r ** 2), f = pn * s ** 2, g = s * ca(h - d, -Math.PI, Math.PI), p = g * g, m = p * g, _ = m * g, y = _ * g, x = y * g, v = lo * (D1 * n - Uf * Math.sin(2 * n) + Bf * Math.sin(4 * n) - Vf * Math.sin(6 * n)), C = ao * u * (g + m / 6 * (1 - a + f) + y / 120 * (5 - 18 * a + l + 72 * f - 58 * pn)) + 5e5;
  let b = ao * (v + u * o * (p / 2 + _ / 24 * (5 - a + 9 * f + 4 * f ** 2) + x / 720 * (61 - 58 * a + l + 600 * f - 330 * pn)));
  return e.north || (b += 1e7), [C, b];
}
function z1(i) {
  return (i - 1) * 6 - 180 + 3;
}
const Jf = [
  /^EPSG:(\d+)$/,
  /^urn:ogc:def:crs:EPSG::(\d+)$/,
  /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/
];
function j1(i) {
  let t = 0;
  for (const r of Jf) {
    const s = i.match(r);
    if (s) {
      t = parseInt(s[1]);
      break;
    }
  }
  if (!t)
    return null;
  let e = 0, n = !1;
  return t > 32700 && t < 32761 ? e = t - 32700 : t > 32600 && t < 32661 && (n = !0, e = t - 32600), e ? { number: e, north: n } : null;
}
function Dh(i, t) {
  return function(e, n, r, s) {
    const o = e.length;
    r = r > 1 ? r : 2, s = s ?? r, n || (r > 2 ? n = e.slice() : n = new Array(o));
    for (let a = 0; a < o; a += s) {
      const l = e[a], h = e[a + 1], c = i(l, h, t);
      n[a] = c[0], n[a + 1] = c[1];
    }
    return n;
  };
}
function Qf(i) {
  return j1(i) ? new r0({ code: i, units: "m" }) : null;
}
function tg(i) {
  const t = j1(i.getCode());
  return t ? {
    forward: Dh(qf, t),
    inverse: Dh(Zf, t)
  } : null;
}
const eg = [tg], ig = [Qf];
let ga = !0;
function U1(i) {
  ga = !1;
}
function cl(i, t) {
  if (t !== void 0) {
    for (let e = 0, n = i.length; e < n; ++e)
      t[e] = i[e];
    t = t;
  } else
    t = i.slice();
  return t;
}
function B1(i, t) {
  if (t !== void 0 && i !== t) {
    for (let e = 0, n = i.length; e < n; ++e)
      t[e] = i[e];
    i = t;
  }
  return i;
}
function ho(i) {
  jf(i.getCode(), i), Pn(i, i, cl);
}
function ng(i) {
  i.forEach(ho);
}
function tt(i) {
  if (typeof i != "string")
    return i;
  const t = mr(i);
  if (t)
    return t;
  for (const e of ig) {
    const n = e(i);
    if (n)
      return n;
  }
  return null;
}
function Lr(i, t, e, n) {
  i = tt(i);
  let r;
  const s = i.getPointResolutionFunc();
  if (s) {
    if (r = s(t, e), n && n !== i.getUnits()) {
      const o = i.getMetersPerUnit();
      o && (r = r * o / Ir[n]);
    }
  } else {
    const o = i.getUnits();
    if (o == "degrees" && !n || n == "degrees")
      r = t;
    else {
      const a = Vr(
        i,
        tt("EPSG:4326")
      );
      if (!a && o !== "degrees")
        r = t * i.getMetersPerUnit();
      else {
        let h = [
          e[0] - t / 2,
          e[1],
          e[0] + t / 2,
          e[1],
          e[0],
          e[1] - t / 2,
          e[0],
          e[1] + t / 2
        ];
        h = a(h, h, 2);
        const c = ua(h.slice(0, 2), h.slice(2, 4)), d = ua(h.slice(4, 6), h.slice(6, 8));
        r = (c + d) / 2;
      }
      const l = n ? Ir[n] : i.getMetersPerUnit();
      l !== void 0 && (r /= l);
    }
  }
  return r;
}
function ma(i) {
  ng(i), i.forEach(function(t) {
    i.forEach(function(e) {
      t !== e && Pn(t, e, cl);
    });
  });
}
function rg(i, t, e, n) {
  i.forEach(function(r) {
    t.forEach(function(s) {
      Pn(r, s, e), Pn(s, r, n);
    });
  });
}
function dl(i, t) {
  return i ? typeof i == "string" ? tt(i) : (
    /** @type {Projection} */
    i
  ) : tt(t);
}
function pa(i) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimensions that should be transformed.
     * @param {number} [stride] Stride.
     * @return {Array<number>} Output.
     */
    (function(t, e, n, r) {
      const s = t.length;
      n = n !== void 0 ? n : 2, r = r ?? n, e = e !== void 0 ? e : new Array(s);
      for (let o = 0; o < s; o += r) {
        const a = i(t.slice(o, o + n)), l = a.length;
        for (let h = 0, c = r; h < c; ++h)
          e[o + h] = h >= l ? t[o + h] : a[h];
      }
      return e;
    })
  );
}
function sg(i, t, e, n) {
  const r = tt(i), s = tt(t);
  Pn(
    r,
    s,
    pa(e)
  ), Pn(
    s,
    r,
    pa(n)
  );
}
function og(i, t) {
  return U1(), tn(
    i,
    "EPSG:4326",
    "EPSG:3857"
  );
}
function Qt(i, t) {
  if (i === t)
    return !0;
  const e = i.getUnits() === t.getUnits();
  return (i.getCode() === t.getCode() || Vr(i, t) === cl) && e;
}
function Vr(i, t) {
  const e = i.getCode(), n = t.getCode();
  let r = Z0(e, n);
  if (r)
    return r;
  let s = null, o = null;
  for (const l of eg)
    s || (s = l(i)), o || (o = l(t));
  if (!s && !o)
    return null;
  const a = "EPSG:4326";
  if (o)
    if (s)
      r = C2(
        s.inverse,
        o.forward
      );
    else {
      const l = Z0(e, a);
      l && (r = C2(
        l,
        o.forward
      ));
    }
  else {
    const l = Z0(a, n);
    l && (r = C2(
      s.inverse,
      l
    ));
  }
  return r && (ho(i), ho(t), Pn(i, t, r)), r;
}
function C2(i, t) {
  return function(e, n, r, s) {
    return n = i(e, n, r, s), t(n, n, r, s);
  };
}
function In(i, t) {
  const e = tt(i), n = tt(t);
  return Vr(e, n);
}
function tn(i, t, e) {
  const n = In(t, e);
  if (!n) {
    const r = tt(t).getCode(), s = tt(e).getCode();
    throw new Error(
      `No transform available between ${r} and ${s}`
    );
  }
  return n(i, void 0, i.length);
}
function Cs(i, t, e, n) {
  const r = In(t, e);
  return Tf(i, r, void 0, n);
}
let ag = null;
function lg() {
  return ag;
}
function kn(i, t) {
  return i;
}
function pt(i, t) {
  return ga && !$t(i, [0, 0]) && i[0] >= -180 && i[0] <= 180 && i[1] >= -90 && i[1] <= 90 && (ga = !1, O1(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), i;
}
function Yo(i, t) {
  return i;
}
function Te(i, t) {
  return i;
}
function zh(i, t, e) {
  return function(n) {
    let r, s;
    if (i.canWrapX()) {
      const o = i.getExtent(), a = it(o);
      n = n.slice(0), s = k1(n, i, a), s && (n[0] = n[0] - s * a), n[0] = ft(n[0], o[0], o[2]), n[1] = ft(n[1], o[1], o[3]), r = e(n);
    } else
      r = e(n);
    return s && t.canWrapX() && (r[0] += s * it(t.getExtent())), r;
  };
}
function hg() {
  ma(Lh), ma(Fh), rg(
    Fh,
    Lh,
    Gf,
    Nf
  );
}
hg();
const V1 = new Array(6);
function Le() {
  return [1, 0, 0, 1, 0, 0];
}
function jh(i) {
  return fl(i, 1, 0, 0, 1, 0, 0);
}
function ul(i, t) {
  const e = i[0], n = i[1], r = i[2], s = i[3], o = i[4], a = i[5], l = t[0], h = t[1], c = t[2], d = t[3], u = t[4], f = t[5];
  return i[0] = e * l + r * h, i[1] = n * l + s * h, i[2] = e * c + r * d, i[3] = n * c + s * d, i[4] = e * u + r * f + o, i[5] = n * u + s * f + a, i;
}
function fl(i, t, e, n, r, s, o) {
  return i[0] = t, i[1] = e, i[2] = n, i[3] = r, i[4] = s, i[5] = o, i;
}
function cg(i, t) {
  return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i;
}
function Tt(i, t) {
  const e = t[0], n = t[1];
  return t[0] = i[0] * e + i[2] * n + i[4], t[1] = i[1] * e + i[3] * n + i[5], t;
}
function b2(i, t, e) {
  return ul(i, fl(V1, t, 0, 0, e, 0, 0));
}
function dg(i, t, e) {
  return ul(i, fl(V1, 1, 0, 0, 1, t, e));
}
function ri(i, t, e, n, r, s, o, a) {
  const l = Math.sin(s), h = Math.cos(s);
  return i[0] = n * h, i[1] = r * l, i[2] = -n * l, i[3] = r * h, i[4] = o * n * h - a * n * l + t, i[5] = o * r * l + a * r * h + e, i;
}
function $1(i, t) {
  const e = ug(t);
  at(e !== 0, "Transformation matrix cannot be inverted");
  const n = t[0], r = t[1], s = t[2], o = t[3], a = t[4], l = t[5];
  return i[0] = o / e, i[1] = -r / e, i[2] = -s / e, i[3] = n / e, i[4] = (s * l - o * a) / e, i[5] = -(n * l - r * a) / e, i;
}
function ug(i) {
  return i[0] * i[3] - i[1] * i[2];
}
const fg = [1e5, 1e5, 1e5, 1e5, 2, 2];
function gg(i) {
  return "matrix(" + i.join(", ") + ")";
}
function _a(i) {
  return i.substring(7, i.length - 1).split(",").map(parseFloat);
}
function mg(i, t) {
  const e = _a(i), n = _a(t);
  for (let r = 0; r < 6; ++r)
    if (Math.round((e[r] - n[r]) * fg[r]) !== 0)
      return !1;
  return !0;
}
function Yi(i, t, e, n, r, s, o) {
  s = s || [], o = o || 2;
  let a = 0;
  for (let l = t; l < e; l += n) {
    const h = i[l], c = i[l + 1];
    s[a++] = r[0] * h + r[2] * c + r[4], s[a++] = r[1] * h + r[3] * c + r[5];
    for (let d = 2; d < o; d++)
      s[a++] = i[l + d];
  }
  return s && s.length != a && (s.length = a), s;
}
function gl(i, t, e, n, r, s, o) {
  o = o || [];
  const a = Math.cos(r), l = Math.sin(r), h = s[0], c = s[1];
  let d = 0;
  for (let u = t; u < e; u += n) {
    const f = i[u] - h, g = i[u + 1] - c;
    o[d++] = h + f * a - g * l, o[d++] = c + f * l + g * a;
    for (let p = u + 2; p < u + n; ++p)
      o[d++] = i[p];
  }
  return o && o.length != d && (o.length = d), o;
}
function pg(i, t, e, n, r, s, o, a) {
  a = a || [];
  const l = o[0], h = o[1];
  let c = 0;
  for (let d = t; d < e; d += n) {
    const u = i[d] - l, f = i[d + 1] - h;
    a[c++] = l + r * u, a[c++] = h + s * f;
    for (let g = d + 2; g < d + n; ++g)
      a[c++] = i[g];
  }
  return a && a.length != c && (a.length = c), a;
}
function _g(i, t, e, n, r, s, o) {
  o = o || [];
  let a = 0;
  for (let l = t; l < e; l += n) {
    o[a++] = i[l] + r, o[a++] = i[l + 1] + s;
    for (let h = l + 2; h < l + n; ++h)
      o[a++] = i[h];
  }
  return o && o.length != a && (o.length = a), o;
}
const Uh = Le(), yg = [NaN, NaN];
class W1 extends De {
  constructor() {
    super(), this.extent_ = ne(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = b1(
      (t, e, n) => {
        if (!n)
          return this.getSimplifiedGeometry(e);
        const r = this.clone();
        return r.applyTransform(n), r.getSimplifiedGeometry(e);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(t, e) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      t,
      e
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return X();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, e, n, r) {
    return X();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, e) {
    return this.closestPointXY(t, e, yg, Number.MIN_VALUE) === 0;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(t, e) {
    return e = e || [NaN, NaN], this.closestPointXY(t[0], t[1], e, 1 / 0), e;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(t) {
    return this.containsXY(t[0], t[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return X();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(t) {
    if (this.extentRevision_ != this.getRevision()) {
      const e = this.computeExtent(this.extent_);
      (isNaN(e[0]) || isNaN(e[1])) && Ur(e), this.extentRevision_ = this.getRevision();
    }
    return Ef(this.extent_, t);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, e) {
    X();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, e, n) {
    X();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(t) {
    return this.getSimplifiedGeometry(t * t);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    return X();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return X();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(t) {
    X();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(t) {
    return X();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, e) {
    X();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(t, e) {
    const n = tt(t), r = n.getUnits() == "tile-pixels" ? function(s, o, a) {
      const l = n.getExtent(), h = n.getWorldExtent(), c = Rt(h) / Rt(l);
      ri(
        Uh,
        h[0],
        h[3],
        c,
        -c,
        0,
        0,
        0
      );
      const d = Yi(
        s,
        0,
        s.length,
        a,
        Uh,
        o
      ), u = In(n, e);
      return u ? u(d, d, a) : d;
    } : In(n, e);
    return this.applyTransform(r), this;
  }
}
class en extends W1 {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(t) {
    return nl(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return X();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @override
   */
  getSimplifiedGeometry(t) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const e = this.getSimplifiedGeometryInternal(t);
    return e.getFlatCoordinates().length < this.flatCoordinates.length ? e : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(t, e) {
    this.stride = co(t), this.layout = t, this.flatCoordinates = e;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(t, e) {
    X();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(t, e, n) {
    let r;
    if (t)
      r = co(t);
    else {
      for (let s = 0; s < n; ++s) {
        if (e.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        }
        e = /** @type {Array<unknown>} */
        e[0];
      }
      r = e.length, t = Dn(r);
    }
    this.layout = t, this.stride = r;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   * @override
   */
  applyTransform(t) {
    this.flatCoordinates && (t(
      this.flatCoordinates,
      this.flatCoordinates,
      this.layout.startsWith("XYZ") ? 3 : 2,
      this.stride
    ), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   * @override
   */
  rotate(t, e) {
    const n = this.getFlatCoordinates();
    if (n) {
      const r = this.getStride();
      gl(
        n,
        0,
        n.length,
        r,
        t,
        e,
        n
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   * @override
   */
  scale(t, e, n) {
    e === void 0 && (e = t), n || (n = ni(this.getExtent()));
    const r = this.getFlatCoordinates();
    if (r) {
      const s = this.getStride();
      pg(
        r,
        0,
        r.length,
        s,
        t,
        e,
        n,
        r
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   * @override
   */
  translate(t, e) {
    const n = this.getFlatCoordinates();
    if (n) {
      const r = this.getStride();
      _g(
        n,
        0,
        n.length,
        r,
        t,
        e,
        n
      ), this.changed();
    }
  }
}
function Dn(i) {
  let t;
  return i == 2 ? t = "XY" : i == 3 ? t = "XYZ" : i == 4 && (t = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  t;
}
function co(i) {
  let t;
  return i == "XY" ? t = 2 : i == "XYZ" || i == "XYM" ? t = 3 : i == "XYZM" && (t = 4), /** @type {number} */
  t;
}
function vg(i, t, e) {
  const n = i.getFlatCoordinates();
  if (!n)
    return null;
  const r = i.getStride();
  return Yi(
    n,
    0,
    n.length,
    r,
    t,
    e
  );
}
function Y1(i, t, e, n) {
  let r = 0;
  const s = i[e - n], o = i[e - n + 1];
  let a = 0, l = 0;
  for (; t < e; t += n) {
    const h = i[t] - s, c = i[t + 1] - o;
    r += l * h - a * c, a = h, l = c;
  }
  return r / 2;
}
function X1(i, t, e, n) {
  let r = 0;
  for (let s = 0, o = e.length; s < o; ++s) {
    const a = e[s];
    r += Y1(i, t, a, n), t = a;
  }
  return r;
}
function xg(i, t, e, n) {
  let r = 0;
  for (let s = 0, o = e.length; s < o; ++s) {
    const a = e[s];
    r += X1(i, t, a, n), t = a[a.length - 1];
  }
  return r;
}
function Bh(i, t, e, n, r, s, o) {
  const a = i[t], l = i[t + 1], h = i[e] - a, c = i[e + 1] - l;
  let d;
  if (h === 0 && c === 0)
    d = t;
  else {
    const u = ((r - a) * h + (s - l) * c) / (h * h + c * c);
    if (u > 1)
      d = e;
    else if (u > 0) {
      for (let f = 0; f < n; ++f)
        o[f] = pe(
          i[t + f],
          i[e + f],
          u
        );
      o.length = n;
      return;
    } else
      d = t;
  }
  for (let u = 0; u < n; ++u)
    o[u] = i[d + u];
  o.length = n;
}
function ml(i, t, e, n, r) {
  let s = i[t], o = i[t + 1];
  for (t += n; t < e; t += n) {
    const a = i[t], l = i[t + 1], h = mi(s, o, a, l);
    h > r && (r = h), s = a, o = l;
  }
  return r;
}
function pl(i, t, e, n, r) {
  for (let s = 0, o = e.length; s < o; ++s) {
    const a = e[s];
    r = ml(i, t, a, n, r), t = a;
  }
  return r;
}
function Cg(i, t, e, n, r) {
  for (let s = 0, o = e.length; s < o; ++s) {
    const a = e[s];
    r = pl(i, t, a, n, r), t = a[a.length - 1];
  }
  return r;
}
function _l(i, t, e, n, r, s, o, a, l, h, c) {
  if (t == e)
    return h;
  let d, u;
  if (r === 0) {
    if (u = mi(
      o,
      a,
      i[t],
      i[t + 1]
    ), u < h) {
      for (d = 0; d < n; ++d)
        l[d] = i[t + d];
      return l.length = n, u;
    }
    return h;
  }
  c = c || [NaN, NaN];
  let f = t + n;
  for (; f < e; )
    if (Bh(
      i,
      f - n,
      f,
      n,
      o,
      a,
      c
    ), u = mi(o, a, c[0], c[1]), u < h) {
      for (h = u, d = 0; d < n; ++d)
        l[d] = c[d];
      l.length = n, f += n;
    } else
      f += n * Math.max(
        (Math.sqrt(u) - Math.sqrt(h)) / r | 0,
        1
      );
  if (s && (Bh(
    i,
    e - n,
    t,
    n,
    o,
    a,
    c
  ), u = mi(o, a, c[0], c[1]), u < h)) {
    for (h = u, d = 0; d < n; ++d)
      l[d] = c[d];
    l.length = n;
  }
  return h;
}
function yl(i, t, e, n, r, s, o, a, l, h, c) {
  c = c || [NaN, NaN];
  for (let d = 0, u = e.length; d < u; ++d) {
    const f = e[d];
    h = _l(
      i,
      t,
      f,
      n,
      r,
      s,
      o,
      a,
      l,
      h,
      c
    ), t = f;
  }
  return h;
}
function bg(i, t, e, n, r, s, o, a, l, h, c) {
  c = c || [NaN, NaN];
  for (let d = 0, u = e.length; d < u; ++d) {
    const f = e[d];
    h = yl(
      i,
      t,
      f,
      n,
      r,
      s,
      o,
      a,
      l,
      h,
      c
    ), t = f[f.length - 1];
  }
  return h;
}
function Z1(i, t, e, n) {
  for (let r = 0, s = e.length; r < s; ++r)
    i[t++] = e[r];
  return t;
}
function Xo(i, t, e, n) {
  for (let r = 0, s = e.length; r < s; ++r) {
    const o = e[r];
    for (let a = 0; a < n; ++a)
      i[t++] = o[a];
  }
  return t;
}
function o0(i, t, e, n, r) {
  r = r || [];
  let s = 0;
  for (let o = 0, a = e.length; o < a; ++o) {
    const l = Xo(
      i,
      t,
      e[o],
      n
    );
    r[s++] = l, t = l;
  }
  return r.length = s, r;
}
function H1(i, t, e, n, r) {
  r = r || [];
  let s = 0;
  for (let o = 0, a = e.length; o < a; ++o) {
    const l = o0(
      i,
      t,
      e[o],
      n,
      r[s]
    );
    l.length === 0 && (l[0] = t), r[s++] = l, t = l[l.length - 1];
  }
  return r.length = s, r;
}
function Ni(i, t, e, n, r) {
  r = r !== void 0 ? r : [];
  let s = 0;
  for (let o = t; o < e; o += n)
    r[s++] = i.slice(o, o + n);
  return r.length = s, r;
}
function js(i, t, e, n, r) {
  r = r !== void 0 ? r : [];
  let s = 0;
  for (let o = 0, a = e.length; o < a; ++o) {
    const l = e[o];
    r[s++] = Ni(
      i,
      t,
      l,
      n,
      r[s]
    ), t = l;
  }
  return r.length = s, r;
}
function ya(i, t, e, n, r) {
  r = r !== void 0 ? r : [];
  let s = 0;
  for (let o = 0, a = e.length; o < a; ++o) {
    const l = e[o];
    r[s++] = l.length === 1 && l[0] === t ? [] : js(
      i,
      t,
      l,
      n,
      r[s]
    ), t = l[l.length - 1];
  }
  return r.length = s, r;
}
function Zo(i, t, e, n, r, s, o) {
  const a = (e - t) / n;
  if (a < 3) {
    for (; t < e; t += n)
      s[o++] = i[t], s[o++] = i[t + 1];
    return o;
  }
  const l = new Array(a);
  l[0] = 1, l[a - 1] = 1;
  const h = [t, e - n];
  let c = 0;
  for (; h.length > 0; ) {
    const d = h.pop(), u = h.pop();
    let f = 0;
    const g = i[u], p = i[u + 1], m = i[d], _ = i[d + 1];
    for (let y = u + n; y < d; y += n) {
      const x = i[y], v = i[y + 1], C = yf(x, v, g, p, m, _);
      C > f && (c = y, f = C);
    }
    f > r && (l[(c - t) / n] = 1, u + n < c && h.push(u, c), c + n < d && h.push(c, d));
  }
  for (let d = 0; d < a; ++d)
    l[d] && (s[o++] = i[t + d * n], s[o++] = i[t + d * n + 1]);
  return o;
}
function K1(i, t, e, n, r, s, o, a) {
  for (let l = 0, h = e.length; l < h; ++l) {
    const c = e[l];
    o = Zo(
      i,
      t,
      c,
      n,
      r,
      s,
      o
    ), a.push(o), t = c;
  }
  return o;
}
function dn(i, t) {
  return t * Math.round(i / t);
}
function wg(i, t, e, n, r, s, o) {
  if (t == e)
    return o;
  let a = dn(i[t], r), l = dn(i[t + 1], r);
  t += n, s[o++] = a, s[o++] = l;
  let h, c;
  do
    if (h = dn(i[t], r), c = dn(i[t + 1], r), t += n, t == e)
      return s[o++] = h, s[o++] = c, o;
  while (h == a && c == l);
  for (; t < e; ) {
    const d = dn(i[t], r), u = dn(i[t + 1], r);
    if (t += n, d == h && u == c)
      continue;
    const f = h - a, g = c - l, p = d - a, m = u - l;
    if (f * m == g * p && (f < 0 && p < f || f == p || f > 0 && p > f) && (g < 0 && m < g || g == m || g > 0 && m > g)) {
      h = d, c = u;
      continue;
    }
    s[o++] = h, s[o++] = c, a = h, l = c, h = d, c = u;
  }
  return s[o++] = h, s[o++] = c, o;
}
function vl(i, t, e, n, r, s, o, a) {
  for (let l = 0, h = e.length; l < h; ++l) {
    const c = e[l];
    o = wg(
      i,
      t,
      c,
      n,
      r,
      s,
      o
    ), a.push(o), t = c;
  }
  return o;
}
function Eg(i, t, e, n, r, s, o, a) {
  for (let l = 0, h = e.length; l < h; ++l) {
    const c = e[l], d = [];
    o = vl(
      i,
      t,
      c,
      n,
      r,
      s,
      o,
      d
    ), a.push(d), t = c[c.length - 1];
  }
  return o;
}
class Us extends en {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      e
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   * @override
   */
  clone() {
    return new Us(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(t, e, n, r) {
    return r < Gn(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      ml(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), _l(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      e,
      n,
      r
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return Y1(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return Ni(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(t) {
    const e = [];
    return e.length = Zo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      e,
      0
    ), new Us(e, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(t) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Xo(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
let de = class q1 extends en {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e) {
    super(), this.setCoordinates(t, e);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   * @override
   */
  clone() {
    const t = new q1(this.flatCoordinates.slice(), this.layout);
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(t, e, n, r) {
    const s = this.flatCoordinates, o = mi(
      t,
      e,
      s[0],
      s[1]
    );
    if (o < r) {
      const a = this.stride;
      for (let l = 0; l < a; ++l)
        n[l] = s[l];
      return n.length = a, o;
    }
    return r;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(t) {
    return vs(this.flatCoordinates, t);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(t) {
    return il(t, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Z1(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
};
function Sg(i, t, e, n, r) {
  return !rl(
    r,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(o) {
      return !_n(
        i,
        t,
        e,
        n,
        o[0],
        o[1]
      );
    }
  );
}
function _n(i, t, e, n, r, s) {
  let o = 0, a = i[e - n], l = i[e - n + 1];
  for (; t < e; t += n) {
    const h = i[t], c = i[t + 1];
    l <= s ? c > s && (h - a) * (s - l) - (r - a) * (c - l) > 0 && o++ : c <= s && (h - a) * (s - l) - (r - a) * (c - l) < 0 && o--, a = h, l = c;
  }
  return o !== 0;
}
function xl(i, t, e, n, r, s) {
  if (e.length === 0 || !_n(i, t, e[0], n, r, s))
    return !1;
  for (let o = 1, a = e.length; o < a; ++o)
    if (_n(i, e[o - 1], e[o], n, r, s))
      return !1;
  return !0;
}
function Mg(i, t, e, n, r, s) {
  if (e.length === 0)
    return !1;
  for (let o = 0, a = e.length; o < a; ++o) {
    const l = e[o];
    if (xl(i, t, l, n, r, s))
      return !0;
    t = l[l.length - 1];
  }
  return !1;
}
function Cl(i, t, e, n, r, s, o) {
  let a, l, h, c, d, u, f;
  const g = r[s + 1], p = [];
  for (let y = 0, x = e.length; y < x; ++y) {
    const v = e[y];
    for (c = i[v - n], u = i[v - n + 1], a = t; a < v; a += n)
      d = i[a], f = i[a + 1], (g <= u && f <= g || u <= g && g <= f) && (h = (g - u) / (f - u) * (d - c) + c, p.push(h)), c = d, u = f;
  }
  let m = NaN, _ = -1 / 0;
  for (p.sort(ei), c = p[0], a = 1, l = p.length; a < l; ++a) {
    d = p[a];
    const y = Math.abs(d - c);
    y > _ && (h = (c + d) / 2, xl(i, t, e, n, h, g) && (m = h, _ = y)), c = d;
  }
  return isNaN(m) && (m = r[s]), o ? (o.push(m, g, _), o) : [m, g, _];
}
function J1(i, t, e, n, r) {
  let s = [];
  for (let o = 0, a = e.length; o < a; ++o) {
    const l = e[o];
    s = Cl(
      i,
      t,
      l,
      n,
      r,
      2 * o,
      s
    ), t = l[l.length - 1];
  }
  return s;
}
function Q1(i, t, e, n, r) {
  let s;
  for (t += n; t < e; t += n)
    if (s = r(
      i.slice(t - n, t),
      i.slice(t, t + n)
    ), s)
      return s;
  return !1;
}
function Ho(i, t, e, n, r, s) {
  return s = s ?? T1(ne(), i, t, e, n), bt(r, s) ? s[0] >= r[0] && s[2] <= r[2] || s[1] >= r[1] && s[3] <= r[3] ? !0 : Q1(
    i,
    t,
    e,
    n,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(o, a) {
      return Mf(r, o, a);
    }
  ) : !1;
}
function Tg(i, t, e, n, r) {
  for (let s = 0, o = e.length; s < o; ++s) {
    if (Ho(i, t, e[s], n, r))
      return !0;
    t = e[s];
  }
  return !1;
}
function td(i, t, e, n, r) {
  return !!(Ho(i, t, e, n, r) || _n(
    i,
    t,
    e,
    n,
    r[0],
    r[1]
  ) || _n(
    i,
    t,
    e,
    n,
    r[0],
    r[3]
  ) || _n(
    i,
    t,
    e,
    n,
    r[2],
    r[1]
  ) || _n(
    i,
    t,
    e,
    n,
    r[2],
    r[3]
  ));
}
function ed(i, t, e, n, r) {
  if (!td(i, t, e[0], n, r))
    return !1;
  if (e.length === 1)
    return !0;
  for (let s = 1, o = e.length; s < o; ++s)
    if (Sg(
      i,
      e[s - 1],
      e[s],
      n,
      r
    ) && !Ho(
      i,
      e[s - 1],
      e[s],
      n,
      r
    ))
      return !1;
  return !0;
}
function Rg(i, t, e, n, r) {
  for (let s = 0, o = e.length; s < o; ++s) {
    const a = e[s];
    if (ed(i, t, a, n, r))
      return !0;
    t = a[a.length - 1];
  }
  return !1;
}
function Pg(i, t, e, n) {
  for (; t < e - n; ) {
    for (let r = 0; r < n; ++r) {
      const s = i[t + r];
      i[t + r] = i[e - n + r], i[e - n + r] = s;
    }
    t += n, e -= n;
  }
}
function bl(i, t, e, n) {
  let r = 0, s = i[e - n], o = i[e - n + 1];
  for (; t < e; t += n) {
    const a = i[t], l = i[t + 1];
    r += (a - s) * (l + o), s = a, o = l;
  }
  return r === 0 ? void 0 : r > 0;
}
function wl(i, t, e, n, r) {
  r = r !== void 0 ? r : !1;
  for (let s = 0, o = e.length; s < o; ++s) {
    const a = e[s], l = bl(
      i,
      t,
      a,
      n
    );
    if (s === 0) {
      if (r && l || !r && !l)
        return !1;
    } else if (r && !l || !r && l)
      return !1;
    t = a;
  }
  return !0;
}
function id(i, t, e, n, r) {
  for (let s = 0, o = e.length; s < o; ++s) {
    const a = e[s];
    if (!wl(i, t, a, n, r))
      return !1;
    a.length && (t = a[a.length - 1]);
  }
  return !0;
}
function uo(i, t, e, n, r) {
  r = r !== void 0 ? r : !1;
  for (let s = 0, o = e.length; s < o; ++s) {
    const a = e[s], l = bl(
      i,
      t,
      a,
      n
    );
    (s === 0 ? r && l || !r && !l : r && !l || !r && l) && Pg(i, t, a, n), t = a;
  }
  return t;
}
function va(i, t, e, n, r) {
  for (let s = 0, o = e.length; s < o; ++s)
    t = uo(
      i,
      t,
      e[s],
      n,
      r
    );
  return t;
}
function nd(i, t) {
  const e = [];
  let n = 0, r = 0, s;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o], h = bl(i, n, l, 2);
    if (s === void 0 && (s = h), h === s)
      e.push(t.slice(r, o + 1));
    else {
      if (e.length === 0)
        continue;
      e[e.length - 1].push(t[r]);
    }
    r = o + 1, n = l;
  }
  return e;
}
class jt extends en {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(t, e, n) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, e !== void 0 && n ? (this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ), this.ends_ = n) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      t,
      e
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(t) {
    this.flatCoordinates ? ot(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   * @override
   */
  clone() {
    const t = new jt(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(t, e, n, r) {
    return r < Gn(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      pl(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), yl(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      e,
      n,
      r
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(t, e) {
    return xl(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      t,
      e
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return X1(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates(t) {
    let e;
    return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), uo(e, 0, this.ends_, this.stride, t)) : e = this.flatCoordinates, js(e, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const t = ni(this.getExtent());
      this.flatInteriorPoint_ = Cl(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        t,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new de(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(t) {
    return t < 0 || this.ends_.length <= t ? null : new Us(
      this.flatCoordinates.slice(
        t === 0 ? 0 : this.ends_[t - 1],
        this.ends_[t]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const t = this.layout, e = this.flatCoordinates, n = this.ends_, r = [];
    let s = 0;
    for (let o = 0, a = n.length; o < a; ++o) {
      const l = n[o], h = new Us(
        e.slice(s, l),
        t
      );
      r.push(h), s = l;
    }
    return r;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const t = this.flatCoordinates;
      wl(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = uo(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(t) {
    const e = [], n = [];
    return e.length = vl(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(t),
      e,
      0,
      n
    ), new jt(e, "XY", n);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(t) {
    return ed(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const n = o0(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed();
  }
}
function Ig(i, t, e, n) {
  e = e || 32;
  const r = [];
  for (let s = 0; s < e; ++s)
    ot(
      r,
      Af(i, t, 2 * Math.PI * s / e, n)
    );
  return r.push(r[0], r[1]), new jt(r, "XY", [r.length]);
}
function fo(i) {
  if (Qi(i))
    throw new Error("Cannot create polygon from empty extent");
  const t = i[0], e = i[1], n = i[2], r = i[3], s = [
    t,
    e,
    t,
    r,
    n,
    r,
    n,
    e,
    t,
    e
  ];
  return new jt(s, "XY", [s.length]);
}
function El(i, t, e, n) {
  const r = it(t) / e[0], s = Rt(t) / e[1];
  return n ? Math.min(i, Math.max(r, s)) : Math.min(i, Math.min(r, s));
}
function Sl(i, t, e) {
  let n = Math.min(i, t);
  const r = 50;
  return n *= Math.log(1 + r * Math.max(0, i / t - 1)) / r + 1, e && (n = Math.max(n, e), n /= Math.log(1 + r * Math.max(0, e / i - 1)) / r + 1), ft(n, e / 2, t * 2);
}
function kg(i, t, e, n) {
  return t = t !== void 0 ? t : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  (function(r, s, o, a) {
    if (r !== void 0) {
      const l = i[0], h = i[i.length - 1], c = e ? El(
        l,
        e,
        o,
        n
      ) : l;
      if (a)
        return t ? Sl(
          r,
          c,
          h
        ) : ft(r, h, c);
      const d = Math.min(c, r), u = Math.floor(Uo(i, d, s));
      return i[u] > c && u < i.length - 1 ? i[u + 1] : i[u];
    }
  });
}
function Lg(i, t, e, n, r, s) {
  return n = n !== void 0 ? n : !0, e = e !== void 0 ? e : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  (function(o, a, l, h) {
    if (o !== void 0) {
      const c = r ? El(
        t,
        r,
        l,
        s
      ) : t;
      if (h)
        return n ? Sl(
          o,
          c,
          e
        ) : ft(o, e, c);
      const d = 1e-9, u = Math.ceil(
        Math.log(t / c) / Math.log(i) - d
      ), f = -a * (0.5 - d) + 0.5, g = Math.min(c, o), p = Math.floor(
        Math.log(t / g) / Math.log(i) + f
      ), m = Math.max(u, p), _ = t / Math.pow(i, m);
      return ft(_, e, c);
    }
  });
}
function Vh(i, t, e, n, r) {
  return e = e !== void 0 ? e : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  (function(s, o, a, l) {
    if (s !== void 0) {
      const h = n ? El(
        i,
        n,
        a,
        r
      ) : i;
      return !e || !l ? ft(s, t, h) : Sl(
        s,
        h,
        t
      );
    }
  });
}
function Ml(i) {
  if (i !== void 0)
    return 0;
}
function $h(i) {
  if (i !== void 0)
    return i;
}
function Ag(i) {
  const t = 2 * Math.PI / i;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    (function(e, n) {
      if (n)
        return e;
      if (e !== void 0)
        return e = Math.floor(e / t + 0.5) * t, e;
    })
  );
}
function Fg(i) {
  const t = ie(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    (function(e, n) {
      return n || e === void 0 ? e : Math.abs(e) <= t ? 0 : e;
    })
  );
}
const rd = 42, Tl = 256, w2 = 0;
class Se extends De {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = Object.assign({}, t), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = dl(t.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, t.projection && U1(), t.center && (t.center = pt(t.center, this.projection_)), t.extent && (t.extent = Te(t.extent, this.projection_)), this.applyOptions_(t);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(t) {
    const e = Object.assign({}, t);
    for (const a in me)
      delete e[a];
    this.setProperties(e, !0);
    const n = Gg(t);
    this.maxResolution_ = n.maxResolution, this.minResolution_ = n.minResolution, this.zoomFactor_ = n.zoomFactor, this.resolutions_ = t.resolutions, this.padding_ = t.padding, this.minZoom_ = n.minZoom;
    const r = Og(t), s = n.constraint, o = Ng(t);
    this.constraints_ = {
      center: r,
      resolution: s,
      rotation: o
    }, this.setRotation(t.rotation !== void 0 ? t.rotation : 0), this.setCenterInternal(
      t.center !== void 0 ? t.center : null
    ), t.resolution !== void 0 ? this.setResolution(t.resolution) : t.zoom !== void 0 && this.setZoom(t.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(t) {
    let e = this.padding_;
    this.padding_ = t;
    const n = this.getCenterInternal();
    if (n) {
      const r = t || [0, 0, 0, 0];
      e = e || [0, 0, 0, 0];
      const s = this.getResolution(), o = s / 2 * (r[3] - e[3] + e[1] - r[1]), a = s / 2 * (r[0] - e[0] + e[2] - r[2]);
      this.setCenterInternal([n[0] + o, n[1] - a]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(t) {
    const e = this.getProperties();
    return e.resolution !== void 0 ? e.resolution = this.getResolution() : e.zoom = this.getZoom(), e.center = this.getCenterInternal(), e.rotation = this.getRotation(), Object.assign({}, e, t);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(t) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const e = new Array(arguments.length);
    for (let n = 0; n < e.length; ++n) {
      let r = arguments[n];
      r.center && (r = Object.assign({}, r), r.center = pt(
        r.center,
        this.getProjection()
      )), r.anchor && (r = Object.assign({}, r), r.anchor = pt(
        r.anchor,
        this.getProjection()
      )), e[n] = r;
    }
    this.animateInternal.apply(this, e);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(t) {
    let e = arguments.length, n;
    e > 1 && typeof arguments[e - 1] == "function" && (n = arguments[e - 1], --e);
    let r = 0;
    for (; r < e && !this.isDef(); ++r) {
      const c = arguments[r];
      c.center && this.setCenterInternal(c.center), c.zoom !== void 0 ? this.setZoom(c.zoom) : c.resolution && this.setResolution(c.resolution), c.rotation !== void 0 && this.setRotation(c.rotation);
    }
    if (r === e) {
      n && M0(n, !0);
      return;
    }
    let s = Date.now(), o = this.targetCenter_.slice(), a = this.targetResolution_, l = this.targetRotation_;
    const h = [];
    for (; r < e; ++r) {
      const c = (
        /** @type {AnimationOptions} */
        arguments[r]
      ), d = {
        start: s,
        complete: !1,
        anchor: c.anchor,
        duration: c.duration !== void 0 ? c.duration : 1e3,
        easing: c.easing || kf,
        callback: n
      };
      if (c.center && (d.sourceCenter = o, d.targetCenter = c.center.slice(), o = d.targetCenter), c.zoom !== void 0 ? (d.sourceResolution = a, d.targetResolution = this.getResolutionForZoom(c.zoom), a = d.targetResolution) : c.resolution && (d.sourceResolution = a, d.targetResolution = c.resolution, a = d.targetResolution), c.rotation !== void 0) {
        d.sourceRotation = l;
        const u = wn(c.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
        d.targetRotation = l + u, l = d.targetRotation;
      }
      Dg(d) ? d.complete = !0 : s += d.duration, h.push(d);
    }
    this.animations_.push(h), this.setHint(mt.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[mt.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[mt.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(mt.ANIMATING, -this.hints_[mt.ANIMATING]);
    let t;
    for (let e = 0, n = this.animations_.length; e < n; ++e) {
      const r = this.animations_[e];
      if (r[0].callback && M0(r[0].callback, !1), !t)
        for (let s = 0, o = r.length; s < o; ++s) {
          const a = r[s];
          if (!a.complete) {
            t = a.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = t, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const t = Date.now();
    let e = !1;
    for (let n = this.animations_.length - 1; n >= 0; --n) {
      const r = this.animations_[n];
      let s = !0;
      for (let o = 0, a = r.length; o < a; ++o) {
        const l = r[o];
        if (l.complete)
          continue;
        const h = t - l.start;
        let c = l.duration > 0 ? h / l.duration : 1;
        c >= 1 ? (l.complete = !0, c = 1) : s = !1;
        const d = l.easing(c);
        if (l.sourceCenter) {
          const u = l.sourceCenter[0], f = l.sourceCenter[1], g = l.targetCenter[0], p = l.targetCenter[1];
          this.nextCenter_ = l.targetCenter;
          const m = u + d * (g - u), _ = f + d * (p - f);
          this.targetCenter_ = [m, _];
        }
        if (l.sourceResolution && l.targetResolution) {
          const u = d === 1 ? l.targetResolution : l.sourceResolution + d * (l.targetResolution - l.sourceResolution);
          if (l.anchor) {
            const f = this.getViewportSize_(this.getRotation()), g = this.constraints_.resolution(
              u,
              0,
              f,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              g,
              l.anchor
            );
          }
          this.nextResolution_ = l.targetResolution, this.targetResolution_ = u, this.applyTargetState_(!0);
        }
        if (l.sourceRotation !== void 0 && l.targetRotation !== void 0) {
          const u = d === 1 ? wn(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : l.sourceRotation + d * (l.targetRotation - l.sourceRotation);
          if (l.anchor) {
            const f = this.constraints_.rotation(
              u,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              f,
              l.anchor
            );
          }
          this.nextRotation_ = l.targetRotation, this.targetRotation_ = u;
        }
        if (this.applyTargetState_(!0), e = !0, !l.complete)
          break;
      }
      if (s) {
        this.animations_[n] = null, this.setHint(mt.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const o = r[0].callback;
        o && M0(o, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), e && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(t, e) {
    let n;
    const r = this.getCenterInternal();
    return r !== void 0 && (n = [r[0] - e[0], r[1] - e[1]], al(n, t - this.getRotation()), Rf(n, e)), n;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(t, e) {
    let n;
    const r = this.getCenterInternal(), s = this.getResolution();
    if (r !== void 0 && s !== void 0) {
      const o = e[0] - t * (e[0] - r[0]) / s, a = e[1] - t * (e[1] - r[1]) / s;
      n = [o, a];
    }
    return n;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(t) {
    const e = this.viewportSize_;
    if (t) {
      const n = e[0], r = e[1];
      return [
        Math.abs(n * Math.cos(t)) + Math.abs(r * Math.sin(t)),
        Math.abs(n * Math.sin(t)) + Math.abs(r * Math.cos(t))
      ];
    }
    return e;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(t) {
    this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const t = this.getCenterInternal();
    return t && kn(t, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(me.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(t) {
    return t !== void 0 ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(t) {
    const e = this.calculateExtentInternal(t);
    return Yo(e, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(t) {
    t = t || this.getViewportSizeMinusPadding_();
    const e = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    at(e, "The view center is not defined");
    const n = (
      /** @type {!number} */
      this.getResolution()
    );
    at(n !== void 0, "The view resolution is not defined");
    const r = (
      /** @type {!number} */
      this.getRotation()
    );
    return at(r !== void 0, "The view rotation is not defined"), zs(e, n, r, t);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(t) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(t) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: t }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(t) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(me.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(t, e) {
    return this.getResolutionForExtentInternal(
      Te(t, this.getProjection()),
      e
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(t, e) {
    e = e || this.getViewportSizeMinusPadding_();
    const n = it(t) / e[0], r = Rt(t) / e[1];
    return Math.max(n, r);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(t) {
    t = t || 2;
    const e = this.getConstrainedResolution(this.maxResolution_), n = this.minResolution_, r = Math.log(e / n) / Math.log(t);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      (function(s) {
        return e / Math.pow(t, s * r);
      })
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(me.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(t) {
    const e = Math.log(t || 2), n = this.getConstrainedResolution(this.maxResolution_), r = this.minResolution_, s = Math.log(n / r) / e;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      (function(o) {
        return Math.log(n / o) / e / s;
      })
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(t) {
    let e = this.getViewportSize_(t);
    const n = this.padding_;
    return n && (e = [
      e[0] - n[1] - n[3],
      e[1] - n[0] - n[2]
    ]), e;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const t = this.getProjection(), e = this.getResolution(), n = this.getRotation();
    let r = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const s = this.padding_;
    if (s) {
      const o = this.getViewportSizeMinusPadding_();
      r = E2(
        r,
        this.getViewportSize_(),
        [o[0] / 2 + s[3], o[1] / 2 + s[0]],
        e,
        n
      );
    }
    return {
      center: r.slice(0),
      projection: t !== void 0 ? t : null,
      resolution: e,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: n,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let t;
    const e = this.getResolution();
    return e !== void 0 && (t = this.getZoomForResolution(e)), t;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(t) {
    let e = this.minZoom_ || 0, n, r;
    if (this.resolutions_) {
      const s = Uo(this.resolutions_, t, 1);
      e = s, n = this.resolutions_[s], s == this.resolutions_.length - 1 ? r = 2 : r = n / this.resolutions_[s + 1];
    } else
      n = this.maxResolution_, r = this.zoomFactor_;
    return e + Math.log(n / t) / Math.log(r);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(t) {
    if (this.resolutions_?.length) {
      if (this.resolutions_.length === 1)
        return this.resolutions_[0];
      const e = ft(
        Math.floor(t),
        0,
        this.resolutions_.length - 2
      ), n = this.resolutions_[e] / this.resolutions_[e + 1];
      return this.resolutions_[e] / Math.pow(n, ft(t - e, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(t, e) {
    let n;
    if (at(
      Array.isArray(t) || typeof /** @type {?} */
      t.getSimplifiedGeometry == "function",
      "Invalid extent or geometry provided as `geometry`"
    ), Array.isArray(t)) {
      at(
        !Qi(t),
        "Cannot fit empty extent provided as `geometry`"
      );
      const r = Te(t, this.getProjection());
      n = fo(r);
    } else if (t.getType() === "Circle") {
      const r = Te(
        t.getExtent(),
        this.getProjection()
      );
      n = fo(r), n.rotate(this.getRotation(), ni(r));
    } else
      n = t;
    this.fitInternal(n, e);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(t) {
    const e = this.getRotation(), n = Math.cos(e), r = Math.sin(-e), s = t.getFlatCoordinates(), o = t.getStride();
    let a = 1 / 0, l = 1 / 0, h = -1 / 0, c = -1 / 0;
    for (let d = 0, u = s.length; d < u; d += o) {
      const f = s[d] * n - s[d + 1] * r, g = s[d] * r + s[d + 1] * n;
      a = Math.min(a, f), l = Math.min(l, g), h = Math.max(h, f), c = Math.max(c, g);
    }
    return [a, l, h, c];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(t, e) {
    e = e || {};
    let n = e.size;
    n || (n = this.getViewportSizeMinusPadding_());
    const r = e.padding !== void 0 ? e.padding : [0, 0, 0, 0], s = e.nearest !== void 0 ? e.nearest : !1;
    let o;
    e.minResolution !== void 0 ? o = e.minResolution : e.maxZoom !== void 0 ? o = this.getResolutionForZoom(e.maxZoom) : o = 0;
    const a = this.rotatedExtentForGeometry(t);
    let l = this.getResolutionForExtentInternal(a, [
      n[0] - r[1] - r[3],
      n[1] - r[0] - r[2]
    ]);
    l = isNaN(l) ? o : Math.max(l, o), l = this.getConstrainedResolution(l, s ? 0 : 1);
    const h = this.getRotation(), c = Math.sin(h), d = Math.cos(h), u = ni(a);
    u[0] += (r[1] - r[3]) / 2 * l, u[1] += (r[0] - r[2]) / 2 * l;
    const f = u[0] * d - u[1] * c, g = u[1] * d + u[0] * c, p = this.getConstrainedCenter([f, g], l), m = e.callback ? e.callback : Gs;
    e.duration !== void 0 ? this.animateInternal(
      {
        resolution: l,
        center: p,
        duration: e.duration,
        easing: e.easing
      },
      m
    ) : (this.targetResolution_ = l, this.targetCenter_ = p, this.applyTargetState_(!1, !0), M0(m, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(t, e, n) {
    this.centerOnInternal(
      pt(t, this.getProjection()),
      e,
      n
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(t, e, n) {
    this.setCenterInternal(
      E2(
        t,
        e,
        n,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(t, e, n, r) {
    let s;
    const o = this.padding_;
    if (o && t) {
      const a = this.getViewportSizeMinusPadding_(-n), l = E2(
        t,
        r,
        [a[0] / 2 + o[3], a[1] / 2 + o[0]],
        e,
        n
      );
      s = [
        t[0] - l[0],
        t[1] - l[1]
      ];
    }
    return s;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(t) {
    const e = kn(this.targetCenter_, this.getProjection());
    this.setCenter([
      e[0] + t[0],
      e[1] + t[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(t) {
    const e = this.targetCenter_;
    this.setCenterInternal([
      e[0] + t[0],
      e[1] + t[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(t, e) {
    e = e && pt(e, this.getProjection()), this.adjustResolutionInternal(t, e);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(t, e) {
    const n = this.getAnimating() || this.getInteracting(), r = this.getViewportSize_(this.getRotation()), s = this.constraints_.resolution(
      this.targetResolution_ * t,
      0,
      r,
      n
    );
    e && (this.targetCenter_ = this.calculateCenterZoom(s, e)), this.targetResolution_ *= t, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(t, e) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -t), e);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(t, e) {
    e && (e = pt(e, this.getProjection())), this.adjustRotationInternal(t, e);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(t, e) {
    const n = this.getAnimating() || this.getInteracting(), r = this.constraints_.rotation(
      this.targetRotation_ + t,
      n
    );
    e && (this.targetCenter_ = this.calculateCenterRotate(r, e)), this.targetRotation_ += t, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(t) {
    this.setCenterInternal(
      t && pt(t, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(t) {
    this.targetCenter_ = t, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(t, e) {
    return this.hints_[t] += e, this.changed(), this.hints_[t];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(t) {
    this.targetResolution_ = t, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(t) {
    this.targetRotation_ = t, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(t) {
    this.setResolution(this.getResolutionForZoom(t));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(t, e) {
    const n = this.getAnimating() || this.getInteracting() || e, r = this.constraints_.rotation(
      this.targetRotation_,
      n
    ), s = this.getViewportSize_(r), o = this.constraints_.resolution(
      this.targetResolution_,
      0,
      s,
      n
    ), a = this.constraints_.center(
      this.targetCenter_,
      o,
      s,
      n,
      this.calculateCenterShift(
        this.targetCenter_,
        o,
        r,
        s
      )
    );
    this.get(me.ROTATION) !== r && this.set(me.ROTATION, r), this.get(me.RESOLUTION) !== o && (this.set(me.RESOLUTION, o), this.set("zoom", this.getZoom(), !0)), (!a || !this.get(me.CENTER) || !$t(this.get(me.CENTER), a)) && this.set(me.CENTER, a), this.getAnimating() && !t && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(t, e, n) {
    t = t !== void 0 ? t : 200;
    const r = e || 0, s = this.constraints_.rotation(this.targetRotation_), o = this.getViewportSize_(s), a = this.constraints_.resolution(
      this.targetResolution_,
      r,
      o
    ), l = this.constraints_.center(
      this.targetCenter_,
      a,
      o,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        a,
        s,
        o
      )
    );
    if (t === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = a, this.targetRotation_ = s, this.targetCenter_ = l, this.applyTargetState_();
      return;
    }
    n = n || (t === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== a || this.getRotation() !== s || !this.getCenterInternal() || !$t(this.getCenterInternal(), l)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: s,
      center: l,
      resolution: a,
      duration: t,
      easing: Nn,
      anchor: n
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(mt.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(t, e, n) {
    n = n && pt(n, this.getProjection()), this.endInteractionInternal(t, e, n);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(t, e, n) {
    this.getInteracting() && (this.setHint(mt.INTERACTING, -1), this.resolveConstraints(t, e, n));
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(t, e) {
    const n = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      t,
      e || this.getResolution(),
      n
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(t, e) {
    const n = this.getResolutionForZoom(t);
    return this.getZoomForResolution(
      this.getConstrainedResolution(n, e)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(t, e) {
    e = e || 0;
    const n = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(t, e, n);
  }
}
function M0(i, t) {
  setTimeout(function() {
    i(t);
  }, 0);
}
function Og(i) {
  if (i.extent !== void 0) {
    const e = i.smoothExtentConstraint !== void 0 ? i.smoothExtentConstraint : !0;
    return kh(i.extent, i.constrainOnlyCenter, e);
  }
  const t = dl(i.projection, "EPSG:3857");
  if (i.multiWorld !== !0 && t.isGlobal()) {
    const e = t.getExtent().slice();
    return e[0] = -1 / 0, e[2] = 1 / 0, kh(e, !1, !1);
  }
  return xf;
}
function Gg(i) {
  let t, e, n, o = i.minZoom !== void 0 ? i.minZoom : w2, a = i.maxZoom !== void 0 ? i.maxZoom : 28;
  const l = i.zoomFactor !== void 0 ? i.zoomFactor : 2, h = i.multiWorld !== void 0 ? i.multiWorld : !1, c = i.smoothResolutionConstraint !== void 0 ? i.smoothResolutionConstraint : !0, d = i.showFullExtent !== void 0 ? i.showFullExtent : !1, u = dl(i.projection, "EPSG:3857"), f = u.getExtent();
  let g = i.constrainOnlyCenter, p = i.extent;
  if (!h && !p && u.isGlobal() && (g = !1, p = f), i.resolutions !== void 0) {
    const m = i.resolutions;
    e = m[o], n = m[a] !== void 0 ? m[a] : m[m.length - 1], i.constrainResolution ? t = kg(
      m,
      c,
      !g && p,
      d
    ) : t = Vh(
      e,
      n,
      c,
      !g && p,
      d
    );
  } else {
    const _ = (f ? Math.max(it(f), Rt(f)) : (
      // use an extent that can fit the whole world if need be
      360 * Ir.degrees / u.getMetersPerUnit()
    )) / Tl / Math.pow(2, w2), y = _ / Math.pow(2, 28 - w2);
    e = i.maxResolution, e !== void 0 ? o = 0 : e = _ / Math.pow(l, o), n = i.minResolution, n === void 0 && (i.maxZoom !== void 0 ? i.maxResolution !== void 0 ? n = e / Math.pow(l, a) : n = _ / Math.pow(l, a) : n = y), a = o + Math.floor(
      Math.log(e / n) / Math.log(l)
    ), n = e / Math.pow(l, a - o), i.constrainResolution ? t = Lg(
      l,
      e,
      n,
      c,
      !g && p,
      d
    ) : t = Vh(
      e,
      n,
      c,
      !g && p,
      d
    );
  }
  return {
    constraint: t,
    maxResolution: e,
    minResolution: n,
    minZoom: o,
    zoomFactor: l
  };
}
function Ng(i) {
  if (i.enableRotation !== void 0 ? i.enableRotation : !0) {
    const e = i.constrainRotation;
    return e === void 0 || e === !0 ? Fg() : e === !1 ? $h : typeof e == "number" ? Ag(e) : $h;
  }
  return Ml;
}
function Dg(i) {
  return !(i.sourceCenter && i.targetCenter && !$t(i.sourceCenter, i.targetCenter) || i.sourceResolution !== i.targetResolution || i.sourceRotation !== i.targetRotation);
}
function E2(i, t, e, n, r) {
  const s = Math.cos(-r);
  let o = Math.sin(-r), a = i[0] * s - i[1] * o, l = i[1] * s + i[0] * o;
  a += (t[0] / 2 - e[0]) * n, l += (e[1] - t[1] / 2) * n, o = -o;
  const h = a * s - l * o, c = l * s + a * o;
  return [h, c];
}
const T0 = "ol-hidden", zg = "ol-selectable", si = "ol-unselectable", Wh = "ol-unsupported", zn = "ol-control", go = "ol-collapsed", jg = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z0-9]+?)\\s*$`
  ].join(""),
  "i"
), Yh = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], xa = {
  normal: 400,
  bold: 700
}, Ca = function(i) {
  const t = i.match(jg);
  if (!t)
    return null;
  const e = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "400",
      variant: "normal"
    }
  );
  for (let n = 0, r = Yh.length; n < r; ++n) {
    const s = t[n + 1];
    s !== void 0 && (e[Yh[n]] = typeof s == "string" ? s.trim() : s);
  }
  return isNaN(Number(e.weight)) && e.weight in xa && (e.weight = xa[e.weight]), e.families = e.family.split(/,\s?/).map((n) => n.trim().replace(/^['"]|['"]$/g, "")), e;
};
function Pt(i, t, e, n) {
  let r;
  return e && e.length ? r = /** @type {HTMLCanvasElement} */
  e.shift() : ye ? r = new class extends OffscreenCanvas {
    style = {};
  }(i ?? 300, t ?? 150) : r = document.createElement("canvas"), i && (r.width = i), t && (r.height = t), /** @type {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} */
  r.getContext("2d", n);
}
let S2;
function mo() {
  return S2 || (S2 = Pt(1, 1)), S2;
}
function a0(i) {
  const t = i.canvas;
  t.width = 1, t.height = 1, i.clearRect(0, 0, 1, 1);
}
function Ug(i) {
  let t = i.offsetWidth;
  const e = getComputedStyle(i);
  return t += parseInt(e.marginLeft, 10) + parseInt(e.marginRight, 10), t;
}
function Bg(i) {
  let t = i.offsetHeight;
  const e = getComputedStyle(i);
  return t += parseInt(e.marginTop, 10) + parseInt(e.marginBottom, 10), t;
}
function Ar(i, t) {
  const e = t.parentNode;
  e && e.replaceChild(i, t);
}
function sd(i) {
  for (; i.lastChild; )
    i.lastChild.remove();
}
function Vg(i, t) {
  const e = i.childNodes;
  for (let n = 0; ; ++n) {
    const r = e[n], s = t[n];
    if (!r && !s)
      break;
    if (r !== s) {
      if (!r) {
        i.appendChild(s);
        continue;
      }
      if (!s) {
        i.removeChild(r), --n;
        continue;
      }
      i.insertBefore(s, r);
    }
  }
}
function od() {
  return new Proxy(
    {
      /**
       * @type {Array<HTMLElement>}
       */
      childNodes: [],
      /**
       * @param {HTMLElement} node html node.
       * @return {HTMLElement} html node.
       */
      appendChild: function(t) {
        return this.childNodes.push(t), t;
      },
      /**
       * dummy function, as this structure is not supposed to have a parent.
       */
      remove: function() {
      },
      /**
       * @param {HTMLElement} node html node.
       * @return {HTMLElement} html node.
       */
      removeChild: function(t) {
        const e = this.childNodes.indexOf(t);
        if (e === -1)
          throw new Error("Node to remove was not found");
        return this.childNodes.splice(e, 1), t;
      },
      /**
       * @param {HTMLElement} newNode new html node.
       * @param {HTMLElement} referenceNode reference html node.
       * @return {HTMLElement} new html node.
       */
      insertBefore: function(t, e) {
        const n = this.childNodes.indexOf(e);
        if (n === -1)
          throw new Error("Reference node not found");
        return this.childNodes.splice(n, 0, t), t;
      },
      style: {}
    },
    {
      get(t, e, n) {
        return e === "firstElementChild" ? t.childNodes.length > 0 ? t.childNodes[0] : null : Reflect.get(t, e, n);
      }
    }
  );
}
function Di(i) {
  return typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas;
}
class Ze extends De {
  /**
   * @param {Options} options Control options.
   */
  constructor(t) {
    super();
    const e = t.element;
    e && !t.target && !e.style.pointerEvents && (e.style.pointerEvents = "auto"), this.element = e || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], t.render && (this.render = t.render), t.target && this.setTarget(t.target);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.element?.remove(), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(t) {
    this.map_ && this.element?.remove();
    for (let e = 0, n = this.listenerKeys.length; e < n; ++e)
      dt(this.listenerKeys[e]);
    if (this.listenerKeys.length = 0, this.map_ = t, t) {
      const e = this.target_ ?? t.getOverlayContainerStopEvent();
      this.element && e.appendChild(this.element), this.render !== Gs && this.listenerKeys.push(
        Q(t, Je.POSTRENDER, this.render, this)
      ), t.render();
    }
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(t) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(t) {
    this.target_ = typeof t == "string" ? document.getElementById(t) : t;
  }
}
class ad extends Ze {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(t) {
    t = t || {}, super({
      element: document.createElement("div"),
      render: t.render,
      target: t.target
    }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = t.collapsed !== void 0 ? t.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = t.collapsible !== void 0, this.collapsible_ = t.collapsible !== void 0 ? t.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1), this.attributions_ = t.attributions;
    const e = t.className !== void 0 ? t.className : "ol-attribution", n = t.tipLabel !== void 0 ? t.tipLabel : "Attributions", r = t.expandClassName !== void 0 ? t.expandClassName : e + "-expand", s = t.collapseLabel !== void 0 ? t.collapseLabel : "", o = t.collapseClassName !== void 0 ? t.collapseClassName : e + "-collapse";
    typeof s == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = s, this.collapseLabel_.className = o) : this.collapseLabel_ = s;
    const a = t.label !== void 0 ? t.label : "i";
    typeof a == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = a, this.label_.className = r) : this.label_ = a;
    const l = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = n, this.toggleButton_.appendChild(l), this.toggleButton_.addEventListener(
      V.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const h = e + " " + si + " " + zn + (this.collapsed_ && this.collapsible_ ? " " + go : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), c = this.element;
    c.className = h, c.appendChild(this.toggleButton_), c.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(t) {
    const e = this.getMap().getAllLayers(), n = new Set(
      e.flatMap((r) => r.getAttributions(t))
    );
    if (this.attributions_ !== void 0 && (Array.isArray(this.attributions_) ? this.attributions_.forEach((r) => n.add(r)) : n.add(this.attributions_)), !this.overrideCollapsible_) {
      const r = !e.some(
        (s) => s.getSource()?.getAttributionsCollapsible() === !1
      );
      this.setCollapsible(r);
    }
    return Array.from(n);
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  async updateElement_(t) {
    if (!t) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const e = await Promise.all(
      this.collectSourceAttributions_(t).map(
        (r) => w1(() => r)
      )
    ), n = e.length > 0;
    if (this.renderedVisible_ != n && (this.element.style.display = n ? "" : "none", this.renderedVisible_ = n), !Ci(e, this.renderedAttributions_)) {
      sd(this.ulElement_);
      for (let r = 0, s = e.length; r < s; ++r) {
        const o = document.createElement("li");
        o.innerHTML = e[r], this.ulElement_.appendChild(o);
      }
      this.renderedAttributions_ = e;
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(t) {
    t.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(go), this.collapsed_ ? Ar(this.collapseLabel_, this.label_) : Ar(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(t) {
    this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(t) {
    this.userCollapsed_ = t, !(!this.collapsible_ || this.collapsed_ === t) && this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(t) {
    this.updateElement_(t.frameState);
  }
}
class ld extends Ze {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(t) {
    t = t || {}, super({
      element: document.createElement("div"),
      render: t.render,
      target: t.target
    });
    const e = t.className !== void 0 ? t.className : "ol-rotate", n = t.label !== void 0 ? t.label : "", r = t.compassClassName !== void 0 ? t.compassClassName : "ol-compass";
    this.label_ = null, typeof n == "string" ? (this.label_ = document.createElement("span"), this.label_.className = r, this.label_.textContent = n) : (this.label_ = n, this.label_.classList.add(r));
    const s = t.tipLabel ? t.tipLabel : "Reset rotation", o = document.createElement("button");
    o.className = e + "-reset", o.setAttribute("type", "button"), o.title = s, o.appendChild(this.label_), o.addEventListener(
      V.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const a = e + " " + si + " " + zn, l = this.element;
    l.className = a, l.appendChild(o), this.callResetNorth_ = t.resetNorth ? t.resetNorth : void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.autoHide_ = t.autoHide !== void 0 ? t.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(T0);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(t) {
    t.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
  }
  /**
   * @private
   */
  resetNorth_() {
    const e = this.getMap().getView();
    if (!e)
      return;
    const n = e.getRotation();
    n !== void 0 && (this.duration_ > 0 && n % (2 * Math.PI) !== 0 ? e.animate({
      rotation: 0,
      duration: this.duration_,
      easing: Nn
    }) : e.setRotation(0));
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(t) {
    const e = t.frameState;
    if (!e)
      return;
    const n = e.viewState.rotation;
    if (n != this.rotation_) {
      const r = "rotate(" + n + "rad)";
      if (this.autoHide_) {
        const s = this.element.classList.contains(T0);
        !s && n === 0 ? this.element.classList.add(T0) : s && n !== 0 && this.element.classList.remove(T0);
      }
      this.label_.style.transform = r;
    }
    this.rotation_ = n;
  }
}
class hd extends Ze {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(t) {
    t = t || {}, super({
      element: document.createElement("div"),
      target: t.target
    });
    const e = t.className !== void 0 ? t.className : "ol-zoom", n = t.delta !== void 0 ? t.delta : 1, r = t.zoomInClassName !== void 0 ? t.zoomInClassName : e + "-in", s = t.zoomOutClassName !== void 0 ? t.zoomOutClassName : e + "-out", o = t.zoomInLabel !== void 0 ? t.zoomInLabel : "+", a = t.zoomOutLabel !== void 0 ? t.zoomOutLabel : "", l = t.zoomInTipLabel !== void 0 ? t.zoomInTipLabel : "Zoom in", h = t.zoomOutTipLabel !== void 0 ? t.zoomOutTipLabel : "Zoom out", c = document.createElement("button");
    c.className = r, c.setAttribute("type", "button"), c.title = l, c.appendChild(
      typeof o == "string" ? document.createTextNode(o) : o
    ), c.addEventListener(
      V.CLICK,
      this.handleClick_.bind(this, n),
      !1
    );
    const d = document.createElement("button");
    d.className = s, d.setAttribute("type", "button"), d.title = h, d.appendChild(
      typeof a == "string" ? document.createTextNode(a) : a
    ), d.addEventListener(
      V.CLICK,
      this.handleClick_.bind(this, -n),
      !1
    );
    const u = e + " " + si + " " + zn, f = this.element;
    f.className = u, f.appendChild(c), f.appendChild(d), this.duration_ = t.duration !== void 0 ? t.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(t, e) {
    e.preventDefault(), this.zoomByDelta_(t);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(t) {
    const n = this.getMap().getView();
    if (!n)
      return;
    const r = n.getZoom();
    if (r !== void 0) {
      const s = n.getConstrainedZoom(r + t);
      this.duration_ > 0 ? (n.getAnimating() && n.cancelAnimations(), n.animate({
        zoom: s,
        duration: this.duration_,
        easing: Nn
      })) : n.setZoom(s);
    }
  }
}
function $g(i) {
  i = i || {};
  const t = new Dt();
  return (i.zoom !== void 0 ? i.zoom : !0) && t.push(new hd(i.zoomOptions)), (i.rotate !== void 0 ? i.rotate : !0) && t.push(new ld(i.rotateOptions)), (i.attribution !== void 0 ? i.attribution : !0) && t.push(new ad(i.attributionOptions)), t;
}
class Wg {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(t, e, n) {
    this.decay_ = t, this.minVelocity_ = e, this.delay_ = n, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(t, e) {
    this.points_.push(t, e, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6)
      return !1;
    const t = Date.now() - this.delay_, e = this.points_.length - 3;
    if (this.points_[e + 2] < t)
      return !1;
    let n = e - 3;
    for (; n > 0 && this.points_[n + 2] > t; )
      n -= 3;
    const r = this.points_[e + 2] - this.points_[n + 2];
    if (r < 1e3 / 60)
      return !1;
    const s = this.points_[e] - this.points_[n], o = this.points_[e + 1] - this.points_[n + 1];
    return this.angle_ = Math.atan2(o, s), this.initialVelocity_ = Math.sqrt(s * s + o * o) / r, this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}
const ba = {
  ACTIVE: "active"
};
class $r extends De {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t && t.handleEvent && (this.handleEvent = t.handleEvent), this.map_ = null, this.setActive(!0);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(ba.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(t) {
    return !0;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(t) {
    this.set(ba.ACTIVE, t);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(t) {
    this.map_ = t;
  }
}
function Yg(i, t, e) {
  const n = i.getCenterInternal();
  if (n) {
    const r = [n[0] + t[0], n[1] + t[1]];
    i.animateInternal({
      duration: e !== void 0 ? e : 250,
      easing: Lf,
      center: i.getConstrainedCenter(r)
    });
  }
}
function Rl(i, t, e, n) {
  const r = i.getZoom();
  if (r === void 0)
    return;
  const s = i.getConstrainedZoom(r + t), o = i.getResolutionForZoom(s);
  i.getAnimating() && i.cancelAnimations(), i.animate({
    resolution: o,
    anchor: e,
    duration: n !== void 0 ? n : 250,
    easing: Nn
  });
}
class Xg extends $r {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(t) {
    let e = !1;
    if (t.type == rt.DBLCLICK) {
      const n = (
        /** @type {MouseEvent} */
        t.originalEvent
      ), r = t.map, s = t.coordinate, o = n.shiftKey ? -this.delta_ : this.delta_, a = r.getView();
      Rl(a, o, s, this.duration_), n.preventDefault(), e = !0;
    }
    return !e;
  }
}
function wa(i) {
  const t = arguments;
  return function(e) {
    let n = !0;
    for (let r = 0, s = t.length; r < s && (n = n && t[r](e), !!n); ++r)
      ;
    return n;
  };
}
const Zg = function(i) {
  const t = i.originalEvent;
  return t.altKey && !(t.metaKey || t.ctrlKey) && !t.shiftKey;
}, Hg = function(i) {
  const t = i.originalEvent;
  return t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
}, Kg = function(i) {
  const t = i.map.getTargetElement(), e = t.getRootNode(), n = i.map.getOwnerDocument().activeElement;
  return e instanceof ShadowRoot ? e.host.contains(n) : t.contains(n);
}, cd = function(i) {
  const t = i.map.getTargetElement(), e = t.getRootNode();
  return (e instanceof ShadowRoot ? e.host : t).hasAttribute("tabindex") ? Kg(i) : !0;
}, _r = Tr, dd = function(i) {
  const t = i.originalEvent;
  return "pointerId" in t && t.button == 0 && !(uf && tl && t.ctrlKey);
}, ud = zr, qg = function(i) {
  return i.type == rt.SINGLECLICK;
}, Pl = function(i) {
  const t = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    i.originalEvent
  );
  return !t.altKey && !(t.metaKey || t.ctrlKey) && !t.shiftKey;
}, Xh = function(i) {
  const t = i.originalEvent;
  return !t.altKey && (tl ? t.metaKey : t.ctrlKey) && !t.shiftKey;
}, Jg = function(i) {
  const t = i.originalEvent;
  return tl ? t.metaKey : t.ctrlKey;
}, Ea = function(i) {
  const t = i.originalEvent;
  return !t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
}, fd = function(i) {
  const t = i.originalEvent, e = (
    /** @type {Element} */
    t.target.tagName
  );
  return e !== "INPUT" && e !== "SELECT" && e !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !t.target.isContentEditable;
}, M2 = function(i) {
  const t = i.originalEvent;
  return "pointerId" in t && t.pointerType == "mouse";
}, gd = function(i) {
  const t = i.originalEvent;
  return "pointerId" in t && t.isPrimary && t.button === 0;
};
class jn extends $r {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      t
    ), t.handleDownEvent && (this.handleDownEvent = t.handleDownEvent), t.handleDragEvent && (this.handleDragEvent = t.handleDragEvent), t.handleMoveEvent && (this.handleMoveEvent = t.handleMoveEvent), t.handleUpEvent && (this.handleUpEvent = t.handleUpEvent), t.stopDown && (this.stopDown = t.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(t) {
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(t) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   * @override
   */
  handleEvent(t) {
    if (!t.originalEvent)
      return !0;
    let e = !1;
    if (this.updateTrackedPointers_(t), this.handlingDownUpSequence) {
      if (t.type == rt.POINTERDRAG)
        this.handleDragEvent(t), t.originalEvent.preventDefault();
      else if (t.type == rt.POINTERUP) {
        const n = this.handleUpEvent(t);
        this.handlingDownUpSequence = n && this.targetPointers.length > 0;
      }
    } else if (t.type == rt.POINTERDOWN) {
      const n = this.handleDownEvent(t);
      this.handlingDownUpSequence = n, e = this.stopDown(n);
    } else t.type == rt.POINTERMOVE && this.handleMoveEvent(t);
    return !e;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(t) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(t) {
    return !1;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(t) {
    return t;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(t) {
    t.activePointers && (this.targetPointers = t.activePointers);
  }
}
function Il(i) {
  const t = i.length;
  let e = 0, n = 0;
  for (let r = 0; r < t; r++)
    e += i[r].clientX, n += i[r].clientY;
  return { clientX: e / t, clientY: n / t };
}
class bs extends jn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super({
      stopDown: zr
    }), t = t || {}, this.kinetic_ = t.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
    const e = t.condition ? t.condition : wa(Pl, gd);
    this.condition_ = t.onFocusOnly ? wa(cd, e) : e, this.noKinetic_ = !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(t) {
    const e = t.map;
    this.panning_ || (this.panning_ = !0, e.getView().beginInteraction());
    const n = this.targetPointers, r = e.getEventPixel(Il(n));
    if (n.length == this.lastPointersCount_) {
      if (this.kinetic_ && this.kinetic_.update(r[0], r[1]), this.lastCentroid) {
        const s = [
          this.lastCentroid[0] - r[0],
          r[1] - this.lastCentroid[1]
        ], a = t.map.getView();
        Pf(s, a.getResolution()), al(s, a.getRotation()), a.adjustCenterInternal(s);
      }
    } else this.kinetic_ && this.kinetic_.begin();
    this.lastCentroid = r, this.lastPointersCount_ = n.length, t.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(t) {
    const e = t.map, n = e.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const r = this.kinetic_.getDistance(), s = this.kinetic_.getAngle(), o = n.getCenterInternal(), a = e.getPixelFromCoordinateInternal(o), l = e.getCoordinateFromPixelInternal([
          a[0] - r * Math.cos(s),
          a[1] - r * Math.sin(s)
        ]);
        n.animateInternal({
          center: n.getConstrainedCenter(l),
          duration: 500,
          easing: Nn
        });
      }
      return this.panning_ && (this.panning_ = !1, n.endInteraction()), !1;
    }
    return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(t) {
    if (this.targetPointers.length > 0 && this.condition_(t)) {
      const n = t.map.getView();
      return this.lastCentroid = null, n.getAnimating() && n.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
    }
    return !1;
  }
}
class Qg extends jn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super({
      stopDown: zr
    }), this.condition_ = t.condition ? t.condition : Hg, this.lastAngle_ = void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(t) {
    if (!M2(t))
      return;
    const e = t.map, n = e.getView();
    if (n.getConstraints().rotation === Ml)
      return;
    const r = e.getSize(), s = t.pixel, o = Math.atan2(r[1] / 2 - s[1], s[0] - r[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const a = o - this.lastAngle_;
      n.adjustRotationInternal(-a);
    }
    this.lastAngle_ = o;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(t) {
    return M2(t) ? (t.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(t) {
    return M2(t) && dd(t) && this.condition_(t) ? (t.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
  }
}
class tm extends jo {
  /**
   * @param {string} className CSS class name.
   */
  constructor(t) {
    super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + t, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const t = this.startPixel_, e = this.endPixel_, n = "px", r = this.element_.style;
    r.left = Math.min(t[0], e[0]) + n, r.top = Math.min(t[1], e[1]) + n, r.width = Math.abs(e[0] - t[0]) + n, r.height = Math.abs(e[1] - t[1]) + n;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(t) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const e = this.element_.style;
      e.left = "inherit", e.top = "inherit", e.width = "inherit", e.height = "inherit";
    }
    this.map_ = t, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(t, e) {
    this.startPixel_ = t, this.endPixel_ = e, this.createOrUpdateGeometry(), this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    if (!this.map_)
      return;
    const t = this.startPixel_, e = this.endPixel_, r = [
      t,
      [t[0], e[1]],
      e,
      [e[0], t[1]]
    ].map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    r[4] = r[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([r]) : this.geometry_ = new jt([r]);
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}
const Zn = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
class ts extends ve {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(t, e, n) {
    super(t), this.coordinate = e, this.mapBrowserEvent = n;
  }
}
class em extends jn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = t ?? {}, this.box_ = new tm(t.className || "ol-dragbox"), this.minArea_ = t.minArea ?? 64, t.onBoxEnd && (this.onBoxEnd = t.onBoxEnd), this.startPixel_ = null, this.condition_ = t.condition ?? dd, this.boxEndCondition_ = t.boxEndCondition ?? this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(t, e, n) {
    const r = n[0] - e[0], s = n[1] - e[1];
    return r * r + s * s >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(t) {
    this.startPixel_ && (this.box_.setPixels(this.startPixel_, t.pixel), this.dispatchEvent(
      new ts(
        Zn.BOXDRAG,
        t.coordinate,
        t
      )
    ));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(t) {
    if (!this.startPixel_)
      return !1;
    const e = this.boxEndCondition_(
      t,
      this.startPixel_,
      t.pixel
    );
    return e && this.onBoxEnd(t), this.dispatchEvent(
      new ts(
        e ? Zn.BOXEND : Zn.BOXCANCEL,
        t.coordinate,
        t
      )
    ), this.box_.setMap(null), this.startPixel_ = null, !1;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(t) {
    return this.condition_(t) ? (this.startPixel_ = t.pixel, this.box_.setMap(t.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
      new ts(
        Zn.BOXSTART,
        t.coordinate,
        t
      )
    ), !0) : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(t) {
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   * @override
   */
  setActive(t) {
    t || (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
      new ts(Zn.BOXCANCEL, this.startPixel_, null)
    ), this.startPixel_ = null)), super.setActive(t);
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   * @override
   */
  setMap(t) {
    this.getMap() && (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
      new ts(Zn.BOXCANCEL, this.startPixel_, null)
    ), this.startPixel_ = null)), super.setMap(t);
  }
}
class im extends em {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const e = t.condition ? t.condition : Ea;
    super({
      condition: e,
      className: t.className || "ol-dragzoom",
      minArea: t.minArea
    }), this.duration_ = t.duration !== void 0 ? t.duration : 200, this.out_ = t.out !== void 0 ? t.out : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @override
   */
  onBoxEnd(t) {
    const n = (
      /** @type {!import("../View.js").default} */
      this.getMap().getView()
    );
    let r = this.getGeometry();
    if (this.out_) {
      const s = n.rotatedExtentForGeometry(r), o = n.getResolutionForExtentInternal(s), a = n.getResolution() / o;
      r = r.clone(), r.scale(a * a);
    }
    n.fitInternal(r, {
      duration: this.duration_,
      easing: Nn
    });
  }
}
const cn = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};
class nm extends $r {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.defaultCondition_ = function(e) {
      return Pl(e) && fd(e);
    }, this.condition_ = t.condition !== void 0 ? t.condition : this.defaultCondition_, this.duration_ = t.duration !== void 0 ? t.duration : 100, this.pixelDelta_ = t.pixelDelta !== void 0 ? t.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(t) {
    let e = !1;
    if (t.type == V.KEYDOWN) {
      const n = (
        /** @type {KeyboardEvent} */
        t.originalEvent
      ), r = n.key;
      if (this.condition_(t) && (r == cn.DOWN || r == cn.LEFT || r == cn.RIGHT || r == cn.UP)) {
        const o = t.map.getView(), a = o.getResolution() * this.pixelDelta_;
        let l = 0, h = 0;
        r == cn.DOWN ? h = -a : r == cn.LEFT ? l = -a : r == cn.RIGHT ? l = a : h = a;
        const c = [l, h];
        al(c, o.getRotation()), Yg(o, c, this.duration_), n.preventDefault(), e = !0;
      }
    }
    return !e;
  }
}
class rm extends $r {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.condition_ = t.condition ? t.condition : function(e) {
      return !Jg(e) && fd(e);
    }, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(t) {
    let e = !1;
    if (t.type == V.KEYDOWN || t.type == V.KEYPRESS) {
      const n = (
        /** @type {KeyboardEvent} */
        t.originalEvent
      ), r = n.key;
      if (this.condition_(t) && (r === "+" || r === "-")) {
        const s = t.map, o = r === "+" ? this.delta_ : -this.delta_, a = s.getView();
        Rl(a, o, void 0, this.duration_), n.preventDefault(), e = !0;
      }
    }
    return !e;
  }
}
const sm = 40, om = 300;
class po extends $r {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      t
    ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = t.maxDelta !== void 0 ? t.maxDelta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.timeout_ = t.timeout !== void 0 ? t.timeout : 80, this.useAnchor_ = t.useAnchor !== void 0 ? t.useAnchor : !0, this.constrainResolution_ = t.constrainResolution !== void 0 ? t.constrainResolution : !1;
    const e = t.condition ? t.condition : _r;
    this.condition_ = t.onFocusOnly ? wa(cd, e) : e, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const t = this.getMap();
    if (!t)
      return;
    t.getView().endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_ ? t.getCoordinateFromPixel(this.lastAnchor_) : null
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(t) {
    if (!this.condition_(t) || t.type !== V.WHEEL)
      return !0;
    const n = t.map, r = (
      /** @type {WheelEvent} */
      t.originalEvent
    );
    r.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = t.pixel);
    let s = r.deltaY;
    switch (r.deltaMode) {
      case WheelEvent.DOM_DELTA_LINE:
        s *= sm;
        break;
      case WheelEvent.DOM_DELTA_PAGE:
        s *= om;
        break;
    }
    if (s === 0)
      return !1;
    this.lastDelta_ = s;
    const o = Date.now();
    this.startTime_ === void 0 && (this.startTime_ = o), (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(s) < 4 ? "trackpad" : "wheel");
    const a = n.getView();
    if (this.mode_ === "trackpad" && !(a.getConstrainResolution() || this.constrainResolution_))
      return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (a.getAnimating() && a.cancelAnimations(), a.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      ), a.adjustZoom(
        -s / this.deltaPerZoom_,
        this.lastAnchor_ ? n.getCoordinateFromPixel(this.lastAnchor_) : null
      ), this.startTime_ = o, !1;
    this.totalDelta_ += s;
    const l = Math.max(this.timeout_ - (o - this.startTime_), 0);
    return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, n),
      l
    ), !1;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(t) {
    const e = t.getView();
    e.getAnimating() && e.cancelAnimations();
    let n = -ft(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    (e.getConstrainResolution() || this.constrainResolution_) && (n = n ? n > 0 ? 1 : -1 : 0), Rl(
      e,
      n,
      this.lastAnchor_ ? t.getCoordinateFromPixel(this.lastAnchor_) : null,
      this.duration_
    ), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(t) {
    this.useAnchor_ = t, t || (this.lastAnchor_ = null);
  }
}
class am extends jn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const e = (
      /** @type {import("./Pointer.js").Options} */
      t
    );
    e.stopDown || (e.stopDown = zr), super(e), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = t.threshold !== void 0 ? t.threshold : 0.3, this.duration_ = t.duration !== void 0 ? t.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(t) {
    let e = 0;
    const n = this.targetPointers[0], r = this.targetPointers[1], s = Math.atan2(
      r.clientY - n.clientY,
      r.clientX - n.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const l = s - this.lastAngle_;
      this.rotationDelta_ += l, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), e = l;
    }
    this.lastAngle_ = s;
    const o = t.map, a = o.getView();
    a.getConstraints().rotation !== Ml && (this.anchor_ = o.getCoordinateFromPixelInternal(
      o.getEventPixel(Il(this.targetPointers))
    ), this.rotating_ && (o.render(), a.adjustRotationInternal(e, this.anchor_)));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(t) {
    return this.targetPointers.length < 2 ? (t.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(t) {
    if (this.targetPointers.length >= 2) {
      const e = t.map;
      return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || e.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
class lm extends jn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const e = (
      /** @type {import("./Pointer.js").Options} */
      t
    );
    e.stopDown || (e.stopDown = zr), super(e), this.anchor_ = null, this.duration_ = t.duration !== void 0 ? t.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(t) {
    let e = 1;
    const n = this.targetPointers[0], r = this.targetPointers[1], s = n.clientX - r.clientX, o = n.clientY - r.clientY, a = Math.sqrt(s * s + o * o);
    this.lastDistance_ !== void 0 && (e = this.lastDistance_ / a), this.lastDistance_ = a;
    const l = t.map, h = l.getView();
    e != 1 && (this.lastScaleDelta_ = e), this.anchor_ = l.getCoordinateFromPixelInternal(
      l.getEventPixel(Il(this.targetPointers))
    ), l.render(), h.adjustResolutionInternal(e, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(t) {
    if (this.targetPointers.length < 2) {
      const n = t.map.getView(), r = this.lastScaleDelta_ > 1 ? 1 : -1;
      return n.endInteraction(this.duration_, r), !1;
    }
    return !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(t) {
    if (this.targetPointers.length >= 2) {
      const e = t.map;
      return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || e.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
function md(i) {
  i = i || {};
  const t = new Dt(), e = new Wg(-5e-3, 0.05, 100);
  return (i.altShiftDragRotate !== void 0 ? i.altShiftDragRotate : !0) && t.push(new Qg()), (i.doubleClickZoom !== void 0 ? i.doubleClickZoom : !0) && t.push(
    new Xg({
      delta: i.zoomDelta,
      duration: i.zoomDuration
    })
  ), (i.dragPan !== void 0 ? i.dragPan : !0) && t.push(
    new bs({
      onFocusOnly: i.onFocusOnly,
      kinetic: e
    })
  ), (i.pinchRotate !== void 0 ? i.pinchRotate : !0) && t.push(new am()), (i.pinchZoom !== void 0 ? i.pinchZoom : !0) && t.push(
    new lm({
      duration: i.zoomDuration
    })
  ), (i.keyboard !== void 0 ? i.keyboard : !0) && (t.push(new nm()), t.push(
    new rm({
      delta: i.zoomDelta,
      duration: i.zoomDuration
    })
  )), (i.mouseWheelZoom !== void 0 ? i.mouseWheelZoom : !0) && t.push(
    new po({
      onFocusOnly: i.onFocusOnly,
      duration: i.zoomDuration
    })
  ), (i.shiftDragZoom !== void 0 ? i.shiftDragZoom : !0) && t.push(
    new im({
      duration: i.zoomDuration
    })
  ), t;
}
const ct = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
class pd extends De {
  /**
   * @param {Options} options Layer options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, this.background_ = t.background;
    const e = Object.assign({}, t);
    typeof t.properties == "object" && (delete e.properties, Object.assign(e, t.properties)), e[ct.OPACITY] = t.opacity !== void 0 ? t.opacity : 1, at(
      typeof e[ct.OPACITY] == "number",
      "Layer opacity must be a number"
    ), e[ct.VISIBLE] = t.visible !== void 0 ? t.visible : !0, e[ct.Z_INDEX] = t.zIndex, e[ct.MAX_RESOLUTION] = t.maxResolution !== void 0 ? t.maxResolution : 1 / 0, e[ct.MIN_RESOLUTION] = t.minResolution !== void 0 ? t.minResolution : 0, e[ct.MIN_ZOOM] = t.minZoom !== void 0 ? t.minZoom : -1 / 0, e[ct.MAX_ZOOM] = t.maxZoom !== void 0 ? t.maxZoom : 1 / 0, this.className_ = e.className !== void 0 ? e.className : "ol-layer", delete e.className, this.setProperties(e), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(t) {
    const e = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: t === void 0 ? !0 : t
    }, n = this.getZIndex();
    return e.opacity = ft(Math.round(this.getOpacity() * 100) / 100, 0, 1), e.visible = this.getVisible(), e.extent = this.getExtent(), e.zIndex = n === void 0 && !e.managed ? 1 / 0 : n, e.maxResolution = this.getMaxResolution(), e.minResolution = Math.max(this.getMinResolution(), 0), e.minZoom = this.getMinZoom(), e.maxZoom = this.getMaxZoom(), this.state_ = e, e;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(t) {
    return X();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(t) {
    return X();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(ct.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(ct.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(ct.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(ct.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(ct.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(ct.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return X();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(ct.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get(ct.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(t) {
    this.background_ = t, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(t) {
    this.set(ct.EXTENT, t);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(t) {
    this.set(ct.MAX_RESOLUTION, t);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(t) {
    this.set(ct.MIN_RESOLUTION, t);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(t) {
    this.set(ct.MAX_ZOOM, t);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(t) {
    this.set(ct.MIN_ZOOM, t);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(t) {
    at(typeof t == "number", "Layer opacity must be a number"), this.set(ct.OPACITY, t);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(t) {
    this.set(ct.VISIBLE, t);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(t) {
    this.set(ct.Z_INDEX, t);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
}
const Ti = {
  /**
   * Triggered when a layer is added
   * @event GroupEvent#addlayer
   * @api
   */
  ADDLAYER: "addlayer",
  /**
   * Triggered when a layer is removed
   * @event GroupEvent#removelayer
   * @api
   */
  REMOVELAYER: "removelayer"
};
class Ai extends ve {
  /**
   * @param {GroupEventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(t, e) {
    super(t), this.layer = e;
  }
}
const T2 = {
  LAYERS: "layers"
};
class vi extends pd {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(t) {
    t = t || {};
    const e = (
      /** @type {Options} */
      Object.assign({}, t)
    );
    delete e.layers;
    let n = t.layers;
    super(e), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(T2.LAYERS, this.handleLayersChanged_), n ? Array.isArray(n) ? n = new Dt(n.slice(), { unique: !0 }) : at(
      typeof /** @type {?} */
      n.getArray == "function",
      "Expected `layers` to be an array or a `Collection`"
    ) : n = new Dt(void 0, { unique: !0 }), this.setLayers(n);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(dt), this.layersListenerKeys_.length = 0;
    const t = this.getLayers();
    this.layersListenerKeys_.push(
      Q(t, Yt.ADD, this.handleLayersAdd_, this),
      Q(
        t,
        Yt.REMOVE,
        this.handleLayersRemove_,
        this
      )
    );
    for (const n in this.listenerKeys_)
      this.listenerKeys_[n].forEach(dt);
    t0(this.listenerKeys_);
    const e = t.getArray();
    for (let n = 0, r = e.length; n < r; n++) {
      const s = e[n];
      this.registerLayerListeners_(s), this.dispatchEvent(new Ai(Ti.ADDLAYER, s));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(t) {
    const e = [
      Q(
        t,
        Mn.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      Q(t, V.CHANGE, this.handleLayerChange_, this)
    ];
    t instanceof vi && e.push(
      Q(t, Ti.ADDLAYER, this.handleLayerGroupAdd_, this),
      Q(
        t,
        Ti.REMOVELAYER,
        this.handleLayerGroupRemove_,
        this
      )
    ), this.listenerKeys_[Y(t)] = e;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(t) {
    this.dispatchEvent(new Ai(Ti.ADDLAYER, t.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(t) {
    this.dispatchEvent(new Ai(Ti.REMOVELAYER, t.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(t) {
    const e = t.element;
    this.registerLayerListeners_(e), this.dispatchEvent(new Ai(Ti.ADDLAYER, e)), this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(t) {
    const e = t.element, n = Y(e);
    this.listenerKeys_[n].forEach(dt), delete this.listenerKeys_[n], this.dispatchEvent(new Ai(Ti.REMOVELAYER, e)), this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(T2.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(t) {
    const e = this.getLayers();
    if (e) {
      const n = e.getArray();
      for (let r = 0, s = n.length; r < s; ++r)
        this.dispatchEvent(
          new Ai(Ti.REMOVELAYER, n[r])
        );
    }
    this.set(T2.LAYERS, t);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(t) {
    return t = t !== void 0 ? t : [], this.getLayers().forEach(function(e) {
      e.getLayersArray(t);
    }), t;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(t) {
    const e = t !== void 0 ? t : [], n = e.length;
    this.getLayers().forEach(function(o) {
      o.getLayerStatesArray(e);
    });
    const r = this.getLayerState();
    let s = r.zIndex;
    !t && r.zIndex === void 0 && (s = 0);
    for (let o = n, a = e.length; o < a; o++) {
      const l = e[o];
      l.opacity *= r.opacity, l.visible = l.visible && r.visible, l.maxResolution = Math.min(
        l.maxResolution,
        r.maxResolution
      ), l.minResolution = Math.max(
        l.minResolution,
        r.minResolution
      ), l.minZoom = Math.max(l.minZoom, r.minZoom), l.maxZoom = Math.min(l.maxZoom, r.maxZoom), r.extent !== void 0 && (l.extent !== void 0 ? l.extent = Ve(
        l.extent,
        r.extent
      ) : l.extent = r.extent), l.zIndex === void 0 && (l.zIndex = s);
    }
    return e;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    return "ready";
  }
}
const Re = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
};
class l0 extends pd {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(t) {
    const e = Object.assign({}, t);
    delete e.source, super(e), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, t.render && (this.render = t.render), t.map && this.setMap(t.map), this.addChangeListener(
      ct.SOURCE,
      this.handleSourcePropertyChange_
    );
    const n = t.source ? (
      /** @type {SourceType} */
      t.source
    ) : null;
    this.setSource(n);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(t) {
    return t = t || [], t.push(this), t;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(t) {
    return t = t || [], t.push(this.getLayerState()), t;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(ct.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    const t = this.getSource();
    return t ? t.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && (dt(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
    const t = this.getSource();
    t && (this.sourceChangeKey_ = Q(
      t,
      V.CHANGE,
      this.handleSourceChange_,
      this
    ), t.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
      this.dispatchEvent("sourceready");
    }, 0))), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(t) {
    return this.renderer_ ? this.renderer_.getFeatures(t) : Promise.resolve([]);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(t) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(t);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(t) {
    let e;
    const n = this.getMapInternal();
    !t && n && (t = n.getView()), t instanceof Se ? e = {
      viewState: t.getState(),
      extent: t.calculateExtent()
    } : e = t, !e.layerStatesArray && n && (e.layerStatesArray = n.getLayerGroup().getLayerStatesArray());
    let r;
    if (e.layerStatesArray) {
      if (r = e.layerStatesArray.find(
        (o) => o.layer === this
      ), !r)
        return !1;
    } else
      r = this.getLayerState();
    const s = this.getExtent();
    return kl(r, e.viewState) && (!s || bt(s, e.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(t) {
    if (!this.isVisible(t))
      return [];
    const e = this.getSource()?.getAttributions();
    if (!e)
      return [];
    const n = t instanceof Se ? t.getViewStateAndExtent() : t;
    let r = e(n);
    return Array.isArray(r) || (r = [r]), r;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(t, e) {
    const n = this.getRenderer();
    return n.prepareFrame(t) ? (this.rendered = !0, n.renderFrame(t, e)) : null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /** @return {string} Declutter */
  getDeclutter() {
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(t, e) {
  }
  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(t) {
    const e = this.getRenderer();
    e && e.renderDeferred(t);
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(t) {
    t || this.unrender(), this.set(ct.MAP, t);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(ct.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(t) {
    this.mapPrecomposeKey_ && (dt(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (dt(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = Q(
      t,
      Re.PRECOMPOSE,
      this.handlePrecompose_,
      this
    ), this.mapRenderKey_ = Q(this, V.CHANGE, t.render, t), this.changed());
  }
  /**
   * @param {import("../events/Event.js").default} renderEvent Render event
   * @private
   */
  handlePrecompose_(t) {
    const e = (
      /** @type {import("../render/Event.js").default} */
      t.frameState.layerStatesArray
    ), n = this.getLayerState(!1);
    at(
      !e.some(
        (r) => r.layer === n.layer
      ),
      "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
    ), e.push(n);
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(t) {
    this.set(ct.SOURCE, t);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * This will clear the renderer so that a new one can be created next time it is needed
   */
  clearRenderer() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.clearRenderer(), this.setSource(null), super.disposeInternal();
  }
}
function kl(i, t) {
  if (!i.visible)
    return !1;
  const e = t.resolution;
  if (e < i.minResolution || e >= i.maxResolution)
    return !1;
  const n = t.zoom;
  return n > i.minZoom && n <= i.maxZoom;
}
function _d(i, t, e = 0, n = i.length - 1, r = hm) {
  for (; n > e; ) {
    if (n - e > 600) {
      const l = n - e + 1, h = t - e + 1, c = Math.log(l), d = 0.5 * Math.exp(2 * c / 3), u = 0.5 * Math.sqrt(c * d * (l - d) / l) * (h - l / 2 < 0 ? -1 : 1), f = Math.max(e, Math.floor(t - h * d / l + u)), g = Math.min(n, Math.floor(t + (l - h) * d / l + u));
      _d(i, t, f, g, r);
    }
    const s = i[t];
    let o = e, a = n;
    for (es(i, e, t), r(i[n], s) > 0 && es(i, e, n); o < a; ) {
      for (es(i, o, a), o++, a--; r(i[o], s) < 0; ) o++;
      for (; r(i[a], s) > 0; ) a--;
    }
    r(i[e], s) === 0 ? es(i, e, a) : (a++, es(i, a, n)), a <= t && (e = a + 1), t <= a && (n = a - 1);
  }
}
function es(i, t, e) {
  const n = i[t];
  i[t] = i[e], i[e] = n;
}
function hm(i, t) {
  return i < t ? -1 : i > t ? 1 : 0;
}
let yd = class {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let e = this.data;
    const n = [];
    if (!P0(t, e)) return n;
    const r = this.toBBox, s = [];
    for (; e; ) {
      for (let o = 0; o < e.children.length; o++) {
        const a = e.children[o], l = e.leaf ? r(a) : a;
        P0(t, l) && (e.leaf ? n.push(a) : P2(t, l) ? this._all(a, n) : s.push(a));
      }
      e = s.pop();
    }
    return n;
  }
  collides(t) {
    let e = this.data;
    if (!P0(t, e)) return !1;
    const n = [];
    for (; e; ) {
      for (let r = 0; r < e.children.length; r++) {
        const s = e.children[r], o = e.leaf ? this.toBBox(s) : s;
        if (P0(t, o)) {
          if (e.leaf || P2(t, o)) return !0;
          n.push(s);
        }
      }
      e = n.pop();
    }
    return !1;
  }
  load(t) {
    if (!(t && t.length)) return this;
    if (t.length < this._minEntries) {
      for (let n = 0; n < t.length; n++)
        this.insert(t[n]);
      return this;
    }
    let e = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = e;
    else if (this.data.height === e.height)
      this._splitRoot(this.data, e);
    else {
      if (this.data.height < e.height) {
        const n = this.data;
        this.data = e, e = n;
      }
      this._insert(e, this.data.height - e.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = nr([]), this;
  }
  remove(t, e) {
    if (!t) return this;
    let n = this.data;
    const r = this.toBBox(t), s = [], o = [];
    let a, l, h;
    for (; n || s.length; ) {
      if (n || (n = s.pop(), l = s[s.length - 1], a = o.pop(), h = !0), n.leaf) {
        const c = cm(t, n.children, e);
        if (c !== -1)
          return n.children.splice(c, 1), s.push(n), this._condense(s), this;
      }
      !h && !n.leaf && P2(n, r) ? (s.push(n), o.push(a), a = 0, l = n, n = n.children[0]) : l ? (a++, n = l.children[a], h = !1) : n = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, e) {
    return t.minX - e.minX;
  }
  compareMinY(t, e) {
    return t.minY - e.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, e) {
    const n = [];
    for (; t; )
      t.leaf ? e.push(...t.children) : n.push(...t.children), t = n.pop();
    return e;
  }
  _build(t, e, n, r) {
    const s = n - e + 1;
    let o = this._maxEntries, a;
    if (s <= o)
      return a = nr(t.slice(e, n + 1)), Hn(a, this.toBBox), a;
    r || (r = Math.ceil(Math.log(s) / Math.log(o)), o = Math.ceil(s / Math.pow(o, r - 1))), a = nr([]), a.leaf = !1, a.height = r;
    const l = Math.ceil(s / o), h = l * Math.ceil(Math.sqrt(o));
    Zh(t, e, n, h, this.compareMinX);
    for (let c = e; c <= n; c += h) {
      const d = Math.min(c + h - 1, n);
      Zh(t, c, d, l, this.compareMinY);
      for (let u = c; u <= d; u += l) {
        const f = Math.min(u + l - 1, d);
        a.children.push(this._build(t, u, f, r - 1));
      }
    }
    return Hn(a, this.toBBox), a;
  }
  _chooseSubtree(t, e, n, r) {
    for (; r.push(e), !(e.leaf || r.length - 1 === n); ) {
      let s = 1 / 0, o = 1 / 0, a;
      for (let l = 0; l < e.children.length; l++) {
        const h = e.children[l], c = R2(h), d = fm(t, h) - c;
        d < o ? (o = d, s = c < s ? c : s, a = h) : d === o && c < s && (s = c, a = h);
      }
      e = a || e.children[0];
    }
    return e;
  }
  _insert(t, e, n) {
    const r = n ? t : this.toBBox(t), s = [], o = this._chooseSubtree(r, this.data, e, s);
    for (o.children.push(t), cs(o, r); e >= 0 && s[e].children.length > this._maxEntries; )
      this._split(s, e), e--;
    this._adjustParentBBoxes(r, s, e);
  }
  // split overflowed node into two
  _split(t, e) {
    const n = t[e], r = n.children.length, s = this._minEntries;
    this._chooseSplitAxis(n, s, r);
    const o = this._chooseSplitIndex(n, s, r), a = nr(n.children.splice(o, n.children.length - o));
    a.height = n.height, a.leaf = n.leaf, Hn(n, this.toBBox), Hn(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(n, a);
  }
  _splitRoot(t, e) {
    this.data = nr([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Hn(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, e, n) {
    let r, s = 1 / 0, o = 1 / 0;
    for (let a = e; a <= n - e; a++) {
      const l = hs(t, 0, a, this.toBBox), h = hs(t, a, n, this.toBBox), c = gm(l, h), d = R2(l) + R2(h);
      c < s ? (s = c, r = a, o = d < o ? d : o) : c === s && d < o && (o = d, r = a);
    }
    return r || n - e;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, e, n) {
    const r = t.leaf ? this.compareMinX : dm, s = t.leaf ? this.compareMinY : um, o = this._allDistMargin(t, e, n, r), a = this._allDistMargin(t, e, n, s);
    o < a && t.children.sort(r);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, e, n, r) {
    t.children.sort(r);
    const s = this.toBBox, o = hs(t, 0, e, s), a = hs(t, n - e, n, s);
    let l = R0(o) + R0(a);
    for (let h = e; h < n - e; h++) {
      const c = t.children[h];
      cs(o, t.leaf ? s(c) : c), l += R0(o);
    }
    for (let h = n - e - 1; h >= e; h--) {
      const c = t.children[h];
      cs(a, t.leaf ? s(c) : c), l += R0(a);
    }
    return l;
  }
  _adjustParentBBoxes(t, e, n) {
    for (let r = n; r >= 0; r--)
      cs(e[r], t);
  }
  _condense(t) {
    for (let e = t.length - 1, n; e >= 0; e--)
      t[e].children.length === 0 ? e > 0 ? (n = t[e - 1].children, n.splice(n.indexOf(t[e]), 1)) : this.clear() : Hn(t[e], this.toBBox);
  }
};
function cm(i, t, e) {
  if (!e) return t.indexOf(i);
  for (let n = 0; n < t.length; n++)
    if (e(i, t[n])) return n;
  return -1;
}
function Hn(i, t) {
  hs(i, 0, i.children.length, t, i);
}
function hs(i, t, e, n, r) {
  r || (r = nr(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;
  for (let s = t; s < e; s++) {
    const o = i.children[s];
    cs(r, i.leaf ? n(o) : o);
  }
  return r;
}
function cs(i, t) {
  return i.minX = Math.min(i.minX, t.minX), i.minY = Math.min(i.minY, t.minY), i.maxX = Math.max(i.maxX, t.maxX), i.maxY = Math.max(i.maxY, t.maxY), i;
}
function dm(i, t) {
  return i.minX - t.minX;
}
function um(i, t) {
  return i.minY - t.minY;
}
function R2(i) {
  return (i.maxX - i.minX) * (i.maxY - i.minY);
}
function R0(i) {
  return i.maxX - i.minX + (i.maxY - i.minY);
}
function fm(i, t) {
  return (Math.max(t.maxX, i.maxX) - Math.min(t.minX, i.minX)) * (Math.max(t.maxY, i.maxY) - Math.min(t.minY, i.minY));
}
function gm(i, t) {
  const e = Math.max(i.minX, t.minX), n = Math.max(i.minY, t.minY), r = Math.min(i.maxX, t.maxX), s = Math.min(i.maxY, t.maxY);
  return Math.max(0, r - e) * Math.max(0, s - n);
}
function P2(i, t) {
  return i.minX <= t.minX && i.minY <= t.minY && t.maxX <= i.maxX && t.maxY <= i.maxY;
}
function P0(i, t) {
  return t.minX <= i.maxX && t.minY <= i.maxY && t.maxX >= i.minX && t.maxY >= i.minY;
}
function nr(i) {
  return {
    children: i,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Zh(i, t, e, n, r) {
  const s = [t, e];
  for (; s.length; ) {
    if (e = s.pop(), t = s.pop(), e - t <= n) continue;
    const o = t + Math.ceil((e - t) / n / 2) * n;
    _d(i, o, t, e, r), s.push(t, o, o, e);
  }
}
const Ll = [NaN, NaN, NaN, 0];
let I2;
function mm() {
  return I2 || (I2 = Pt(1, 1, void 0, {
    willReadFrequently: !0,
    desynchronized: !0
  })), I2;
}
const pm = /^rgba?\(\s*(\d+%?)\s+(\d+%?)\s+(\d+%?)(?:\s*\/\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i, _m = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i, ym = /^rgba?\(\s*(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i, vm = /^#([\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/i;
function I0(i, t) {
  return i.endsWith("%") ? Number(i.substring(0, i.length - 1)) / t : Number(i);
}
function ws(i) {
  throw new Error('failed to parse "' + i + '" as color');
}
function vd(i) {
  if (i.toLowerCase().startsWith("rgb")) {
    const s = i.match(_m) || i.match(pm) || i.match(ym);
    if (s) {
      const o = s[4], a = 100 / 255;
      return [
        ft(I0(s[1], a) + 0.5 | 0, 0, 255),
        ft(I0(s[2], a) + 0.5 | 0, 0, 255),
        ft(I0(s[3], a) + 0.5 | 0, 0, 255),
        o !== void 0 ? ft(I0(o, 100), 0, 1) : 1
      ];
    }
    ws(i);
  }
  if (i.startsWith("#")) {
    if (vm.test(i)) {
      const s = i.substring(1), o = s.length <= 4 ? 1 : 2, a = [0, 0, 0, 255];
      for (let l = 0, h = s.length; l < h; l += o) {
        let c = parseInt(s.substring(l, l + o), 16);
        o === 1 && (c += c << 4), a[l / o] = c;
      }
      return a[3] = a[3] / 255, a;
    }
    ws(i);
  }
  const t = mm();
  t.fillStyle = "#abcdef";
  let e = t.fillStyle;
  t.fillStyle = i, t.fillStyle === e && (t.fillStyle = "#fedcba", e = t.fillStyle, t.fillStyle = i, t.fillStyle === e && ws(i));
  const n = t.fillStyle;
  if (n.startsWith("#") || n.startsWith("rgba"))
    return vd(n);
  t.clearRect(0, 0, 1, 1), t.fillRect(0, 0, 1, 1);
  const r = Array.from(t.getImageData(0, 0, 1, 1).data);
  return r[3] = jr(r[3] / 255, 3), r;
}
function xm(i) {
  return typeof i == "string" ? i : Fl(i);
}
const Cm = 1024, is = {};
let k2 = 0;
function bm(i) {
  if (i.length === 4)
    return i;
  const t = i.slice();
  return t[3] = 1, t;
}
function L2(i) {
  return i > 31308e-7 ? Math.pow(i, 1 / 2.4) * 269.025 - 14.025 : i * 3294.6;
}
function A2(i) {
  return i > 0.2068965 ? Math.pow(i, 3) : (i - 4 / 29) * (108 / 841);
}
function F2(i) {
  return i > 10.314724 ? Math.pow((i + 14.025) / 269.025, 2.4) : i / 3294.6;
}
function O2(i) {
  return i > 88564e-7 ? Math.pow(i, 1 / 3) : i / (108 / 841) + 4 / 29;
}
function Hh(i) {
  const t = F2(i[0]), e = F2(i[1]), n = F2(i[2]), r = O2(t * 0.222488403 + e * 0.716873169 + n * 0.06060791), s = 500 * (O2(t * 0.452247074 + e * 0.399439023 + n * 0.148375274) - r), o = 200 * (r - O2(t * 0.016863605 + e * 0.117638439 + n * 0.865350722)), a = Math.atan2(o, s) * (180 / Math.PI);
  return [
    116 * r - 16,
    Math.sqrt(s * s + o * o),
    a < 0 ? a + 360 : a,
    i[3]
  ];
}
function wm(i) {
  const t = (i[0] + 16) / 116, e = i[1], n = i[2] * Math.PI / 180, r = A2(t), s = A2(t + e / 500 * Math.cos(n)), o = A2(t - e / 200 * Math.sin(n)), a = L2(s * 3.021973625 - r * 1.617392459 - o * 0.404875592), l = L2(s * -0.943766287 + r * 1.916279586 + o * 0.027607165), h = L2(s * 0.069407491 - r * 0.22898585 + o * 1.159737864);
  return [
    ft(a + 0.5 | 0, 0, 255),
    ft(l + 0.5 | 0, 0, 255),
    ft(h + 0.5 | 0, 0, 255),
    i[3]
  ];
}
function Al(i) {
  if (i === "none")
    return Ll;
  if (is.hasOwnProperty(i))
    return is[i];
  if (k2 >= Cm) {
    let e = 0;
    for (const n in is)
      (e++ & 3) === 0 && (delete is[n], --k2);
  }
  const t = vd(i);
  t.length !== 4 && ws(i);
  for (const e of t)
    isNaN(e) && ws(i);
  return is[i] = t, ++k2, t;
}
function Ln(i) {
  return Array.isArray(i) ? i : Al(i);
}
function Fl(i) {
  let t = i[0];
  t != (t | 0) && (t = t + 0.5 | 0);
  let e = i[1];
  e != (e | 0) && (e = e + 0.5 | 0);
  let n = i[2];
  n != (n | 0) && (n = n + 0.5 | 0);
  const r = i[3] === void 0 ? 1 : Math.round(i[3] * 1e3) / 1e3;
  return "rgba(" + t + "," + e + "," + n + "," + r + ")";
}
function Kh(i) {
  return i[0] > 0 && i[1] > 0;
}
function Em(i, t, e) {
  return e === void 0 && (e = [0, 0]), e[0] = i[0] * t + 0.5 | 0, e[1] = i[1] * t + 0.5 | 0, e;
}
function Zt(i, t) {
  return Array.isArray(i) ? i : (t === void 0 ? t = [i, i] : (t[0] = i, t[1] = i), t);
}
let Un = 0;
const te = 1 << Un++, nt = 1 << Un++, oe = 1 << Un++, Ue = 1 << Un++, An = 1 << Un++, ds = 1 << Un++, k0 = Math.pow(2, Un) - 1, Ol = {
  [te]: "boolean",
  [nt]: "number",
  [oe]: "string",
  [Ue]: "color",
  [An]: "number[]",
  [ds]: "size"
}, Sm = Object.keys(Ol).map(Number).sort(ei);
function Mm(i) {
  return i in Ol;
}
function us(i) {
  const t = [];
  for (const e of Sm)
    fs(i, e) && t.push(Ol[e]);
  return t.length === 0 ? "untyped" : t.length < 3 ? t.join(" or ") : t.slice(0, -1).join(", ") + ", or " + t[t.length - 1];
}
function fs(i, t) {
  return (i & t) === t;
}
function Ri(i, t) {
  return i === t;
}
class It {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(t, e) {
    if (!Mm(t))
      throw new Error(
        `literal expressions must have a specific type, got ${us(t)}`
      );
    this.type = t, this.value = e;
  }
}
class Tm {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(t, e, ...n) {
    this.type = t, this.operator = e, this.args = n;
  }
}
function xd() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: !1,
    geometryType: !1,
    mapState: !1
  };
}
function zt(i, t, e) {
  switch (typeof i) {
    case "boolean": {
      if (Ri(t, oe))
        return new It(oe, i ? "true" : "false");
      if (!fs(t, te))
        throw new Error(
          `got a boolean, but expected ${us(t)}`
        );
      return new It(te, i);
    }
    case "number": {
      if (Ri(t, ds))
        return new It(ds, Zt(i));
      if (Ri(t, te))
        return new It(te, !!i);
      if (Ri(t, oe))
        return new It(oe, i.toString());
      if (!fs(t, nt))
        throw new Error(`got a number, but expected ${us(t)}`);
      return new It(nt, i);
    }
    case "string": {
      if (Ri(t, Ue))
        return new It(Ue, Al(i));
      if (Ri(t, te))
        return new It(te, !!i);
      if (!fs(t, oe))
        throw new Error(`got a string, but expected ${us(t)}`);
      return new It(oe, i);
    }
  }
  if (!Array.isArray(i))
    throw new Error("expression must be an array or a primitive value");
  if (i.length === 0)
    throw new Error("empty expression");
  if (typeof i[0] == "string")
    return Dm(i, t, e);
  for (const n of i)
    if (typeof n != "number")
      throw new Error("expected an array of numbers");
  if (Ri(t, ds)) {
    if (i.length !== 2)
      throw new Error(
        `expected an array of two values for a size, got ${i.length}`
      );
    return new It(ds, i);
  }
  if (Ri(t, Ue)) {
    if (i.length === 3)
      return new It(Ue, [...i, 1]);
    if (i.length === 4)
      return new It(Ue, i);
    throw new Error(
      `expected an array of 3 or 4 values for a color, got ${i.length}`
    );
  }
  if (!fs(t, An))
    throw new Error(
      `got an array of numbers, but expected ${us(t)}`
    );
  return new It(An, i);
}
const M = {
  Get: "get",
  Var: "var",
  Concat: "concat",
  GeometryType: "geometry-type",
  LineMetric: "line-metric",
  Any: "any",
  All: "all",
  Not: "!",
  Resolution: "resolution",
  Zoom: "zoom",
  Time: "time",
  Equal: "==",
  NotEqual: "!=",
  GreaterThan: ">",
  GreaterThanOrEqualTo: ">=",
  LessThan: "<",
  LessThanOrEqualTo: "<=",
  Multiply: "*",
  Divide: "/",
  Add: "+",
  Subtract: "-",
  Clamp: "clamp",
  Mod: "%",
  Pow: "^",
  Abs: "abs",
  Floor: "floor",
  Ceil: "ceil",
  Round: "round",
  Sin: "sin",
  Cos: "cos",
  Atan: "atan",
  Sqrt: "sqrt",
  Match: "match",
  Between: "between",
  Interpolate: "interpolate",
  Coalesce: "coalesce",
  Case: "case",
  In: "in",
  Number: "number",
  String: "string",
  Array: "array",
  Color: "color",
  Id: "id",
  Band: "band",
  Palette: "palette",
  ToString: "to-string",
  Has: "has"
}, Rm = {
  [M.Get]: Z(J(1, 1 / 0), qh),
  [M.Var]: Z(J(1, 1), Pm),
  [M.Has]: Z(J(1, 1 / 0), qh),
  [M.Id]: Z(Im, Kn),
  [M.Concat]: Z(
    J(2, 1 / 0),
    st(oe)
  ),
  [M.GeometryType]: Z(km, Kn),
  [M.LineMetric]: Z(Kn),
  [M.Resolution]: Z(G2, Kn),
  [M.Zoom]: Z(G2, Kn),
  [M.Time]: Z(G2, Kn),
  [M.Any]: Z(
    J(2, 1 / 0),
    st(te)
  ),
  [M.All]: Z(
    J(2, 1 / 0),
    st(te)
  ),
  [M.Not]: Z(
    J(1, 1),
    st(te)
  ),
  [M.Equal]: Z(
    J(2, 2),
    st(k0)
  ),
  [M.NotEqual]: Z(
    J(2, 2),
    st(k0)
  ),
  [M.GreaterThan]: Z(
    J(2, 2),
    st(nt)
  ),
  [M.GreaterThanOrEqualTo]: Z(
    J(2, 2),
    st(nt)
  ),
  [M.LessThan]: Z(
    J(2, 2),
    st(nt)
  ),
  [M.LessThanOrEqualTo]: Z(
    J(2, 2),
    st(nt)
  ),
  [M.Multiply]: Z(
    J(2, 1 / 0),
    Jh
  ),
  [M.Coalesce]: Z(
    J(2, 1 / 0),
    Jh
  ),
  [M.Divide]: Z(
    J(2, 2),
    st(nt)
  ),
  [M.Add]: Z(
    J(2, 1 / 0),
    st(nt)
  ),
  [M.Subtract]: Z(
    J(2, 2),
    st(nt)
  ),
  [M.Clamp]: Z(
    J(3, 3),
    st(nt)
  ),
  [M.Mod]: Z(
    J(2, 2),
    st(nt)
  ),
  [M.Pow]: Z(
    J(2, 2),
    st(nt)
  ),
  [M.Abs]: Z(
    J(1, 1),
    st(nt)
  ),
  [M.Floor]: Z(
    J(1, 1),
    st(nt)
  ),
  [M.Ceil]: Z(
    J(1, 1),
    st(nt)
  ),
  [M.Round]: Z(
    J(1, 1),
    st(nt)
  ),
  [M.Sin]: Z(
    J(1, 1),
    st(nt)
  ),
  [M.Cos]: Z(
    J(1, 1),
    st(nt)
  ),
  [M.Atan]: Z(
    J(1, 2),
    st(nt)
  ),
  [M.Sqrt]: Z(
    J(1, 1),
    st(nt)
  ),
  [M.Match]: Z(
    J(4, 1 / 0),
    Qh,
    Am
  ),
  [M.Between]: Z(
    J(3, 3),
    st(nt)
  ),
  [M.Interpolate]: Z(
    J(6, 1 / 0),
    Qh,
    Fm
  ),
  [M.Case]: Z(
    J(3, 1 / 0),
    Lm,
    Om
  ),
  [M.In]: Z(J(2, 2), Gm),
  [M.Number]: Z(
    J(1, 1 / 0),
    st(k0)
  ),
  [M.String]: Z(
    J(1, 1 / 0),
    st(k0)
  ),
  [M.Array]: Z(
    J(1, 1 / 0),
    st(nt)
  ),
  [M.Color]: Z(
    J(1, 4),
    st(nt)
  ),
  [M.Band]: Z(
    J(1, 3),
    st(nt)
  ),
  [M.Palette]: Z(
    J(2, 2),
    Nm
  ),
  [M.ToString]: Z(
    J(1, 1),
    st(te | nt | oe | Ue)
  )
};
function qh(i, t, e) {
  const n = i.length - 1, r = new Array(n);
  for (let s = 0; s < n; ++s) {
    const o = i[s + 1];
    switch (typeof o) {
      case "number": {
        r[s] = new It(nt, o);
        break;
      }
      case "string": {
        r[s] = new It(oe, o);
        break;
      }
      default:
        throw new Error(
          `expected a string key or numeric array index for a get operation, got ${o}`
        );
    }
    s === 0 && e.properties.add(String(o));
  }
  return r;
}
function Pm(i, t, e) {
  const n = i[1];
  if (typeof n != "string")
    throw new Error("expected a string argument for var operation");
  return e.variables.add(n), [new It(oe, n)];
}
function Im(i, t, e) {
  e.featureId = !0;
}
function km(i, t, e) {
  e.geometryType = !0;
}
function G2(i, t, e) {
  e.mapState = !0;
}
function Kn(i, t, e) {
  const n = i[0];
  if (i.length !== 1)
    throw new Error(`expected no arguments for ${n} operation`);
  return [];
}
function J(i, t) {
  return function(e, n, r) {
    const s = e[0], o = e.length - 1;
    if (i === t) {
      if (o !== i) {
        const a = i === 1 ? "" : "s";
        throw new Error(
          `expected ${i} argument${a} for ${s}, got ${o}`
        );
      }
    } else if (o < i || o > t) {
      const a = t === 1 / 0 ? `${i} or more` : `${i} to ${t}`;
      throw new Error(
        `expected ${a} arguments for ${s}, got ${o}`
      );
    }
  };
}
function Jh(i, t, e) {
  const n = i.length - 1, r = new Array(n);
  for (let s = 0; s < n; ++s) {
    const o = zt(i[s + 1], t, e);
    r[s] = o;
  }
  return r;
}
function st(i) {
  return function(t, e, n) {
    const r = t.length - 1, s = new Array(r);
    for (let o = 0; o < r; ++o) {
      const a = zt(t[o + 1], i, n);
      s[o] = a;
    }
    return s;
  };
}
function Lm(i, t, e) {
  const n = i[0], r = i.length - 1;
  if (r % 2 === 0)
    throw new Error(
      `expected an odd number of arguments for ${n}, got ${r} instead`
    );
}
function Qh(i, t, e) {
  const n = i[0], r = i.length - 1;
  if (r % 2 === 1)
    throw new Error(
      `expected an even number of arguments for operation ${n}, got ${r} instead`
    );
}
function Am(i, t, e) {
  const n = i.length - 1, r = oe | nt | te, s = zt(i[1], r, e), o = zt(i[i.length - 1], t, e), a = new Array(n - 2);
  for (let l = 0; l < n - 2; l += 2) {
    try {
      const h = zt(i[l + 2], s.type, e);
      a[l] = h;
    } catch (h) {
      throw new Error(
        `failed to parse argument ${l + 1} of match expression: ${h.message}`
      );
    }
    try {
      const h = zt(i[l + 3], o.type, e);
      a[l + 1] = h;
    } catch (h) {
      throw new Error(
        `failed to parse argument ${l + 2} of match expression: ${h.message}`
      );
    }
  }
  return [s, ...a, o];
}
function Fm(i, t, e) {
  const n = i[1];
  let r;
  switch (n[0]) {
    case "linear":
      r = 1;
      break;
    case "exponential":
      const l = n[1];
      if (typeof l != "number" || l <= 0)
        throw new Error(
          `expected a number base for exponential interpolation, got ${JSON.stringify(l)} instead`
        );
      r = l;
      break;
    default:
      throw new Error(
        `invalid interpolation type: ${JSON.stringify(n)}`
      );
  }
  const s = new It(nt, r);
  let o;
  try {
    o = zt(i[2], nt, e);
  } catch (l) {
    throw new Error(
      `failed to parse argument 1 in interpolate expression: ${l.message}`
    );
  }
  const a = new Array(i.length - 3);
  for (let l = 0; l < a.length; l += 2) {
    try {
      const h = zt(i[l + 3], nt, e);
      a[l] = h;
    } catch (h) {
      throw new Error(
        `failed to parse argument ${l + 2} for interpolate expression: ${h.message}`
      );
    }
    try {
      const h = zt(i[l + 4], t, e);
      a[l + 1] = h;
    } catch (h) {
      throw new Error(
        `failed to parse argument ${l + 3} for interpolate expression: ${h.message}`
      );
    }
  }
  return [s, o, ...a];
}
function Om(i, t, e) {
  const n = zt(i[i.length - 1], t, e), r = new Array(i.length - 1);
  for (let s = 0; s < r.length - 1; s += 2) {
    try {
      const o = zt(i[s + 1], te, e);
      r[s] = o;
    } catch (o) {
      throw new Error(
        `failed to parse argument ${s} of case expression: ${o.message}`
      );
    }
    try {
      const o = zt(i[s + 2], n.type, e);
      r[s + 1] = o;
    } catch (o) {
      throw new Error(
        `failed to parse argument ${s + 1} of case expression: ${o.message}`
      );
    }
  }
  return r[r.length - 1] = n, r;
}
function Gm(i, t, e) {
  let n = i[2];
  if (!Array.isArray(n))
    throw new Error(
      'the second argument for the "in" operator must be an array'
    );
  let r;
  if (typeof n[0] == "string") {
    if (n[0] !== "literal")
      throw new Error(
        'for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions'
      );
    if (!Array.isArray(n[1]))
      throw new Error(
        'failed to parse "in" expression: the literal operator must be followed by an array'
      );
    n = n[1], r = oe;
  } else
    r = nt;
  const s = new Array(n.length);
  for (let a = 0; a < s.length; a++)
    try {
      const l = zt(n[a], r, e);
      s[a] = l;
    } catch (l) {
      throw new Error(
        `failed to parse haystack item ${a} for "in" expression: ${l.message}`
      );
    }
  return [zt(i[1], r, e), ...s];
}
function Nm(i, t, e) {
  let n;
  try {
    n = zt(i[1], nt, e);
  } catch (o) {
    throw new Error(
      `failed to parse first argument in palette expression: ${o.message}`
    );
  }
  const r = i[2];
  if (!Array.isArray(r))
    throw new Error("the second argument of palette must be an array");
  const s = new Array(r.length);
  for (let o = 0; o < s.length; o++) {
    let a;
    try {
      a = zt(r[o], Ue, e);
    } catch (l) {
      throw new Error(
        `failed to parse color at index ${o} in palette expression: ${l.message}`
      );
    }
    if (!(a instanceof It))
      throw new Error(
        `the palette color at index ${o} must be a literal value`
      );
    s[o] = a;
  }
  return [n, ...s];
}
function Z(...i) {
  return function(t, e, n) {
    const r = t[0];
    let s;
    for (let o = 0; o < i.length; o++) {
      const a = i[o](t, e, n);
      if (o == i.length - 1) {
        if (!a)
          throw new Error(
            "expected last argument validator to return the parsed args"
          );
        s = a;
      }
    }
    return new Tm(e, r, ...s);
  };
}
function Dm(i, t, e) {
  const n = i[0], r = Rm[n];
  if (!r)
    throw new Error(`unknown operator: ${n}`);
  return r(i, t, e);
}
function Cd(i) {
  if (!i)
    return "";
  const t = i.getType();
  switch (t) {
    case "Point":
    case "LineString":
    case "Polygon":
      return t;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        t.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return Cd(
        /** @type {import("../geom/GeometryCollection.js").default} */
        i.getGeometries()[0]
      );
    default:
      return "";
  }
}
function bd() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function bi(i, t, e) {
  const n = zt(i, t, e);
  return We(n);
}
function We(i, t) {
  if (i instanceof It) {
    if (i.type === Ue && typeof i.value == "string") {
      const n = Al(i.value);
      return function() {
        return n;
      };
    }
    return function() {
      return i.value;
    };
  }
  const e = i.operator;
  switch (e) {
    case M.Number:
    case M.String:
    case M.Coalesce:
      return zm(i);
    case M.Get:
    case M.Var:
    case M.Has:
      return jm(i);
    case M.Id:
      return (n) => n.featureId;
    case M.GeometryType:
      return (n) => n.geometryType;
    case M.Concat: {
      const n = i.args.map((r) => We(r));
      return (r) => "".concat(...n.map((s) => s(r).toString()));
    }
    case M.Resolution:
      return (n) => n.resolution;
    case M.Any:
    case M.All:
    case M.Between:
    case M.In:
    case M.Not:
      return Bm(i);
    case M.Equal:
    case M.NotEqual:
    case M.LessThan:
    case M.LessThanOrEqualTo:
    case M.GreaterThan:
    case M.GreaterThanOrEqualTo:
      return Um(i);
    case M.Multiply:
    case M.Divide:
    case M.Add:
    case M.Subtract:
    case M.Clamp:
    case M.Mod:
    case M.Pow:
    case M.Abs:
    case M.Floor:
    case M.Ceil:
    case M.Round:
    case M.Sin:
    case M.Cos:
    case M.Atan:
    case M.Sqrt:
      return Vm(i);
    case M.Case:
      return $m(i);
    case M.Match:
      return Wm(i);
    case M.Interpolate:
      return Ym(i);
    case M.ToString:
      return Xm(i);
    default:
      throw new Error(`Unsupported operator ${e}`);
  }
}
function zm(i, t) {
  const e = i.operator, n = i.args.length, r = new Array(n);
  for (let s = 0; s < n; ++s)
    r[s] = We(i.args[s]);
  switch (e) {
    case M.Coalesce:
      return (s) => {
        for (let o = 0; o < n; ++o) {
          const a = r[o](s);
          if (typeof a < "u" && a !== null)
            return a;
        }
        throw new Error("Expected one of the values to be non-null");
      };
    case M.Number:
    case M.String:
      return (s) => {
        for (let o = 0; o < n; ++o) {
          const a = r[o](s);
          if (typeof a === e)
            return a;
        }
        throw new Error(`Expected one of the values to be a ${e}`);
      };
    default:
      throw new Error(`Unsupported assertion operator ${e}`);
  }
}
function jm(i, t) {
  const n = (
    /** @type {string} */
    /** @type {LiteralExpression} */
    i.args[0].value
  );
  switch (i.operator) {
    case M.Get:
      return (r) => {
        const s = i.args;
        let o = r.properties[n];
        for (let a = 1, l = s.length; a < l; ++a) {
          const c = (
            /** @type {string|number} */
            /** @type {LiteralExpression} */
            s[a].value
          );
          o = o[c];
        }
        return o;
      };
    case M.Var:
      return (r) => r.variables[n];
    case M.Has:
      return (r) => {
        const s = i.args;
        if (!(n in r.properties))
          return !1;
        let o = r.properties[n];
        for (let a = 1, l = s.length; a < l; ++a) {
          const c = (
            /** @type {string|number} */
            /** @type {LiteralExpression} */
            s[a].value
          );
          if (!o || !Object.hasOwn(o, c))
            return !1;
          o = o[c];
        }
        return !0;
      };
    default:
      throw new Error(`Unsupported accessor operator ${i.operator}`);
  }
}
function Um(i, t) {
  const e = i.operator, n = We(i.args[0]), r = We(i.args[1]);
  switch (e) {
    case M.Equal:
      return (s) => n(s) === r(s);
    case M.NotEqual:
      return (s) => n(s) !== r(s);
    case M.LessThan:
      return (s) => n(s) < r(s);
    case M.LessThanOrEqualTo:
      return (s) => n(s) <= r(s);
    case M.GreaterThan:
      return (s) => n(s) > r(s);
    case M.GreaterThanOrEqualTo:
      return (s) => n(s) >= r(s);
    default:
      throw new Error(`Unsupported comparison operator ${e}`);
  }
}
function Bm(i, t) {
  const e = i.operator, n = i.args.length, r = new Array(n);
  for (let s = 0; s < n; ++s)
    r[s] = We(i.args[s]);
  switch (e) {
    case M.Any:
      return (s) => {
        for (let o = 0; o < n; ++o)
          if (r[o](s))
            return !0;
        return !1;
      };
    case M.All:
      return (s) => {
        for (let o = 0; o < n; ++o)
          if (!r[o](s))
            return !1;
        return !0;
      };
    case M.Between:
      return (s) => {
        const o = r[0](s), a = r[1](s), l = r[2](s);
        return o >= a && o <= l;
      };
    case M.In:
      return (s) => {
        const o = r[0](s);
        for (let a = 1; a < n; ++a)
          if (o === r[a](s))
            return !0;
        return !1;
      };
    case M.Not:
      return (s) => !r[0](s);
    default:
      throw new Error(`Unsupported logical operator ${e}`);
  }
}
function Vm(i, t) {
  const e = i.operator, n = i.args.length, r = new Array(n);
  for (let s = 0; s < n; ++s)
    r[s] = We(i.args[s]);
  switch (e) {
    case M.Multiply:
      return (s) => {
        let o = 1;
        for (let a = 0; a < n; ++a)
          o *= r[a](s);
        return o;
      };
    case M.Divide:
      return (s) => r[0](s) / r[1](s);
    case M.Add:
      return (s) => {
        let o = 0;
        for (let a = 0; a < n; ++a)
          o += r[a](s);
        return o;
      };
    case M.Subtract:
      return (s) => r[0](s) - r[1](s);
    case M.Clamp:
      return (s) => {
        const o = r[0](s), a = r[1](s);
        if (o < a)
          return a;
        const l = r[2](s);
        return o > l ? l : o;
      };
    case M.Mod:
      return (s) => r[0](s) % r[1](s);
    case M.Pow:
      return (s) => Math.pow(r[0](s), r[1](s));
    case M.Abs:
      return (s) => Math.abs(r[0](s));
    case M.Floor:
      return (s) => Math.floor(r[0](s));
    case M.Ceil:
      return (s) => Math.ceil(r[0](s));
    case M.Round:
      return (s) => Math.round(r[0](s));
    case M.Sin:
      return (s) => Math.sin(r[0](s));
    case M.Cos:
      return (s) => Math.cos(r[0](s));
    case M.Atan:
      return n === 2 ? (s) => Math.atan2(r[0](s), r[1](s)) : (s) => Math.atan(r[0](s));
    case M.Sqrt:
      return (s) => Math.sqrt(r[0](s));
    default:
      throw new Error(`Unsupported numeric operator ${e}`);
  }
}
function $m(i, t) {
  const e = i.args.length, n = new Array(e);
  for (let r = 0; r < e; ++r)
    n[r] = We(i.args[r]);
  return (r) => {
    for (let s = 0; s < e - 1; s += 2)
      if (n[s](r))
        return n[s + 1](r);
    return n[e - 1](r);
  };
}
function Wm(i, t) {
  const e = i.args.length, n = new Array(e);
  for (let r = 0; r < e; ++r)
    n[r] = We(i.args[r]);
  return (r) => {
    const s = n[0](r);
    for (let o = 1; o < e - 1; o += 2)
      if (s === n[o](r))
        return n[o + 1](r);
    return n[e - 1](r);
  };
}
function Ym(i, t) {
  const e = i.args.length, n = new Array(e);
  for (let r = 0; r < e; ++r)
    n[r] = We(i.args[r]);
  return (r) => {
    const s = n[0](r), o = n[1](r);
    let a, l;
    for (let h = 2; h < e; h += 2) {
      const c = n[h](r);
      let d = n[h + 1](r);
      const u = Array.isArray(d);
      if (u && (d = bm(d)), c >= o)
        return h === 2 ? d : u ? Zm(
          s,
          o,
          a,
          l,
          c,
          d
        ) : gs(
          s,
          o,
          a,
          l,
          c,
          d
        );
      a = c, l = d;
    }
    return l;
  };
}
function Xm(i, t) {
  const e = i.operator, n = i.args.length, r = new Array(n);
  for (let s = 0; s < n; ++s)
    r[s] = We(i.args[s]);
  switch (e) {
    case M.ToString:
      return (s) => {
        const o = r[0](s);
        return i.args[0].type === Ue ? Fl(o) : o.toString();
      };
    default:
      throw new Error(`Unsupported convert operator ${e}`);
  }
}
function gs(i, t, e, n, r, s) {
  const o = r - e;
  if (o === 0)
    return n;
  const a = t - e, l = i === 1 ? a / o : (Math.pow(i, a) - 1) / (Math.pow(i, o) - 1);
  return n + l * (s - n);
}
function Zm(i, t, e, n, r, s) {
  if (r - e === 0)
    return n;
  const a = Hh(n), l = Hh(s);
  let h = l[2] - a[2];
  h > 180 ? h -= 360 : h < -180 && (h += 360);
  const c = [
    gs(i, t, e, a[0], r, l[0]),
    gs(i, t, e, a[1], r, l[1]),
    a[2] + gs(i, t, e, 0, r, h),
    gs(i, t, e, n[3], r, s[3])
  ];
  return wm(c);
}
const z = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
class wd extends e0 {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
   * resolution will be assumed.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default|Loader} stateOrLoader State.
   */
  constructor(t, e, n, r) {
    super(), this.extent = t, this.pixelRatio_ = n, this.resolution = e, this.state = typeof r == "function" ? z.IDLE : r, this.image_ = null, this.loader = typeof r == "function" ? r : null;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(V.CHANGE);
  }
  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  getExtent() {
    return this.extent;
  }
  /**
   * @return {import('./DataTile.js').ImageLike} Image.
   */
  getImage() {
    return this.image_;
  }
  /**
   * @return {number} PixelRatio.
   */
  getPixelRatio() {
    return this.pixelRatio_;
  }
  /**
   * @return {number|Array<number>} Resolution.
   */
  getResolution() {
    return (
      /** @type {number} */
      this.resolution
    );
  }
  /**
   * @return {import("./ImageState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == z.IDLE && this.loader) {
      this.state = z.LOADING, this.changed();
      const t = this.getResolution(), e = Array.isArray(t) ? t[0] : t;
      w1(
        () => this.loader(
          this.getExtent(),
          e,
          this.getPixelRatio()
        )
      ).then((n) => {
        "image" in n && (this.image_ = n.image), "extent" in n && (this.extent = n.extent), "resolution" in n && (this.resolution = n.resolution), "pixelRatio" in n && (this.pixelRatio_ = n.pixelRatio), (n instanceof HTMLImageElement || E1 && n instanceof ImageBitmap || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement) && (this.image_ = n), this.state = z.LOADED;
      }).catch((n) => {
        this.state = z.ERROR, console.error(n);
      }).finally(() => this.changed());
    }
  }
  /**
   * @param {import('./DataTile.js').ImageLike} image The image.
   */
  setImage(t) {
    this.image_ = t;
  }
  /**
   * @param {number|Array<number>} resolution Resolution.
   */
  setResolution(t) {
    this.resolution = t;
  }
}
function Hm(i, t, e) {
  const n = (
    /** @type {HTMLImageElement} */
    i
  );
  let r = !0, s = !1, o = !1;
  const a = [
    Ns(n, V.LOAD, function() {
      o = !0, s || t();
    })
  ];
  return n.src && el ? (s = !0, n.decode().then(function() {
    r && t();
  }).catch(function(l) {
    r && (o ? t() : e());
  })) : a.push(Ns(n, V.ERROR, e)), function() {
    r = !1, a.forEach(dt);
  };
}
function Km(i, t) {
  return new Promise((e, n) => {
    function r() {
      o(), e(i);
    }
    function s() {
      o(), n(new Error("Image load error"));
    }
    function o() {
      i.removeEventListener("load", r), i.removeEventListener("error", s);
    }
    i.addEventListener("load", r), i.addEventListener("error", s);
  });
}
function Ed(i, t) {
  return t && (i.src = t), i.src && el ? new Promise(
    (e, n) => i.decode().then(() => e(i)).catch(
      (r) => i.complete && i.width ? e(i) : n(r)
    )
  ) : Km(i);
}
function Sd(i, t) {
  return t && (i.src = t), i.src && el && E1 ? i.decode().then(() => createImageBitmap(i)).catch((e) => {
    if (i.complete && i.width)
      return i;
    throw e;
  }) : Ed(i);
}
class qm {
  constructor() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 1024;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let t = 0;
      for (const e in this.cache_) {
        const n = this.cache_[e];
        (t++ & 3) === 0 && !n.hasListener() && (delete this.cache_[e], delete this.patternCache_[e], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(t, e, n) {
    const r = N2(t, e, n);
    return r in this.cache_ ? this.cache_[r] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(t, e, n) {
    const r = N2(t, e, n);
    return r in this.patternCache_ ? this.patternCache_[r] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(t, e, n, r, s) {
    const o = N2(t, e, n), a = o in this.cache_;
    this.cache_[o] = r, s && (r.getImageState() === z.IDLE && r.load(), r.getImageState() === z.LOADING ? r.ready().then(() => {
      this.patternCache_[o] = mo().createPattern(
        r.getImage(1),
        "repeat"
      );
    }) : this.patternCache_[o] = mo().createPattern(
      r.getImage(1),
      "repeat"
    )), a || ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `1024`. Change this value when
   * your map uses more than 1024 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(t) {
    this.maxCacheSize_ = t, this.expire();
  }
}
function N2(i, t, e) {
  const n = e ? Ln(e) : "null";
  return t + ":" + i + ":" + n;
}
const Pe = new qm();
let ns = null;
class Md extends e0 {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(t, e, n, r, s) {
    super(), this.hitDetectionImage_ = null, this.image_ = t, this.crossOrigin_ = n, this.canvas_ = {}, this.color_ = s, this.imageState_ = r === void 0 ? z.IDLE : r, this.size_ = t && t.width && t.height ? [t.width, t.height] : null, this.src_ = e, this.tainted_, this.ready_ = null;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === z.LOADED) {
      ns || (ns = Pt(1, 1, void 0, {
        willReadFrequently: !0
      })), ns.drawImage(this.image_, 0, 0);
      try {
        ns.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        ns = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(V.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = z.ERROR, this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = z.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(t) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(t) {
    return this.replaceColor_(t), this.canvas_[t] ? t : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const t = this.size_[0], e = this.size_[1], n = Pt(t, e);
        n.fillRect(0, 0, t, e), this.hitDetectionImage_ = n.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === z.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = z.LOADING;
      try {
        this.src_ !== void 0 && (this.image_.src = this.src_);
      } catch {
        this.handleImageError_();
      }
      this.image_ instanceof HTMLImageElement && Ed(this.image_, this.src_).then((t) => {
        this.image_ = t, this.handleImageLoad_();
      }).catch(this.handleImageError_.bind(this));
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(t) {
    if (!this.color_ || this.canvas_[t] || this.imageState_ !== z.LOADED)
      return;
    const e = this.image_, n = Pt(
      Math.ceil(e.width * t),
      Math.ceil(e.height * t)
    ), r = n.canvas;
    n.scale(t, t), n.drawImage(e, 0, 0), n.globalCompositeOperation = "multiply", n.fillStyle = xm(this.color_), n.fillRect(0, 0, r.width / t, r.height / t), n.globalCompositeOperation = "destination-in", n.drawImage(e, 0, 0), this.canvas_[t] = r;
  }
  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    return this.ready_ || (this.ready_ = new Promise((t) => {
      if (this.imageState_ === z.LOADED || this.imageState_ === z.ERROR)
        t();
      else {
        const e = () => {
          (this.imageState_ === z.LOADED || this.imageState_ === z.ERROR) && (this.removeEventListener(V.CHANGE, e), t());
        };
        this.addEventListener(V.CHANGE, e);
      }
    })), this.ready_;
  }
}
function _o(i, t, e, n, r, s) {
  let o = t === void 0 ? void 0 : Pe.get(t, e, r);
  return o || (o = new Md(
    i,
    i && "src" in i ? i.src || void 0 : t,
    e,
    n,
    r
  ), Pe.set(t, e, r, o, s)), s && o && !Pe.getPattern(t, e, r) && Pe.set(t, e, r, o, s), o;
}
function ti(i) {
  return i ? Array.isArray(i) ? Fl(i) : typeof i == "object" && "src" in i ? Jm(i) : i : null;
}
function Jm(i) {
  if (!i.offset || !i.size)
    return Pe.getPattern(i.src, "anonymous", i.color);
  const t = i.src + ":" + i.offset, e = Pe.getPattern(
    t,
    void 0,
    i.color
  );
  if (e)
    return e;
  const n = Pe.get(i.src, "anonymous", null);
  if (n.getImageState() !== z.LOADED)
    return null;
  const r = Pt(
    i.size[0],
    i.size[1]
  );
  return r.drawImage(
    n.getImage(1),
    i.offset[0],
    i.offset[1],
    i.size[0],
    i.size[1],
    0,
    0,
    i.size[0],
    i.size[1]
  ), _o(
    r.canvas,
    t,
    void 0,
    z.LOADED,
    i.color,
    !0
  ), Pe.getPattern(t, void 0, i.color);
}
const Td = "10px sans-serif", ae = "#000", Fr = "round", pi = [], _i = 0, Or = "round", Bs = 10, Vs = "#000", $s = "center", yo = "middle", yn = [0, 0, 0, 0], Ws = 1, rr = new De();
let rs = null, tc;
const Sa = {}, Qm = /* @__PURE__ */ new Set([
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui",
  "ui-serif",
  "ui-sans-serif",
  "ui-monospace",
  "ui-rounded",
  "emoji",
  "math",
  "fangsong"
]);
function t4(i, t, e) {
  return `${i} ${t} 16px "${e}"`;
}
const e4 = /* @__PURE__ */ (function() {
  let t, e;
  async function n(s) {
    await e.ready;
    const o = await e.load(s);
    if (o.length === 0)
      return !1;
    const a = Ca(s), l = a.families[0].toLowerCase(), h = a.weight;
    return o.some(
      /**
       * @param {import('../css.js').FontParameters} f Font.
       * @return {boolean} Font matches.
       */
      (c) => {
        const d = c.family.replace(/^['"]|['"]$/g, "").toLowerCase(), u = xa[c.weight] || c.weight;
        return d === l && c.style === a.style && u == h;
      }
    );
  }
  async function r() {
    await e.ready;
    let s = !0;
    const o = rr.getProperties(), a = Object.keys(o).filter(
      (l) => o[l] < 100
    );
    for (let l = a.length - 1; l >= 0; --l) {
      const h = a[l];
      let c = o[h];
      c < 100 && (await n(h) ? (t0(Sa), rr.set(h, 100)) : (c += 10, rr.set(h, c, !0), c < 100 && (s = !1)));
    }
    t = void 0, s || (t = setTimeout(r, 100));
  }
  return async function(s) {
    e || (e = ye ? self.fonts : document.fonts);
    const o = Ca(s);
    if (!o)
      return;
    const a = o.families;
    let l = !1;
    for (const h of a) {
      if (Qm.has(h))
        continue;
      const c = t4(o.style, o.weight, h);
      rr.get(c) === void 0 && (rr.set(c, 0, !0), l = !0);
    }
    l && (clearTimeout(t), t = setTimeout(r, 100));
  };
})(), i4 = /* @__PURE__ */ (function() {
  let i;
  return function(t) {
    let e = Sa[t];
    if (e == null) {
      if (ye) {
        const n = Ca(t), r = Rd(t, "g");
        e = (isNaN(Number(n.lineHeight)) ? 1.2 : Number(n.lineHeight)) * (r.actualBoundingBoxAscent + r.actualBoundingBoxDescent);
      } else
        i || (i = document.createElement("div"), i.innerHTML = "M", i.style.minHeight = "0", i.style.maxHeight = "none", i.style.height = "auto", i.style.padding = "0", i.style.border = "none", i.style.position = "absolute", i.style.display = "block", i.style.left = "-99999px"), i.style.font = t, document.body.appendChild(i), e = i.offsetHeight, document.body.removeChild(i);
      Sa[t] = e;
    }
    return e;
  };
})();
function Rd(i, t) {
  return rs || (rs = Pt(1, 1)), i != tc && (rs.font = i, tc = rs.font), rs.measureText(t);
}
function Pd(i, t) {
  return Rd(i, t).width;
}
function ec(i, t, e) {
  if (t in e)
    return e[t];
  const n = t.split(`
`).reduce((r, s) => Math.max(r, Pd(i, s)), 0);
  return e[t] = n, n;
}
function n4(i, t) {
  const e = [], n = [], r = [];
  let s = 0, o = 0, a = 0, l = 0;
  for (let h = 0, c = t.length; h <= c; h += 2) {
    const d = t[h];
    if (d === `
` || h === c) {
      s = Math.max(s, o), r.push(o), o = 0, a += l, l = 0;
      continue;
    }
    const u = t[h + 1] || i.font, f = Pd(u, d);
    e.push(f), o += f;
    const g = i4(u);
    n.push(g), l = Math.max(l, g);
  }
  return { width: s, height: a, widths: e, heights: n, lineWidths: r };
}
function r4(i, t, e, n, r, s, o, a, l, h, c) {
  i.save(), e !== 1 && (i.globalAlpha === void 0 ? i.globalAlpha = (d) => d.globalAlpha *= e : i.globalAlpha *= e), t && i.transform.apply(i, t), /** @type {*} */
  n.contextInstructions ? (i.translate(l, h), i.scale(c[0], c[1]), s4(
    /** @type {Label} */
    n,
    i
  )) : c[0] < 0 || c[1] < 0 ? (i.translate(l, h), i.scale(c[0], c[1]), i.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    n,
    r,
    s,
    o,
    a,
    0,
    0,
    o,
    a
  )) : i.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    n,
    r,
    s,
    o,
    a,
    l,
    h,
    o * c[0],
    a * c[1]
  ), i.restore();
}
function s4(i, t) {
  const e = i.contextInstructions;
  for (let n = 0, r = e.length; n < r; n += 2)
    Array.isArray(e[n + 1]) ? t[e[n]].apply(
      t,
      e[n + 1]
    ) : t[e[n]] = e[n + 1];
}
class Ko {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale, this.scaleArray_ = Zt(t.scale), this.displacement_ = t.displacement, this.declutterMode_ = t.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale();
    return new Ko({
      opacity: this.getOpacity(),
      scale: Array.isArray(t) ? t.slice() : t,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return X();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(t) {
    return X();
  }
  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return X();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(t) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return X();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return X();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return X();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return X();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(t) {
    this.displacement_ = t;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(t) {
    this.opacity_ = t;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(t) {
    this.rotateWithView_ = t;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(t) {
    this.rotation_ = t;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(t) {
    this.scale_ = t, this.scaleArray_ = Zt(t);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
    X();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    X();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
    X();
  }
  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
}
class qo extends Ko {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    super({
      opacity: 1,
      rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : !1,
      rotation: t.rotation !== void 0 ? t.rotation : 0,
      scale: t.scale !== void 0 ? t.scale : 1,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      declutterMode: t.declutterMode
    }), this.hitDetectionCanvas_ = null, this.fill_ = t.fill !== void 0 ? t.fill : null, this.origin_ = [0, 0], this.points_ = t.points, this.radius = t.radius, this.radius2_ = t.radius2, this.angle_ = t.angle !== void 0 ? t.angle : 0, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? z.LOADING : z.LOADED, this.imageState_ === z.LOADING && this.ready().then(() => this.imageState_ = z.LOADED), this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   * @override
   */
  clone() {
    const t = this.getScale(), e = new qo({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(t) ? t.slice() : t,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return e.setOpacity(this.getOpacity()), e;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    const t = this.size_, e = this.getDisplacement(), n = this.getScaleArray();
    return [
      t[0] / 2 - e[0] / n[0],
      t[1] / 2 + e[1] / n[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t, this.render();
  }
  /**
   * @return {HTMLCanvasElement|OffscreenCanvas} Image element.
   * @override
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
      this.renderOptions_
    )), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement|OffscreenCanvas} Image or Canvas element.
   * @api
   * @override
   */
  getImage(t) {
    const e = this.fill_?.getKey(), n = `${t},${this.angle_},${this.radius},${this.radius2_},${this.points_},${e}` + Object.values(this.renderOptions_).join(",");
    let r = (
      /** @type {HTMLCanvasElement|OffscreenCanvas} */
      Pe.get(n, null, null)?.getImage(1)
    );
    if (!r) {
      const s = this.renderOptions_, o = Math.ceil(s.size * t), a = Pt(o, o);
      this.draw_(s, a, t), r = a.canvas, Pe.set(
        n,
        null,
        null,
        new Md(r, void 0, null, z.LOADED, null)
      );
    }
    return r;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   * @override
   */
  getPixelRatio(t) {
    return t;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   * @override
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(t) {
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(t) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(t, e, n) {
    if (e === 0 || this.points_ === 1 / 0 || t !== "bevel" && t !== "miter")
      return e;
    let r = this.radius, s = this.radius2_ === void 0 ? r : this.radius2_;
    if (r < s) {
      const b = r;
      r = s, s = b;
    }
    const o = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, a = 2 * Math.PI / o, l = s * Math.sin(a), h = Math.sqrt(s * s - l * l), c = r - h, d = Math.sqrt(l * l + c * c), u = d / l;
    if (t === "miter" && u <= n)
      return u * e;
    const f = e / 2 / u, g = e / 2 * (c / d), m = Math.sqrt((r + f) * (r + f) + g * g) - r;
    if (this.radius2_ === void 0 || t === "bevel")
      return m * 2;
    const _ = r * Math.sin(a), y = Math.sqrt(r * r - _ * _), x = s - y, C = Math.sqrt(_ * _ + x * x) / _;
    if (C <= n) {
      const b = C * e / 2 - s - r;
      return 2 * Math.max(m, b);
    }
    return m * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let t = Fr, e = Or, n = 0, r = null, s = 0, o, a = 0;
    this.stroke_ && (o = ti(this.stroke_.getColor() ?? Vs), a = this.stroke_.getWidth() ?? Ws, r = this.stroke_.getLineDash(), s = this.stroke_.getLineDashOffset() ?? 0, e = this.stroke_.getLineJoin() ?? Or, t = this.stroke_.getLineCap() ?? Fr, n = this.stroke_.getMiterLimit() ?? Bs);
    const l = this.calculateLineJoinSize_(e, a, n), h = Math.max(this.radius, this.radius2_ || 0), c = Math.ceil(2 * h + l);
    return {
      strokeStyle: o,
      strokeWidth: a,
      size: c,
      lineCap: t,
      lineDash: r,
      lineDashOffset: s,
      lineJoin: e,
      miterLimit: n
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const t = this.renderOptions_.size;
    this.hitDetectionCanvas_ = null, this.size_ = [t, t];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(t, e, n) {
    if (e.scale(n, n), e.translate(t.size / 2, t.size / 2), this.createPath_(e), this.fill_) {
      let r = this.fill_.getColor();
      r === null && (r = ae), e.fillStyle = ti(r), e.fill();
    }
    t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement|OffscreenCanvas} Canvas containing the icon
   */
  createHitDetectionCanvas_(t) {
    let e;
    if (this.fill_) {
      let n = this.fill_.getColor(), r = 0;
      typeof n == "string" && (n = Ln(n)), n === null ? r = 1 : Array.isArray(n) && (r = n.length === 4 ? n[3] : 1), r === 0 && (e = Pt(t.size, t.size), this.drawHitDetectionCanvas_(t, e));
    }
    return e ? e.canvas : this.getImage(1);
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(t) {
    let e = this.points_;
    const n = this.radius;
    if (e === 1 / 0)
      t.arc(0, 0, n, 0, 2 * Math.PI);
    else {
      const r = this.radius2_ === void 0 ? n : this.radius2_;
      this.radius2_ !== void 0 && (e *= 2);
      const s = this.angle_ - Math.PI / 2, o = 2 * Math.PI / e;
      for (let a = 0; a < e; a++) {
        const l = s + a * o, h = a % 2 === 0 ? n : r;
        t.lineTo(h * Math.cos(l), h * Math.sin(l));
      }
      t.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(t, e) {
    e.translate(t.size / 2, t.size / 2), this.createPath_(e), e.fillStyle = ae, e.fill(), t.strokeStyle && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke());
  }
  /**
   * @override
   */
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
}
class h0 extends qo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || { radius: 5 }, super({
      points: 1 / 0,
      fill: t.fill,
      radius: t.radius,
      stroke: t.stroke,
      scale: t.scale !== void 0 ? t.scale : 1,
      rotation: t.rotation !== void 0 ? t.rotation : 0,
      rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : !1,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      declutterMode: t.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   * @override
   */
  clone() {
    const t = this.getScale(), e = new h0({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(t) ? t.slice() : t,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return e.setOpacity(this.getOpacity()), e;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(t) {
    this.radius = t, this.render();
  }
}
class Ne {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.patternImage_ = null, this.color_ = null, t.color !== void 0 && this.setColor(t.color);
  }
  /**
   * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const t = this.getColor();
    return new Ne({
      color: Array.isArray(t) ? t.slice() : t || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(t) {
    if (t !== null && typeof t == "object" && "src" in t) {
      const e = _o(
        null,
        t.src,
        "anonymous",
        void 0,
        t.offset ? null : t.color ? t.color : null,
        !(t.offset && t.size)
      );
      e.ready().then(() => {
        this.patternImage_ = null;
      }), e.getImageState() === z.IDLE && e.load(), e.getImageState() === z.LOADING && (this.patternImage_ = e);
    }
    this.color_ = t;
  }
  /**
   * @return {string} Key of the fill for cache lookup.
   */
  getKey() {
    const t = this.getColor();
    return t ? t instanceof CanvasPattern || t instanceof CanvasGradient ? Y(t) : typeof t == "object" && "src" in t ? t.src + ":" + t.offset : Ln(t).toString() : "";
  }
  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }
  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
}
function ic(i, t, e, n) {
  return e !== void 0 && n !== void 0 ? [e / i, n / t] : e !== void 0 ? e / i : n !== void 0 ? n / t : 1;
}
class Wr extends Ko {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const e = t.opacity !== void 0 ? t.opacity : 1, n = t.rotation !== void 0 ? t.rotation : 0, r = t.scale !== void 0 ? t.scale : 1, s = t.rotateWithView !== void 0 ? t.rotateWithView : !1;
    super({
      opacity: e,
      rotation: n,
      scale: r,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      rotateWithView: s,
      declutterMode: t.declutterMode
    }), this.anchor_ = t.anchor !== void 0 ? t.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = t.anchorOrigin !== void 0 ? t.anchorOrigin : "top-left", this.anchorXUnits_ = t.anchorXUnits !== void 0 ? t.anchorXUnits : "fraction", this.anchorYUnits_ = t.anchorYUnits !== void 0 ? t.anchorYUnits : "fraction", this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null;
    const o = t.img !== void 0 ? t.img : null;
    let a = t.src;
    at(
      !(a !== void 0 && o),
      "`image` and `src` cannot be provided at the same time"
    ), (a === void 0 || a.length === 0) && o && (a = /** @type {HTMLImageElement} */
    o.src || Y(o)), at(
      a !== void 0 && a.length > 0,
      "A defined and non-empty `src` or `image` must be provided"
    ), at(
      !((t.width !== void 0 || t.height !== void 0) && t.scale !== void 0),
      "`width` or `height` cannot be provided together with `scale`"
    );
    let l;
    if (t.src !== void 0 ? l = z.IDLE : o !== void 0 && ("complete" in o ? o.complete ? l = o.src ? z.LOADED : z.IDLE : l = z.LOADING : l = z.LOADED), this.color_ = t.color !== void 0 ? Ln(t.color) : null, this.iconImage_ = _o(
      o,
      /** @type {string} */
      a,
      this.crossOrigin_,
      l,
      this.color_
    ), this.offset_ = t.offset !== void 0 ? t.offset : [0, 0], this.offsetOrigin_ = t.offsetOrigin !== void 0 ? t.offsetOrigin : "top-left", this.origin_ = null, this.size_ = t.size !== void 0 ? t.size : null, this.initialOptions_, t.width !== void 0 || t.height !== void 0) {
      let h, c;
      if (t.size)
        [h, c] = t.size;
      else {
        const d = this.getImage(1);
        if (d.width && d.height)
          h = d.width, c = d.height;
        else if (d instanceof HTMLImageElement) {
          this.initialOptions_ = t;
          const u = () => {
            if (this.unlistenImageChange(u), !this.initialOptions_)
              return;
            const f = this.iconImage_.getSize();
            this.setScale(
              ic(
                f[0],
                f[1],
                t.width,
                t.height
              )
            );
          };
          this.listenImageChange(u);
          return;
        }
      }
      h !== void 0 && this.setScale(
        ic(h, c, t.width, t.height)
      );
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   * @override
   */
  clone() {
    let t, e, n;
    return this.initialOptions_ ? (e = this.initialOptions_.width, n = this.initialOptions_.height) : (t = this.getScale(), t = Array.isArray(t) ? t.slice() : t), new Wr({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: t,
      width: e,
      height: n,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    let t = this.normalizedAnchor_;
    if (!t) {
      t = this.anchor_;
      const r = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!r)
          return null;
        t = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (t[0] *= r[0]), this.anchorYUnits_ == "fraction" && (t[1] *= r[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!r)
          return null;
        t === this.anchor_ && (t = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (t[0] = -t[0] + r[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (t[1] = -t[1] + r[1]);
      }
      this.normalizedAnchor_ = t;
    }
    const e = this.getDisplacement(), n = this.getScaleArray();
    return [
      t[0] - e[0] / n[0],
      t[1] + e[1] / n[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(t) {
    this.anchor_ = t, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   * @override
   */
  getImage(t) {
    return this.iconImage_.getImage(t);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   * @override
   */
  getPixelRatio(t) {
    return this.iconImage_.getPixelRatio(t);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas|ImageBitmap} Image element.
   * @override
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let t = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const e = this.getSize(), n = this.iconImage_.getSize();
      if (!e || !n)
        return null;
      t = t.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (t[0] = n[0] - e[0] - t[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (t[1] = n[1] - e[1] - t[1]);
    }
    return this.origin_ = t, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Set the image URI
   * @param {string} src Image source URI
   * @api
   */
  setSrc(t) {
    this.iconImage_ = _o(
      null,
      t,
      this.crossOrigin_,
      z.IDLE,
      this.color_
    );
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   * @override
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const t = this.getScaleArray();
    if (this.size_)
      return this.size_[0] * t[0];
    if (this.iconImage_.getImageState() == z.LOADED)
      return this.iconImage_.getSize()[0] * t[0];
  }
  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const t = this.getScaleArray();
    if (this.size_)
      return this.size_[1] * t[1];
    if (this.iconImage_.getImageState() == z.LOADED)
      return this.iconImage_.getSize()[1] * t[1];
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   * @override
   */
  setScale(t) {
    delete this.initialOptions_, super.setScale(t);
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(t) {
    this.iconImage_.addEventListener(V.CHANGE, t);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   * @override
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(t) {
    this.iconImage_.removeEventListener(V.CHANGE, t);
  }
  /**
   * @override
   */
  ready() {
    return this.iconImage_.ready();
  }
}
class Ae {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.color_ = t.color !== void 0 ? t.color : null, this.lineCap_ = t.lineCap, this.lineDash_ = t.lineDash !== void 0 ? t.lineDash : null, this.lineDashOffset_ = t.lineDashOffset, this.lineJoin_ = t.lineJoin, this.miterLimit_ = t.miterLimit, this.width_ = t.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const t = this.getColor();
    return new Ae({
      color: Array.isArray(t) ? t.slice() : t || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(t) {
    this.color_ = t;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(t) {
    this.lineCap_ = t;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(t) {
    this.lineDash_ = t;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(t) {
    this.lineDashOffset_ = t;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(t) {
    this.lineJoin_ = t;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(t) {
    this.miterLimit_ = t;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(t) {
    this.width_ = t;
  }
}
class At {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(t) {
    t = t || {}, this.geometry_ = null, this.geometryFunction_ = nc, t.geometry !== void 0 && this.setGeometry(t.geometry), this.fill_ = t.fill !== void 0 ? t.fill : null, this.image_ = t.image !== void 0 ? t.image : null, this.renderer_ = t.renderer !== void 0 ? t.renderer : null, this.hitDetectionRenderer_ = t.hitDetectionRenderer !== void 0 ? t.hitDetectionRenderer : null, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.text_ = t.text !== void 0 ? t.text : null, this.zIndex_ = t.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let t = this.getGeometry();
    return t && typeof t == "object" && (t = /** @type {import("../geom/Geometry.js").default} */
    t.clone()), new At({
      geometry: t ?? void 0,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer() ?? void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(t) {
    this.renderer_ = t;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(t) {
    this.hitDetectionRenderer_ = t;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(t) {
    this.image_ = t;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(t) {
    this.text_ = t;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction|null} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(t) {
    typeof t == "function" ? this.geometryFunction_ = t : typeof t == "string" ? this.geometryFunction_ = function(e) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        e.get(t)
      );
    } : t ? t !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        t
      );
    }) : this.geometryFunction_ = nc, this.geometry_ = t;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(t) {
    this.zIndex_ = t;
  }
}
function o4(i) {
  let t;
  if (typeof i == "function")
    t = i;
  else {
    let e;
    Array.isArray(i) ? e = i : (at(
      typeof /** @type {?} */
      i.getZIndex == "function",
      "Expected an `Style` or an array of `Style`"
    ), e = [
      /** @type {Style} */
      i
    ]), t = function() {
      return e;
    };
  }
  return t;
}
let D2 = null;
function Id(i, t) {
  if (!D2) {
    const e = new Ne({
      color: "rgba(255,255,255,0.4)"
    }), n = new Ae({
      color: "#3399CC",
      width: 1.25
    });
    D2 = [
      new At({
        image: new h0({
          fill: e,
          stroke: n,
          radius: 5
        }),
        fill: e,
        stroke: n
      })
    ];
  }
  return D2;
}
function kd() {
  const i = {}, t = [255, 255, 255, 1], e = [0, 153, 255, 1], n = 3;
  return i.Polygon = [
    new At({
      fill: new Ne({
        color: [255, 255, 255, 0.5]
      })
    })
  ], i.MultiPolygon = i.Polygon, i.LineString = [
    new At({
      stroke: new Ae({
        color: t,
        width: n + 2
      })
    }),
    new At({
      stroke: new Ae({
        color: e,
        width: n
      })
    })
  ], i.MultiLineString = i.LineString, i.Circle = i.Polygon.concat(i.LineString), i.Point = [
    new At({
      image: new h0({
        radius: n * 2,
        fill: new Ne({
          color: e
        }),
        stroke: new Ae({
          color: t,
          width: n / 2
        })
      }),
      zIndex: 1 / 0
    })
  ], i.MultiPoint = i.Point, i.GeometryCollection = i.Polygon.concat(
    i.LineString,
    i.Point
  ), i;
}
function nc(i) {
  return i.getGeometry();
}
const a4 = "#333";
class c0 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.font_ = t.font, this.rotation_ = t.rotation, this.rotateWithView_ = t.rotateWithView, this.keepUpright_ = t.keepUpright, this.scale_ = t.scale, this.scaleArray_ = Zt(t.scale !== void 0 ? t.scale : 1), this.text_ = t.text, this.textAlign_ = t.textAlign, this.justify_ = t.justify, this.repeat_ = t.repeat, this.textBaseline_ = t.textBaseline, this.fill_ = t.fill !== void 0 ? t.fill : new Ne({ color: a4 }), this.maxAngle_ = t.maxAngle !== void 0 ? t.maxAngle : Math.PI / 4, this.placement_ = t.placement !== void 0 ? t.placement : "point", this.overflow_ = !!t.overflow, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.offsetX_ = t.offsetX !== void 0 ? t.offsetX : 0, this.offsetY_ = t.offsetY !== void 0 ? t.offsetY : 0, this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null, this.backgroundStroke_ = t.backgroundStroke ? t.backgroundStroke : null, this.padding_ = t.padding === void 0 ? null : t.padding, this.declutterMode_ = t.declutterMode;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale();
    return new c0({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      keepUpright: this.getKeepUpright(),
      scale: Array.isArray(t) ? t.slice() : t,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() instanceof Ne ? this.getFill().clone() : this.getFill(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0,
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Determine whether the text can be rendered upside down.
   * @return {boolean|undefined} Keep text upright.
   * @api
   */
  getKeepUpright() {
    return this.keepUpright_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(t) {
    this.overflow_ = t;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(t) {
    this.font_ = t;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(t) {
    this.maxAngle_ = t;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(t) {
    this.offsetX_ = t;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(t) {
    this.offsetY_ = t;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(t) {
    this.placement_ = t;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(t) {
    this.repeat_ = t;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(t) {
    this.rotateWithView_ = t;
  }
  /**
   * Set whether the text can be rendered upside down.
   *
   * @param {boolean} keepUpright Keep text upright.
   * @api
   */
  setKeepUpright(t) {
    this.keepUpright_ = t;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(t) {
    this.rotation_ = t;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(t) {
    this.scale_ = t, this.scaleArray_ = Zt(t !== void 0 ? t : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(t) {
    this.text_ = t;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(t) {
    this.textAlign_ = t;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(t) {
    this.justify_ = t;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(t) {
    this.textBaseline_ = t;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(t) {
    this.backgroundFill_ = t;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(t) {
    this.backgroundStroke_ = t;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(t) {
    this.padding_ = t;
  }
}
function l4(i) {
  return !0;
}
function h4(i) {
  const t = xd(), e = c4(i, t), n = bd();
  return function(r, s) {
    if (n.properties = r.getPropertiesInternal(), n.resolution = s, t.featureId) {
      const o = r.getId();
      o !== void 0 ? n.featureId = o : n.featureId = null;
    }
    return t.geometryType && (n.geometryType = Cd(
      r.getGeometry()
    )), e(n);
  };
}
function rc(i) {
  const t = xd(), e = i.length, n = new Array(e);
  for (let o = 0; o < e; ++o)
    n[o] = Ma(i[o], t);
  const r = bd(), s = new Array(e);
  return function(o, a) {
    if (r.properties = o.getPropertiesInternal(), r.resolution = a, t.featureId) {
      const h = o.getId();
      h !== void 0 ? r.featureId = h : r.featureId = null;
    }
    let l = 0;
    for (let h = 0; h < e; ++h) {
      const c = n[h](r);
      c && (s[l] = c, l += 1);
    }
    return s.length = l, s;
  };
}
function c4(i, t) {
  const e = i.length, n = new Array(e);
  for (let r = 0; r < e; ++r) {
    const s = i[r], o = "filter" in s ? bi(s.filter, te, t) : l4;
    let a;
    if (Array.isArray(s.style)) {
      const l = s.style.length;
      a = new Array(l);
      for (let h = 0; h < l; ++h)
        a[h] = Ma(s.style[h], t);
    } else
      a = [Ma(s.style, t)];
    n[r] = { filter: o, styles: a };
  }
  return function(r) {
    const s = [];
    let o = !1;
    for (let a = 0; a < e; ++a) {
      const l = n[a].filter;
      if (l(r) && !(i[a].else && o)) {
        o = !0;
        for (const h of n[a].styles) {
          const c = h(r);
          c && s.push(c);
        }
      }
    }
    return s;
  };
}
function Ma(i, t) {
  const e = Ys(i, "", t), n = Xs(i, "", t), r = d4(i, t), s = u4(i, t), o = le(i, "z-index", t);
  if (!e && !n && !r && !s && !Zi(i))
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(i)
    );
  const a = new At();
  return function(l) {
    let h = !0;
    if (e) {
      const c = e(l);
      c && (h = !1), a.setFill(c);
    }
    if (n) {
      const c = n(l);
      c && (h = !1), a.setStroke(c);
    }
    if (r) {
      const c = r(l);
      c && (h = !1), a.setText(c);
    }
    if (s) {
      const c = s(l);
      c && (h = !1), a.setImage(c);
    }
    return o && a.setZIndex(o(l)), h ? null : a;
  };
}
function Ys(i, t, e) {
  let n;
  if (t + "fill-pattern-src" in i)
    n = p4(i, t + "fill-", e);
  else {
    if (i[t + "fill-color"] === "none")
      return (s) => null;
    n = Gl(
      i,
      t + "fill-color",
      e
    );
  }
  if (!n)
    return null;
  const r = new Ne();
  return function(s) {
    const o = n(s);
    return o === Ll ? null : (r.setColor(o), r);
  };
}
function Xs(i, t, e) {
  const n = le(
    i,
    t + "stroke-width",
    e
  ), r = Gl(
    i,
    t + "stroke-color",
    e
  );
  if (!n && !r)
    return null;
  const s = gi(
    i,
    t + "stroke-line-cap",
    e
  ), o = gi(
    i,
    t + "stroke-line-join",
    e
  ), a = Ld(
    i,
    t + "stroke-line-dash",
    e
  ), l = le(
    i,
    t + "stroke-line-dash-offset",
    e
  ), h = le(
    i,
    t + "stroke-miter-limit",
    e
  ), c = new Ae();
  return function(d) {
    if (r) {
      const u = r(d);
      if (u === Ll)
        return null;
      c.setColor(u);
    }
    if (n && c.setWidth(n(d)), s) {
      const u = s(d);
      if (u !== "butt" && u !== "round" && u !== "square")
        throw new Error("Expected butt, round, or square line cap");
      c.setLineCap(u);
    }
    if (o) {
      const u = o(d);
      if (u !== "bevel" && u !== "round" && u !== "miter")
        throw new Error("Expected bevel, round, or miter line join");
      c.setLineJoin(u);
    }
    return a && c.setLineDash(a(d)), l && c.setLineDashOffset(l(d)), h && c.setMiterLimit(h(d)), c;
  };
}
function d4(i, t) {
  const e = "text-", n = gi(i, e + "value", t);
  if (!n)
    return null;
  const r = Ys(i, e, t), s = Ys(
    i,
    e + "background-",
    t
  ), o = Xs(i, e, t), a = Xs(
    i,
    e + "background-",
    t
  ), l = gi(i, e + "font", t), h = le(
    i,
    e + "max-angle",
    t
  ), c = le(
    i,
    e + "offset-x",
    t
  ), d = le(
    i,
    e + "offset-y",
    t
  ), u = yr(
    i,
    e + "overflow",
    t
  ), f = gi(
    i,
    e + "placement",
    t
  ), g = le(i, e + "repeat", t), p = Jo(i, e + "scale", t), m = yr(
    i,
    e + "rotate-with-view",
    t
  ), _ = le(
    i,
    e + "rotation",
    t
  ), y = gi(i, e + "align", t), x = gi(
    i,
    e + "justify",
    t
  ), v = gi(
    i,
    e + "baseline",
    t
  ), C = yr(
    i,
    e + "keep-upright",
    t
  ), b = Ld(
    i,
    e + "padding",
    t
  ), w = Qo(
    i,
    e + "declutter-mode"
  ), E = new c0({ declutterMode: w });
  return function(S) {
    if (E.setText(n(S)), r && E.setFill(r(S)), s && E.setBackgroundFill(s(S)), o && E.setStroke(o(S)), a && E.setBackgroundStroke(a(S)), l && E.setFont(l(S)), h && E.setMaxAngle(h(S)), c && E.setOffsetX(c(S)), d && E.setOffsetY(d(S)), u && E.setOverflow(u(S)), f) {
      const R = f(S);
      if (R !== "point" && R !== "line")
        throw new Error("Expected point or line for text-placement");
      E.setPlacement(R);
    }
    if (g && E.setRepeat(g(S)), p && E.setScale(p(S)), m && E.setRotateWithView(m(S)), _ && E.setRotation(_(S)), y) {
      const R = y(S);
      if (R !== "left" && R !== "center" && R !== "right" && R !== "end" && R !== "start")
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      E.setTextAlign(R);
    }
    if (x) {
      const R = x(S);
      if (R !== "left" && R !== "right" && R !== "center")
        throw new Error("Expected left, right, or center for text-justify");
      E.setJustify(R);
    }
    if (v) {
      const R = v(S);
      if (R !== "bottom" && R !== "top" && R !== "middle" && R !== "alphabetic" && R !== "hanging")
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      E.setTextBaseline(R);
    }
    return b && E.setPadding(b(S)), C && E.setKeepUpright(C(S)), E;
  };
}
function u4(i, t) {
  return "icon-src" in i ? f4(i, t) : "shape-points" in i ? g4(i, t) : "circle-radius" in i ? m4(i, t) : null;
}
function f4(i, t) {
  const e = "icon-", n = e + "src", r = Ad(i[n], n), s = vo(
    i,
    e + "anchor",
    t
  ), o = Jo(i, e + "scale", t), a = le(
    i,
    e + "opacity",
    t
  ), l = vo(
    i,
    e + "displacement",
    t
  ), h = le(
    i,
    e + "rotation",
    t
  ), c = yr(
    i,
    e + "rotate-with-view",
    t
  ), d = oc(i, e + "anchor-origin"), u = ac(
    i,
    e + "anchor-x-units"
  ), f = ac(
    i,
    e + "anchor-y-units"
  ), g = x4(i, e + "color"), p = y4(i, e + "cross-origin"), m = v4(i, e + "offset"), _ = oc(i, e + "offset-origin"), y = xo(i, e + "width"), x = xo(i, e + "height"), v = _4(i, e + "size"), C = Qo(
    i,
    e + "declutter-mode"
  ), b = new Wr({
    src: r,
    anchorOrigin: d,
    anchorXUnits: u,
    anchorYUnits: f,
    color: g,
    crossOrigin: p,
    offset: m,
    offsetOrigin: _,
    height: x,
    width: y,
    size: v,
    declutterMode: C
  });
  return function(w) {
    return a && b.setOpacity(a(w)), l && b.setDisplacement(l(w)), h && b.setRotation(h(w)), c && b.setRotateWithView(c(w)), o && b.setScale(o(w)), s && b.setAnchor(s(w)), b;
  };
}
function g4(i, t) {
  const e = "shape-", n = e + "points", r = e + "radius", s = Ta(i[n], n), o = Ta(i[r], r), a = Ys(i, e, t), l = Xs(i, e, t), h = Jo(i, e + "scale", t), c = vo(
    i,
    e + "displacement",
    t
  ), d = le(
    i,
    e + "rotation",
    t
  ), u = yr(
    i,
    e + "rotate-with-view",
    t
  ), f = xo(i, e + "radius2"), g = xo(i, e + "angle"), p = Qo(
    i,
    e + "declutter-mode"
  ), m = new qo({
    points: s,
    radius: o,
    radius2: f,
    angle: g,
    declutterMode: p
  });
  return function(_) {
    return a && m.setFill(a(_)), l && m.setStroke(l(_)), c && m.setDisplacement(c(_)), d && m.setRotation(d(_)), u && m.setRotateWithView(u(_)), h && m.setScale(h(_)), m;
  };
}
function m4(i, t) {
  const e = "circle-", n = Ys(i, e, t), r = Xs(i, e, t), s = le(i, e + "radius", t), o = Jo(i, e + "scale", t), a = vo(
    i,
    e + "displacement",
    t
  ), l = le(
    i,
    e + "rotation",
    t
  ), h = yr(
    i,
    e + "rotate-with-view",
    t
  ), c = Qo(
    i,
    e + "declutter-mode"
  ), d = new h0({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode: c
  });
  return function(u) {
    return s && d.setRadius(s(u)), n && d.setFill(n(u)), r && d.setStroke(r(u)), a && d.setDisplacement(a(u)), l && d.setRotation(l(u)), h && d.setRotateWithView(h(u)), o && d.setScale(o(u)), d;
  };
}
function le(i, t, e) {
  if (!(t in i))
    return;
  const n = bi(i[t], nt, e);
  return function(r) {
    return Ta(n(r), t);
  };
}
function gi(i, t, e) {
  if (!(t in i))
    return null;
  const n = bi(i[t], oe, e);
  return function(r) {
    return Ad(n(r), t);
  };
}
function p4(i, t, e) {
  const n = gi(
    i,
    t + "pattern-src",
    e
  ), r = sc(
    i,
    t + "pattern-offset",
    e
  ), s = sc(
    i,
    t + "pattern-size",
    e
  ), o = Gl(
    i,
    t + "color",
    e
  );
  return function(a) {
    return {
      src: n(a),
      offset: r && r(a),
      size: s && s(a),
      color: o && o(a)
    };
  };
}
function yr(i, t, e) {
  if (!(t in i))
    return null;
  const n = bi(i[t], te, e);
  return function(r) {
    const s = n(r);
    if (typeof s != "boolean")
      throw new Error(`Expected a boolean for ${t}`);
    return s;
  };
}
function Gl(i, t, e) {
  if (!(t in i))
    return null;
  const n = bi(i[t], Ue, e);
  return function(r) {
    return Fd(n(r), t);
  };
}
function Ld(i, t, e) {
  if (!(t in i))
    return null;
  const n = bi(i[t], An, e);
  return function(r) {
    return d0(n(r), t);
  };
}
function vo(i, t, e) {
  if (!(t in i))
    return null;
  const n = bi(i[t], An, e);
  return function(r) {
    const s = d0(n(r), t);
    if (s.length !== 2)
      throw new Error(`Expected two numbers for ${t}`);
    return s;
  };
}
function sc(i, t, e) {
  if (!(t in i))
    return null;
  const n = bi(i[t], An, e);
  return function(r) {
    return Od(n(r), t);
  };
}
function Jo(i, t, e) {
  if (!(t in i))
    return null;
  const n = bi(
    i[t],
    An | nt,
    e
  );
  return function(r) {
    return C4(n(r), t);
  };
}
function xo(i, t) {
  const e = i[t];
  if (e !== void 0) {
    if (typeof e != "number")
      throw new Error(`Expected a number for ${t}`);
    return e;
  }
}
function _4(i, t) {
  const e = i[t];
  if (e !== void 0) {
    if (typeof e == "number")
      return Zt(e);
    if (!Array.isArray(e))
      throw new Error(`Expected a number or size array for ${t}`);
    if (e.length !== 2 || typeof e[0] != "number" || typeof e[1] != "number")
      throw new Error(`Expected a number or size array for ${t}`);
    return e;
  }
}
function y4(i, t) {
  const e = i[t];
  if (e !== void 0) {
    if (typeof e != "string")
      throw new Error(`Expected a string for ${t}`);
    return e;
  }
}
function oc(i, t) {
  const e = i[t];
  if (e !== void 0) {
    if (e !== "bottom-left" && e !== "bottom-right" && e !== "top-left" && e !== "top-right")
      throw new Error(
        `Expected bottom-left, bottom-right, top-left, or top-right for ${t}`
      );
    return e;
  }
}
function ac(i, t) {
  const e = i[t];
  if (e !== void 0) {
    if (e !== "pixels" && e !== "fraction")
      throw new Error(`Expected pixels or fraction for ${t}`);
    return e;
  }
}
function v4(i, t) {
  const e = i[t];
  if (e !== void 0)
    return d0(e, t);
}
function Qo(i, t) {
  const e = i[t];
  if (e !== void 0) {
    if (typeof e != "string")
      throw new Error(`Expected a string for ${t}`);
    if (e !== "declutter" && e !== "obstacle" && e !== "none")
      throw new Error(`Expected declutter, obstacle, or none for ${t}`);
    return e;
  }
}
function x4(i, t) {
  const e = i[t];
  if (e !== void 0)
    return Fd(e, t);
}
function d0(i, t) {
  if (!Array.isArray(i))
    throw new Error(`Expected an array for ${t}`);
  const e = i.length;
  for (let n = 0; n < e; ++n)
    if (typeof i[n] != "number")
      throw new Error(`Expected an array of numbers for ${t}`);
  return i;
}
function Ad(i, t) {
  if (typeof i != "string")
    throw new Error(`Expected a string for ${t}`);
  return i;
}
function Ta(i, t) {
  if (typeof i != "number")
    throw new Error(`Expected a number for ${t}`);
  return i;
}
function Fd(i, t) {
  if (typeof i == "string")
    return i;
  const e = d0(i, t), n = e.length;
  if (n < 3 || n > 4)
    throw new Error(`Expected a color with 3 or 4 values for ${t}`);
  return e;
}
function Od(i, t) {
  const e = d0(i, t);
  if (e.length !== 2)
    throw new Error(`Expected an array of two numbers for ${t}`);
  return e;
}
function C4(i, t) {
  return typeof i == "number" ? i : Od(i, t);
}
const lc = {
  RENDER_ORDER: "renderOrder"
};
class Nl extends l0 {
  /**
   * @param {Options<FeatureType, VectorSourceType>} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const e = Object.assign({}, t);
    delete e.style, delete e.renderBuffer, delete e.updateWhileAnimating, delete e.updateWhileInteracting, super(e), this.declutter_ = t.declutter ? String(t.declutter) : void 0, this.renderBuffer_ = t.renderBuffer !== void 0 ? t.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(t.style), this.updateWhileAnimating_ = t.updateWhileAnimating !== void 0 ? t.updateWhileAnimating : !1, this.updateWhileInteracting_ = t.updateWhileInteracting !== void 0 ? t.updateWhileInteracting : !1;
  }
  /**
   * @return {string} Declutter group.
   * @override
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   * @override
   */
  getFeatures(t) {
    return super.getFeatures(t);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {import("../render.js").OrderFunction|null|undefined} Render order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(lc.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   * @override
   */
  renderDeclutter(t, e) {
    const n = this.getDeclutter();
    n in t.declutter || (t.declutter[n] = new yd(9)), this.getRenderer().renderDeclutter(t, e);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(t) {
    this.set(lc.RENDER_ORDER, t);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(t) {
    this.style_ = t === void 0 ? Id : t;
    const e = b4(t);
    this.styleFunction_ = t === null ? void 0 : o4(e), this.changed();
  }
  /**
   * @param {boolean|string|number} declutter Declutter images and text.
   * @api
   */
  setDeclutter(t) {
    this.declutter_ = t ? String(t) : void 0, this.changed();
  }
}
function b4(i) {
  if (i === void 0)
    return Id;
  if (!i)
    return null;
  if (typeof i == "function" || i instanceof At)
    return i;
  if (!Array.isArray(i))
    return rc([i]);
  if (i.length === 0)
    return [];
  const t = i.length, e = i[0];
  if (e instanceof At) {
    const r = new Array(t);
    for (let s = 0; s < t; ++s) {
      const o = i[s];
      if (!(o instanceof At))
        throw new Error("Expected a list of style instances");
      r[s] = o;
    }
    return r;
  }
  if ("style" in e) {
    const r = new Array(t);
    for (let s = 0; s < t; ++s) {
      const o = i[s];
      if (!("style" in o))
        throw new Error("Expected a list of rules with a style property");
      r[s] = o;
    }
    return h4(r);
  }
  return rc(
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    i
  );
}
class Gd extends ve {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(t, e, n, r) {
    super(t), this.inversePixelTransform = e, this.frameState = n, this.context = r;
  }
}
class w4 extends jo {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(t) {
    super(), this.map_ = t;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(t, e) {
    X();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(t) {
    const e = t.viewState, n = t.coordinateToPixelTransform, r = t.pixelToCoordinateTransform;
    ri(
      n,
      t.size[0] / 2,
      t.size[1] / 2,
      1 / e.resolution,
      -1 / e.resolution,
      -e.rotation,
      -e.center[0],
      -e.center[1]
    ), $1(r, n);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(t, e, n, r, s, o, a, l) {
    let h;
    const c = e.viewState;
    function d(v, C, b, w) {
      return s.call(o, C, v ? b : null, w);
    }
    const u = c.projection, f = Bo(t.slice(), u), g = [[0, 0]];
    if (u.canWrapX() && r) {
      const v = u.getExtent(), C = it(v);
      g.push([-C, 0], [C, 0]);
    }
    const p = e.layerStatesArray, m = p.length, _ = (
      /** @type {Array<HitMatch<T>>} */
      []
    ), y = [];
    for (let v = 0; v < g.length; v++)
      for (let C = m - 1; C >= 0; --C) {
        const b = p[C], w = b.layer;
        if (w.hasRenderer() && kl(b, c) && a.call(l, w)) {
          const E = w.getRenderer(), S = w.getSource();
          if (E && S) {
            const R = S.getWrapX() ? f : t, I = d.bind(
              null,
              b.managed
            );
            y[0] = R[0] + g[v][0], y[1] = R[1] + g[v][1], h = E.forEachFeatureAtCoordinate(
              y,
              e,
              n,
              I,
              _
            );
          }
          if (h)
            return h;
        }
      }
    if (_.length === 0)
      return;
    const x = 1 / _.length;
    return _.forEach((v, C) => v.distanceSq += C * x), _.sort((v, C) => v.distanceSq - C.distanceSq), _.some((v) => h = v.callback(v.feature, v.layer, v.geometry)), h;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(t, e, n, r, s, o) {
    return this.forEachFeatureAtCoordinate(
      t,
      e,
      n,
      r,
      Tr,
      this,
      s,
      o
    ) !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(t) {
    X();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(t) {
    Pe.canExpireCache() && t.postRenderFunctions.push(E4);
  }
}
function E4(i, t) {
  Pe.expire();
}
class S4 extends w4 {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(t) {
    super(t), this.fontChangeListenerKey_ = Q(
      rr,
      Mn.PROPERTYCHANGE,
      t.redrawText,
      t
    ), this.element_ = ye ? od() : document.createElement("div");
    const e = this.element_.style;
    e.position = "absolute", e.width = "100%", e.height = "100%", e.zIndex = "0", this.element_.className = si + " ol-layers";
    const n = t.getViewport();
    n && n.insertBefore(this.element_, n.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  dispatchRenderEvent(t, e) {
    const n = this.getMap();
    if (n.hasListener(t)) {
      const r = new Gd(t, void 0, e);
      n.dispatchEvent(r);
    }
  }
  /**
   * @override
   */
  disposeInternal() {
    dt(this.fontChangeListenerKey_), this.element_.remove(), super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderFrame(t) {
    if (!t) {
      this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    this.calculateMatrices2D(t), this.dispatchRenderEvent(Re.PRECOMPOSE, t);
    const e = t.layerStatesArray.sort(
      (h, c) => h.zIndex - c.zIndex
    );
    e.some(
      (h) => h.layer instanceof Nl && h.layer.getDeclutter()
    ) && (t.declutter = {});
    const r = t.viewState;
    this.children_.length = 0;
    const s = [];
    let o = null;
    for (let h = 0, c = e.length; h < c; ++h) {
      const d = e[h];
      t.layerIndex = h;
      const u = d.layer, f = u.getSourceState();
      if (!kl(d, r) || f != "ready" && f != "undefined") {
        u.unrender();
        continue;
      }
      const g = u.render(t, o);
      g && (g !== o && (this.children_.push(g), o = g), s.push(d));
    }
    this.declutter(t, s), Vg(this.element_, this.children_);
    const l = this.getMap().getTargetElement();
    if (Di(l)) {
      const h = l.getContext("2d");
      for (const c of this.children_) {
        const d = c.firstElementChild || c, u = c.style.backgroundColor;
        if (u && (!Di(d) || d.width > 0) && (h.fillStyle = u, h.fillRect(0, 0, l.width, l.height)), Di(d) && d.width > 0) {
          const f = c.style.opacity || d.style.opacity;
          h.globalAlpha = f === "" ? 1 : Number(f);
          const g = d.style.transform;
          if (g)
            h.setTransform(
              .../** @type {[number, number, number, number, number, number]} */
              _a(g)
            );
          else {
            const p = parseFloat(d.style.width) / d.width, m = parseFloat(d.style.height) / d.height;
            h.setTransform(p, 0, 0, m, 0, 0);
          }
          h.drawImage(d, 0, 0);
        }
      }
      h.globalAlpha = 1, h.setTransform(1, 0, 0, 1, 0, 0);
    }
    this.dispatchRenderEvent(Re.POSTCOMPOSE, t), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(t);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */
  declutter(t, e) {
    if (t.declutter) {
      for (let n = e.length - 1; n >= 0; --n) {
        const r = e[n], s = r.layer;
        s.getDeclutter() && s.renderDeclutter(t, r);
      }
      e.forEach(
        (n) => n.layer.renderDeferred(t)
      );
    }
  }
}
function Nd(i) {
  if (i instanceof l0) {
    i.setMapInternal(null);
    return;
  }
  i instanceof vi && i.getLayers().forEach(Nd);
}
function Dd(i, t) {
  if (i instanceof l0) {
    i.setMapInternal(t);
    return;
  }
  if (i instanceof vi) {
    const e = i.getLayers().getArray();
    for (let n = 0, r = e.length; n < r; ++n)
      Dd(e[n], t);
  }
}
let zd = class extends De {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(t) {
    super(), t = t || {}, this.on, this.once, this.un;
    const e = M4(t);
    this.renderComplete_ = !1, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = t.maxTilesLoading !== void 0 ? t.maxTilesLoading : 16, this.pixelRatio_ = t.pixelRatio !== void 0 ? t.pixelRatio : ff, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = Le(), this.pixelToCoordinateTransform_ = Le(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, ye || (this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_)), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = t.moveTolerance, this.keyboardEventTarget_ = e.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, ye || (this.resizeObserver_ = new ResizeObserver(() => this.updateSize())), this.controls = e.controls || (ye ? new Dt() : $g()), this.interactions = e.interactions || (ye ? new Dt() : md({
      onFocusOnly: !0
    })), this.overlays_ = e.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new pf(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    ), this.addChangeListener(
      Et.LAYERGROUP,
      this.handleLayerGroupChanged_
    ), this.addChangeListener(Et.VIEW, this.handleViewChanged_), this.addChangeListener(Et.SIZE, this.handleSizeChanged_), this.addChangeListener(Et.TARGET, this.handleTargetChanged_), this.setProperties(e.values);
    const n = this;
    t.view && !(t.view instanceof Se) && t.view.then(function(r) {
      n.setView(new Se(r));
    }), this.controls.addEventListener(
      Yt.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (r) => {
        r.element.setMap(this);
      }
    ), this.controls.addEventListener(
      Yt.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (r) => {
        r.element.setMap(null);
      }
    ), this.interactions.addEventListener(
      Yt.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (r) => {
        r.element.setMap(this);
      }
    ), this.interactions.addEventListener(
      Yt.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (r) => {
        r.element.setMap(null);
      }
    ), this.overlays_.addEventListener(
      Yt.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (r) => {
        this.addOverlayInternal_(r.element);
      }
    ), this.overlays_.addEventListener(
      Yt.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (r) => {
        const s = r.element.getId();
        s !== void 0 && delete this.overlayIdIndex_[s.toString()], r.element.setMap(null);
      }
    ), this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (r) => {
        r.setMap(this);
      }
    ), this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (r) => {
        r.setMap(this);
      }
    ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(t) {
    this.getControls().push(t);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(t) {
    this.getInteractions().push(t);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(t) {
    this.getLayerGroup().getLayers().push(t);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(t) {
    Dd(t.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(t) {
    this.getOverlays().push(t);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(t) {
    const e = t.getId();
    e !== void 0 && (this.overlayIdIndex_[e.toString()] = t), t.setMap(this);
  }
  /**
   *
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_?.disconnect(), this.setTarget(null), super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * For polygons without a fill, only the stroke will be used for hit detection.
   * Polygons must have a fill style applied to ensure that pixels inside a polygon are detected.
   * The fill can be transparent.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(t, e, n) {
    if (!this.frameState_ || !this.renderer_)
      return;
    const r = this.getCoordinateFromPixelInternal(t);
    n = n !== void 0 ? n : {};
    const s = n.hitTolerance !== void 0 ? n.hitTolerance : 0, o = n.layerFilter !== void 0 ? n.layerFilter : Tr, a = n.checkWrapped !== !1;
    return this.renderer_.forEachFeatureAtCoordinate(
      r,
      this.frameState_,
      s,
      a,
      e,
      null,
      o,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * For polygons without a fill, only the stroke will be used for hit detection.
   * Polygons must have a fill style applied to ensure that pixels inside a polygon are detected.
   * The fill can be transparent.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(t, e) {
    const n = [];
    return this.forEachFeatureAtPixel(
      t,
      function(r) {
        n.push(r);
      },
      e
    ), n;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const t = [];
    function e(n) {
      n.forEach(function(r) {
        r instanceof vi ? e(r.getLayers()) : t.push(r);
      });
    }
    return e(this.getLayers()), t;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * For polygons without a fill, only the stroke will be used for hit detection.
   * Polygons must have a fill style applied to ensure that pixels inside a polygon are detected.
   * The fill can be transparent.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(t, e) {
    if (!this.frameState_ || !this.renderer_)
      return !1;
    const n = this.getCoordinateFromPixelInternal(t);
    e = e !== void 0 ? e : {};
    const r = e.layerFilter !== void 0 ? e.layerFilter : Tr, s = e.hitTolerance !== void 0 ? e.hitTolerance : 0, o = e.checkWrapped !== !1;
    return this.renderer_.hasFeatureAtCoordinate(
      n,
      this.frameState_,
      s,
      o,
      r,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(t) {
    return this.getCoordinateFromPixel(this.getEventPixel(t));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(t) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(t));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(t) {
    const n = this.viewport_.getBoundingClientRect(), r = this.getSize(), s = n.width / r[0], o = n.height / r[1], a = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in t ? (
        /** @type {TouchEvent} */
        t.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        t
      )
    );
    return [
      (a.clientX - n.left) / s,
      (a.clientY - n.top) / o
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(Et.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(t) {
    return kn(
      this.getCoordinateFromPixelInternal(t),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(t) {
    const e = this.frameState_;
    return e ? Tt(e.pixelToCoordinateTransform, t.slice()) : null;
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */
  getOverlayById(t) {
    const e = this.overlayIdIndex_[t.toString()];
    return e !== void 0 ? e : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(Et.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(t) {
    const e = this.getLayerGroup();
    if (t instanceof Dt) {
      e.setLayers(t);
      return;
    }
    const n = e.getLayers();
    n.clear(), n.extend(t);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    return this.getLayerGroup().getLayers();
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const t = this.getLayerGroup().getLayerStatesArray();
    for (let e = 0, n = t.length; e < n; ++e) {
      const r = t[e];
      if (!r.visible)
        continue;
      const s = r.layer.getRenderer();
      if (s && !s.ready)
        return !0;
      const o = r.layer.getSource();
      if (o && o.loading)
        return !0;
    }
    return !1;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(t) {
    const e = pt(
      t,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(e);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(t) {
    const e = this.frameState_;
    return e ? Tt(
      e.coordinateToPixelTransform,
      t.slice(0, 2)
    ) : null;
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(Et.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(Et.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const t = this.getTargetElement();
    return t ? t.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(t, e, n, r) {
    return _f(
      this.frameState_,
      t,
      e,
      n,
      r
    );
  }
  /**
   * @param {PointerEvent|KeyboardEvent|WheelEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(t, e) {
    e = e || t.type;
    const n = new fi(e, this, t);
    this.handleMapBrowserEvent(n);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(t) {
    if (!this.frameState_)
      return;
    const e = t.originalEvent, n = e.type;
    if (n === Qe.POINTERDOWN || n === V.WHEEL || n === V.KEYDOWN) {
      const r = this.getOwnerDocument(), s = this.viewport_.getRootNode ? this.viewport_.getRootNode() : r, o = (
        /** @type {Node} */
        e.target
      ), a = s instanceof ShadowRoot ? s.host === o ? s.host.ownerDocument : s : s === r ? r.documentElement : s;
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(o) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !a.contains(o)
      )
        return;
    }
    if (t.frameState = this.frameState_, this.dispatchEvent(t) !== !1) {
      const r = this.getInteractions().getArray().slice();
      for (let s = r.length - 1; s >= 0; s--) {
        const o = r[s];
        if (o.getMap() !== this || !o.getActive() || !this.getTargetElement())
          continue;
        if (!o.handleEvent(t) || t.propagationStopped)
          break;
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const t = this.frameState_, e = this.tileQueue_;
    if (!e.isEmpty()) {
      let r = this.maxTilesLoading_, s = r;
      if (t) {
        const o = t.viewHints;
        if (o[mt.ANIMATING] || o[mt.INTERACTING]) {
          const a = Date.now() - t.time > 8;
          r = a ? 0 : 8, s = a ? 0 : 2;
        }
      }
      e.getTilesLoading() < r && (e.reprioritize(), e.loadMoreTiles(r, s));
    }
    t && this.renderer_ && !t.animate && (this.renderComplete_ ? (this.hasListener(Re.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
      Re.RENDERCOMPLETE,
      t
    ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
      new ir(Je.LOADEND, this, t)
    ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
      new ir(Je.LOADSTART, this, t)
    )));
    const n = this.postRenderFunctions_;
    if (t)
      for (let r = 0, s = n.length; r < s; ++r)
        n[r](this, t);
    n.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let n = 0, r = this.targetChangeHandlerKeys_.length; n < r; ++n)
        dt(this.targetChangeHandlerKeys_[n]);
      this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
        V.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      ), this.viewport_.removeEventListener(
        V.WHEEL,
        this.boundHandleBrowserEvent_
      ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, this.viewport_.remove();
    }
    if (this.targetElement_ && !Di(this.targetElement_)) {
      this.resizeObserver_?.unobserve(this.targetElement_);
      const n = this.targetElement_.getRootNode();
      n instanceof ShadowRoot && this.resizeObserver_.unobserve(n.host), this.setSize(void 0);
    }
    const t = this.getTarget(), e = typeof t == "string" ? document.getElementById(t) : t;
    if (this.targetElement_ = e, !e)
      this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
    else {
      if (Di(e) || e.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new S4(this)), !Di(e)) {
        this.mapBrowserEventHandler_ = new gf(
          this,
          this.moveTolerance_
        );
        for (const r in rt)
          this.mapBrowserEventHandler_.addEventListener(
            rt[r],
            this.handleMapBrowserEvent.bind(this)
          );
        this.viewport_.addEventListener(
          V.CONTEXTMENU,
          this.boundHandleBrowserEvent_,
          !1
        ), this.viewport_.addEventListener(
          V.WHEEL,
          this.boundHandleBrowserEvent_,
          S1 ? { passive: !1 } : !1
        );
        let n;
        if (this.keyboardEventTarget_)
          n = this.keyboardEventTarget_;
        else {
          const r = e.getRootNode();
          n = r instanceof ShadowRoot ? r.host : e;
        }
        if (this.targetChangeHandlerKeys_ = [
          Q(
            n,
            V.KEYDOWN,
            this.handleBrowserEvent,
            this
          ),
          Q(
            n,
            V.KEYPRESS,
            this.handleBrowserEvent,
            this
          )
        ], e instanceof HTMLElement) {
          const r = e.getRootNode();
          r instanceof ShadowRoot && this.resizeObserver_.observe(r.host), this.resizeObserver_?.observe(e);
        }
      }
      this.updateSize();
    }
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    this.viewPropertyListenerKey_ && (dt(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (dt(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
    const t = this.getView();
    t && (this.updateViewportSize_(this.getSize()), this.viewPropertyListenerKey_ = Q(
      t,
      Mn.PROPERTYCHANGE,
      this.handleViewPropertyChanged_,
      this
    ), this.viewChangeListenerKey_ = Q(
      t,
      V.CHANGE,
      this.handleViewPropertyChanged_,
      this
    ), t.resolveConstraints(0)), this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(dt), this.layerGroupPropertyListenerKeys_ = null);
    const t = this.getLayerGroup();
    t && (this.handleLayerAdd_(new Ai("addlayer", t)), this.layerGroupPropertyListenerKeys_ = [
      Q(t, Mn.PROPERTYCHANGE, this.render, this),
      Q(t, V.CHANGE, this.render, this),
      Q(t, "addlayer", this.handleLayerAdd_, this),
      Q(t, "removelayer", this.handleLayerRemove_, this)
    ]), this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    if (!this.frameState_)
      return;
    const t = this.frameState_.layerStatesArray;
    for (let e = 0, n = t.length; e < n; ++e) {
      const r = t[e].layer;
      r.hasRenderer() && r.getRenderer().handleFontsChanged();
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(t) {
    return this.getControls().remove(t);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(t) {
    return this.getInteractions().remove(t);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(t) {
    return this.getLayerGroup().getLayers().remove(t);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(t) {
    Nd(t.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(t) {
    return this.getOverlays().remove(t);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(t) {
    const e = this.getSize(), n = this.getView(), r = this.frameState_;
    let s = null;
    if (e !== void 0 && Kh(e) && n && n.isDef()) {
      const o = n.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      ), a = n.getState();
      if (s = {
        animate: !1,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutter: null,
        extent: zs(
          a.center,
          a.resolution,
          a.rotation,
          e
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: e,
        tileQueue: this.tileQueue_,
        time: t,
        usedTiles: {},
        viewState: a,
        viewHints: o,
        wantedTiles: {},
        mapId: Y(this),
        renderTargets: {}
      }, a.nextCenter && a.nextResolution) {
        const l = isNaN(a.nextRotation) ? a.rotation : a.nextRotation;
        s.nextExtent = zs(
          a.nextCenter,
          a.nextResolution,
          l,
          e
        );
      }
    }
    this.frameState_ = s, this.renderer_.renderFrame(s), s && (s.animate && this.render(), Array.prototype.push.apply(
      this.postRenderFunctions_,
      s.postRenderFunctions
    ), r && (!this.previousExtent_ || !Qi(this.previousExtent_) && !Hi(s.extent, this.previousExtent_)) && (this.dispatchEvent(
      new ir(Je.MOVESTART, this, r)
    ), this.previousExtent_ = Ur(this.previousExtent_)), this.previousExtent_ && !s.viewHints[mt.ANIMATING] && !s.viewHints[mt.INTERACTING] && !Hi(s.extent, this.previousExtent_) && (this.dispatchEvent(
      new ir(Je.MOVEEND, this, s)
    ), M1(s.extent, this.previousExtent_))), this.dispatchEvent(new ir(Je.POSTRENDER, this, s)), this.renderComplete_ = (this.hasListener(Je.LOADSTART) || this.hasListener(Je.LOADEND) || this.hasListener(Re.RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady(), this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
      this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
    }, 0));
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(t) {
    const e = this.getLayerGroup();
    e && this.handleLayerRemove_(new Ai("removelayer", e)), this.set(Et.LAYERGROUP, t);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(t) {
    this.set(Et.SIZE, t);
  }
  /**
   * Set the target element to render this map into.
   * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
   *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
   *  `tabindex` atribute must be set on the custom element's host element.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(t) {
    this.set(Et.TARGET, t);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>|null} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(t) {
    if (!t || t instanceof Se) {
      this.set(Et.VIEW, t);
      return;
    }
    this.set(Et.VIEW, new Se());
    const e = this;
    t.then(function(n) {
      e.setView(new Se(n));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const t = this.getTargetElement();
    let e;
    if (t) {
      let r, s;
      if (Di(t))
        r = t.width, s = t.height;
      else {
        const o = getComputedStyle(t);
        r = t.offsetWidth - parseFloat(o.borderLeftWidth) - parseFloat(o.paddingLeft) - parseFloat(o.paddingRight) - parseFloat(o.borderRightWidth), s = t.offsetHeight - parseFloat(o.borderTopWidth) - parseFloat(o.paddingTop) - parseFloat(o.paddingBottom) - parseFloat(o.borderBottomWidth);
      }
      !isNaN(r) && !isNaN(s) && (e = [Math.max(0, r), Math.max(0, s)], !Kh(e) && (t.offsetWidth || t.offsetHeight || t.getClientRects().length) && O1(
        "No map visible because the map container's width or height are 0."
      ));
    }
    const n = this.getSize();
    e && (!n || !Ci(e, n)) && (this.setSize(e), this.updateViewportSize_(e));
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(t) {
    const e = this.getView();
    e && e.setViewportSize(t);
  }
};
function M4(i) {
  let t = null;
  i.keyboardEventTarget !== void 0 && (t = typeof i.keyboardEventTarget == "string" ? document.getElementById(i.keyboardEventTarget) : i.keyboardEventTarget);
  const e = {}, n = i.layers && typeof /** @type {?} */
  i.layers.getLayers == "function" ? (
    /** @type {LayerGroup} */
    i.layers
  ) : new vi({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      i.layers
    )
  });
  e[Et.LAYERGROUP] = n, e[Et.TARGET] = i.target, e[Et.VIEW] = i.view instanceof Se ? i.view : new Se();
  let r;
  i.controls !== void 0 && (Array.isArray(i.controls) ? r = new Dt(i.controls.slice()) : (at(
    typeof /** @type {?} */
    i.controls.getArray == "function",
    "Expected `controls` to be an array or an `ol/Collection.js`"
  ), r = i.controls));
  let s;
  i.interactions !== void 0 && (Array.isArray(i.interactions) ? s = new Dt(i.interactions.slice()) : (at(
    typeof /** @type {?} */
    i.interactions.getArray == "function",
    "Expected `interactions` to be an array or an `ol/Collection.js`"
  ), s = i.interactions));
  let o;
  return i.overlays !== void 0 ? Array.isArray(i.overlays) ? o = new Dt(i.overlays.slice()) : (at(
    typeof /** @type {?} */
    i.overlays.getArray == "function",
    "Expected `overlays` to be an array or an `ol/Collection.js`"
  ), o = i.overlays) : o = new Dt(), {
    controls: r,
    interactions: s,
    keyboardEventTarget: t,
    overlays: o,
    values: e
  };
}
const T4 = ':root,:host{--ol-background-color: white;--ol-accent-background-color: #F5F5F5;--ol-subtle-background-color: rgba(128, 128, 128, .25);--ol-partial-background-color: rgba(255, 255, 255, .75);--ol-foreground-color: #333333;--ol-subtle-foreground-color: #666666;--ol-brand-color: #00AAFF}.ol-box{box-sizing:border-box;border-radius:2px;border:1.5px solid var(--ol-background-color);background-color:var(--ol-partial-background-color)}.ol-mouse-position{top:8px;right:8px;position:absolute}.ol-scale-line{background:var(--ol-partial-background-color);border-radius:4px;bottom:8px;left:8px;padding:2px;position:absolute}.ol-scale-line-inner{border:1px solid var(--ol-subtle-foreground-color);border-top:none;color:var(--ol-foreground-color);font-size:10px;text-align:center;margin:1px;will-change:contents,width;transition:all .25s}.ol-scale-bar{position:absolute;bottom:8px;left:8px}.ol-scale-bar-inner{display:flex}.ol-scale-step-marker{width:1px;height:15px;background-color:var(--ol-foreground-color);float:right;z-index:10}.ol-scale-step-text{position:absolute;bottom:-5px;font-size:10px;z-index:11;color:var(--ol-foreground-color);text-shadow:-1.5px 0 var(--ol-partial-background-color),0 1.5px var(--ol-partial-background-color),1.5px 0 var(--ol-partial-background-color),0 -1.5px var(--ol-partial-background-color)}.ol-scale-text{position:absolute;font-size:12px;text-align:center;bottom:25px;color:var(--ol-foreground-color);text-shadow:-1.5px 0 var(--ol-partial-background-color),0 1.5px var(--ol-partial-background-color),1.5px 0 var(--ol-partial-background-color),0 -1.5px var(--ol-partial-background-color)}.ol-scale-singlebar{position:relative;height:10px;z-index:9;box-sizing:border-box;border:1px solid var(--ol-foreground-color)}.ol-scale-singlebar-even{background-color:var(--ol-subtle-foreground-color)}.ol-scale-singlebar-odd{background-color:var(--ol-background-color)}.ol-unsupported{display:none}.ol-viewport,.ol-unselectable{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.ol-viewport canvas{all:unset;overflow:hidden}.ol-viewport{touch-action:pan-x pan-y}.ol-selectable{-webkit-touch-callout:default;-webkit-user-select:text;-moz-user-select:text;user-select:text}.ol-grabbing{cursor:-webkit-grabbing;cursor:-moz-grabbing;cursor:grabbing}.ol-grab{cursor:move;cursor:-webkit-grab;cursor:-moz-grab;cursor:grab}.ol-control{position:absolute;background-color:var(--ol-subtle-background-color);border-radius:4px}.ol-zoom{top:.5em;left:.5em}.ol-rotate{top:.5em;right:.5em;transition:opacity .25s linear,visibility 0s linear}.ol-rotate.ol-hidden{opacity:0;visibility:hidden;transition:opacity .25s linear,visibility 0s linear .25s}.ol-zoom-extent{top:4.643em;left:.5em}.ol-full-screen{right:.5em;top:.5em}.ol-control button{display:block;margin:1px;padding:0;color:var(--ol-subtle-foreground-color);font-weight:700;text-decoration:none;font-size:inherit;text-align:center;height:1.375em;width:1.375em;line-height:.4em;background-color:var(--ol-background-color);border:none;border-radius:2px}.ol-control button::-moz-focus-inner{border:none;padding:0}.ol-zoom-extent button{line-height:1.4em}.ol-compass{display:block;font-weight:400;will-change:transform}.ol-touch .ol-control button{font-size:1.5em}.ol-touch .ol-zoom-extent{top:5.5em}.ol-control button:hover,.ol-control button:focus{text-decoration:none;outline:1px solid var(--ol-subtle-foreground-color);color:var(--ol-foreground-color)}.ol-zoom .ol-zoom-in{border-radius:2px 2px 0 0}.ol-zoom .ol-zoom-out{border-radius:0 0 2px 2px}.ol-attribution{text-align:right;bottom:.5em;right:.5em;max-width:calc(100% - 1.3em);display:flex;flex-flow:row-reverse;align-items:center}.ol-attribution a{color:var(--ol-subtle-foreground-color);text-decoration:none}.ol-attribution ul{margin:0;padding:1px .5em;color:var(--ol-foreground-color);text-shadow:0 0 2px var(--ol-background-color);font-size:12px}.ol-attribution li{display:inline;list-style:none}.ol-attribution li:not(:last-child):after{content:" "}.ol-attribution img{max-height:2em;max-width:inherit;vertical-align:middle}.ol-attribution button{flex-shrink:0}.ol-attribution.ol-collapsed ul{display:none}.ol-attribution:not(.ol-collapsed){background:var(--ol-partial-background-color)}.ol-attribution.ol-uncollapsible{bottom:0;right:0;border-radius:4px 0 0}.ol-attribution.ol-uncollapsible img{margin-top:-.2em;max-height:1.6em}.ol-attribution.ol-uncollapsible button{display:none}.ol-zoomslider{top:4.5em;left:.5em;height:200px}.ol-zoomslider button{position:relative;height:10px}.ol-touch .ol-zoomslider{top:5.5em}.ol-overviewmap{left:.5em;bottom:.5em}.ol-overviewmap.ol-uncollapsible{bottom:0;left:0;border-radius:0 4px 0 0}.ol-overviewmap .ol-overviewmap-map,.ol-overviewmap button{display:block}.ol-overviewmap .ol-overviewmap-map{border:1px solid var(--ol-subtle-foreground-color);height:150px;width:150px}.ol-overviewmap:not(.ol-collapsed) button{bottom:0;left:0;position:absolute}.ol-overviewmap.ol-collapsed .ol-overviewmap-map,.ol-overviewmap.ol-uncollapsible button{display:none}.ol-overviewmap:not(.ol-collapsed){background:var(--ol-subtle-background-color)}.ol-overviewmap-box{border:1.5px dotted var(--ol-subtle-foreground-color)}.ol-overviewmap .ol-overviewmap-box:hover{cursor:move}.ol-overviewmap .ol-viewport:hover{cursor:pointer}';
class Lt extends De {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(t) {
    if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), t)
      if (typeof /** @type {?} */
      t.getSimplifiedGeometry == "function") {
        const e = (
          /** @type {Geometry} */
          t
        );
        this.setGeometry(e);
      } else {
        const e = t;
        this.setProperties(e);
      }
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const t = (
      /** @type {Feature<Geometry>} */
      new Lt(this.hasProperties() ? this.getProperties() : null)
    );
    t.setGeometryName(this.getGeometryName());
    const e = this.getGeometry();
    e && t.setGeometry(
      /** @type {Geometry} */
      e.clone()
    );
    const n = this.getStyle();
    return n && t.setStyle(n), t;
  }
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleGeometryChanged_() {
    this.geometryChangeKey_ && (dt(this.geometryChangeKey_), this.geometryChangeKey_ = null);
    const t = this.getGeometry();
    t && (this.geometryChangeKey_ = Q(
      t,
      V.CHANGE,
      this.handleGeometryChange_,
      this
    )), this.changed();
  }
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(t) {
    this.set(this.geometryName_, t);
  }
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(t) {
    this.style_ = t, this.styleFunction_ = t ? R4(t) : void 0, this.changed();
  }
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(t) {
    this.id_ = t, this.changed();
  }
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(t) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = t, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
  }
}
function R4(i) {
  if (typeof i == "function")
    return i;
  let t;
  return Array.isArray(i) ? t = i : (at(
    typeof /** @type {?} */
    i.getZIndex == "function",
    "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
  ), t = [
    /** @type {import("./style/Style.js").default} */
    i
  ]), function() {
    return t;
  };
}
class t2 extends en {
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius in units of the projection.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e, n) {
    super(), n !== void 0 && e === void 0 ? this.setFlatCoordinates(n, t) : (e = e || 0, this.setCenterAndRadius(t, e, n));
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   * @override
   */
  clone() {
    const t = new t2(
      this.flatCoordinates.slice(),
      void 0,
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(t, e, n, r) {
    const s = this.flatCoordinates, o = t - s[0], a = e - s[1], l = o * o + a * a;
    if (l < r) {
      if (l === 0)
        for (let h = 0; h < this.stride; ++h)
          n[h] = s[h];
      else {
        const h = this.getRadius() / Math.sqrt(l);
        n[0] = s[0] + h * o, n[1] = s[1] + h * a;
        for (let c = 2; c < this.stride; ++c)
          n[c] = s[c];
      }
      return n.length = this.stride, l;
    }
    return r;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(t, e) {
    const n = this.flatCoordinates, r = t - n[0], s = e - n[1];
    return r * r + s * s <= this.getRadiusSquared_();
  }
  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */
  getCenter() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(t) {
    const e = this.flatCoordinates, n = e[this.stride] - e[0];
    return ii(
      e[0] - n,
      e[1] - n,
      e[0] + n,
      e[1] + n,
      t
    );
  }
  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return Math.sqrt(this.getRadiusSquared_());
  }
  /**
   * @private
   * @return {number} Radius squared.
   */
  getRadiusSquared_() {
    const t = this.flatCoordinates[this.stride] - this.flatCoordinates[0], e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return t * t + e * e;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Circle";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(t) {
    const e = this.getExtent();
    if (bt(t, e)) {
      const n = this.getCenter();
      return t[0] <= n[0] && t[2] >= n[0] || t[1] <= n[1] && t[3] >= n[1] ? !0 : rl(t, this.intersectsCoordinate.bind(this));
    }
    return !1;
  }
  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */
  setCenter(t) {
    const e = this.stride, n = this.flatCoordinates[e] - this.flatCoordinates[0], r = t.slice();
    r[e] = r[0] + n;
    for (let s = 1; s < e; ++s)
      r[e + s] = t[s];
    this.setFlatCoordinates(this.layout, r), this.changed();
  }
  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCenterAndRadius(t, e, n) {
    this.setLayout(n, t, 0), this.flatCoordinates || (this.flatCoordinates = []);
    const r = this.flatCoordinates;
    let s = Z1(r, 0, t, this.stride);
    r[s++] = r[0] + e;
    for (let o = 1, a = this.stride; o < a; ++o)
      r[s++] = r[o];
    r.length = s, this.changed();
  }
  /**
   * @override
   */
  getCoordinates() {
    return null;
  }
  /**
   * @override
   */
  setCoordinates(t, e) {
  }
  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  setRadius(t) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t, this.changed();
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   * @override
   */
  rotate(t, e) {
    const n = this.getCenter(), r = this.getStride();
    this.setCenter(
      gl(n, 0, n.length, r, t, e, n)
    ), this.changed();
  }
}
t2.prototype.transform;
function Co(i, t, e, n, r, s, o) {
  let a, l;
  const h = (e - t) / n;
  if (h === 1)
    a = t;
  else if (h === 2)
    a = t, l = r;
  else if (h !== 0) {
    let c = i[t], d = i[t + 1], u = 0;
    const f = [0];
    for (let m = t + n; m < e; m += n) {
      const _ = i[m], y = i[m + 1];
      u += Math.sqrt((_ - c) * (_ - c) + (y - d) * (y - d)), f.push(u), c = _, d = y;
    }
    const g = r * u, p = rf(f, g);
    p < 0 ? (l = (g - f[-p - 2]) / (f[-p - 1] - f[-p - 2]), a = t + (-p - 2) * n) : a = t + p * n;
  }
  o = o > 1 ? o : 2, s = s || new Array(o);
  for (let c = 0; c < o; ++c)
    s[c] = a === void 0 ? NaN : l === void 0 ? i[a + c] : pe(i[a + c], i[a + n + c], l);
  return s;
}
function Ra(i, t, e, n, r, s) {
  if (e == t)
    return null;
  let o;
  if (r < i[t + n - 1])
    return s ? (o = i.slice(t, t + n), o[n - 1] = r, o) : null;
  if (i[e - 1] < r)
    return s ? (o = i.slice(e - n, e), o[n - 1] = r, o) : null;
  if (r == i[t + n - 1])
    return i.slice(t, t + n);
  let a = t / n, l = e / n;
  for (; a < l; ) {
    const u = a + l >> 1;
    r < i[(u + 1) * n - 1] ? l = u : a = u + 1;
  }
  const h = i[a * n - 1];
  if (r == h)
    return i.slice((a - 1) * n, (a - 1) * n + n);
  const c = i[(a + 1) * n - 1], d = (r - h) / (c - h);
  o = [];
  for (let u = 0; u < n - 1; ++u)
    o.push(
      pe(
        i[(a - 1) * n + u],
        i[a * n + u],
        d
      )
    );
  return o.push(r), o;
}
function P4(i, t, e, n, r, s, o) {
  if (o)
    return Ra(
      i,
      t,
      e[e.length - 1],
      n,
      r,
      s
    );
  let a;
  if (r < i[n - 1])
    return s ? (a = i.slice(0, n), a[n - 1] = r, a) : null;
  if (i[i.length - 1] < r)
    return s ? (a = i.slice(i.length - n), a[n - 1] = r, a) : null;
  for (let l = 0, h = e.length; l < h; ++l) {
    const c = e[l];
    if (t != c) {
      if (r < i[t + n - 1])
        return null;
      if (r <= i[c - 1])
        return Ra(
          i,
          t,
          c,
          n,
          r,
          !1
        );
      t = c;
    }
  }
  return null;
}
function Dl(i, t, e, n) {
  let r = i[t], s = i[t + 1], o = 0;
  for (let a = t + n; a < e; a += n) {
    const l = i[a], h = i[a + 1];
    o += Math.sqrt((l - r) * (l - r) + (h - s) * (h - s)), r = l, s = h;
  }
  return o;
}
class Kt extends en {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e) {
    super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, e !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      e
    );
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(t) {
    ot(this.flatCoordinates, t), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   * @override
   */
  clone() {
    const t = new Kt(
      this.flatCoordinates.slice(),
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(t, e, n, r) {
    return r < Gn(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      ml(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), _l(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !1,
      t,
      e,
      n,
      r
    ));
  }
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(t) {
    return Q1(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(t, e) {
    return this.layout != "XYM" && this.layout != "XYZM" ? null : (e = e !== void 0 ? e : !1, Ra(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      e
    ));
  }
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return Ni(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(t, e) {
    return Co(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      e,
      this.stride
    );
  }
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return Dl(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(
      0.5,
      this.flatMidpoint_ ?? void 0
    ), this.flatMidpointRevision_ = this.getRevision()), /** @type {Array<number>} */
    this.flatMidpoint_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(t) {
    const e = [];
    return e.length = Zo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      e,
      0
    ), new Kt(e, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "LineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(t) {
    return Ho(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      this.getExtent()
    );
  }
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Xo(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
class oi extends en {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(t, e, n) {
    if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(t[0]))
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        t,
        e
      );
    else if (e !== void 0 && n)
      this.setFlatCoordinates(
        e,
        /** @type {Array<number>} */
        t
      ), this.ends_ = n;
    else {
      const r = (
        /** @type {Array<LineString>} */
        t
      ), s = [], o = [];
      for (let l = 0, h = r.length; l < h; ++l) {
        const c = r[l];
        ot(s, c.getFlatCoordinates()), o.push(s.length);
      }
      const a = r.length === 0 ? this.getLayout() : r[0].getLayout();
      this.setFlatCoordinates(a, s), this.ends_ = o;
    }
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(t) {
    ot(this.flatCoordinates, t.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   * @override
   */
  clone() {
    const t = new oi(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(t, e, n, r) {
    return r < Gn(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      pl(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), yl(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !1,
      t,
      e,
      n,
      r
    ));
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(t, e, n) {
    return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (e = e !== void 0 ? e : !1, n = n !== void 0 ? n : !1, P4(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t,
      e,
      n
    ));
  }
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return js(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(t) {
    return t < 0 || this.ends_.length <= t ? null : new Kt(
      this.flatCoordinates.slice(
        t === 0 ? 0 : this.ends_[t - 1],
        this.ends_[t]
      ),
      this.layout
    );
  }
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const t = this.flatCoordinates, e = this.ends_, n = this.layout, r = [];
    let s = 0;
    for (let o = 0, a = e.length; o < a; ++o) {
      const l = e[o], h = new Kt(
        t.slice(s, l),
        n
      );
      r.push(h), s = l;
    }
    return r;
  }
  /**
   * Return the sum of all line string lengths
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    const t = this.ends_;
    let e = 0, n = 0;
    for (let r = 0, s = t.length; r < s; ++r)
      n += Dl(
        this.flatCoordinates,
        e,
        t[r],
        this.stride
      ), e = t[r];
    return n;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const t = [], e = this.flatCoordinates;
    let n = 0;
    const r = this.ends_, s = this.stride;
    for (let o = 0, a = r.length; o < a; ++o) {
      const l = r[o], h = Co(
        e,
        n,
        l,
        s,
        0.5
      );
      ot(t, h), n = l;
    }
    return t;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(t) {
    const e = [], n = [];
    return e.length = K1(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t,
      e,
      0,
      n
    ), new oi(e, "XY", n);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "MultiLineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(t) {
    return Tg(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const n = o0(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed();
  }
}
class nn extends en {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, e) {
    super(), e && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      e
    );
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(t) {
    ot(this.flatCoordinates, t.getFlatCoordinates()), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   * @override
   */
  clone() {
    const t = new nn(
      this.flatCoordinates.slice(),
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(t, e, n, r) {
    if (r < Gn(this.getExtent(), t, e))
      return r;
    const s = this.flatCoordinates, o = this.stride;
    for (let a = 0, l = s.length; a < l; a += o) {
      const h = mi(
        t,
        e,
        s[a],
        s[a + 1]
      );
      if (h < r) {
        r = h;
        for (let c = 0; c < o; ++c)
          n[c] = s[a + c];
        n.length = o;
      }
    }
    return r;
  }
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return Ni(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(t) {
    const e = this.flatCoordinates.length / this.stride;
    return t < 0 || e <= t ? null : new de(
      this.flatCoordinates.slice(
        t * this.stride,
        (t + 1) * this.stride
      ),
      this.layout
    );
  }
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const t = this.flatCoordinates, e = this.layout, n = this.stride, r = [];
    for (let s = 0, o = t.length; s < o; s += n) {
      const a = new de(t.slice(s, s + n), e);
      r.push(a);
    }
    return r;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "MultiPoint";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(t) {
    const e = this.flatCoordinates, n = this.stride;
    for (let r = 0, s = e.length; r < s; r += n) {
      const o = e[r], a = e[r + 1];
      if (il(t, o, a))
        return !0;
    }
    return !1;
  }
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Xo(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
function jd(i, t, e, n) {
  const r = [];
  let s = ne();
  for (let o = 0, a = e.length; o < a; ++o) {
    const l = e[o];
    s = nl(
      i,
      t,
      l[0],
      n
    ), r.push((s[0] + s[2]) / 2, (s[1] + s[3]) / 2), t = l[l.length - 1];
  }
  return r;
}
class xi extends en {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(t, e, n) {
    if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !n && !Array.isArray(t[0])) {
      const r = (
        /** @type {Array<Polygon>} */
        t
      ), s = [], o = [];
      for (let a = 0, l = r.length; a < l; ++a) {
        const h = r[a], c = s.length, d = h.getEnds();
        for (let u = 0, f = d.length; u < f; ++u)
          d[u] += c;
        ot(s, h.getFlatCoordinates()), o.push(d);
      }
      e = r.length === 0 ? this.getLayout() : r[0].getLayout(), t = s, n = o;
    }
    e !== void 0 && n ? (this.setFlatCoordinates(
      e,
      /** @type {Array<number>} */
      t
    ), this.endss_ = n) : this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      t,
      e
    );
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(t) {
    let e;
    if (!this.flatCoordinates)
      this.flatCoordinates = t.getFlatCoordinates().slice(), e = t.getEnds().slice(), this.endss_.push();
    else {
      const n = this.flatCoordinates.length;
      ot(this.flatCoordinates, t.getFlatCoordinates()), e = t.getEnds().slice();
      for (let r = 0, s = e.length; r < s; ++r)
        e[r] += n;
    }
    this.endss_.push(e), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   * @override
   */
  clone() {
    const t = this.endss_.length, e = new Array(t);
    for (let r = 0; r < t; ++r)
      e[r] = this.endss_[r].slice();
    const n = new xi(
      this.flatCoordinates.slice(),
      this.layout,
      e
    );
    return n.applyProperties(this), n;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(t, e, n, r) {
    return r < Gn(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Cg(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), bg(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      e,
      n,
      r
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(t, e) {
    return Mg(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      t,
      e
    );
  }
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return xg(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates(t) {
    let e;
    return t !== void 0 ? (e = this.getOrientedFlatCoordinates().slice(), va(
      e,
      0,
      this.endss_,
      this.stride,
      t
    )) : e = this.flatCoordinates, ya(
      e,
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const t = jd(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = J1(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        t
      ), this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.flatInteriorPoints_
    );
  }
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new nn(this.getFlatInteriorPoints().slice(), "XYM");
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const t = this.flatCoordinates;
      id(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = va(
        this.orientedFlatCoordinates_,
        0,
        this.endss_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(t) {
    const e = [], n = [];
    return e.length = Eg(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(t),
      e,
      0,
      n
    ), new xi(e, "XY", n);
  }
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(t) {
    if (t < 0 || this.endss_.length <= t)
      return null;
    let e;
    if (t === 0)
      e = 0;
    else {
      const s = this.endss_[t - 1];
      e = s[s.length - 1];
    }
    const n = this.endss_[t].slice(), r = n[n.length - 1];
    if (e !== 0)
      for (let s = 0, o = n.length; s < o; ++s)
        n[s] -= e;
    return new jt(
      this.flatCoordinates.slice(e, r),
      this.layout,
      n
    );
  }
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const t = this.layout, e = this.flatCoordinates, n = this.endss_, r = [];
    let s = 0;
    for (let o = 0, a = n.length; o < a; ++o) {
      const l = n[o].slice(), h = l[l.length - 1];
      if (s !== 0)
        for (let d = 0, u = l.length; d < u; ++d)
          l[d] -= s;
      const c = new jt(
        e.slice(s, h),
        t,
        l
      );
      r.push(c), s = h;
    }
    return r;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "MultiPolygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(t) {
    return Rg(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(t, e) {
    this.setLayout(e, t, 3), this.flatCoordinates || (this.flatCoordinates = []);
    const n = H1(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.endss_
    );
    if (n.length === 0)
      this.flatCoordinates.length = 0;
    else {
      const r = n[n.length - 1];
      this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1];
    }
    this.changed();
  }
}
class Ud {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(t, e, n, r, s) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(t) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(t) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(t, e, n) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} [index] Render order index.
   */
  drawFeature(t, e, n) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawGeometryCollection(t, e, n) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(t, e, n) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(t, e, n) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(t, e, n) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(t, e, n) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(t, e, n) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(t, e, n) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(t, e, n) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, e) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(t, e) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(t, e) {
  }
}
const $ = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, L0 = [$.FILL], zi = [$.STROKE], vn = [$.BEGIN_PATH], hc = [$.CLOSE_PATH];
class u0 extends Ud {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, n, r) {
    super(), this.tolerance = t, this.maxExtent = e, this.pixelRatio = r, this.maxLineWidth = 0, this.resolution = n, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(t) {
    const e = this.pixelRatio;
    return e == 1 ? t : t.map(function(n) {
      return n * e;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(t, e) {
    const n = this.getBufferedMaxExtent(), r = this.tmpCoordinate_, s = this.coordinates;
    let o = s.length;
    for (let a = 0, l = t.length; a < l; a += e)
      r[0] = t[a], r[1] = t[a + 1], Rn(n, r) && (s[o++] = r[0], s[o++] = r[1]);
    return o;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(t, e, n, r, s, o) {
    const a = this.coordinates;
    let l = a.length;
    const h = this.getBufferedMaxExtent();
    o && (e += r);
    let c = t[e], d = t[e + 1];
    const u = this.tmpCoordinate_;
    let f = !0, g, p, m;
    for (g = e + r; g < n; g += r)
      u[0] = t[g], u[1] = t[g + 1], m = da(h, u), m !== p ? (f && (a[l++] = c, a[l++] = d, f = !1), a[l++] = u[0], a[l++] = u[1]) : m === Ot.INTERSECTING ? (a[l++] = u[0], a[l++] = u[1], f = !1) : f = !0, c = u[0], d = u[1], p = m;
    return (s && f || g === e + r) && (a[l++] = c, a[l++] = d), l;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(t, e, n, r, s) {
    for (let o = 0, a = n.length; o < a; ++o) {
      const l = n[o], h = this.appendFlatLineCoordinates(
        t,
        e,
        l,
        r,
        !1,
        !1
      );
      s.push(h), e = l;
    }
    return e;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   * @override
   */
  drawCustom(t, e, n, r, s) {
    this.beginGeometry(t, e, s);
    const o = t.getType(), a = t.getStride(), l = this.coordinates.length;
    let h, c, d, u, f;
    switch (o) {
      case "MultiPolygon":
        h = /** @type {import("../../geom/MultiPolygon.js").default} */
        t.getOrientedFlatCoordinates(), u = [];
        const g = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t.getEndss()
        );
        f = 0;
        for (let p = 0, m = g.length; p < m; ++p) {
          const _ = [];
          f = this.drawCustomCoordinates_(
            h,
            f,
            g[p],
            a,
            _
          ), u.push(_);
        }
        this.instructions.push([
          $.CUSTOM,
          l,
          u,
          t,
          n,
          ya,
          s
        ]), this.hitDetectionInstructions.push([
          $.CUSTOM,
          l,
          u,
          t,
          r || n,
          ya,
          s
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        d = [], h = o == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          t.getOrientedFlatCoordinates()
        ) : t.getFlatCoordinates(), f = this.drawCustomCoordinates_(
          h,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          t.getEnds(),
          a,
          d
        ), this.instructions.push([
          $.CUSTOM,
          l,
          d,
          t,
          n,
          js,
          s
        ]), this.hitDetectionInstructions.push([
          $.CUSTOM,
          l,
          d,
          t,
          r || n,
          js,
          s
        ]);
        break;
      case "LineString":
      case "Circle":
        h = t.getFlatCoordinates(), c = this.appendFlatLineCoordinates(
          h,
          0,
          h.length,
          a,
          !1,
          !1
        ), this.instructions.push([
          $.CUSTOM,
          l,
          c,
          t,
          n,
          Ni,
          s
        ]), this.hitDetectionInstructions.push([
          $.CUSTOM,
          l,
          c,
          t,
          r || n,
          Ni,
          s
        ]);
        break;
      case "MultiPoint":
        h = t.getFlatCoordinates(), c = this.appendFlatPointCoordinates(h, a), c > l && (this.instructions.push([
          $.CUSTOM,
          l,
          c,
          t,
          n,
          Ni,
          s
        ]), this.hitDetectionInstructions.push([
          $.CUSTOM,
          l,
          c,
          t,
          r || n,
          Ni,
          s
        ]));
        break;
      case "Point":
        h = t.getFlatCoordinates(), this.coordinates.push(h[0], h[1]), c = this.coordinates.length, this.instructions.push([
          $.CUSTOM,
          l,
          c,
          t,
          n,
          void 0,
          s
        ]), this.hitDetectionInstructions.push([
          $.CUSTOM,
          l,
          c,
          t,
          r || n,
          void 0,
          s
        ]);
        break;
    }
    this.endGeometry(e);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} index Render order index
   */
  beginGeometry(t, e, n) {
    this.beginGeometryInstruction1_ = [
      $.BEGIN_GEOMETRY,
      e,
      0,
      t,
      n
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      $.BEGIN_GEOMETRY,
      e,
      0,
      t,
      n
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const t = this.hitDetectionInstructions;
    t.reverse();
    let e;
    const n = t.length;
    let r, s, o = -1;
    for (e = 0; e < n; ++e)
      r = t[e], s = /** @type {import("./Instruction.js").default} */
      r[0], s == $.END_GEOMETRY ? o = e : s == $.BEGIN_GEOMETRY && (r[2] = e, of(this.hitDetectionInstructions, o, e), o = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import('../canvas.js').FillStrokeState} [state] State.
   * @return {import('../canvas.js').FillStrokeState} State.
   */
  fillStyleToState(t, e = (
    /** @type {import('../canvas.js').FillStrokeState} */
    {}
  )) {
    if (t) {
      const n = t.getColor();
      e.fillPatternScale = n && typeof n == "object" && "src" in n ? this.pixelRatio : 1, e.fillStyle = ti(
        n || ae
      );
    } else
      e.fillStyle = void 0;
    return e;
  }
  /**
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {import("../canvas.js").FillStrokeState} State.
   */
  strokeStyleToState(t, e = (
    /** @type {import('../canvas.js').FillStrokeState} */
    {}
  )) {
    if (t) {
      const n = t.getColor();
      e.strokeStyle = ti(
        n || Vs
      );
      const r = t.getLineCap();
      e.lineCap = r !== void 0 ? r : Fr;
      const s = t.getLineDash();
      e.lineDash = s ? s.slice() : pi;
      const o = t.getLineDashOffset();
      e.lineDashOffset = o || _i;
      const a = t.getLineJoin();
      e.lineJoin = a !== void 0 ? a : Or;
      const l = t.getWidth();
      e.lineWidth = l !== void 0 ? l : Ws;
      const h = t.getMiterLimit();
      e.miterLimit = h !== void 0 ? h : Bs, e.lineWidth > this.maxLineWidth && (this.maxLineWidth = e.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      e.strokeStyle = void 0, e.lineCap = void 0, e.lineDash = null, e.lineDashOffset = void 0, e.lineJoin = void 0, e.lineWidth = void 0, e.miterLimit = void 0;
    return e;
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @override
   */
  setFillStrokeStyle(t, e) {
    const n = this.state;
    this.fillStyleToState(t, n), this.strokeStyleToState(e, n);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(t) {
    const e = t.fillStyle, n = [$.SET_FILL_STYLE, e];
    return typeof e != "string" && n.push(t.fillPatternScale), n;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(t) {
    this.instructions.push(this.createStroke(t));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(t) {
    return [
      $.SET_STROKE_STYLE,
      t.strokeStyle,
      t.lineWidth * this.pixelRatio,
      t.lineCap,
      t.lineJoin,
      t.miterLimit,
      t.lineDash ? this.applyPixelRatio(t.lineDash) : null,
      t.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(t, e) {
    const n = t.fillStyle;
    (typeof n != "string" || t.currentFillStyle != n) && (this.instructions.push(e.call(this, t)), t.currentFillStyle = n);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(t, e) {
    const n = t.strokeStyle, r = t.lineCap, s = t.lineDash, o = t.lineDashOffset, a = t.lineJoin, l = t.lineWidth, h = t.miterLimit;
    (t.currentStrokeStyle != n || t.currentLineCap != r || s != t.currentLineDash && !Ci(t.currentLineDash, s) || t.currentLineDashOffset != o || t.currentLineJoin != a || t.currentLineWidth != l || t.currentMiterLimit != h) && (e.call(this, t), t.currentStrokeStyle = n, t.currentLineCap = r, t.currentLineDash = s, t.currentLineDashOffset = o, t.currentLineJoin = a, t.currentLineWidth = l, t.currentMiterLimit = h);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(t) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const e = [$.END_GEOMETRY, t];
    this.instructions.push(e), this.hitDetectionInstructions.push(e);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = M1(this.maxExtent), this.maxLineWidth > 0)) {
      const t = this.resolution * (this.maxLineWidth + 1) / 2;
      Ie(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
class I4 extends u0 {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, n, r) {
    super(t, e, n, r), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawPoint(t, e, n) {
    if (!this.image_ || this.maxExtent && !Rn(this.maxExtent, t.getFlatCoordinates()))
      return;
    this.beginGeometry(t, e, n);
    const r = t.getFlatCoordinates(), s = t.getStride(), o = this.coordinates.length, a = this.appendFlatPointCoordinates(r, s);
    this.instructions.push([
      $.DRAW_IMAGE,
      o,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      $.DRAW_IMAGE,
      o,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(e);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawMultiPoint(t, e, n) {
    if (!this.image_)
      return;
    this.beginGeometry(t, e, n);
    const r = t.getFlatCoordinates(), s = [];
    for (let l = 0, h = r.length; l < h; l += t.getStride())
      (!this.maxExtent || Rn(this.maxExtent, r.slice(l, l + 2))) && s.push(
        r[l],
        r[l + 1]
      );
    const o = this.coordinates.length, a = this.appendFlatPointCoordinates(s, 2);
    this.instructions.push([
      $.DRAW_IMAGE,
      o,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      $.DRAW_IMAGE,
      o,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(e);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   * @override
   */
  setImageStyle(t, e) {
    const n = t.getAnchor(), r = t.getSize(), s = t.getOrigin();
    this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio), this.anchorX_ = n[0], this.anchorY_ = n[1], this.hitDetectionImage_ = t.getHitDetectionImage(), this.image_ = t.getImage(this.pixelRatio), this.height_ = r[1], this.opacity_ = t.getOpacity(), this.originX_ = s[0], this.originY_ = s[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScaleArray(), this.width_ = r[0], this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
  }
}
class k4 extends u0 {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, n, r) {
    super(t, e, n, r);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(t, e, n, r) {
    const s = this.coordinates.length, o = this.appendFlatLineCoordinates(
      t,
      e,
      n,
      r,
      !1,
      !1
    ), a = [
      $.MOVE_TO_LINE_TO,
      s,
      o
    ];
    return this.instructions.push(a), this.hitDetectionInstructions.push(a), n;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawLineString(t, e, n) {
    const r = this.state, s = r.strokeStyle, o = r.lineWidth;
    if (s === void 0 || o === void 0)
      return;
    this.updateStrokeStyle(r, this.applyStroke), this.beginGeometry(t, e, n), this.hitDetectionInstructions.push(
      [
        $.SET_STROKE_STYLE,
        r.strokeStyle,
        r.lineWidth,
        r.lineCap,
        r.lineJoin,
        r.miterLimit,
        pi,
        _i
      ],
      vn
    );
    const a = t.getFlatCoordinates(), l = t.getStride();
    this.drawFlatCoordinates_(
      a,
      0,
      a.length,
      l
    ), this.hitDetectionInstructions.push(zi), this.endGeometry(e);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawMultiLineString(t, e, n) {
    const r = this.state, s = r.strokeStyle, o = r.lineWidth;
    if (s === void 0 || o === void 0)
      return;
    this.updateStrokeStyle(r, this.applyStroke), this.beginGeometry(t, e, n), this.hitDetectionInstructions.push(
      [
        $.SET_STROKE_STYLE,
        r.strokeStyle,
        r.lineWidth,
        r.lineCap,
        r.lineJoin,
        r.miterLimit,
        pi,
        _i
      ],
      vn
    );
    const a = t.getEnds(), l = t.getFlatCoordinates(), h = t.getStride();
    let c = 0;
    for (let d = 0, u = a.length; d < u; ++d)
      c = this.drawFlatCoordinates_(
        l,
        c,
        /** @type {number} */
        a[d],
        h
      );
    this.hitDetectionInstructions.push(zi), this.endGeometry(e);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    const t = this.state;
    return t.lastStroke != null && t.lastStroke != this.coordinates.length && this.instructions.push(zi), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @override
   */
  applyStroke(t) {
    t.lastStroke != null && t.lastStroke != this.coordinates.length && (this.instructions.push(zi), t.lastStroke = this.coordinates.length), t.lastStroke = 0, super.applyStroke(t), this.instructions.push(vn);
  }
}
class cc extends u0 {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, n, r) {
    super(t, e, n, r);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(t, e, n, r) {
    const s = this.state, o = s.fillStyle !== void 0, a = s.strokeStyle !== void 0, l = n.length;
    this.instructions.push(vn), this.hitDetectionInstructions.push(vn);
    for (let h = 0; h < l; ++h) {
      const c = n[h], d = this.coordinates.length, u = this.appendFlatLineCoordinates(
        t,
        e,
        c,
        r,
        !0,
        !a
      ), f = [
        $.MOVE_TO_LINE_TO,
        d,
        u
      ];
      this.instructions.push(f), this.hitDetectionInstructions.push(f), a && (this.instructions.push(hc), this.hitDetectionInstructions.push(hc)), e = c;
    }
    return o && (this.instructions.push(L0), this.hitDetectionInstructions.push(L0)), a && (this.instructions.push(zi), this.hitDetectionInstructions.push(zi)), e;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawCircle(t, e, n) {
    const r = this.state, s = r.fillStyle, o = r.strokeStyle;
    if (s === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, e, n), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      $.SET_FILL_STYLE,
      ae
    ]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      $.SET_STROKE_STYLE,
      r.strokeStyle,
      r.lineWidth,
      r.lineCap,
      r.lineJoin,
      r.miterLimit,
      pi,
      _i
    ]);
    const a = t.getFlatCoordinates(), l = t.getStride(), h = this.coordinates.length;
    this.appendFlatLineCoordinates(
      a,
      0,
      a.length,
      l,
      !1,
      !1
    );
    const c = [$.CIRCLE, h];
    this.instructions.push(vn, c), this.hitDetectionInstructions.push(vn, c), r.fillStyle !== void 0 && (this.instructions.push(L0), this.hitDetectionInstructions.push(L0)), r.strokeStyle !== void 0 && (this.instructions.push(zi), this.hitDetectionInstructions.push(zi)), this.endGeometry(e);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawPolygon(t, e, n) {
    const r = this.state, s = r.fillStyle, o = r.strokeStyle;
    if (s === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, e, n), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      $.SET_FILL_STYLE,
      ae
    ]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      $.SET_STROKE_STYLE,
      r.strokeStyle,
      r.lineWidth,
      r.lineCap,
      r.lineJoin,
      r.miterLimit,
      pi,
      _i
    ]);
    const a = t.getEnds(), l = t.getOrientedFlatCoordinates(), h = t.getStride();
    this.drawFlatCoordinatess_(
      l,
      0,
      /** @type {Array<number>} */
      a,
      h
    ), this.endGeometry(e);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawMultiPolygon(t, e, n) {
    const r = this.state, s = r.fillStyle, o = r.strokeStyle;
    if (s === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, e, n), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      $.SET_FILL_STYLE,
      ae
    ]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      $.SET_STROKE_STYLE,
      r.strokeStyle,
      r.lineWidth,
      r.lineCap,
      r.lineJoin,
      r.miterLimit,
      pi,
      _i
    ]);
    const a = t.getEndss(), l = t.getOrientedFlatCoordinates(), h = t.getStride();
    let c = 0;
    for (let d = 0, u = a.length; d < u; ++d)
      c = this.drawFlatCoordinatess_(
        l,
        c,
        a[d],
        h
      );
    this.endGeometry(e);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const t = this.tolerance;
    if (t !== 0) {
      const e = this.coordinates;
      for (let n = 0, r = e.length; n < r; ++n)
        e[n] = dn(e[n], t);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const t = this.state;
    this.updateFillStyle(t, this.createFill), this.updateStrokeStyle(t, this.applyStroke);
  }
}
function L4(i, t, e, n, r) {
  const s = [];
  let o = e, a = 0, l = t.slice(e, 2);
  for (; a < i && o + r < n; ) {
    const [h, c] = l.slice(-2), d = t[o + r], u = t[o + r + 1], f = Math.sqrt(
      (d - h) * (d - h) + (u - c) * (u - c)
    );
    if (a += f, a >= i) {
      const g = (i - a + f) / f, p = pe(h, d, g), m = pe(c, u, g);
      l.push(p, m), s.push(l), l = [p, m], a == i && (o += r), a = 0;
    } else if (a < i)
      l.push(
        t[o + r],
        t[o + r + 1]
      ), o += r;
    else {
      const g = f - a, p = pe(h, d, g / f), m = pe(c, u, g / f);
      l.push(p, m), s.push(l), l = [p, m], a = 0, o += r;
    }
  }
  return a > 0 && s.push(l), s;
}
function A4(i, t, e, n, r) {
  let s = e, o = e, a = 0, l = 0, h = e, c, d, u, f, g, p, m, _, y, x;
  for (d = e; d < n; d += r) {
    const v = t[d], C = t[d + 1];
    g !== void 0 && (y = v - g, x = C - p, f = Math.sqrt(y * y + x * x), m !== void 0 && (l += u, c = Math.acos((m * y + _ * x) / (u * f)), c > i && (l > a && (a = l, s = h, o = d), l = 0, h = d - r)), u = f, m = y, _ = x), g = v, p = C;
  }
  return l += f, l > a ? [h, d] : [s, o];
}
const bo = {
  left: 0,
  center: 0.5,
  right: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class F4 extends u0 {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, n, r) {
    super(t, e, n, r), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textKeepUpright_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[ae] = { fillStyle: ae }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    const t = super.finish();
    return t.textStates = this.textStates, t.fillStates = this.fillStates, t.strokeStates = this.strokeStates, t;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawText(t, e, n) {
    const r = this.textFillState_, s = this.textStrokeState_, o = this.textState_;
    if (this.text_ === "" || !o || !r && !s)
      return;
    const a = this.coordinates;
    let l = a.length;
    const h = t.getType();
    let c = null, d = t.getStride();
    if (o.placement === "line" && (h == "LineString" || h == "MultiLineString" || h == "Polygon" || h == "MultiPolygon")) {
      if (!bt(this.maxExtent, t.getExtent()))
        return;
      let u;
      if (c = t.getFlatCoordinates(), h == "LineString")
        u = [c.length];
      else if (h == "MultiLineString")
        u = /** @type {import("../../geom/MultiLineString.js").default} */
        t.getEnds();
      else if (h == "Polygon")
        u = /** @type {import("../../geom/Polygon.js").default} */
        t.getEnds().slice(0, 1);
      else if (h == "MultiPolygon") {
        const m = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t.getEndss()
        );
        u = [];
        for (let _ = 0, y = m.length; _ < y; ++_)
          u.push(m[_][0]);
      }
      this.beginGeometry(t, e, n);
      const f = o.repeat, g = f ? void 0 : o.textAlign;
      let p = 0;
      for (let m = 0, _ = u.length; m < _; ++m) {
        let y;
        f ? y = L4(
          f * this.resolution,
          c,
          p,
          u[m],
          d
        ) : y = [c.slice(p, u[m])];
        for (let x = 0, v = y.length; x < v; ++x) {
          const C = y[x];
          let b = 0, w = C.length;
          if (g == null) {
            const S = A4(
              o.maxAngle,
              C,
              0,
              C.length,
              2
            );
            b = S[0], w = S[1];
          }
          for (let S = b; S < w; S += d)
            a.push(C[S], C[S + 1]);
          const E = a.length;
          p = u[m], this.drawChars_(l, E), l = E;
        }
      }
      this.endGeometry(e);
    } else {
      let u = o.overflow ? null : [];
      switch (h) {
        case "Point":
        case "MultiPoint":
          c = /** @type {import("../../geom/MultiPoint.js").default} */
          t.getFlatCoordinates();
          break;
        case "LineString":
          c = /** @type {import("../../geom/LineString.js").default} */
          t.getFlatMidpoint();
          break;
        case "Circle":
          c = /** @type {import("../../geom/Circle.js").default} */
          t.getCenter();
          break;
        case "MultiLineString":
          c = /** @type {import("../../geom/MultiLineString.js").default} */
          t.getFlatMidpoints(), d = 2;
          break;
        case "Polygon":
          c = /** @type {import("../../geom/Polygon.js").default} */
          t.getFlatInteriorPoint(), o.overflow || u.push(c[2] / this.resolution), d = 3;
          break;
        case "MultiPolygon":
          const v = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            t.getFlatInteriorPoints()
          );
          c = [];
          for (let C = 0, b = v.length; C < b; C += 3)
            o.overflow || u.push(v[C + 2] / this.resolution), c.push(v[C], v[C + 1]);
          if (c.length === 0)
            return;
          d = 2;
          break;
      }
      const f = this.appendFlatPointCoordinates(c, d);
      if (f === l)
        return;
      if (u && (f - l) / 2 !== c.length / d) {
        let v = l / 2;
        u = u.filter((C, b) => {
          const w = a[(v + b) * 2] === c[b * d] && a[(v + b) * 2 + 1] === c[b * d + 1];
          return w || --v, w;
        });
      }
      this.saveTextStates_();
      const g = o.backgroundFill ? this.createFill(this.fillStyleToState(o.backgroundFill)) : null, p = o.backgroundStroke ? this.createStroke(this.strokeStyleToState(o.backgroundStroke)) : null;
      this.beginGeometry(t, e, n);
      let m = o.padding;
      if (m != yn && (o.scale[0] < 0 || o.scale[1] < 0)) {
        let v = o.padding[0], C = o.padding[1], b = o.padding[2], w = o.padding[3];
        o.scale[0] < 0 && (C = -C, w = -w), o.scale[1] < 0 && (v = -v, b = -b), m = [v, C, b, w];
      }
      const _ = this.pixelRatio;
      this.instructions.push([
        $.DRAW_IMAGE,
        l,
        f,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        m == yn ? yn : m.map(function(v) {
          return v * _;
        }),
        g,
        p,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        u
      ]);
      const y = 1 / _, x = g ? g.slice(0) : null;
      x && (x[1] = ae), this.hitDetectionInstructions.push([
        $.DRAW_IMAGE,
        l,
        f,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [y, y],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        m,
        x,
        p,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_ ? ae : this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        u
      ]), this.endGeometry(e);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const t = this.textStrokeState_, e = this.textState_, n = this.textFillState_, r = this.strokeKey_;
    t && (r in this.strokeStates || (this.strokeStates[r] = {
      strokeStyle: t.strokeStyle,
      lineCap: t.lineCap,
      lineDashOffset: t.lineDashOffset,
      lineWidth: t.lineWidth,
      lineJoin: t.lineJoin,
      miterLimit: t.miterLimit,
      lineDash: t.lineDash
    }));
    const s = this.textKey_;
    s in this.textStates || (this.textStates[s] = {
      font: e.font,
      textAlign: e.textAlign || $s,
      justify: e.justify,
      textBaseline: e.textBaseline || yo,
      scale: e.scale
    });
    const o = this.fillKey_;
    n && (o in this.fillStates || (this.fillStates[o] = {
      fillStyle: n.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(t, e) {
    const n = this.textStrokeState_, r = this.textState_, s = this.strokeKey_, o = this.textKey_, a = this.fillKey_;
    this.saveTextStates_();
    const l = this.pixelRatio, h = bo[r.textBaseline], c = this.textOffsetY_ * l, d = this.text_, u = n ? n.lineWidth * Math.abs(r.scale[0]) / 2 : 0;
    this.instructions.push([
      $.DRAW_CHARS,
      t,
      e,
      h,
      r.overflow,
      a,
      r.maxAngle,
      l,
      c,
      s,
      u * l,
      d,
      o,
      1,
      this.declutterMode_,
      this.textKeepUpright_
    ]), this.hitDetectionInstructions.push([
      $.DRAW_CHARS,
      t,
      e,
      h,
      r.overflow,
      a && ae,
      r.maxAngle,
      l,
      c,
      s,
      u * l,
      d,
      o,
      1 / l,
      this.declutterMode_,
      this.textKeepUpright_
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   * @override
   */
  setTextStyle(t, e) {
    let n, r, s;
    if (!t)
      this.text_ = "";
    else {
      const o = t.getFill();
      o ? (r = this.textFillState_, r || (r = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = r), r.fillStyle = ti(
        o.getColor() || ae
      )) : (r = null, this.textFillState_ = r);
      const a = t.getStroke();
      if (!a)
        s = null, this.textStrokeState_ = s;
      else {
        s = this.textStrokeState_, s || (s = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = s);
        const p = a.getLineDash(), m = a.getLineDashOffset(), _ = a.getWidth(), y = a.getMiterLimit();
        s.lineCap = a.getLineCap() || Fr, s.lineDash = p ? p.slice() : pi, s.lineDashOffset = m === void 0 ? _i : m, s.lineJoin = a.getLineJoin() || Or, s.lineWidth = _ === void 0 ? Ws : _, s.miterLimit = y === void 0 ? Bs : y, s.strokeStyle = ti(
          a.getColor() || Vs
        );
      }
      n = this.textState_;
      const l = t.getFont() || Td;
      e4(l);
      const h = t.getScaleArray();
      n.overflow = t.getOverflow(), n.font = l, n.maxAngle = t.getMaxAngle(), n.placement = t.getPlacement(), n.textAlign = t.getTextAlign(), n.repeat = t.getRepeat(), n.justify = t.getJustify(), n.textBaseline = t.getTextBaseline() || yo, n.backgroundFill = t.getBackgroundFill(), n.backgroundStroke = t.getBackgroundStroke(), n.padding = t.getPadding() || yn, n.scale = h === void 0 ? [1, 1] : h;
      const c = t.getOffsetX(), d = t.getOffsetY(), u = t.getRotateWithView(), f = t.getKeepUpright(), g = t.getRotation();
      this.text_ = t.getText() || "", this.textOffsetX_ = c === void 0 ? 0 : c, this.textOffsetY_ = d === void 0 ? 0 : d, this.textRotateWithView_ = u === void 0 ? !1 : u, this.textKeepUpright_ = f === void 0 ? !0 : f, this.textRotation_ = g === void 0 ? 0 : g, this.strokeKey_ = s ? (typeof s.strokeStyle == "string" ? s.strokeStyle : Y(s.strokeStyle)) + s.lineCap + s.lineDashOffset + "|" + s.lineWidth + s.lineJoin + s.miterLimit + "[" + s.lineDash.join() + "]" : "", this.textKey_ = n.font + n.scale + (n.textAlign || "?") + (n.repeat || "?") + (n.justify || "?") + (n.textBaseline || "?"), this.fillKey_ = r && r.fillStyle ? typeof r.fillStyle == "string" ? r.fillStyle : "|" + Y(r.fillStyle) : "";
    }
    this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = e;
  }
}
const O4 = {
  Circle: cc,
  Default: u0,
  Image: I4,
  LineString: k4,
  Polygon: cc,
  Text: F4
};
class Bd {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, e, n, r) {
    this.tolerance_ = t, this.maxExtent_ = e, this.pixelRatio_ = r, this.resolution_ = n, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const t = {};
    for (const e in this.buildersByZIndex_) {
      t[e] = t[e] || {};
      const n = this.buildersByZIndex_[e];
      for (const r in n) {
        const s = n[r].finish();
        t[e][r] = s;
      }
    }
    return t;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(t, e) {
    const n = t !== void 0 ? t.toString() : "0";
    let r = this.buildersByZIndex_[n];
    r === void 0 && (r = {}, this.buildersByZIndex_[n] = r);
    let s = r[e];
    if (s === void 0) {
      const o = O4[e];
      s = new o(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), r[e] = s;
    }
    return s;
  }
}
function G4(i, t, e, n, r, s, o, a, l, h, c, d, u = !0) {
  let f = i[t], g = i[t + 1], p = 0, m = 0, _ = 0, y = 0;
  function x() {
    p = f, m = g, t += n, f = i[t], g = i[t + 1], y += _, _ = Math.sqrt((f - p) * (f - p) + (g - m) * (g - m));
  }
  do
    x();
  while (t < e - n && y + _ < s);
  let v = _ === 0 ? 0 : (s - y) / _;
  const C = pe(p, f, v), b = pe(m, g, v), w = t - n, E = y, S = s + a * l(h, r, c);
  for (; t < e - n && y + _ < S; )
    x();
  v = _ === 0 ? 0 : (S - y) / _;
  const R = pe(p, f, v), I = pe(m, g, v);
  let L = !1;
  if (u)
    if (d) {
      const H = [C, b, R, I];
      gl(H, 0, 4, 2, d, H, H), L = H[0] > H[2];
    } else
      L = C > R;
  const A = Math.PI, N = [], K = w + n === t;
  t = w, _ = 0, y = E, f = i[t], g = i[t + 1];
  let G;
  if (K) {
    x(), G = Math.atan2(g - m, f - p), L && (G += G > 0 ? -A : A);
    const H = (R + C) / 2, j = (I + b) / 2;
    return N[0] = [H, j, (S - s) / 2, G, r], N;
  }
  r = r.replace(/\n/g, " ");
  for (let H = 0, j = r.length; H < j; ) {
    x();
    let q = Math.atan2(g - m, f - p);
    if (L && (q += q > 0 ? -A : A), G !== void 0) {
      let wt = q - G;
      if (wt += wt > A ? -2 * A : wt < -A ? 2 * A : 0, Math.abs(wt) > o)
        return null;
    }
    G = q;
    const et = H;
    let ut = 0;
    for (; H < j; ++H) {
      const wt = L ? j - H - 1 : H, fe = a * l(h, r[wt], c);
      if (t + n < e && y + _ < s + ut + fe / 2)
        break;
      ut += fe;
    }
    if (H === et)
      continue;
    const P = L ? r.substring(j - et, j - H) : r.substring(et, H);
    v = _ === 0 ? 0 : (s + ut / 2 - y) / _;
    const Ut = pe(p, f, v), qt = pe(m, g, v);
    N.push([Ut, qt, ut / 2, q, P]), s += ut;
  }
  return N;
}
class zl {
  constructor() {
    this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = /** @type {ZIndexContextProxy} */
    new Proxy(mo(), {
      get: (t, e) => {
        if (typeof /** @type {*} */
        mo()[e] == "function")
          return this.push_(e), this.pushMethodArgs_;
      },
      set: (t, e, n) => (this.push_(e, n), !0)
    });
  }
  /**
   * @param {...*} args Arguments to push to the instructions array.
   * @private
   */
  push_(...t) {
    const e = this.instructions_, n = this.zIndex + this.offset_;
    e[n] || (e[n] = []), e[n].push(...t);
  }
  /**
   * @private
   * @param {...*} args Args.
   * @return {ZIndexContext} This.
   */
  pushMethodArgs_ = (...t) => (this.push_(t), this);
  /**
   * Push a function that renders to the context directly.
   * @param {function(CanvasRenderingContext2D): void} render Function.
   */
  pushFunction(t) {
    this.push_(t);
  }
  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   */
  draw(t) {
    this.instructions_.forEach((e) => {
      for (let n = 0, r = e.length; n < r; ++n) {
        const s = e[n];
        if (typeof s == "function") {
          s(t);
          continue;
        }
        const o = e[++n];
        if (typeof /** @type {*} */
        t[s] == "function")
          t[s](...o);
        else {
          if (typeof o == "function") {
            t[s] = o(t);
            continue;
          }
          t[s] = o;
        }
      }
    });
  }
  clear() {
    this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
  }
  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length, this.zIndex = 0;
  }
}
const qn = ne(), Pi = [], di = [], ui = [], Ii = [];
function dc(i) {
  return i[3].declutterBox;
}
const uc = new RegExp(
  /* eslint-disable prettier/prettier */
  "[-----]"
  /* eslint-enable prettier/prettier */
);
function z2(i, t) {
  return t === "start" ? t = uc.test(i) ? "right" : "left" : t === "end" && (t = uc.test(i) ? "left" : "right"), bo[t];
}
function N4(i, t, e) {
  return e > 0 && i.push(`
`, ""), i.push(t, ""), i;
}
function D4(i, t, e) {
  return e % 2 === 0 && (i += t), i;
}
class z4 {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
   * @param {boolean} [deferredRendering] Enable deferred rendering.
   */
  constructor(t, e, n, r, s) {
    this.overlaps = n, this.pixelRatio = e, this.resolution = t, this.alignAndScaleFill_, this.instructions = r.instructions, this.coordinates = r.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = Le(), this.hitDetectionInstructions = r.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = r.fillStates || {}, this.strokeStates = r.strokeStates || {}, this.textStates = r.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = s ? new zl() : null;
  }
  /**
   * @return {ZIndexContext} ZIndex context.
   */
  getZIndexContext() {
    return this.zIndexContext_;
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(t, e, n, r) {
    const s = t + e + n + r;
    if (this.labels_[s])
      return this.labels_[s];
    const o = r ? this.strokeStates[r] : null, a = n ? this.fillStates[n] : null, l = this.textStates[e], h = this.pixelRatio, c = [
      l.scale[0] * h,
      l.scale[1] * h
    ], d = l.justify ? bo[l.justify] : z2(
      Array.isArray(t) ? t[0] : t,
      l.textAlign || $s
    ), u = r && o.lineWidth ? o.lineWidth : 0, f = Array.isArray(t) ? t : String(t).split(`
`).reduce(N4, []), { width: g, height: p, widths: m, heights: _, lineWidths: y } = n4(
      l,
      f
    ), x = g + u, v = [], C = (x + 2) * c[0], b = (p + u) * c[1], w = {
      width: C < 0 ? Math.floor(C) : Math.ceil(C),
      height: b < 0 ? Math.floor(b) : Math.ceil(b),
      contextInstructions: v
    };
    (c[0] != 1 || c[1] != 1) && v.push("scale", c), r && (v.push("strokeStyle", o.strokeStyle), v.push("lineWidth", u), v.push("lineCap", o.lineCap), v.push("lineJoin", o.lineJoin), v.push("miterLimit", o.miterLimit), v.push("setLineDash", [o.lineDash]), v.push("lineDashOffset", o.lineDashOffset)), n && v.push("fillStyle", a.fillStyle), v.push("textBaseline", "middle"), v.push("textAlign", "center");
    const E = 0.5 - d;
    let S = d * x + E * u;
    const R = [], I = [];
    let L = 0, A = 0, N = 0, K = 0, G;
    for (let H = 0, j = f.length; H < j; H += 2) {
      const q = f[H];
      if (q === `
`) {
        A += L, L = 0, S = d * x + E * u, ++K;
        continue;
      }
      const et = f[H + 1] || l.font;
      et !== G && (r && R.push("font", et), n && I.push("font", et), G = et), L = Math.max(L, _[N]);
      const ut = [
        q,
        S + E * m[N] + d * (m[N] - y[K]),
        0.5 * (u + L) + A
      ];
      S += m[N], r && R.push("strokeText", ut), n && I.push("fillText", ut), ++N;
    }
    return Array.prototype.push.apply(v, R), Array.prototype.push.apply(v, I), this.labels_[s] = w, w;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(t, e, n, r, s, o, a) {
    t.beginPath(), t.moveTo.apply(t, e), t.lineTo.apply(t, n), t.lineTo.apply(t, r), t.lineTo.apply(t, s), t.lineTo.apply(t, e), o && (this.alignAndScaleFill_ = /** @type {number} */
    o[2], t.fillStyle = /** @type {string} */
    o[1], this.fill_(t)), a && (this.setStrokeStyle_(
      t,
      /** @type {Array<*>} */
      a
    ), t.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(t, e, n, r, s, o, a, l, h, c, d, u, f, g, p, m) {
    a *= u[0], l *= u[1];
    let _ = n - a, y = r - l;
    const x = s + h > t ? t - h : s, v = o + c > e ? e - c : o, C = g[3] + x * u[0] + g[1], b = g[0] + v * u[1] + g[2], w = _ - g[3], E = y - g[0];
    (p || d !== 0) && (Pi[0] = w, Ii[0] = w, Pi[1] = E, di[1] = E, di[0] = w + C, ui[0] = di[0], ui[1] = E + b, Ii[1] = ui[1]);
    let S;
    return d !== 0 ? (S = ri(
      Le(),
      n,
      r,
      1,
      1,
      d,
      -n,
      -r
    ), Tt(S, Pi), Tt(S, di), Tt(S, ui), Tt(S, Ii), ii(
      Math.min(Pi[0], di[0], ui[0], Ii[0]),
      Math.min(Pi[1], di[1], ui[1], Ii[1]),
      Math.max(Pi[0], di[0], ui[0], Ii[0]),
      Math.max(Pi[1], di[1], ui[1], Ii[1]),
      qn
    )) : ii(
      Math.min(w, w + C),
      Math.min(E, E + b),
      Math.max(w, w + C),
      Math.max(E, E + b),
      qn
    ), f && (_ = Math.round(_), y = Math.round(y)), {
      drawImageX: _,
      drawImageY: y,
      drawImageW: x,
      drawImageH: v,
      originX: h,
      originY: c,
      declutterBox: {
        minX: qn[0],
        minY: qn[1],
        maxX: qn[2],
        maxY: qn[3],
        value: m
      },
      canvasTransform: S,
      scale: u
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(t, e, n, r, s, o, a) {
    const l = !!(o || a), h = r.declutterBox, c = a ? a[2] * r.scale[0] / 2 : 0;
    return h.minX - c <= e[0] && h.maxX + c >= 0 && h.minY - c <= e[1] && h.maxY + c >= 0 && (l && this.replayTextBackground_(
      t,
      Pi,
      di,
      ui,
      Ii,
      /** @type {Array<*>} */
      o,
      /** @type {Array<*>} */
      a
    ), r4(
      t,
      r.canvasTransform,
      s,
      n,
      r.originX,
      r.originY,
      r.drawImageW,
      r.drawImageH,
      r.drawImageX,
      r.drawImageY,
      r.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   */
  fill_(t) {
    const e = this.alignAndScaleFill_;
    if (e) {
      const n = Tt(this.renderedTransform_, [0, 0]), r = 512 * this.pixelRatio;
      t.save(), t.translate(n[0] % r, n[1] % r), e !== 1 && t.scale(e, e), t.rotate(this.viewRotation_);
    }
    t.fill(), e && t.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(t, e) {
    t.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    e[1], e[1] && (t.lineWidth = /** @type {number} */
    e[2], t.lineCap = /** @type {CanvasLineCap} */
    e[3], t.lineJoin = /** @type {CanvasLineJoin} */
    e[4], t.miterLimit = /** @type {number} */
    e[5], t.lineDashOffset = /** @type {number} */
    e[7], t.setLineDash(
      /** @type {Array<number>} */
      e[6]
    ));
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(t, e, n, r) {
    const s = this.textStates[e], o = this.createLabel(t, e, r, n), a = this.strokeStates[n], l = this.pixelRatio, h = z2(
      Array.isArray(t) ? t[0] : t,
      s.textAlign || $s
    ), c = bo[s.textBaseline || yo], d = a && a.lineWidth ? a.lineWidth : 0, u = o.width / l - 2 * s.scale[0], f = h * u + 2 * (0.5 - h) * d, g = c * o.height / l + 2 * (0.5 - c) * d;
    return {
      label: o,
      anchorX: f,
      anchorY: g
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(t, e, n, r, s, o, a, l) {
    const h = this.zIndexContext_;
    let c;
    this.pixelCoordinates_ && Ci(n, this.renderedTransform_) ? c = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), c = Yi(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      n,
      this.pixelCoordinates_
    ), cg(this.renderedTransform_, n));
    let d = 0;
    const u = r.length;
    let f = 0, g, p, m, _, y, x, v, C, b, w, E, S, R, I = 0, L = 0;
    const A = this.coordinateCache_, N = this.viewRotation_, K = Math.round(Math.atan2(-n[1], n[0]) * 1e12) / 1e12, G = (
      /** @type {import("../../render.js").State} */
      {
        context: t,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: N
      }
    ), H = this.instructions != r || this.overlaps ? 0 : 200;
    let j, q, et, ut;
    for (; d < u; ) {
      const P = r[d];
      switch (
        /** @type {import("./Instruction.js").default} */
        P[0]
      ) {
        case $.BEGIN_GEOMETRY:
          j = /** @type {import("../../Feature.js").FeatureLike} */
          P[1], ut = P[3], j.getGeometry() ? a !== void 0 && !bt(a, ut.getExtent()) ? d = /** @type {number} */
          P[2] + 1 : ++d : d = /** @type {number} */
          P[2], h && (h.zIndex = P[4]);
          break;
        case $.BEGIN_PATH:
          I > H && (this.fill_(t), I = 0), L > H && (t.stroke(), L = 0), !I && !L && (t.beginPath(), y = NaN, x = NaN), ++d;
          break;
        case $.CIRCLE:
          f = /** @type {number} */
          P[1];
          const qt = c[f], wt = c[f + 1], fe = c[f + 2], Bt = c[f + 3], He = fe - qt, ze = Bt - wt, ge = Math.sqrt(He * He + ze * ze);
          t.moveTo(qt + ge, wt), t.arc(qt, wt, ge, 0, 2 * Math.PI, !0), ++d;
          break;
        case $.CLOSE_PATH:
          t.closePath(), ++d;
          break;
        case $.CUSTOM:
          f = /** @type {number} */
          P[1], g = P[2];
          const x0 = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            P[3]
          ), f2 = P[4], Zr = P[5];
          G.geometry = x0, G.feature = j, d in A || (A[d] = []);
          const sn = A[d];
          Zr ? Zr(c, f, g, 2, sn) : (sn[0] = c[f], sn[1] = c[f + 1], sn.length = 2), h && (h.zIndex = P[6]), f2(sn, G), ++d;
          break;
        case $.DRAW_IMAGE:
          f = /** @type {number} */
          P[1], g = /** @type {number} */
          P[2], b = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          P[3], p = /** @type {number} */
          P[4], m = /** @type {number} */
          P[5];
          let xe = (
            /** @type {number} */
            P[6]
          );
          const Ke = (
            /** @type {number} */
            P[7]
          ), Vn = (
            /** @type {number} */
            P[8]
          ), $n = (
            /** @type {number} */
            P[9]
          ), Hr = (
            /** @type {boolean} */
            P[10]
          );
          let on = (
            /** @type {number} */
            P[11]
          );
          const Wn = (
            /** @type {import("../../size.js").Size} */
            P[12]
          );
          let Yn = (
            /** @type {number} */
            P[13]
          );
          _ = P[14] || "declutter";
          const Ft = (
            /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
            P[15]
          );
          if (!b && P.length >= 20) {
            w = /** @type {string} */
            P[19], E = /** @type {string} */
            P[20], S = /** @type {string} */
            P[21], R = /** @type {string} */
            P[22];
            const Ce = this.drawLabelWithPointPlacement_(
              w,
              E,
              S,
              R
            );
            b = Ce.label, P[3] = b;
            const an = (
              /** @type {number} */
              P[23]
            );
            p = (Ce.anchorX - an) * this.pixelRatio, P[4] = p;
            const be = (
              /** @type {number} */
              P[24]
            );
            m = (Ce.anchorY - be) * this.pixelRatio, P[5] = m, xe = b.height, P[6] = xe, Yn = b.width, P[13] = Yn;
          }
          let g2;
          P.length > 25 && (g2 = /** @type {number} */
          P[25]);
          let m2, C0, b0;
          P.length > 17 ? (m2 = /** @type {Array<number>} */
          P[16], C0 = /** @type {Array<*>} */
          P[17], b0 = /** @type {Array<*>} */
          P[18]) : (m2 = yn, C0 = null, b0 = null), Hr && K ? on += N : !Hr && !K && (on -= N);
          let P3 = 0;
          for (; f < g; f += 2) {
            if (g2 && g2[P3++] < Yn / this.pixelRatio)
              continue;
            const Ce = this.calculateImageOrLabelDimensions_(
              b.width,
              b.height,
              c[f],
              c[f + 1],
              Yn,
              xe,
              p,
              m,
              Vn,
              $n,
              on,
              Wn,
              s,
              m2,
              !!C0 || !!b0,
              j
            ), an = [
              t,
              e,
              b,
              Ce,
              Ke,
              C0,
              b0
            ];
            if (l) {
              let be, qe, we;
              if (Ft) {
                const xt = g - f;
                if (!Ft[xt]) {
                  Ft[xt] = { args: an, declutterMode: _ };
                  continue;
                }
                const Jt = Ft[xt];
                be = Jt.args, qe = Jt.declutterMode, delete Ft[xt], we = dc(be);
              }
              let li, hi;
              if (be && (qe !== "declutter" || !l.collides(we)) && (li = !0), (_ !== "declutter" || !l.collides(Ce.declutterBox)) && (hi = !0), qe === "declutter" && _ === "declutter") {
                const xt = li && hi;
                li = xt, hi = xt;
              }
              li && (qe !== "none" && l.insert(we), this.replayImageOrLabel_.apply(this, be)), hi && (_ !== "none" && l.insert(Ce.declutterBox), this.replayImageOrLabel_.apply(this, an));
            } else
              this.replayImageOrLabel_.apply(this, an);
          }
          ++d;
          break;
        case $.DRAW_CHARS:
          const dh = (
            /** @type {number} */
            P[1]
          ), uh = (
            /** @type {number} */
            P[2]
          ), p2 = (
            /** @type {number} */
            P[3]
          ), I3 = (
            /** @type {number} */
            P[4]
          );
          R = /** @type {string} */
          P[5];
          const k3 = (
            /** @type {number} */
            P[6]
          ), fh = (
            /** @type {number} */
            P[7]
          ), gh = (
            /** @type {number} */
            P[8]
          );
          S = /** @type {string} */
          P[9];
          const _2 = (
            /** @type {number} */
            P[10]
          );
          w = /** @type {string|Array<string>} */
          P[11], Array.isArray(w) && (w = w.reduce(D4, "")), E = /** @type {string} */
          P[12];
          const mh = [
            /** @type {number} */
            P[13],
            /** @type {number} */
            P[13]
          ];
          _ = P[14] || "declutter";
          const L3 = (
            /** @type {boolean} */
            P[15]
          ), y2 = this.textStates[E], Kr = y2.font, qr = [
            y2.scale[0] * fh,
            y2.scale[1] * fh
          ];
          let Jr;
          Kr in this.widths_ ? Jr = this.widths_[Kr] : (Jr = {}, this.widths_[Kr] = Jr);
          const ph = Dl(c, dh, uh, 2), _h = Math.abs(qr[0]) * ec(Kr, w, Jr);
          if (I3 || _h <= ph) {
            const Ce = this.textStates[E].textAlign, an = (ph - _h) * z2(w, Ce), be = G4(
              c,
              dh,
              uh,
              2,
              w,
              an,
              k3,
              Math.abs(qr[0]),
              ec,
              Kr,
              Jr,
              K ? 0 : this.viewRotation_,
              L3
            );
            t: if (be) {
              const qe = [];
              let we, li, hi, xt, Jt;
              if (S)
                for (we = 0, li = be.length; we < li; ++we) {
                  Jt = be[we], hi = /** @type {string} */
                  Jt[4], xt = this.createLabel(hi, E, "", S), p = /** @type {number} */
                  Jt[2] + (qr[0] < 0 ? -_2 : _2), m = p2 * xt.height + (0.5 - p2) * 2 * _2 * qr[1] / qr[0] - gh;
                  const ci = this.calculateImageOrLabelDimensions_(
                    xt.width,
                    xt.height,
                    Jt[0],
                    Jt[1],
                    xt.width,
                    xt.height,
                    p,
                    m,
                    0,
                    0,
                    Jt[3],
                    mh,
                    !1,
                    yn,
                    !1,
                    j
                  );
                  if (l && _ === "declutter" && l.collides(ci.declutterBox))
                    break t;
                  qe.push([
                    t,
                    e,
                    xt,
                    ci,
                    1,
                    null,
                    null
                  ]);
                }
              if (R)
                for (we = 0, li = be.length; we < li; ++we) {
                  Jt = be[we], hi = /** @type {string} */
                  Jt[4], xt = this.createLabel(hi, E, R, ""), p = /** @type {number} */
                  Jt[2], m = p2 * xt.height - gh;
                  const ci = this.calculateImageOrLabelDimensions_(
                    xt.width,
                    xt.height,
                    Jt[0],
                    Jt[1],
                    xt.width,
                    xt.height,
                    p,
                    m,
                    0,
                    0,
                    Jt[3],
                    mh,
                    !1,
                    yn,
                    !1,
                    j
                  );
                  if (l && _ === "declutter" && l.collides(ci.declutterBox))
                    break t;
                  qe.push([
                    t,
                    e,
                    xt,
                    ci,
                    1,
                    null,
                    null
                  ]);
                }
              l && _ !== "none" && l.load(qe.map(dc));
              for (let ci = 0, A3 = qe.length; ci < A3; ++ci)
                this.replayImageOrLabel_.apply(this, qe[ci]);
            }
          }
          ++d;
          break;
        case $.END_GEOMETRY:
          if (o !== void 0) {
            j = /** @type {import("../../Feature.js").FeatureLike} */
            P[1];
            const Ce = o(
              j,
              ut,
              _
            );
            if (Ce)
              return Ce;
          }
          ++d;
          break;
        case $.FILL:
          H ? I++ : this.fill_(t), ++d;
          break;
        case $.MOVE_TO_LINE_TO:
          for (f = /** @type {number} */
          P[1], g = /** @type {number} */
          P[2], q = c[f], et = c[f + 1], t.moveTo(q, et), y = q + 0.5 | 0, x = et + 0.5 | 0, f += 2; f < g; f += 2)
            q = c[f], et = c[f + 1], v = q + 0.5 | 0, C = et + 0.5 | 0, (f == g - 2 || v !== y || C !== x) && (t.lineTo(q, et), y = v, x = C);
          ++d;
          break;
        case $.SET_FILL_STYLE:
          this.alignAndScaleFill_ = P[2], I && (this.fill_(t), I = 0, L && (t.stroke(), L = 0)), t.fillStyle = P[1], ++d;
          break;
        case $.SET_STROKE_STYLE:
          L && (t.stroke(), L = 0), this.setStrokeStyle_(
            t,
            /** @type {Array<*>} */
            P
          ), ++d;
          break;
        case $.STROKE:
          H ? L++ : t.stroke(), ++d;
          break;
        default:
          ++d;
          break;
      }
    }
    I && this.fill_(t), L && t.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
   */
  execute(t, e, n, r, s, o) {
    this.viewRotation_ = r, this.execute_(
      t,
      e,
      n,
      this.instructions,
      s,
      void 0,
      void 0,
      o
    );
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(t, e, n, r, s) {
    return this.viewRotation_ = n, this.execute_(
      t,
      [t.canvas.width, t.canvas.height],
      e,
      this.hitDetectionInstructions,
      !0,
      r,
      s
    );
  }
}
const fn = [
  "Polygon",
  "Circle",
  "LineString",
  "Image",
  "Text",
  "Default"
], wo = ["Image", "Text"], j4 = fn.filter(
  (i) => !wo.includes(i)
);
class Vd {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
   */
  constructor(t, e, n, r, s, o, a) {
    this.maxExtent_ = t, this.overlaps_ = r, this.pixelRatio_ = n, this.resolution_ = e, this.renderBuffer_ = o, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = Le(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(s, a);
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(t, e) {
    const n = this.getClipCoords(e);
    t.beginPath(), t.moveTo(n[0], n[1]), t.lineTo(n[2], n[3]), t.lineTo(n[4], n[5]), t.lineTo(n[6], n[7]), t.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   * @param {boolean} deferredRendering Enable deferred rendering.
   */
  createExecutors_(t, e) {
    for (const n in t) {
      let r = this.executorsByZIndex_[n];
      r === void 0 && (r = {}, this.executorsByZIndex_[n] = r);
      const s = t[n];
      for (const o in s) {
        const a = s[o];
        r[o] = new z4(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          a,
          e
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(t) {
    for (const e in this.executorsByZIndex_) {
      const n = this.executorsByZIndex_[e];
      for (let r = 0, s = t.length; r < s; ++r)
        if (t[r] in n)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, e, n, r, s, o) {
    r = Math.round(r);
    const a = r * 2 + 1, l = ri(
      this.hitDetectionTransform_,
      r + 0.5,
      r + 0.5,
      1 / e,
      -1 / e,
      -n,
      -t[0],
      -t[1]
    ), h = !this.hitDetectionContext_;
    h && (this.hitDetectionContext_ = Pt(
      a,
      a
    ));
    const c = this.hitDetectionContext_;
    c.canvas.width !== a || c.canvas.height !== a ? (c.canvas.width = a, c.canvas.height = a) : h || c.clearRect(0, 0, a, a);
    let d;
    this.renderBuffer_ !== void 0 && (d = ne(), xs(d, t), Ie(
      d,
      e * (this.renderBuffer_ + r),
      d
    ));
    const u = U4(r);
    let f;
    function g(C, b, w) {
      const E = c.getImageData(
        0,
        0,
        a,
        a
      ).data;
      for (let S = 0, R = u.length; S < R; S++)
        if (E[u[S]] > 0) {
          if (!o || w === "none" || f !== "Image" && f !== "Text" || o.includes(C)) {
            const I = (u[S] - 3) / 4, L = r - I % a, A = r - (I / a | 0), N = s(C, b, L * L + A * A);
            if (N)
              return N;
          }
          c.clearRect(0, 0, a, a);
          break;
        }
    }
    const p = Object.keys(this.executorsByZIndex_).map(Number);
    p.sort(ei);
    let m, _, y, x, v;
    for (m = p.length - 1; m >= 0; --m) {
      const C = p[m].toString();
      for (y = this.executorsByZIndex_[C], _ = fn.length - 1; _ >= 0; --_)
        if (f = fn[_], x = y[f], x !== void 0 && (v = x.executeHitDetection(
          c,
          l,
          n,
          g,
          d
        ), v))
          return v;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(t) {
    const e = this.maxExtent_;
    if (!e)
      return null;
    const n = e[0], r = e[1], s = e[2], o = e[3], a = [n, r, n, o, s, o, s, r];
    return Yi(a, 0, 8, 2, t, a), a;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return Zi(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} targetContext Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ALL}
   * @param {import("rbush").default<import('./Executor.js').DeclutterEntry>|null} [declutterTree] Declutter tree.
   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
   */
  execute(t, e, n, r, s, o, a) {
    const l = Object.keys(this.executorsByZIndex_).map(Number);
    l.sort(a ? sf : ei), o = o || fn;
    const h = fn.length;
    for (let c = 0, d = l.length; c < d; ++c) {
      const u = l[c].toString(), f = this.executorsByZIndex_[u];
      for (let g = 0, p = o.length; g < p; ++g) {
        const m = o[g], _ = f[m];
        if (_ !== void 0) {
          const y = a === null ? void 0 : _.getZIndexContext(), x = y ? y.getContext() : t, v = this.maxExtent_ && m !== "Image" && m !== "Text";
          if (v && (x.save(), this.clip(x, n)), !y || m === "Text" || m === "Image" ? _.execute(
            x,
            e,
            n,
            r,
            s,
            a
          ) : y.pushFunction(
            (C) => _.execute(
              C,
              e,
              n,
              r,
              s,
              a
            )
          ), v && x.restore(), y) {
            y.offset();
            const C = l[c] * h + fn.indexOf(m);
            this.deferredZIndexContexts_[C] || (this.deferredZIndexContexts_[C] = []), this.deferredZIndexContexts_[C].push(y);
          }
        }
      }
    }
    this.renderedContext_ = t;
  }
  getDeferredZIndexContexts() {
    return this.deferredZIndexContexts_;
  }
  getRenderedContext() {
    return this.renderedContext_;
  }
  renderDeferred() {
    const t = this.deferredZIndexContexts_, e = Object.keys(t).map(Number).sort(ei);
    for (let n = 0, r = e.length; n < r; ++n)
      t[e[n]].forEach((s) => {
        s.draw(this.renderedContext_), s.clear();
      }), t[e[n]].length = 0;
  }
}
const j2 = {};
function U4(i) {
  if (j2[i] !== void 0)
    return j2[i];
  const t = i * 2 + 1, e = i * i, n = new Array(e + 1);
  for (let s = 0; s <= i; ++s)
    for (let o = 0; o <= i; ++o) {
      const a = s * s + o * o;
      if (a > e)
        break;
      let l = n[a];
      l || (l = [], n[a] = l), l.push(((i + s) * t + (i + o)) * 4 + 3), s > 0 && l.push(((i - s) * t + (i + o)) * 4 + 3), o > 0 && (l.push(((i + s) * t + (i - o)) * 4 + 3), s > 0 && l.push(((i - s) * t + (i - o)) * 4 + 3));
    }
  const r = [];
  for (let s = 0, o = n.length; s < o; ++s)
    n[s] && r.push(...n[s]);
  return j2[i] = r, r;
}
class B4 extends Ud {
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(t, e, n, r, s, o, a) {
    super(), this.context_ = t, this.pixelRatio_ = e, this.extent_ = n, this.transform_ = r, this.transformRotation_ = r ? jr(Math.atan2(r[1], r[0]), 10) : 0, this.viewRotation_ = s, this.squaredTolerance_ = o, this.userTransform_ = a, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = Le();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(t, e, n, r) {
    if (!this.image_)
      return;
    const s = Yi(
      t,
      e,
      n,
      r,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_, a = this.tmpLocalTransform_, l = o.globalAlpha;
    this.imageOpacity_ != 1 && (o.globalAlpha = l * this.imageOpacity_);
    let h = this.imageRotation_;
    this.transformRotation_ === 0 && (h -= this.viewRotation_), this.imageRotateWithView_ && (h += this.viewRotation_);
    for (let c = 0, d = s.length; c < d; c += 2) {
      const u = s[c] - this.imageAnchorX_, f = s[c + 1] - this.imageAnchorY_;
      if (h !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const g = u + this.imageAnchorX_, p = f + this.imageAnchorY_;
        ri(
          a,
          g,
          p,
          1,
          1,
          h,
          -g,
          -p
        ), o.save(), o.transform.apply(o, a), o.translate(g, p), o.scale(this.imageScale_[0], this.imageScale_[1]), o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), o.restore();
      } else
        o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          u,
          f,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (o.globalAlpha = l);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(t, e, n, r) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const s = Yi(
      t,
      e,
      n,
      r,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_;
    let a = this.textRotation_;
    for (this.transformRotation_ === 0 && (a -= this.viewRotation_), this.textRotateWithView_ && (a += this.viewRotation_); e < n; e += r) {
      const l = s[e] + this.textOffsetX_, h = s[e + 1] + this.textOffsetY_;
      a !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (o.save(), o.translate(l - this.textOffsetX_, h - this.textOffsetY_), o.rotate(a), o.translate(this.textOffsetX_, this.textOffsetY_), o.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && o.strokeText(this.text_, 0, 0), this.textFillState_ && o.fillText(this.text_, 0, 0), o.restore()) : (this.textStrokeState_ && o.strokeText(this.text_, l, h), this.textFillState_ && o.fillText(this.text_, l, h));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(t, e, n, r, s) {
    const o = this.context_, a = Yi(
      t,
      e,
      n,
      r,
      this.transform_,
      this.pixelCoordinates_
    );
    o.moveTo(a[0], a[1]);
    let l = a.length;
    s && (l -= 2);
    for (let h = 2; h < l; h += 2)
      o.lineTo(a[h], a[h + 1]);
    return s && o.closePath(), n;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(t, e, n, r) {
    for (let s = 0, o = n.length; s < o; ++s)
      e = this.moveToLineTo_(
        t,
        e,
        n[s],
        r,
        !0
      );
    return e;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   * @override
   */
  drawCircle(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/Circle.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!bt(this.extent_, t.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const e = vg(
          t,
          this.transform_,
          this.pixelCoordinates_
        ), n = e[2] - e[0], r = e[3] - e[1], s = Math.sqrt(n * n + r * r), o = this.context_;
        o.beginPath(), o.arc(
          e[0],
          e[1],
          s,
          0,
          2 * Math.PI
        ), this.fillState_ && o.fill(), this.strokeState_ && o.stroke();
      }
      this.text_ !== "" && this.drawText_(t.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   * @override
   */
  setStyle(t) {
    this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(t) {
    this.transform_ = t;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   * @override
   */
  drawGeometry(t) {
    switch (t.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          t
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          t
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          t
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          t
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          t
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          t
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          t
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   * @override
   */
  drawFeature(t, e) {
    const n = e.getGeometryFunction()(t);
    n && (this.setStyle(e), this.drawGeometry(n));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   * @override
   */
  drawGeometryCollection(t) {
    const e = t.getGeometriesArray();
    for (let n = 0, r = e.length; n < r; ++n)
      this.drawGeometry(e[n]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   * @override
   */
  drawPoint(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/Point.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const e = t.getFlatCoordinates(), n = t.getStride();
    this.image_ && this.drawImages_(e, 0, e.length, n), this.text_ !== "" && this.drawText_(e, 0, e.length, n);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   * @override
   */
  drawMultiPoint(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPoint.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const e = t.getFlatCoordinates(), n = t.getStride();
    this.image_ && this.drawImages_(e, 0, e.length, n), this.text_ !== "" && this.drawText_(e, 0, e.length, n);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   * @override
   */
  drawLineString(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/LineString.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!bt(this.extent_, t.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const e = this.context_, n = t.getFlatCoordinates();
        e.beginPath(), this.moveToLineTo_(
          n,
          0,
          n.length,
          t.getStride(),
          !1
        ), e.stroke();
      }
      if (this.text_ !== "") {
        const e = t.getFlatMidpoint();
        this.drawText_(e, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   * @override
   */
  drawMultiLineString(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiLineString.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const e = t.getExtent();
    if (bt(this.extent_, e)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const n = this.context_, r = t.getFlatCoordinates();
        let s = 0;
        const o = (
          /** @type {Array<number>} */
          t.getEnds()
        ), a = t.getStride();
        n.beginPath();
        for (let l = 0, h = o.length; l < h; ++l)
          s = this.moveToLineTo_(
            r,
            s,
            o[l],
            a,
            !1
          );
        n.stroke();
      }
      if (this.text_ !== "") {
        const n = t.getFlatMidpoints();
        this.drawText_(n, 0, n.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   * @override
   */
  drawPolygon(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/Polygon.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!bt(this.extent_, t.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const e = this.context_;
        e.beginPath(), this.drawRings_(
          t.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          t.getEnds(),
          t.getStride()
        ), this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
      }
      if (this.text_ !== "") {
        const e = t.getFlatInteriorPoint();
        this.drawText_(e, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @override
   */
  drawMultiPolygon(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPolygon.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!bt(this.extent_, t.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const e = this.context_, n = t.getOrientedFlatCoordinates();
        let r = 0;
        const s = t.getEndss(), o = t.getStride();
        e.beginPath();
        for (let a = 0, l = s.length; a < l; ++a) {
          const h = s[a];
          r = this.drawRings_(n, r, h, o);
        }
        this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
      }
      if (this.text_ !== "") {
        const e = t.getFlatInteriorPoints();
        this.drawText_(e, 0, e.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(t) {
    const e = this.context_, n = this.contextFillState_;
    n ? n.fillStyle != t.fillStyle && (n.fillStyle = t.fillStyle, e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle, this.contextFillState_ = {
      fillStyle: t.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(t) {
    const e = this.context_, n = this.contextStrokeState_;
    n ? (n.lineCap != t.lineCap && (n.lineCap = t.lineCap, e.lineCap = t.lineCap), Ci(n.lineDash, t.lineDash) || e.setLineDash(
      n.lineDash = t.lineDash
    ), n.lineDashOffset != t.lineDashOffset && (n.lineDashOffset = t.lineDashOffset, e.lineDashOffset = t.lineDashOffset), n.lineJoin != t.lineJoin && (n.lineJoin = t.lineJoin, e.lineJoin = t.lineJoin), n.lineWidth != t.lineWidth && (n.lineWidth = t.lineWidth, e.lineWidth = t.lineWidth), n.miterLimit != t.miterLimit && (n.miterLimit = t.miterLimit, e.miterLimit = t.miterLimit), n.strokeStyle != t.strokeStyle && (n.strokeStyle = t.strokeStyle, e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap, e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset, e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.strokeStyle = t.strokeStyle, this.contextStrokeState_ = {
      lineCap: t.lineCap,
      lineDash: t.lineDash,
      lineDashOffset: t.lineDashOffset,
      lineJoin: t.lineJoin,
      lineWidth: t.lineWidth,
      miterLimit: t.miterLimit,
      strokeStyle: t.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(t) {
    const e = this.context_, n = this.contextTextState_, r = t.textAlign ? t.textAlign : $s;
    n ? (n.font != t.font && (n.font = t.font, e.font = t.font), n.textAlign != r && (n.textAlign = r, e.textAlign = r), n.textBaseline != t.textBaseline && (n.textBaseline = t.textBaseline, e.textBaseline = t.textBaseline)) : (e.font = t.font, e.textAlign = r, e.textBaseline = t.textBaseline, this.contextTextState_ = {
      font: t.font,
      textAlign: r,
      textBaseline: t.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @override
   */
  setFillStrokeStyle(t, e) {
    if (!t)
      this.fillState_ = null;
    else {
      const n = t.getColor();
      this.fillState_ = {
        fillStyle: ti(
          n || ae
        )
      };
    }
    if (!e)
      this.strokeState_ = null;
    else {
      const n = e.getColor(), r = e.getLineCap(), s = e.getLineDash(), o = e.getLineDashOffset(), a = e.getLineJoin(), l = e.getWidth(), h = e.getMiterLimit(), c = s || pi;
      this.strokeState_ = {
        lineCap: r !== void 0 ? r : Fr,
        lineDash: this.pixelRatio_ === 1 ? c : c.map((d) => d * this.pixelRatio_),
        lineDashOffset: (o || _i) * this.pixelRatio_,
        lineJoin: a !== void 0 ? a : Or,
        lineWidth: (l !== void 0 ? l : Ws) * this.pixelRatio_,
        miterLimit: h !== void 0 ? h : Bs,
        strokeStyle: ti(
          n || Vs
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @override
   */
  setImageStyle(t) {
    let e;
    if (!t || !(e = t.getSize())) {
      this.image_ = null;
      return;
    }
    const n = t.getPixelRatio(this.pixelRatio_), r = t.getAnchor(), s = t.getOrigin();
    this.image_ = t.getImage(this.pixelRatio_), this.imageAnchorX_ = r[0] * n, this.imageAnchorY_ = r[1] * n, this.imageHeight_ = e[1] * n, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = s[0], this.imageOriginY_ = s[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation();
    const o = t.getScaleArray();
    this.imageScale_ = [
      o[0] * this.pixelRatio_ / n,
      o[1] * this.pixelRatio_ / n
    ], this.imageWidth_ = e[0] * n;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @override
   */
  setTextStyle(t) {
    if (!t)
      this.text_ = "";
    else {
      const e = t.getFill();
      if (!e)
        this.textFillState_ = null;
      else {
        const f = e.getColor();
        this.textFillState_ = {
          fillStyle: ti(
            f || ae
          )
        };
      }
      const n = t.getStroke();
      if (!n)
        this.textStrokeState_ = null;
      else {
        const f = n.getColor(), g = n.getLineCap(), p = n.getLineDash(), m = n.getLineDashOffset(), _ = n.getLineJoin(), y = n.getWidth(), x = n.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: g !== void 0 ? g : Fr,
          lineDash: p || pi,
          lineDashOffset: m || _i,
          lineJoin: _ !== void 0 ? _ : Or,
          lineWidth: y !== void 0 ? y : Ws,
          miterLimit: x !== void 0 ? x : Bs,
          strokeStyle: ti(
            f || Vs
          )
        };
      }
      const r = t.getFont(), s = t.getOffsetX(), o = t.getOffsetY(), a = t.getRotateWithView(), l = t.getRotation(), h = t.getScaleArray(), c = t.getText(), d = t.getTextAlign(), u = t.getTextBaseline();
      this.textState_ = {
        font: r !== void 0 ? r : Td,
        textAlign: d !== void 0 ? d : $s,
        textBaseline: u !== void 0 ? u : yo
      }, this.text_ = c !== void 0 ? Array.isArray(c) ? c.reduce((f, g, p) => f += p % 2 ? " " : g, "") : c : "", this.textOffsetX_ = s !== void 0 ? this.pixelRatio_ * s : 0, this.textOffsetY_ = o !== void 0 ? this.pixelRatio_ * o : 0, this.textRotateWithView_ = a !== void 0 ? a : !1, this.textRotation_ = l !== void 0 ? l : 0, this.textScale_ = [
        this.pixelRatio_ * h[0],
        this.pixelRatio_ * h[1]
      ];
    }
  }
}
const _e = 0.5;
function $d(i, t, e, n, r, s, o, a, l) {
  const h = l ? Yo(r) : r, c = i[0] * _e, d = i[1] * _e, u = Pt(c, d);
  u.imageSmoothingEnabled = !1;
  const f = u.canvas, g = new B4(
    u,
    _e,
    r,
    null,
    o,
    a,
    l ? Vr(lg(), l) : null
  ), p = e.length, m = Math.floor((256 * 256 * 256 - 1) / p), _ = {};
  for (let x = 1; x <= p; ++x) {
    const v = e[x - 1], C = v.getStyleFunction() || n;
    if (!C)
      continue;
    let b = C(v, s);
    if (!b)
      continue;
    Array.isArray(b) || (b = [b]);
    const E = (x * m).toString(16).padStart(7, "#00000");
    for (let S = 0, R = b.length; S < R; ++S) {
      const I = b[S], L = I.getGeometryFunction()(v);
      if (!L || !bt(h, L.getExtent()))
        continue;
      const A = I.clone(), N = A.getFill();
      N && N.setColor(E);
      const K = A.getStroke();
      K && (K.setColor(E), K.setLineDash(null)), A.setText(void 0);
      const G = I.getImage();
      if (G) {
        const et = G.getImageSize();
        if (!et)
          continue;
        const ut = Pt(
          et[0],
          et[1],
          void 0,
          { alpha: !1 }
        ), P = ut.canvas;
        ut.fillStyle = E, ut.fillRect(0, 0, P.width, P.height), A.setImage(
          new Wr({
            img: P,
            anchor: G.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: G.getOrigin(),
            opacity: 1,
            size: G.getSize(),
            scale: G.getScale(),
            rotation: G.getRotation(),
            rotateWithView: G.getRotateWithView()
          })
        );
      }
      const H = A.getZIndex() || 0;
      let j = _[H];
      j || (j = {}, _[H] = j, j.Polygon = [], j.Circle = [], j.LineString = [], j.Point = []);
      const q = L.getType();
      if (q === "GeometryCollection") {
        const et = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          L.getGeometriesArrayRecursive()
        );
        for (let ut = 0, P = et.length; ut < P; ++ut) {
          const Ut = et[ut];
          j[Ut.getType().replace("Multi", "")].push(
            Ut,
            A
          );
        }
      } else
        j[q.replace("Multi", "")].push(L, A);
    }
  }
  const y = Object.keys(_).map(Number).sort(ei);
  for (let x = 0, v = y.length; x < v; ++x) {
    const C = _[y[x]];
    for (const b in C) {
      const w = C[b];
      for (let E = 0, S = w.length; E < S; E += 2) {
        g.setStyle(w[E + 1]);
        for (let R = 0, I = t.length; R < I; ++R)
          g.setTransform(t[R]), g.drawGeometry(w[E]);
      }
    }
  }
  return u.getImageData(0, 0, f.width, f.height);
}
function Wd(i, t, e) {
  const n = [];
  if (e) {
    const r = Math.floor(Math.round(i[0]) * _e), s = Math.floor(Math.round(i[1]) * _e), o = (ft(r, 0, e.width - 1) + ft(s, 0, e.height - 1) * e.width) * 4, a = e.data[o], l = e.data[o + 1], c = e.data[o + 2] + 256 * (l + 256 * a), d = Math.floor((256 * 256 * 256 - 1) / t.length);
    c && c % d === 0 && n.push(t[c / d - 1]);
  }
  return n;
}
const V4 = 0.5, Yd = {
  Point: q4,
  LineString: Z4,
  Polygon: Q4,
  MultiPoint: J4,
  MultiLineString: H4,
  MultiPolygon: K4,
  GeometryCollection: X4,
  Circle: W4
};
function $4(i, t) {
  return parseInt(Y(i), 10) - parseInt(Y(t), 10);
}
function Pa(i, t) {
  const e = Xd(i, t);
  return e * e;
}
function Xd(i, t) {
  return V4 * i / t;
}
function W4(i, t, e, n, r) {
  const s = e.getFill(), o = e.getStroke();
  if (s || o) {
    const l = i.getBuilder(e.getZIndex(), "Circle");
    l.setFillStrokeStyle(s, o), l.drawCircle(t, n, r);
  }
  const a = e.getText();
  if (a && a.getText()) {
    const l = i.getBuilder(e.getZIndex(), "Text");
    l.setTextStyle(a), l.drawText(t, n);
  }
}
function Eo(i, t, e, n, r, s, o, a) {
  const l = [], h = e.getImage();
  if (h) {
    let u = !0;
    const f = h.getImageState();
    f == z.LOADED || f == z.ERROR ? u = !1 : f == z.IDLE && h.load(), u && l.push(h.ready());
  }
  const c = e.getFill();
  c && c.loading() && l.push(c.ready());
  const d = l.length > 0;
  return d && Promise.all(l).then(() => r(null)), Y4(
    i,
    t,
    e,
    n,
    s,
    o,
    a
  ), d;
}
function Y4(i, t, e, n, r, s, o) {
  const a = e.getGeometryFunction()(t);
  if (!a)
    return;
  const l = a.simplifyTransformed(
    n,
    r
  );
  if (e.getRenderer())
    Zd(i, l, e, t, o);
  else {
    const c = Yd[l.getType()];
    c(
      i,
      l,
      e,
      t,
      o,
      s
    );
  }
}
function Zd(i, t, e, n, r) {
  if (t.getType() == "GeometryCollection") {
    const o = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      t.getGeometries()
    );
    for (let a = 0, l = o.length; a < l; ++a)
      Zd(i, o[a], e, n, r);
    return;
  }
  i.getBuilder(e.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    t,
    n,
    e.getRenderer(),
    e.getHitDetectionRenderer(),
    r
  );
}
function X4(i, t, e, n, r, s) {
  const o = t.getGeometriesArray();
  let a, l;
  for (a = 0, l = o.length; a < l; ++a) {
    const h = Yd[o[a].getType()];
    h(
      i,
      o[a],
      e,
      n,
      r,
      s
    );
  }
}
function Z4(i, t, e, n, r) {
  const s = e.getStroke();
  if (s) {
    const a = i.getBuilder(
      e.getZIndex(),
      "LineString"
    );
    a.setFillStrokeStyle(null, s), a.drawLineString(t, n, r);
  }
  const o = e.getText();
  if (o && o.getText()) {
    const a = i.getBuilder(e.getZIndex(), "Text");
    a.setTextStyle(o), a.drawText(t, n, r);
  }
}
function H4(i, t, e, n, r) {
  const s = e.getStroke();
  if (s) {
    const a = i.getBuilder(
      e.getZIndex(),
      "LineString"
    );
    a.setFillStrokeStyle(null, s), a.drawMultiLineString(t, n, r);
  }
  const o = e.getText();
  if (o && o.getText()) {
    const a = i.getBuilder(e.getZIndex(), "Text");
    a.setTextStyle(o), a.drawText(t, n, r);
  }
}
function K4(i, t, e, n, r) {
  const s = e.getFill(), o = e.getStroke();
  if (o || s) {
    const l = i.getBuilder(e.getZIndex(), "Polygon");
    l.setFillStrokeStyle(s, o), l.drawMultiPolygon(t, n, r);
  }
  const a = e.getText();
  if (a && a.getText()) {
    const l = i.getBuilder(e.getZIndex(), "Text");
    l.setTextStyle(a), l.drawText(t, n, r);
  }
}
function q4(i, t, e, n, r, s) {
  const o = e.getImage(), a = e.getText(), l = a && a.getText(), h = s && o && l ? {} : void 0;
  if (o) {
    if (o.getImageState() != z.LOADED)
      return;
    const c = i.getBuilder(e.getZIndex(), "Image");
    c.setImageStyle(o, h), c.drawPoint(t, n, r);
  }
  if (l) {
    const c = i.getBuilder(e.getZIndex(), "Text");
    c.setTextStyle(a, h), c.drawText(t, n, r);
  }
}
function J4(i, t, e, n, r, s) {
  const o = e.getImage(), a = o && o.getOpacity() !== 0, l = e.getText(), h = l && l.getText(), c = s && a && h ? {} : void 0;
  if (a) {
    if (o.getImageState() != z.LOADED)
      return;
    const d = i.getBuilder(e.getZIndex(), "Image");
    d.setImageStyle(o, c), d.drawMultiPoint(t, n, r);
  }
  if (h) {
    const d = i.getBuilder(e.getZIndex(), "Text");
    d.setTextStyle(l, c), d.drawText(t, n, r);
  }
}
function Q4(i, t, e, n, r) {
  const s = e.getFill(), o = e.getStroke();
  if (s || o) {
    const l = i.getBuilder(e.getZIndex(), "Polygon");
    l.setFillStrokeStyle(s, o), l.drawPolygon(t, n, r);
  }
  const a = e.getText();
  if (a && a.getText()) {
    const l = i.getBuilder(e.getZIndex(), "Text");
    l.setTextStyle(a), l.drawText(t, n, r);
  }
}
const t9 = 5;
class e9 extends i0 {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(t) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = t, this.staleKeys_ = new Array(), this.maxStaleKeys = t9;
  }
  /**
   * @return {Array<string>} Get the list of stale keys.
   */
  getStaleKeys() {
    return this.staleKeys_;
  }
  /**
   * @param {string} key The new stale key.
   */
  prependStaleKey(t) {
    this.staleKeys_.unshift(t), this.staleKeys_.length > this.maxStaleKeys && (this.staleKeys_.length = this.maxStaleKeys);
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(t) {
    return X();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(t) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    return X();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(t, e) {
    return X();
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, e, n, r, s) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(t) {
    const e = (
      /** @type {import("../Image.js").default} */
      t.target
    );
    (e.getState() === z.LOADED || e.getState() === z.ERROR) && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(t) {
    let e = t.getState();
    return e != z.LOADED && e != z.ERROR && t.addEventListener(V.CHANGE, this.boundHandleImageChange_), e == z.IDLE && (t.load(), e = t.getState()), e == z.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const t = this.getLayer();
    t && t.getVisible() && t.getSourceState() === "ready" && t.changed();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(t) {
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
const fc = [];
let sr = null;
function i9() {
  sr = Pt(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class jl extends e9 {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(t) {
    super(t), this.container = null, this.renderedResolution, this.tempTransform = Le(), this.pixelTransform = Le(), this.inversePixelTransform = Le(), this.context = null, this.deferredContext_ = null, this.containerReused = !1, this.frameState = null;
  }
  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(t, e, n) {
    sr || i9(), sr.clearRect(0, 0, 1, 1);
    let r;
    try {
      sr.drawImage(t, e, n, 1, 1, 0, 0, 1, 1), r = sr.getImageData(0, 0, 1, 1).data;
    } catch {
      return sr = null, null;
    }
    return r;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(t) {
    let n = this.getLayer().getBackground();
    return typeof n == "function" && (n = n(t.viewState.resolution)), n || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS transform matrix.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(t, e, n) {
    const r = this.getLayer().getClassName();
    let s, o;
    if (t && t.className === r && (!n || t && t.style.backgroundColor && Ci(
      Ln(t.style.backgroundColor),
      Ln(n)
    ))) {
      const a = t.firstElementChild;
      Di(a) && (o = a.getContext("2d"));
    }
    if (o && mg(o.canvas.style.transform, e) ? (this.container = t, this.context = o, this.containerReused = !0) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null), !this.container) {
      s = ye ? od() : document.createElement("div"), s.className = r;
      let a = s.style;
      a.position = "absolute", a.width = "100%", a.height = "100%", o = Pt();
      const l = (
        /** @type {HTMLCanvasElement} */
        o.canvas
      );
      s.appendChild(l), a = l.style, a.position = "absolute", a.left = "0", a.transformOrigin = "top left", this.container = s, this.context = o;
    }
    !this.containerReused && n && !this.container.style.backgroundColor && (this.container.style.backgroundColor = n);
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(t, e, n) {
    const r = Xe(n), s = n0(n), o = Br(n), a = Rr(n);
    Tt(e.coordinateToPixelTransform, r), Tt(e.coordinateToPixelTransform, s), Tt(e.coordinateToPixelTransform, o), Tt(e.coordinateToPixelTransform, a);
    const l = this.inversePixelTransform;
    Tt(l, r), Tt(l, s), Tt(l, o), Tt(l, a), t.save(), t.beginPath(), t.moveTo(Math.round(r[0]), Math.round(r[1])), t.lineTo(Math.round(s[0]), Math.round(s[1])), t.lineTo(Math.round(o[0]), Math.round(o[1])), t.lineTo(Math.round(a[0]), Math.round(a[1])), t.clip();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @protected
   */
  prepareContainer(t, e) {
    const n = t.extent, r = t.viewState.resolution, s = t.viewState.rotation, o = t.pixelRatio, a = Math.round(it(n) / r * o), l = Math.round(Rt(n) / r * o);
    ri(
      this.pixelTransform,
      t.size[0] / 2,
      t.size[1] / 2,
      1 / o,
      1 / o,
      s,
      -a / 2,
      -l / 2
    ), $1(this.inversePixelTransform, this.pixelTransform);
    const h = gg(this.pixelTransform);
    if (this.useContainer(e, h, this.getBackground(t)), !this.containerReused) {
      const c = this.context.canvas;
      c.width != a || c.height != l ? (c.width = a, c.height = l) : this.context.clearRect(0, 0, a, l), h !== /** @type {HTMLCanvasElement} */
      c.style.transform && (c.style.transform = h);
    }
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(t, e, n) {
    const r = this.getLayer();
    if (r.hasListener(t)) {
      const s = new Gd(
        t,
        this.inversePixelTransform,
        n,
        e
      );
      r.dispatchEvent(s);
    }
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(t, e) {
    this.frameState = e, !e.declutter && this.dispatchRenderEvent_(Re.PRERENDER, t, e);
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(t, e) {
    e.declutter || this.dispatchRenderEvent_(Re.POSTRENDER, t, e);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(t) {
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(t) {
    return t.declutter && !this.deferredContext_ && (this.deferredContext_ = new zl()), t.declutter ? this.deferredContext_.getContext() : this.context;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(t) {
    t.declutter && (this.dispatchRenderEvent_(
      Re.PRERENDER,
      this.context,
      t
    ), t.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(t), this.dispatchRenderEvent_(
      Re.POSTRENDER,
      this.context,
      t
    ));
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(t, e, n, r, s, o, a) {
    const l = s / 2, h = o / 2, c = r / e, d = -c, u = -t[0] + a, f = -t[1];
    return ri(
      this.tempTransform,
      l,
      h,
      c,
      d,
      -n,
      u,
      f
    );
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
class n9 extends jl {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(t) {
    super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.clipped_ = !1, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = ne(), this.wrappedRenderedExtent_ = ne(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.renderedFrameDeclutter_, this.replayGroup_ = null, this.replayGroupChanged = !0, this.clipping = !0, this.targetContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} [declutterable] `true` to only render declutterable items,
   *     `false` to only render non-declutterable items, `undefined` to render all.
   */
  renderWorlds(t, e, n) {
    const r = e.extent, s = e.viewState, o = s.center, a = s.resolution, l = s.projection, h = s.rotation, c = l.getExtent(), d = this.getLayer().getSource(), u = this.getLayer().getDeclutter(), f = e.pixelRatio, g = e.viewHints, p = !(g[mt.ANIMATING] || g[mt.INTERACTING]), m = this.context, _ = Math.round(it(r) / a * f), y = Math.round(Rt(r) / a * f), x = d.getWrapX() && l.canWrapX(), v = x ? it(c) : null, C = x ? Math.ceil((r[2] - c[2]) / v) + 1 : 1;
    let b = x ? Math.floor((r[0] - c[0]) / v) : 0;
    do {
      let w = this.getRenderTransform(
        o,
        a,
        0,
        f,
        _,
        y,
        b * v
      );
      e.declutter && (w = w.slice(0)), t.execute(
        m,
        [m.canvas.width, m.canvas.height],
        w,
        h,
        p,
        n === void 0 ? fn : n ? wo : j4,
        n ? u && e.declutter[u] : void 0
      );
    } while (++b < C);
  }
  /**
   * @private
   */
  setDrawContext_() {
    this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = Pt(
      this.context.canvas.width,
      this.context.canvas.height,
      fc
    ));
  }
  /**
   * @private
   */
  resetDrawContext_() {
    if (this.opacity_ !== 1 && this.targetContext_) {
      const t = this.targetContext_.globalAlpha;
      this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = t, a0(this.context), fc.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(t) {
    !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, t, !0);
  }
  /**
   * Render deferred instructions.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferredInternal(t) {
    this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.clipped_ && this.context.restore(), this.resetDrawContext_());
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(t, e) {
    const n = t.layerStatesArray[t.layerIndex];
    this.opacity_ = n.opacity;
    const r = t.viewState;
    this.prepareContainer(t, e);
    const s = this.context, o = this.replayGroup_;
    let a = o && !o.isEmpty();
    if (!a && !(this.getLayer().hasListener(Re.PRERENDER) || this.getLayer().hasListener(Re.POSTRENDER)))
      return this.container;
    if (this.setDrawContext_(), this.preRender(s, t), r.projection, this.clipped_ = !1, a && n.extent && this.clipping) {
      const l = Te(n.extent);
      a = bt(l, t.extent), this.clipped_ = a && !Be(l, t.extent), this.clipped_ && this.clipUnrotated(s, t, l);
    }
    return a && this.renderWorlds(
      o,
      t,
      this.getLayer().getDeclutter() ? !1 : void 0
    ), !t.declutter && this.clipped_ && s.restore(), this.postRender(s, t), this.renderedRotation_ !== r.rotation && (this.renderedRotation_ = r.rotation, this.hitDetectionImageData_ = null), t.declutter || this.resetDrawContext_(), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   * @override
   */
  getFeatures(t) {
    return new Promise((e) => {
      if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const n = this.frameState.size.slice(), r = this.renderedCenter_, s = this.renderedResolution_, o = this.renderedRotation_, a = this.renderedProjection_, l = this.wrappedRenderedExtent_, h = this.getLayer(), c = [], d = n[0] * _e, u = n[1] * _e;
        c.push(
          this.getRenderTransform(
            r,
            s,
            o,
            _e,
            d,
            u,
            0
          ).slice()
        );
        const f = h.getSource(), g = a.getExtent();
        if (f.getWrapX() && a.canWrapX() && !Be(g, l)) {
          let p = l[0];
          const m = it(g);
          let _ = 0, y;
          for (; p < g[0]; )
            --_, y = m * _, c.push(
              this.getRenderTransform(
                r,
                s,
                o,
                _e,
                d,
                u,
                y
              ).slice()
            ), p += m;
          for (_ = 0, p = l[2]; p > g[2]; )
            ++_, y = m * _, c.push(
              this.getRenderTransform(
                r,
                s,
                o,
                _e,
                d,
                u,
                y
              ).slice()
            ), p -= m;
        }
        this.hitDetectionImageData_ = $d(
          n,
          c,
          this.renderedFeatures_,
          h.getStyleFunction(),
          l,
          s,
          o,
          Pa(s, this.renderedPixelRatio_),
          null
        );
      }
      e(
        Wd(t, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   * @override
   */
  forEachFeatureAtCoordinate(t, e, n, r, s) {
    if (!this.replayGroup_)
      return;
    const o = e.viewState.resolution, a = e.viewState.rotation, l = this.getLayer(), h = {}, c = function(u, f, g) {
      const p = Y(u), m = h[p];
      if (m) {
        if (m !== !0 && g < m.distanceSq) {
          if (g === 0)
            return h[p] = !0, s.splice(s.lastIndexOf(m), 1), r(u, l, f);
          m.geometry = f, m.distanceSq = g;
        }
      } else {
        if (g === 0)
          return h[p] = !0, r(u, l, f);
        s.push(
          h[p] = {
            feature: u,
            layer: l,
            geometry: f,
            distanceSq: g,
            callback: r
          }
        );
      }
    }, d = this.getLayer().getDeclutter();
    return this.replayGroup_.forEachFeatureAtCoordinate(
      t,
      o,
      a,
      n,
      c,
      d ? e.declutter?.[d]?.all().map((u) => u.value) : null
    );
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @override
   */
  handleFontsChanged() {
    const t = this.getLayer();
    t.getVisible() && this.replayGroup_ && t.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(t) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(t) {
    const e = this.getLayer(), n = e.getSource();
    if (!n)
      return !1;
    const r = t.viewHints[mt.ANIMATING], s = t.viewHints[mt.INTERACTING], o = e.getUpdateWhileAnimating(), a = e.getUpdateWhileInteracting();
    if (this.ready && !o && r || !a && s)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const l = t.extent, h = t.viewState, c = h.projection, d = h.resolution, u = t.pixelRatio, f = e.getRevision(), g = e.getRenderBuffer();
    let p = e.getRenderOrder();
    p === void 0 && (p = $4);
    const m = h.center.slice(), _ = Ie(
      l,
      g * d
    ), y = _.slice(), x = [_.slice()], v = c.getExtent();
    if (n.getWrapX() && c.canWrapX() && !Be(v, t.extent)) {
      const N = it(v), K = Math.max(it(_) / 2, N);
      _[0] = v[0] - K, _[2] = v[2] + K, Bo(m, c);
      const G = P1(x[0], c);
      G[0] < v[0] && G[2] < v[2] ? x.push([
        G[0] + N,
        G[1],
        G[2] + N,
        G[3]
      ]) : G[0] > v[0] && G[2] > v[2] && x.push([
        G[0] - N,
        G[1],
        G[2] - N,
        G[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == d && this.renderedRevision_ == f && this.renderedRenderOrder_ == p && this.renderedFrameDeclutter_ === !!t.declutter && Be(this.wrappedRenderedExtent_, _))
      return Ci(this.renderedExtent_, y) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = y), this.renderedCenter_ = m, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const C = new Bd(
      Xd(d, u),
      _,
      d,
      u
    );
    let b;
    for (let N = 0, K = x.length; N < K; ++N)
      n.loadFeatures(x[N], d, c);
    const w = Pa(d, u);
    let E = !0;
    const S = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} index Index.
       */
      (N, K) => {
        let G;
        const H = N.getStyleFunction() || e.getStyleFunction();
        if (H && (G = H(N, d)), G) {
          const j = this.renderFeature(
            N,
            w,
            G,
            C,
            b,
            this.getLayer().getDeclutter(),
            K
          );
          E = E && !j;
        }
      }
    ), R = Yo(_), I = n.getFeaturesInExtent(R);
    p && I.sort(p);
    for (let N = 0, K = I.length; N < K; ++N)
      S(I[N], N);
    this.renderedFeatures_ = I, this.ready = E;
    const L = C.finish(), A = new Vd(
      _,
      d,
      u,
      n.getOverlaps(),
      L,
      e.getRenderBuffer(),
      !!t.declutter
    );
    return this.renderedResolution_ = d, this.renderedRevision_ = f, this.renderedRenderOrder_ = p, this.renderedFrameDeclutter_ = !!t.declutter, this.renderedExtent_ = y, this.wrappedRenderedExtent_ = _, this.renderedCenter_ = m, this.renderedProjection_ = c, this.renderedPixelRatio_ = u, this.replayGroup_ = A, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(t, e, n, r, s, o, a) {
    if (!n)
      return !1;
    let l = !1;
    if (Array.isArray(n))
      for (let h = 0, c = n.length; h < c; ++h)
        l = Eo(
          r,
          t,
          n[h],
          e,
          this.boundHandleStyleImageChange_,
          s,
          o,
          a
        ) || l;
    else
      l = Eo(
        r,
        t,
        n,
        e,
        this.boundHandleStyleImageChange_,
        s,
        o,
        a
      );
    return l;
  }
}
class yi extends Nl {
  /**
   * @param {Options<VectorSourceType, FeatureType>} [options] Options.
   */
  constructor(t) {
    super(t);
  }
  /**
   * @override
   */
  createRenderer() {
    return new n9(this);
  }
}
let r9 = !1;
function Hd(i, t, e, n, r, s, o) {
  const a = new XMLHttpRequest();
  a.open(
    "GET",
    typeof i == "function" ? i(e, n, r) : i,
    !0
  ), t.getType() == "arraybuffer" && (a.responseType = "arraybuffer"), a.withCredentials = r9, a.onload = function(l) {
    if (!a.status || a.status >= 200 && a.status < 300) {
      const h = t.getType();
      try {
        let c;
        h == "text" || h == "json" ? c = a.responseText : h == "xml" ? c = a.responseXML || a.responseText : h == "arraybuffer" && (c = /** @type {ArrayBuffer} */
        a.response), c ? s(
          /** @type {Array<FeatureType>} */
          t.readFeatures(c, {
            extent: e,
            featureProjection: r
          }),
          t.readProjection(c)
        ) : o();
      } catch {
        o();
      }
    } else
      o();
  }, a.onerror = o, a.send();
}
function gc(i, t) {
  return function(e, n, r, s, o) {
    Hd(
      i,
      t,
      e,
      n,
      r,
      /**
       * @param {Array<FeatureType>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      (a, l) => {
        this.addFeatures(a), s !== void 0 && s(a);
      },
      () => {
        this.changed(), o !== void 0 && o();
      }
    );
  };
}
function s9(i, t) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
class Fe extends W1 {
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  constructor(t) {
    super(), this.geometries_ = t, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
  }
  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(dt), this.changeEventsKeys_.length = 0;
  }
  /**
   * @private
   */
  listenGeometriesChange_() {
    const t = this.geometries_;
    for (let e = 0, n = t.length; e < n; ++e)
      this.changeEventsKeys_.push(
        Q(t[e], V.CHANGE, this.changed, this)
      );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   * @override
   */
  clone() {
    const t = new Fe(
      U2(this.geometries_)
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(t, e, n, r) {
    if (r < Gn(this.getExtent(), t, e))
      return r;
    const s = this.geometries_;
    for (let o = 0, a = s.length; o < a; ++o)
      r = s[o].closestPointXY(
        t,
        e,
        n,
        r
      );
    return r;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(t, e) {
    const n = this.geometries_;
    for (let r = 0, s = n.length; r < s; ++r)
      if (n[r].containsXY(t, e))
        return !0;
    return !1;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(t) {
    Ur(t);
    const e = this.geometries_;
    for (let n = 0, r = e.length; n < r; ++n)
      Ds(t, e[n].getExtent());
    return t;
  }
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return U2(this.geometries_);
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    let t = [];
    const e = this.geometries_;
    for (let n = 0, r = e.length; n < r; ++n)
      e[n].getType() === this.getType() ? t = t.concat(
        /** @type {GeometryCollection} */
        e[n].getGeometriesArrayRecursive()
      ) : t.push(e[n]);
    return t;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   * @override
   */
  getSimplifiedGeometry(t) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t < this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const e = [], n = this.geometries_;
    let r = !1;
    for (let s = 0, o = n.length; s < o; ++s) {
      const a = n[s], l = a.getSimplifiedGeometry(t);
      e.push(l), l !== a && (r = !0);
    }
    return r ? new Fe(
      e
    ) : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "GeometryCollection";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(t) {
    const e = this.geometries_;
    for (let n = 0, r = e.length; n < r; ++n)
      if (e[n].intersectsExtent(t))
        return !0;
    return !1;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   * @override
   */
  rotate(t, e) {
    const n = this.geometries_;
    for (let r = 0, s = n.length; r < s; ++r)
      n[r].rotate(t, e);
    this.changed();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   * @override
   */
  scale(t, e, n) {
    n || (n = ni(this.getExtent()));
    const r = this.geometries_;
    for (let s = 0, o = r.length; s < o; ++s)
      r[s].scale(t, e, n);
    this.changed();
  }
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(t) {
    this.setGeometriesArray(U2(t));
  }
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(t) {
    this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   * @override
   */
  applyTransform(t) {
    const e = this.geometries_;
    for (let n = 0, r = e.length; n < r; ++n)
      e[n].applyTransform(t);
    this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   * @override
   */
  translate(t, e) {
    const n = this.geometries_;
    for (let r = 0, s = n.length; r < s; ++r)
      n[r].translate(t, e);
    this.changed();
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.unlistenGeometriesChange_(), super.disposeInternal();
  }
}
function U2(i) {
  return i.map((t) => t.clone());
}
const mc = Le();
class Xt {
  /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(t, e, n, r, s, o) {
    this.styleFunction, this.extent_, this.id_ = o, this.type_ = t, this.flatCoordinates_ = e, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = n || null, this.properties_ = s, this.squaredTolerance_, this.stride_ = r, this.simplifiedGeometry_;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(t) {
    return this.properties_[t];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_ || (this.extent_ = this.type_ === "Point" ? vs(this.flatCoordinates_) : nl(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2
    )), this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const t = ni(this.getExtent());
      this.flatInteriorPoints_ = Cl(
        this.flatCoordinates_,
        0,
        this.ends_,
        2,
        t,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const t = nd(this.flatCoordinates_, this.ends_), e = jd(this.flatCoordinates_, 0, t, 2);
      this.flatInteriorPoints_ = J1(
        this.flatCoordinates_,
        0,
        t,
        2,
        e
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpoints_ || (this.flatMidpoints_ = Co(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2,
      0.5
    )), this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const t = this.flatCoordinates_;
      let e = 0;
      const n = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let r = 0, s = n.length; r < s; ++r) {
        const o = n[r], a = Co(t, e, o, 2, 0.5);
        ot(this.flatMidpoints_, a), e = o;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(t, e) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride_;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(t) {
    t = tt(t);
    const e = t.getExtent(), n = t.getWorldExtent();
    if (e && n) {
      const r = Rt(n) / Rt(e);
      ri(
        mc,
        n[0],
        n[3],
        r,
        -r,
        0,
        0,
        0
      ), Yi(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        mc,
        this.flatCoordinates_
      );
    }
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */
  applyTransform(t) {
    t(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
  }
  /**
   * @return {RenderFeature} A cloned render feature.
   */
  clone() {
    return new Xt(
      this.type_,
      this.flatCoordinates_.slice(),
      this.ends_?.slice(),
      this.stride_,
      Object.assign({}, this.properties_),
      this.id_
    );
  }
  /**
   * @return {Array<number>|null} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */
  enableSimplifyTransformed() {
    return this.simplifyTransformed = b1((t, e) => {
      if (t === this.squaredTolerance_)
        return this.simplifiedGeometry_;
      this.simplifiedGeometry_ = this.clone(), e && this.simplifiedGeometry_.applyTransform(e);
      const n = this.simplifiedGeometry_.getFlatCoordinates();
      let r;
      switch (this.type_) {
        case "LineString":
          n.length = Zo(
            n,
            0,
            this.simplifiedGeometry_.flatCoordinates_.length,
            this.simplifiedGeometry_.stride_,
            t,
            n,
            0
          ), r = [n.length];
          break;
        case "MultiLineString":
          r = [], n.length = K1(
            n,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            t,
            n,
            0,
            r
          );
          break;
        case "Polygon":
          r = [], n.length = vl(
            n,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            Math.sqrt(t),
            n,
            0,
            r
          );
          break;
      }
      return r && (this.simplifiedGeometry_ = new Xt(
        this.type_,
        n,
        r,
        2,
        this.properties_,
        this.id_
      )), this.squaredTolerance_ = t, this.simplifiedGeometry_;
    }), this;
  }
}
Xt.prototype.getFlatCoordinates = Xt.prototype.getOrientedFlatCoordinates;
class Ia {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(t) {
    this.rbush_ = new yd(t), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(t, e) {
    const n = {
      minX: t[0],
      minY: t[1],
      maxX: t[2],
      maxY: t[3],
      value: e
    };
    this.rbush_.insert(n), this.items_[Y(e)] = n;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(t, e) {
    const n = new Array(e.length);
    for (let r = 0, s = e.length; r < s; r++) {
      const o = t[r], a = e[r], l = {
        minX: o[0],
        minY: o[1],
        maxX: o[2],
        maxY: o[3],
        value: a
      };
      n[r] = l, this.items_[Y(a)] = l;
    }
    this.rbush_.load(n);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(t) {
    const e = Y(t), n = this.items_[e];
    return delete this.items_[e], this.rbush_.remove(n) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(t, e) {
    const n = this.items_[Y(e)], r = [n.minX, n.minY, n.maxX, n.maxY];
    Hi(r, t) || (this.remove(e), this.insert(t, e));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(e) {
      return e.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(t) {
    const e = {
      minX: t[0],
      minY: t[1],
      maxX: t[2],
      maxY: t[3]
    };
    return this.rbush_.search(e).map(function(r) {
      return r.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   */
  forEach(t) {
    return this.forEach_(this.getAll(), t);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   */
  forEachInExtent(t, e) {
    return this.forEach_(this.getInExtent(t), e);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   * @private
   */
  forEach_(t, e) {
    let n;
    for (let r = 0, s = t.length; r < s; r++)
      if (n = e(t[r]), n)
        return n;
    return n;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return Zi(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(t) {
    const e = this.rbush_.toJSON();
    return ii(e.minX, e.minY, e.maxX, e.maxY, t);
  }
  /**
   * @param {RBush<T>} rbush R-Tree.
   */
  concat(t) {
    this.rbush_.load(t.rbush_.all());
    for (const e in t.items_)
      this.items_[e] = t.items_[e];
  }
}
class Ul extends De {
  /**
   * @param {Options} options Source options.
   */
  constructor(t) {
    super(), this.projection = tt(t.projection), this.attributions_ = pc(t.attributions), this.attributionsCollapsible_ = t.attributionsCollapsible ?? !0, this.loading = !1, this.state_ = t.state !== void 0 ? t.state : "ready", this.wrapX_ = t.wrapX !== void 0 ? t.wrapX : !1, this.interpolate_ = !!t.interpolate, this.viewResolver = null, this.viewRejector = null;
    const e = this;
    this.viewPromise_ = new Promise(function(n, r) {
      e.viewResolver = n, e.viewRejector = r;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(t) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(t) {
    this.attributions_ = pc(t), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(t) {
    this.state_ = t, this.changed();
  }
}
function pc(i) {
  return i ? typeof i == "function" ? i : (Array.isArray(i) || (i = [i]), (t) => i) : null;
}
const re = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
class ki extends ve {
  /**
   * @param {string} type Type.
   * @param {FeatureType} [feature] Feature.
   * @param {Array<FeatureType>} [features] Features.
   */
  constructor(t, e, n) {
    super(t), this.feature = e, this.features = n;
  }
}
class e2 extends Ul {
  /**
   * @param {Options<FeatureType>} [options] Vector source options.
   */
  constructor(t) {
    t = t || {}, super({
      attributions: t.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: t.wrapX !== void 0 ? t.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = Gs, this.format_ = t.format || null, this.overlaps_ = t.overlaps === void 0 ? !0 : t.overlaps, this.url_ = t.url, t.loader !== void 0 ? this.loader_ = t.loader : this.url_ !== void 0 && (at(this.format_, "`format` must be set when `url` is set"), this.loader_ = gc(this.url_, this.format_)), this.strategy_ = t.strategy !== void 0 ? t.strategy : s9;
    const e = t.useSpatialIndex !== void 0 ? t.useSpatialIndex : !0;
    this.featuresRtree_ = e ? new Ia() : null, this.loadedExtentsRtree_ = new Ia(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let n, r;
    Array.isArray(t.features) ? r = t.features : t.features && (n = t.features, r = n.getArray()), !e && n === void 0 && (n = new Dt(r)), r !== void 0 && this.addFeaturesInternal(r), n !== void 0 && this.bindFeaturesCollection_(n);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureType} feature Feature to add.
   * @api
   */
  addFeature(t) {
    this.addFeatureInternal(t), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @protected
   */
  addFeatureInternal(t) {
    const e = Y(t);
    if (!this.addToIndex_(e, t)) {
      this.featuresCollection_ && this.featuresCollection_.remove(t);
      return;
    }
    this.setupChangeEvents_(e, t);
    const n = t.getGeometry();
    if (n) {
      const r = n.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(r, t);
    } else
      this.nullGeometryFeatures_[e] = t;
    this.dispatchEvent(
      new ki(re.ADDFEATURE, t)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @private
   */
  setupChangeEvents_(t, e) {
    e instanceof Xt || (this.featureChangeKeys_[t] = [
      Q(e, V.CHANGE, this.handleFeatureChange_, this),
      Q(
        e,
        Mn.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ]);
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(t, e) {
    let n = !0;
    if (e.getId() !== void 0) {
      const r = String(e.getId());
      if (!(r in this.idIndex_))
        this.idIndex_[r] = e;
      else if (e instanceof Xt) {
        const s = this.idIndex_[r];
        s instanceof Xt ? Array.isArray(s) ? s.push(e) : this.idIndex_[r] = [s, e] : n = !1;
      } else
        n = !1;
    }
    return n && (at(
      !(t in this.uidIndex_),
      "The passed `feature` was already added to the source"
    ), this.uidIndex_[t] = e), n;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<FeatureType>} features Features to add.
   * @api
   */
  addFeatures(t) {
    this.addFeaturesInternal(t), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureType>} features Features.
   * @protected
   */
  addFeaturesInternal(t) {
    const e = [], n = [], r = [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s], l = Y(a);
      this.addToIndex_(l, a) && n.push(a);
    }
    for (let s = 0, o = n.length; s < o; s++) {
      const a = n[s], l = Y(a);
      this.setupChangeEvents_(l, a);
      const h = a.getGeometry();
      if (h) {
        const c = h.getExtent();
        e.push(c), r.push(a);
      } else
        this.nullGeometryFeatures_[l] = a;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(e, r), this.hasListener(re.ADDFEATURE))
      for (let s = 0, o = n.length; s < o; s++)
        this.dispatchEvent(
          new ki(re.ADDFEATURE, n[s])
        );
  }
  /**
   * @param {!Collection<FeatureType>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(t) {
    let e = !1;
    this.addEventListener(
      re.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(n) {
        e || (e = !0, t.push(n.feature), e = !1);
      }
    ), this.addEventListener(
      re.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(n) {
        e || (e = !0, t.remove(n.feature), e = !1);
      }
    ), t.addEventListener(
      Yt.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (n) => {
        e || (e = !0, this.addFeature(n.element), e = !1);
      }
    ), t.addEventListener(
      Yt.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (n) => {
        e || (e = !0, this.removeFeature(n.element), e = !1);
      }
    ), this.featuresCollection_ = t;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(t) {
    if (t) {
      for (const n in this.featureChangeKeys_)
        this.featureChangeKeys_[n].forEach(dt);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      this.featuresRtree_.forEach((n) => {
        this.removeFeatureInternal(n);
      });
      for (const n in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[n]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const e = new ki(re.CLEAR);
    this.dispatchEvent(e), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureType): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(t) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(t);
    this.featuresCollection_ && this.featuresCollection_.forEach(t);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(t, e) {
    const n = [t[0], t[1], t[0], t[1]];
    return this.forEachFeatureInExtent(n, function(r) {
      const s = r.getGeometry();
      if (s instanceof Xt || s.intersectsCoordinate(t))
        return e(r);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(t, e) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(t, e);
    this.featuresCollection_ && this.featuresCollection_.forEach(e);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(t, e) {
    return this.forEachFeatureInExtent(
      t,
      /**
       * @param {FeatureType} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(n) {
        const r = n.getGeometry();
        if (r instanceof Xt || r.intersectsExtent(t)) {
          const s = e(n);
          if (s)
            return s;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with a {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureType>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    let t;
    return this.featuresCollection_ ? t = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), Zi(this.nullGeometryFeatures_) || ot(t, Object.values(this.nullGeometryFeatures_))), t;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesAtCoordinate(t) {
    const e = [];
    return this.forEachFeatureAtCoordinateDirect(t, function(n) {
      e.push(n);
    }), e;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(t, e) {
    if (this.featuresRtree_) {
      if (!(e && e.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(t);
      const r = I1(t, e);
      return [].concat(
        ...r.map((s) => this.featuresRtree_.getInExtent(s))
      );
    }
    return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureType|null} Closest feature (or `null` if none found).
   * @api
   */
  getClosestFeatureToCoordinate(t, e) {
    const n = t[0], r = t[1];
    let s = null;
    const o = [NaN, NaN];
    let a = 1 / 0;
    const l = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return e = e || Tr, this.featuresRtree_.forEachInExtent(
      l,
      /**
       * @param {FeatureType} feature Feature.
       */
      function(h) {
        if (e(h)) {
          const c = h.getGeometry(), d = a;
          if (a = c instanceof Xt ? 0 : c.closestPointXY(n, r, o, a), a < d) {
            s = h;
            const u = Math.sqrt(a);
            l[0] = n - u, l[1] = r - u, l[2] = n + u, l[3] = r + u;
          }
        }
      }
    ), s;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(t) {
    return this.featuresRtree_.getExtent(t);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(t) {
    const e = this.idIndex_[t.toString()];
    return e !== void 0 ? (
      /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
      e
    ) : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureType|null} The feature (or `null` if not found).
   */
  getFeatureByUid(t) {
    const e = this.uidIndex_[t];
    return e !== void 0 ? e : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default<FeatureType>|null}} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(t) {
    const e = (
      /** @type {FeatureType} */
      t.target
    ), n = Y(e), r = e.getGeometry();
    if (!r)
      n in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e), this.nullGeometryFeatures_[n] = e);
    else {
      const o = r.getExtent();
      n in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[n], this.featuresRtree_ && this.featuresRtree_.insert(o, e)) : this.featuresRtree_ && this.featuresRtree_.update(o, e);
    }
    const s = e.getId();
    if (s !== void 0) {
      const o = s.toString();
      this.idIndex_[o] !== e && (this.removeFromIdIndex_(e), this.idIndex_[o] = e);
    } else
      this.removeFromIdIndex_(e), this.uidIndex_[n] = e;
    this.changed(), this.dispatchEvent(
      new ki(re.CHANGEFEATURE, e)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureType} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(t) {
    const e = t.getId();
    return e !== void 0 ? e in this.idIndex_ : Y(t) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && Zi(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(t, e, n) {
    const r = this.loadedExtentsRtree_, s = this.strategy_(t, e, n);
    for (let o = 0, a = s.length; o < a; ++o) {
      const l = s[o];
      r.forEachInExtent(
        l,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(c) {
          return Be(c.extent, l);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new ki(re.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        l,
        e,
        n,
        /**
         * @param {Array<FeatureType>} features Loaded features
         */
        (c) => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new ki(
              re.FEATURESLOADEND,
              void 0,
              c
            )
          );
        },
        () => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new ki(re.FEATURESLOADERROR)
          );
        }
      ), r.insert(l, { extent: l.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  /**
   * @override
   */
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(t) {
    const e = this.loadedExtentsRtree_, n = e.forEachInExtent(t, function(r) {
      if (Hi(r.extent, t))
        return r;
    });
    n && e.remove(n);
  }
  /**
   * Batch remove features from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {Array<FeatureType>} features Features to remove.
   * @api
   */
  removeFeatures(t) {
    let e = !1;
    for (let n = 0, r = t.length; n < r; ++n)
      e = this.removeFeatureInternal(t[n]) || e;
    e && this.changed();
  }
  /**
   * Remove a single feature from the source. If you want to batch remove
   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
   * instead.
   * @param {FeatureType} feature Feature to remove.
   * @api
   */
  removeFeature(t) {
    if (!t)
      return;
    this.removeFeatureInternal(t) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @return {boolean} True if the feature was removed, false if it was not found.
   * @protected
   */
  removeFeatureInternal(t) {
    const e = Y(t);
    if (!(e in this.uidIndex_))
      return !1;
    e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e] : this.featuresRtree_ && this.featuresRtree_.remove(t), this.featureChangeKeys_[e]?.forEach(dt), delete this.featureChangeKeys_[e];
    const r = t.getId();
    if (r !== void 0) {
      const s = r.toString(), o = this.idIndex_[s];
      o === t ? delete this.idIndex_[s] : Array.isArray(o) && (o.splice(o.indexOf(t), 1), o.length === 1 && (this.idIndex_[s] = o[0]));
    }
    return delete this.uidIndex_[e], this.hasListener(re.REMOVEFEATURE) && this.dispatchEvent(
      new ki(re.REMOVEFEATURE, t)
    ), !0;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureType} feature The feature.
   * @private
   */
  removeFromIdIndex_(t) {
    for (const e in this.idIndex_)
      if (this.idIndex_[e] === t) {
        delete this.idIndex_[e];
        break;
      }
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(t) {
    this.loader_ = t;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(t) {
    at(this.format_, "`format` must be set when `url` is set"), this.url_ = t, this.setLoader(gc(t, this.format_));
  }
  /**
   * @param {boolean} overlaps The source can have overlapping geometries.
   */
  setOverlaps(t) {
    this.overlaps_ = t, this.changed();
  }
}
function ji(i, t) {
  const e = i.length;
  return t < 0 ? i[t + e] : t >= e ? i[t - e] : i[t];
}
function cr(i, t) {
  const e = i.length;
  let n = Math.floor(t);
  const r = t - n;
  n >= e ? n -= e : n < 0 && (n += e);
  let s = n + 1;
  s >= e && (s -= e);
  const o = i[n], a = o[0], l = o[1], h = i[s], c = h[0] - a, d = h[1] - l;
  return [a + c * r, l + d * r];
}
const A0 = {
  index: -1,
  endIndex: NaN,
  closestTargetDistance: 1 / 0
};
function Kd(i, t, e, n) {
  const r = i[0], s = i[1];
  let o = 1 / 0, a = -1, l = NaN;
  for (let d = 0; d < t.targets.length; ++d) {
    const u = t.targets[d], f = u.coordinates;
    let g = 1 / 0, p;
    for (let m = 0; m < f.length - 1; ++m) {
      const _ = f[m], y = f[m + 1], x = Qd(r, s, _, y);
      x.squaredDistance < g && (g = x.squaredDistance, p = m + x.along);
    }
    g < o && (o = g, u.ring && t.targetIndex === d && (u.endIndex > u.startIndex ? p < u.startIndex && (p += f.length) : u.endIndex < u.startIndex && p > u.startIndex && (p -= f.length)), l = p, a = d);
  }
  const h = t.targets[a];
  let c = h.ring;
  if (t.targetIndex === a && c) {
    const d = cr(
      h.coordinates,
      l
    ), u = e.getPixelFromCoordinate(d), f = e.getPixelFromCoordinate(t.startCoord);
    lr(u, f) > n && (c = !1);
  }
  if (c) {
    const d = h.coordinates, u = d.length, f = h.startIndex, g = l;
    if (f < g) {
      const p = G0(
        d,
        f,
        g
      );
      G0(
        d,
        f,
        g - u
      ) < p && (l -= u);
    } else {
      const p = G0(
        d,
        f,
        g
      );
      G0(
        d,
        f,
        g + u
      ) < p && (l += u);
    }
  }
  return A0.index = a, A0.endIndex = l, A0.closestTargetDistance = o, A0;
}
function qd(i, t) {
  const e = [];
  for (let n = 0; n < t.length; ++n) {
    const s = t[n].getGeometry();
    Jd(i, s, e);
  }
  return e;
}
function Jd(i, t, e) {
  if (t instanceof Kt) {
    F0(i, t.getCoordinates(), !1, e);
    return;
  }
  if (t instanceof oi) {
    const n = t.getCoordinates();
    for (let r = 0, s = n.length; r < s; ++r)
      F0(i, n[r], !1, e);
    return;
  }
  if (t instanceof jt) {
    const n = t.getCoordinates();
    for (let r = 0, s = n.length; r < s; ++r)
      F0(i, n[r], !0, e);
    return;
  }
  if (t instanceof xi) {
    const n = t.getCoordinates();
    for (let r = 0, s = n.length; r < s; ++r) {
      const o = n[r];
      for (let a = 0, l = o.length; a < l; ++a)
        F0(i, o[a], !0, e);
    }
    return;
  }
  if (t instanceof Fe) {
    const n = t.getGeometries();
    for (let r = 0; r < n.length; ++r)
      Jd(i, n[r], e);
    return;
  }
}
function F0(i, t, e, n) {
  const r = i[0], s = i[1];
  for (let o = 0, a = t.length - 1; o < a; ++o) {
    const l = t[o], h = t[o + 1], c = Qd(r, s, l, h);
    if (c.squaredDistance === 0) {
      const d = o + c.along;
      n.push({
        coordinates: t,
        ring: e,
        startIndex: d,
        endIndex: d
      });
      return;
    }
  }
}
function O0(i, t) {
  return mi(i[0], i[1], t[0], t[1]);
}
function G0(i, t, e) {
  let n, r;
  t < e ? (n = t, r = e) : (n = e, r = t);
  const s = Math.ceil(n), o = Math.floor(r);
  if (s > o) {
    const l = cr(i, n), h = cr(i, r);
    return O0(l, h);
  }
  let a = 0;
  if (n < s) {
    const l = cr(i, n), h = ji(i, s);
    a += O0(l, h);
  }
  if (o < r) {
    const l = ji(i, o), h = cr(i, r);
    a += O0(l, h);
  }
  for (let l = s; l < o - 1; ++l) {
    const h = ji(i, l), c = ji(i, l + 1);
    a += O0(h, c);
  }
  return a;
}
const B2 = { along: 0, squaredDistance: 0 };
function Qd(i, t, e, n) {
  const r = e[0], s = e[1], o = n[0], a = n[1], l = o - r, h = a - s;
  let c = 0, d = r, u = s;
  return (l !== 0 || h !== 0) && (c = ft(((i - r) * l + (t - s) * h) / (l * l + h * h), 0, 1), d += l * c, u += h * c), B2.along = c, B2.squaredDistance = jr(mi(i, t, d, u), 10), B2;
}
const N0 = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: "drawstart",
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: "drawend",
  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: "drawabort"
};
class D0 extends ve {
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */
  constructor(t, e) {
    super(t), this.feature = e;
  }
}
class o9 extends jn {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    const e = (
      /** @type {import("./Pointer.js").Options} */
      t
    );
    e.stopDown || (e.stopDown = zr), super(e), this.on, this.once, this.un, this.options_ = t, this.shouldHandle_ = !1, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = !1, this.source_ = t.source ? t.source : null, this.features_ = t.features ? t.features : null, this.snapTolerance_ = t.snapTolerance ? t.snapTolerance : 12, this.type_ = /** @type {import("../geom/Geometry.js").Type} */
    t.type, this.mode_ = h9(this.type_), this.stopClick_ = !!t.stopClick, this.ignoreNextUpEvent_ = !1, this.minPoints_ = t.minPoints ? t.minPoints : this.mode_ === "Polygon" ? 3 : 2, this.maxPoints_ = this.mode_ === "Circle" ? 2 : t.maxPoints ? t.maxPoints : 1 / 0, this.finishCondition_ = t.finishCondition ? t.finishCondition : Tr, this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : "XY";
    let n = t.geometryFunction;
    if (!n) {
      const r = this.mode_;
      if (r === "Circle")
        n = (s, o, a) => {
          const l = o || new t2([NaN, NaN]), h = pt(s[0]), c = Pr(
            h,
            pt(s[s.length - 1])
          );
          return l.setCenterAndRadius(
            h,
            Math.sqrt(c),
            this.geometryLayout_
          ), l;
        };
      else {
        let s;
        r === "Point" ? s = de : r === "LineString" ? s = Kt : r === "Polygon" && (s = jt), n = (o, a, l) => (a ? r === "Polygon" ? o[0].length ? a.setCoordinates(
          [o[0].concat([o[0][0]])],
          this.geometryLayout_
        ) : a.setCoordinates([], this.geometryLayout_) : a.setCoordinates(o, this.geometryLayout_) : a = new s(o, this.geometryLayout_), a);
      }
    }
    this.geometryFunction_ = n, this.dragVertexDelay_ = t.dragVertexDelay !== void 0 ? t.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = t.clickTolerance ? t.clickTolerance * t.clickTolerance : 36, this.overlay_ = new yi({
      source: new e2({
        useSpatialIndex: !1,
        wrapX: t.wrapX ? t.wrapX : !1
      }),
      style: t.style ? t.style : a9(),
      updateWhileInteracting: !0
    }), this.geometryName_ = t.geometryName, this.condition_ = t.condition ? t.condition : Pl, this.freehandCondition_, t.freehand ? this.freehandCondition_ = _r : this.freehandCondition_ = t.freehandCondition ? t.freehandCondition : Ea, this.traceCondition_, this.setTrace(t.trace || !1), this.traceState_ = { active: !1 }, this.traceSource_ = t.traceSource || t.source || null, this.addChangeListener(ba.ACTIVE, this.updateState_);
  }
  /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */
  setTrace(t) {
    let e;
    t ? t === !0 ? e = _r : e = t : e = ud, this.traceCondition_ = e;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   * @override
   */
  setMap(t) {
    super.setMap(t), this.updateState_();
  }
  /**
   * Set whether the drawing is done in freehand mode.
   *
   * @param {boolean} freehand Freehand drawing.
   * @api
   */
  setFreehand(t) {
    this.freehand_ = t, this.freehand_ ? this.freehandCondition_ = _r : this.freehandCondition_ = this.options_ && this.options_.freehandCondition ? this.options_.freehandCondition : Ea;
  }
  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * Get if this interaction is in freehand mode.
   * @return {boolean} Freehand drawing.
   * @api
   */
  getFreehand() {
    return this.freehand_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default<PointerEvent>} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   * @override
   */
  handleEvent(t) {
    t.originalEvent.type === V.CONTEXTMENU && t.originalEvent.preventDefault(), this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(t);
    let e = t.type === rt.POINTERMOVE, n = !0;
    return !this.freehand_ && this.lastDragTime_ && t.type === rt.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = t.pixel, this.shouldHandle_ = !this.freehand_, e = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && this.downTimeout_ !== void 0 && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0)), this.freehand_ && t.type === rt.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(t.coordinate), n = !1) : this.freehand_ && t.type === rt.POINTERDOWN ? n = !1 : e && this.getPointerCount() < 2 ? (n = t.type === rt.POINTERMOVE, n && this.freehand_ ? (this.handlePointerMove_(t), this.shouldHandle_ && t.originalEvent.preventDefault()) : (t.originalEvent.pointerType === "mouse" || t.type === rt.POINTERDRAG && this.downTimeout_ === void 0) && this.handlePointerMove_(t)) : t.type === rt.DBLCLICK && (n = !1), super.handleEvent(t) && n;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default<PointerEvent>} event Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(t) {
    return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = t.pixel, this.finishCoordinate_ || this.startDrawing_(t.coordinate), !0) : this.condition_(t) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(() => {
      this.handlePointerMove_(
        new fi(
          rt.POINTERMOVE,
          t.map,
          t.originalEvent,
          !1,
          t.frameState
        )
      );
    }, this.dragVertexDelay_), this.downPx_ = t.pixel, !0) : (this.lastDragTime_ = void 0, !1);
  }
  /**
   * @private
   */
  deactivateTrace_() {
    this.traceState_ = { active: !1 };
  }
  /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  toggleTraceState_(t) {
    if (!this.traceSource_ || !this.traceCondition_(t))
      return;
    if (this.traceState_.active) {
      this.deactivateTrace_();
      return;
    }
    const e = this.getMap(), n = e.getCoordinateFromPixel([
      t.pixel[0] - this.snapTolerance_,
      t.pixel[1] + this.snapTolerance_
    ]), r = e.getCoordinateFromPixel([
      t.pixel[0] + this.snapTolerance_,
      t.pixel[1] - this.snapTolerance_
    ]), s = Gt([n, r]), o = this.traceSource_.getFeaturesInExtent(s);
    if (o.length === 0)
      return;
    const a = qd(t.coordinate, o);
    a.length && (this.traceState_ = {
      active: !0,
      startCoord: t.coordinate.slice(),
      targets: a,
      targetIndex: -1
    });
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */
  addOrRemoveTracedCoordinates_(t, e) {
    const n = t.startIndex <= t.endIndex, r = t.startIndex <= e;
    n === r ? n && e > t.endIndex || !n && e < t.endIndex ? this.addTracedCoordinates_(t, t.endIndex, e) : (n && e < t.endIndex || !n && e > t.endIndex) && this.removeTracedCoordinates_(e, t.endIndex) : (this.removeTracedCoordinates_(t.startIndex, t.endIndex), this.addTracedCoordinates_(t, t.startIndex, e));
  }
  /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  removeTracedCoordinates_(t, e) {
    if (t === e)
      return;
    let n = 0;
    if (t < e) {
      const r = Math.ceil(t);
      let s = Math.floor(e);
      s === e && (s -= 1), n = s - r + 1;
    } else {
      const r = Math.floor(t);
      let s = Math.ceil(e);
      s === e && (s += 1), n = r - s + 1;
    }
    n > 0 && this.removeLastPoints_(n);
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  addTracedCoordinates_(t, e, n) {
    if (e === n)
      return;
    const r = [];
    if (e < n) {
      const s = Math.ceil(e);
      let o = Math.floor(n);
      o === n && (o -= 1);
      for (let a = s; a <= o; ++a)
        r.push(ji(t.coordinates, a));
    } else {
      const s = Math.floor(e);
      let o = Math.ceil(n);
      o === n && (o += 1);
      for (let a = s; a >= o; --a)
        r.push(ji(t.coordinates, a));
    }
    r.length && this.appendCoordinates(r);
  }
  /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  updateTrace_(t) {
    const e = this.traceState_;
    if (!e.active)
      return;
    if (e.targetIndex === -1) {
      const a = t.map.getPixelFromCoordinate(e.startCoord);
      if (lr(a, t.pixel) < this.snapTolerance_)
        return;
    }
    const n = Kd(
      t.coordinate,
      e,
      this.getMap(),
      this.snapTolerance_
    );
    if (e.targetIndex !== n.index) {
      if (e.targetIndex !== -1) {
        const l = e.targets[e.targetIndex];
        this.removeTracedCoordinates_(l.startIndex, l.endIndex);
      }
      const a = e.targets[n.index];
      this.addTracedCoordinates_(
        a,
        a.startIndex,
        n.endIndex
      );
    } else {
      const a = e.targets[e.targetIndex];
      this.addOrRemoveTracedCoordinates_(a, n.endIndex);
    }
    e.targetIndex = n.index;
    const r = e.targets[e.targetIndex];
    r.endIndex = n.endIndex;
    const s = cr(
      r.coordinates,
      r.endIndex
    ), o = this.getMap().getPixelFromCoordinate(s);
    t.coordinate = s, t.pixel = [Math.round(o[0]), Math.round(o[1])];
  }
  /**
   * Handle drag events.
   * @param {import("../MapBrowserEvent.js").default<PointerEvent>} event Event.
   * @override
   */
  handleDragEvent(t) {
    this.ignoreNextUpEvent_ = !0, super.handleDragEvent(t);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default<PointerEvent>} event Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(t) {
    let e = !0;
    if (this.getPointerCount() === 0) {
      this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(t);
      const n = this.traceState_.active;
      if (this.ignoreNextUpEvent_ || this.toggleTraceState_(t), this.shouldHandle_) {
        const r = !this.finishCoordinate_;
        r && this.startDrawing_(t.coordinate), !r && this.freehand_ ? this.finishDrawing() : !this.freehand_ && (!r || this.mode_ === "Point") && (this.atFinish_(t.pixel, n) ? this.finishCondition_(t) && this.finishDrawing() : this.addToDrawing_(t.coordinate)), e = !1;
      } else this.freehand_ && this.abortDrawing();
    }
    return this.ignoreNextUpEvent_ = !1, !e && this.stopClick_ && t.preventDefault(), e;
  }
  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default<PointerEvent>} event A move event.
   * @private
   */
  handlePointerMove_(t) {
    if (this.pointerType_ = t.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      const e = this.downPx_, n = t.pixel, r = e[0] - n[0], s = e[1] - n[1], o = r * r + s * s;
      if (this.shouldHandle_ = this.freehand_ ? o > this.squaredClickTolerance_ : o <= this.squaredClickTolerance_, !this.shouldHandle_)
        return;
    }
    if (!this.finishCoordinate_) {
      this.createOrUpdateSketchPoint_(t.coordinate.slice());
      return;
    }
    this.updateTrace_(t), this.modifyDrawing_(t.coordinate);
  }
  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  atFinish_(t, e) {
    let n = !1;
    if (this.sketchFeature_) {
      let r = !1, s = [this.finishCoordinate_];
      const o = this.mode_;
      if (o === "Point")
        n = !0;
      else if (o === "Circle")
        n = this.sketchCoords_.length === 2;
      else if (o === "LineString")
        r = !e && this.sketchCoords_.length > this.minPoints_;
      else if (o === "Polygon") {
        const a = (
          /** @type {PolyCoordType} */
          this.sketchCoords_
        );
        r = a[0].length > this.minPoints_, s = [
          a[0][0],
          a[0][a[0].length - 2]
        ], e ? s = [a[0][0]] : s = [
          a[0][0],
          a[0][a[0].length - 2]
        ];
      }
      if (r) {
        const a = this.getMap();
        for (let l = 0, h = s.length; l < h; l++) {
          const c = s[l], d = a.getPixelFromCoordinate(c), u = t[0] - d[0], f = t[1] - d[1], g = this.freehand_ ? 1 : this.snapTolerance_;
          if (n = Math.sqrt(u * u + f * f) <= g, n) {
            this.finishCoordinate_ = c;
            break;
          }
        }
      }
    }
    return n;
  }
  /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */
  createOrUpdateSketchPoint_(t) {
    this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(t) : (this.sketchPoint_ = new Lt(new de(t)), this.updateSketchFeatures_());
  }
  /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */
  createOrUpdateCustomSketchLine_(t) {
    this.sketchLine_ || (this.sketchLine_ = new Lt());
    const e = t.getLinearRing(0);
    let n = this.sketchLine_.getGeometry();
    n ? (n.setFlatCoordinates(
      e.getLayout(),
      e.getFlatCoordinates()
    ), n.changed()) : (n = new Kt(
      e.getFlatCoordinates(),
      e.getLayout()
    ), this.sketchLine_.setGeometry(n));
  }
  /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */
  startDrawing_(t) {
    const e = this.getMap().getView().getProjection(), n = co(this.geometryLayout_);
    for (; t.length < n; )
      t.push(0);
    this.finishCoordinate_ = t, this.mode_ === "Point" ? this.sketchCoords_ = t.slice() : this.mode_ === "Polygon" ? (this.sketchCoords_ = [[t.slice(), t.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [t.slice(), t.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new Lt(new Kt(this.sketchLineCoords_)));
    const r = this.geometryFunction_(
      this.sketchCoords_,
      void 0,
      e
    );
    this.sketchFeature_ = new Lt(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(r), this.updateSketchFeatures_(), this.dispatchEvent(
      new D0(N0.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */
  modifyDrawing_(t) {
    const e = this.getMap(), n = this.sketchFeature_.getGeometry(), r = e.getView().getProjection(), s = co(this.geometryLayout_);
    let o, a;
    for (; t.length < s; )
      t.push(0);
    this.mode_ === "Point" ? a = this.sketchCoords_ : this.mode_ === "Polygon" ? (o = /** @type {PolyCoordType} */
    this.sketchCoords_[0], a = o[o.length - 1], this.atFinish_(e.getPixelFromCoordinate(t)) && (t = this.finishCoordinate_.slice())) : (o = this.sketchCoords_, a = o[o.length - 1]), a[0] = t[0], a[1] = t[1], this.geometryFunction_(
      /** @type {!LineCoordType} */
      this.sketchCoords_,
      n,
      r
    ), this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(t), n.getType() === "Polygon" && this.mode_ !== "Polygon" ? this.createOrUpdateCustomSketchLine_(
      /** @type {Polygon} */
      n
    ) : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_), this.updateSketchFeatures_();
  }
  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @return {Feature<import("../geom/SimpleGeometry.js").default>} The sketch feature.
   * @private
   */
  addToDrawing_(t) {
    const e = this.sketchFeature_.getGeometry(), n = this.getMap().getView().getProjection();
    let r, s;
    const o = this.mode_;
    return o === "LineString" || o === "Circle" ? (this.finishCoordinate_ = t.slice(), s = /** @type {LineCoordType} */
    this.sketchCoords_, s.length >= this.maxPoints_ && (this.freehand_ ? s.pop() : r = !0), s.push(t.slice()), this.geometryFunction_(s, e, n)) : o === "Polygon" && (s = /** @type {PolyCoordType} */
    this.sketchCoords_[0], s.length >= this.maxPoints_ && (this.freehand_ ? s.pop() : r = !0), s.push(t.slice()), r && (this.finishCoordinate_ = s[0]), this.geometryFunction_(this.sketchCoords_, e, n)), this.createOrUpdateSketchPoint_(t.slice()), this.updateSketchFeatures_(), r ? this.finishDrawing() : this.sketchFeature_;
  }
  /**
   * @param {number} n The number of points to remove.
   */
  removeLastPoints_(t) {
    if (!this.sketchFeature_)
      return;
    const e = this.sketchFeature_.getGeometry(), n = this.getMap().getView().getProjection(), r = this.mode_;
    for (let s = 0; s < t; ++s) {
      let o;
      if (r === "LineString" || r === "Circle") {
        if (o = /** @type {LineCoordType} */
        this.sketchCoords_, o.splice(-2, 1), o.length >= 2) {
          this.finishCoordinate_ = o[o.length - 2].slice();
          const a = this.finishCoordinate_.slice();
          o[o.length - 1] = a, this.createOrUpdateSketchPoint_(a);
        }
        this.geometryFunction_(o, e, n), e.getType() === "Polygon" && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(
          /** @type {Polygon} */
          e
        );
      } else if (r === "Polygon") {
        o = /** @type {PolyCoordType} */
        this.sketchCoords_[0], o.splice(-2, 1);
        const a = this.sketchLine_.getGeometry();
        if (o.length >= 2) {
          const l = o[o.length - 2].slice();
          o[o.length - 1] = l, this.createOrUpdateSketchPoint_(l);
        }
        a.setCoordinates(o), this.geometryFunction_(this.sketchCoords_, e, n);
      }
      if (o.length === 1) {
        this.abortDrawing();
        break;
      }
    }
    this.updateSketchFeatures_();
  }
  /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */
  removeLastPoint() {
    this.removeLastPoints_(1);
  }
  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The drawn feature.
   * @api
   */
  finishDrawing() {
    const t = this.abortDrawing_();
    if (!t)
      return null;
    let e = this.sketchCoords_;
    const n = t.getGeometry(), r = this.getMap().getView().getProjection();
    return this.mode_ === "LineString" ? (e.pop(), this.geometryFunction_(e, n, r)) : this.mode_ === "Polygon" && (e[0].pop(), this.geometryFunction_(e, n, r), e = n.getCoordinates()), this.type_ === "MultiPoint" ? t.setGeometry(
      new nn([
        /** @type {PointCoordType} */
        e
      ])
    ) : this.type_ === "MultiLineString" ? t.setGeometry(
      new oi([
        /** @type {LineCoordType} */
        e
      ])
    ) : this.type_ === "MultiPolygon" && t.setGeometry(
      new xi([
        /** @type {PolyCoordType} */
        e
      ])
    ), this.dispatchEvent(new D0(N0.DRAWEND, t)), this.features_ && this.features_.push(t), this.source_ && this.source_.addFeature(t), t;
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */
  abortDrawing_() {
    this.finishCoordinate_ = null;
    const t = this.sketchFeature_;
    return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0), this.deactivateTrace_(), t;
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */
  abortDrawing() {
    const t = this.abortDrawing_();
    t && this.dispatchEvent(new D0(N0.DRAWABORT, t));
  }
  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */
  appendCoordinates(t) {
    const e = this.mode_, n = !this.sketchFeature_;
    n && this.startDrawing_(t[0]);
    let r;
    if (e === "LineString" || e === "Circle")
      r = /** @type {LineCoordType} */
      this.sketchCoords_;
    else if (e === "Polygon")
      r = this.sketchCoords_ && this.sketchCoords_.length ? (
        /** @type {PolyCoordType} */
        this.sketchCoords_[0]
      ) : [];
    else
      return;
    n && r.shift(), r.pop();
    for (let o = 0; o < t.length; o++)
      this.addToDrawing_(t[o]);
    const s = t[t.length - 1];
    this.sketchFeature_ = this.addToDrawing_(s), this.modifyDrawing_(s);
  }
  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */
  extend(t) {
    const n = t.getGeometry();
    this.sketchFeature_ = t, this.sketchCoords_ = n.getCoordinates();
    const r = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = r.slice(), this.sketchCoords_.push(r.slice()), this.sketchPoint_ = new Lt(new de(r)), this.updateSketchFeatures_(), this.dispatchEvent(
      new D0(N0.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Redraw the sketch features.
   * @private
   */
  updateSketchFeatures_() {
    const t = [];
    this.sketchFeature_ && t.push(this.sketchFeature_), this.sketchLine_ && t.push(this.sketchLine_), this.sketchPoint_ && t.push(this.sketchPoint_);
    const e = this.overlay_.getSource();
    e.clear(!0), e.addFeatures(t);
  }
  /**
   * @private
   */
  updateState_() {
    const t = this.getMap(), e = this.getActive();
    (!t || !e) && this.abortDrawing(), this.overlay_.setMap(e ? t : null);
  }
}
function a9() {
  const i = kd();
  return function(t, e) {
    return i[t.getGeometry().getType()];
  };
}
function l9() {
  return function(i, t, e) {
    const n = Gt(
      /** @type {LineCoordType} */
      [
        i[0],
        i[i.length - 1]
      ].map(function(s) {
        return pt(s);
      })
    ), r = [
      [
        Rr(n),
        Br(n),
        n0(n),
        Xe(n),
        Rr(n)
      ]
    ];
    return t ? t.setCoordinates(r) : t = new jt(r), t;
  };
}
function h9(i) {
  switch (i) {
    case "Point":
    case "MultiPoint":
      return "Point";
    case "LineString":
    case "MultiLineString":
      return "LineString";
    case "Polygon":
    case "MultiPolygon":
      return "Polygon";
    case "Circle":
      return "Circle";
    default:
      throw new Error("Invalid type: " + i);
  }
}
const _c = 0, Es = 1, yc = [0, 0, 0, 0], vr = [], V2 = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: "modifystart",
  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: "modifyend"
};
function $2(i, t, e) {
  let n;
  switch (t) {
    case "LineString":
      n = i;
      break;
    case "MultiLineString":
    case "Polygon":
      n = i[e[0]];
      break;
    case "MultiPolygon":
      n = i[e[1]][e[0]];
      break;
  }
  return n;
}
class W2 extends ve {
  /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(t, e, n) {
    super(t), this.features = e, this.mapBrowserEvent = n;
  }
}
class c9 extends jn {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    super(
      /** @type {import("./Pointer.js").Options} */
      t
    ), this.on, this.once, this.un, this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this), this.condition_ = t.condition ? t.condition : gd, this.defaultDeleteCondition_ = function(n) {
      return Zg(n) && qg(n);
    }, this.deleteCondition_ = t.deleteCondition ? t.deleteCondition : this.defaultDeleteCondition_, this.insertVertexCondition_ = t.insertVertexCondition ? t.insertVertexCondition : _r, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastCoordinate_ = [0, 0], this.ignoreNextSingleClick_ = !1, this.featuresBeingModified_ = null, this.rBush_ = new Ia(), this.pixelTolerance_ = t.pixelTolerance !== void 0 ? t.pixelTolerance : 10, this.snappedToVertex_ = !1, this.changingFeature_ = !1, this.dragSegments_ = [], this.overlay_ = new yi({
      source: new e2({
        useSpatialIndex: !1,
        wrapX: !!t.wrapX
      }),
      style: t.style ? t.style : u9(),
      updateWhileAnimating: !0,
      updateWhileInteracting: !0
    }), this.SEGMENT_WRITERS_ = {
      Point: this.writePointGeometry_.bind(this),
      LineString: this.writeLineStringGeometry_.bind(this),
      LinearRing: this.writeLineStringGeometry_.bind(this),
      Polygon: this.writePolygonGeometry_.bind(this),
      MultiPoint: this.writeMultiPointGeometry_.bind(this),
      MultiLineString: this.writeMultiLineStringGeometry_.bind(this),
      MultiPolygon: this.writeMultiPolygonGeometry_.bind(this),
      Circle: this.writeCircleGeometry_.bind(this),
      GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this)
    }, this.source_ = null, this.traceSource_ = t.traceSource || t.source || null, this.traceCondition_, this.setTrace(t.trace || !1), this.traceState_ = { active: !1 }, this.traceSegments_ = null, this.hitDetection_ = null;
    let e;
    if (t.features ? e = t.features : t.source && (this.source_ = t.source, e = new Dt(this.source_.getFeatures()), this.source_.addEventListener(
      re.ADDFEATURE,
      this.handleSourceAdd_.bind(this)
    ), this.source_.addEventListener(
      re.REMOVEFEATURE,
      this.handleSourceRemove_.bind(this)
    )), !e)
      throw new Error(
        "The modify interaction requires features, a source or a layer"
      );
    t.hitDetection && (this.hitDetection_ = t.hitDetection), this.features_ = e, this.features_.forEach(this.addFeature_.bind(this)), this.features_.addEventListener(
      Yt.ADD,
      this.handleFeatureAdd_.bind(this)
    ), this.features_.addEventListener(
      Yt.REMOVE,
      this.handleFeatureRemove_.bind(this)
    ), this.lastPointerEvent_ = null, this.delta_ = [0, 0], this.snapToPointer_ = t.snapToPointer === void 0 ? !this.hitDetection_ : t.snapToPointer;
  }
  /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */
  setTrace(t) {
    let e;
    t ? t === !0 ? e = _r : e = t : e = ud, this.traceCondition_ = e;
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  addFeature_(t) {
    const e = t.getGeometry();
    if (e) {
      const r = this.SEGMENT_WRITERS_[e.getType()];
      r && r(t, e);
    }
    const n = this.getMap();
    n && n.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastCoordinate_), t.addEventListener(V.CHANGE, this.boundHandleFeatureChange_);
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<SegmentData>} segments The segments subject to modification.
   * @private
   */
  willModifyFeatures_(t, e) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new Dt();
      const n = this.featuresBeingModified_.getArray();
      for (let r = 0, s = e.length; r < s; ++r) {
        const o = e[r].feature;
        o && !n.includes(o) && this.featuresBeingModified_.push(o);
      }
      this.featuresBeingModified_.getLength() === 0 ? this.featuresBeingModified_ = null : this.dispatchEvent(
        new W2(
          V2.MODIFYSTART,
          this.featuresBeingModified_,
          t
        )
      );
    }
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeature_(t) {
    this.removeFeatureSegmentData_(t), this.vertexFeature_ && this.features_.getLength() === 0 && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t.removeEventListener(
      V.CHANGE,
      this.boundHandleFeatureChange_
    );
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureSegmentData_(t) {
    const e = this.rBush_, n = [];
    e.forEach(
      /**
       * @param {SegmentData} node RTree node.
       */
      function(r) {
        t === r.feature && n.push(r);
      }
    );
    for (let r = n.length - 1; r >= 0; --r) {
      const s = n[r];
      for (let o = this.dragSegments_.length - 1; o >= 0; --o)
        this.dragSegments_[o][0] === s && this.dragSegments_.splice(o, 1);
      e.remove(s);
    }
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   * @override
   */
  setActive(t) {
    this.vertexFeature_ && !t && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), super.setActive(t);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   * @override
   */
  setMap(t) {
    this.overlay_.setMap(t), super.setMap(t);
  }
  /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceAdd_(t) {
    t.feature && this.features_.push(t.feature);
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceRemove_(t) {
    t.feature && this.features_.remove(t.feature);
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureAdd_(t) {
    this.addFeature_(t.element);
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  handleFeatureChange_(t) {
    if (!this.changingFeature_) {
      const e = (
        /** @type {Feature} */
        t.target
      );
      this.removeFeature_(e), this.addFeature_(e);
    }
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureRemove_(t) {
    this.removeFeature_(t.element);
  }
  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */
  writePointGeometry_(t, e) {
    const n = e.getCoordinates(), r = {
      feature: t,
      geometry: e,
      segment: [n, n]
    };
    this.rBush_.insert(e.getExtent(), r);
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  writeMultiPointGeometry_(t, e) {
    const n = e.getCoordinates();
    for (let r = 0, s = n.length; r < s; ++r) {
      const o = n[r], a = {
        feature: t,
        geometry: e,
        depth: [r],
        index: r,
        segment: [o, o]
      };
      this.rBush_.insert(e.getExtent(), a);
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  writeLineStringGeometry_(t, e) {
    const n = e.getCoordinates();
    for (let r = 0, s = n.length - 1; r < s; ++r) {
      const o = n.slice(r, r + 2), a = {
        feature: t,
        geometry: e,
        index: r,
        segment: o
      };
      this.rBush_.insert(Gt(o), a);
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  writeMultiLineStringGeometry_(t, e) {
    const n = e.getCoordinates();
    for (let r = 0, s = n.length; r < s; ++r) {
      const o = n[r];
      for (let a = 0, l = o.length - 1; a < l; ++a) {
        const h = o.slice(a, a + 2), c = {
          feature: t,
          geometry: e,
          depth: [r],
          index: a,
          segment: h
        };
        this.rBush_.insert(Gt(h), c);
      }
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  writePolygonGeometry_(t, e) {
    const n = e.getCoordinates();
    for (let r = 0, s = n.length; r < s; ++r) {
      const o = n[r];
      for (let a = 0, l = o.length - 1; a < l; ++a) {
        const h = o.slice(a, a + 2), c = {
          feature: t,
          geometry: e,
          depth: [r],
          index: a,
          segment: h
        };
        this.rBush_.insert(Gt(h), c);
      }
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  writeMultiPolygonGeometry_(t, e) {
    const n = e.getCoordinates();
    for (let r = 0, s = n.length; r < s; ++r) {
      const o = n[r];
      for (let a = 0, l = o.length; a < l; ++a) {
        const h = o[a];
        for (let c = 0, d = h.length - 1; c < d; ++c) {
          const u = h.slice(c, c + 2), f = {
            feature: t,
            geometry: e,
            depth: [a, r],
            index: c,
            segment: u
          };
          this.rBush_.insert(Gt(u), f);
        }
      }
    }
  }
  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  writeCircleGeometry_(t, e) {
    const n = e.getCenter(), r = {
      feature: t,
      geometry: e,
      index: _c,
      segment: [n, n]
    }, s = {
      feature: t,
      geometry: e,
      index: Es,
      segment: [n, n]
    }, o = [r, s];
    r.featureSegments = o, s.featureSegments = o, this.rBush_.insert(vs(n), r);
    let a = (
      /** @type {import("../geom/Geometry.js").default} */
      e
    );
    this.rBush_.insert(a.getExtent(), s);
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  writeGeometryCollectionGeometry_(t, e) {
    const n = e.getGeometriesArray();
    for (let r = 0; r < n.length; ++r) {
      const s = n[r], o = this.SEGMENT_WRITERS_[s.getType()];
      o(t, s);
    }
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<Feature>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @param {boolean} existing The vertex represents an existing vertex.
   * @return {Feature} Vertex feature.
   * @private
   */
  createOrUpdateVertexFeature_(t, e, n, r) {
    let s = this.vertexFeature_;
    return s ? s.getGeometry().setCoordinates(t) : (s = new Lt(new de(t)), this.vertexFeature_ = s, this.overlay_.getSource().addFeature(s)), s.set("features", e), s.set("geometries", n), s.set("existing", r), s;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(t) {
    if (!t.originalEvent)
      return !0;
    this.lastPointerEvent_ = t;
    let e;
    return !t.map.getView().getInteracting() && t.type == rt.POINTERMOVE && !this.handlingDownUpSequence && this.handlePointerMove_(t), this.vertexFeature_ && this.deleteCondition_(t) && (t.type != rt.SINGLECLICK || !this.ignoreNextSingleClick_ ? e = this.removePoint() : e = !0), t.type == rt.SINGLECLICK && (this.ignoreNextSingleClick_ = !1), super.handleEvent(t) && !e;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate Pixel coordinate.
   * @return {Array<SegmentData>|undefined} Insert vertices and update drag segments.
   * @private
   */
  findInsertVerticesAndUpdateDragSegments_(t) {
    if (this.handlePointerAtPixel_(t), this.dragSegments_.length = 0, this.featuresBeingModified_ = null, !this.vertexFeature_)
      return;
    this.getMap().getView().getProjection();
    const n = [], r = this.vertexFeature_.getGeometry().getCoordinates(), s = Gt([r]), o = this.rBush_.getInExtent(s), a = {};
    o.sort(d9);
    for (let l = 0, h = o.length; l < h; ++l) {
      const c = o[l], d = c.segment;
      let u = Y(c.geometry);
      const f = c.depth;
      if (f && (u += "-" + f.join("-")), a[u] || (a[u] = new Array(2)), c.geometry.getType() === "Circle" && c.index === Es) {
        const g = xc(
          t,
          c
        );
        $t(g, r) && !a[u][0] && (this.dragSegments_.push([c, 0]), a[u][0] = c);
        continue;
      }
      if ($t(d[0], r) && !a[u][0]) {
        this.dragSegments_.push([c, 0]), a[u][0] = c;
        continue;
      }
      if ($t(d[1], r) && !a[u][1]) {
        if (a[u][0] && a[u][0].index === 0) {
          let g = c.geometry.getCoordinates();
          switch (c.geometry.getType()) {
            // prevent dragging closed linestrings by the connecting node
            case "LineString":
            case "MultiLineString":
              continue;
            // if dragging the first vertex of a polygon, ensure the other segment
            // belongs to the closing vertex of the linear ring
            case "MultiPolygon":
              g = g[f[1]];
            /* falls through */
            case "Polygon":
              if (c.index !== g[f[0]].length - 2)
                continue;
              break;
          }
        }
        this.dragSegments_.push([c, 1]), a[u][1] = c;
        continue;
      }
      Y(d) in this.vertexSegments_ && !a[u][0] && !a[u][1] && n.push(c);
    }
    return n;
  }
  /**
   * @private
   */
  deactivateTrace_() {
    this.traceState_ = { active: !1 };
  }
  /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  updateTrace_(t) {
    const e = this.traceState_;
    if (!e.active)
      return;
    if (e.targetIndex === -1) {
      const s = t.map.getPixelFromCoordinate(e.startCoord);
      if (lr(s, t.pixel) < this.pixelTolerance_)
        return;
    }
    const n = Kd(
      t.coordinate,
      e,
      t.map,
      this.pixelTolerance_
    );
    if (e.targetIndex === -1 && Math.sqrt(n.closestTargetDistance) / t.map.getView().getResolution() > this.pixelTolerance_)
      return;
    if (e.targetIndex !== n.index) {
      if (e.targetIndex !== -1) {
        const o = e.targets[e.targetIndex];
        this.removeTracedCoordinates_(o.startIndex, o.endIndex);
      } else
        for (const o of this.traceSegments_) {
          const a = o[0], l = a.geometry, h = o[1], c = l.getCoordinates();
          $2(
            c,
            l.getType(),
            a.depth
          ).splice(a.index + h, 1), l.setCoordinates(c), h === 0 && (a.index -= 1);
        }
      const s = e.targets[n.index];
      this.addTracedCoordinates_(
        s,
        s.startIndex,
        n.endIndex
      );
    } else {
      const s = e.targets[e.targetIndex];
      this.addOrRemoveTracedCoordinates_(s, n.endIndex);
    }
    e.targetIndex = n.index;
    const r = e.targets[e.targetIndex];
    r.endIndex = n.endIndex;
  }
  getTraceCandidates_(t) {
    const e = this.getMap(), n = this.pixelTolerance_, r = e.getCoordinateFromPixel([
      t.pixel[0] - n,
      t.pixel[1] + n
    ]), s = e.getCoordinateFromPixel([
      t.pixel[0] + n,
      t.pixel[1] - n
    ]), o = Gt([r, s]);
    return this.traceSource_.getFeaturesInExtent(o);
  }
  /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  toggleTraceState_(t) {
    if (!this.traceSource_ || !this.traceCondition_(t))
      return;
    if (this.traceState_.active) {
      this.deactivateTrace_(), this.traceSegments_ = null;
      return;
    }
    const e = this.getTraceCandidates_(t);
    if (e.length === 0)
      return;
    const n = qd(t.coordinate, e);
    n.length && (this.traceState_ = {
      active: !0,
      startCoord: t.coordinate.slice(),
      targets: n,
      targetIndex: -1
    });
  }
  /**
   * @param {import('./tracing.js').TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */
  addOrRemoveTracedCoordinates_(t, e) {
    const n = t.startIndex <= t.endIndex, r = t.startIndex <= e;
    n === r ? n && e > t.endIndex || !n && e < t.endIndex ? this.addTracedCoordinates_(t, t.endIndex, e) : (n && e < t.endIndex || !n && e > t.endIndex) && this.removeTracedCoordinates_(e, t.endIndex) : (this.removeTracedCoordinates_(t.startIndex, t.endIndex), this.addTracedCoordinates_(t, t.startIndex, e));
  }
  /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  removeTracedCoordinates_(t, e) {
    if (t === e)
      return;
    let n = 0;
    if (t < e) {
      const r = Math.ceil(t);
      let s = Math.floor(e);
      s === e && (s -= 1), n = s - r + 1;
    } else {
      const r = Math.floor(t);
      let s = Math.ceil(e);
      s === e && (s += 1), n = r - s + 1;
    }
    if (n > 0)
      for (const r of this.traceSegments_) {
        const s = r[0], o = s.geometry, a = r[1];
        let l = r[0].index + 1;
        a === 1 && (l -= n);
        const h = o.getCoordinates();
        $2(
          h,
          o.getType(),
          s.depth
        ).splice(l, n), o.setCoordinates(h), a === 1 && (s.index -= n);
      }
  }
  /**
   * @param {import('./tracing.js').TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  addTracedCoordinates_(t, e, n) {
    if (e === n)
      return;
    const r = [];
    if (e < n) {
      const s = Math.ceil(e);
      let o = Math.floor(n);
      o === n && (o -= 1);
      for (let a = s; a <= o; ++a)
        r.push(ji(t.coordinates, a));
    } else {
      const s = Math.floor(e);
      let o = Math.ceil(n);
      o === n && (o += 1);
      for (let a = s; a >= o; --a)
        r.push(ji(t.coordinates, a));
    }
    if (r.length)
      for (const s of this.traceSegments_) {
        const o = s[0], a = o.geometry, l = s[1], h = o.index + 1;
        l === 0 && r.reverse();
        const c = a.getCoordinates();
        $2(
          c,
          a.getType(),
          o.depth
        ).splice(h, 0, ...r), a.setCoordinates(c), l === 1 && (o.index += r.length);
      }
  }
  /**
   * @param {import('../coordinate.js').Coordinate} vertex Vertex.
   * @param {DragSegment} dragSegment Drag segment.
   */
  updateGeometry_(t, e) {
    const n = e[0], r = n.depth;
    let s;
    const o = n.segment, a = n.geometry, l = e[1];
    for (; t.length < a.getStride(); )
      t.push(o[l][t.length]);
    switch (a.getType()) {
      case "Point":
        s = t, o[0] = t, o[1] = t;
        break;
      case "MultiPoint":
        s = a.getCoordinates(), s[n.index] = t, o[0] = t, o[1] = t;
        break;
      case "LineString":
        s = a.getCoordinates(), s[n.index + l] = t, o[l] = t;
        break;
      case "MultiLineString":
        s = a.getCoordinates(), s[r[0]][n.index + l] = t, o[l] = t;
        break;
      case "Polygon":
        s = a.getCoordinates(), s[r[0]][n.index + l] = t, o[l] = t;
        break;
      case "MultiPolygon":
        s = a.getCoordinates(), s[r[1]][r[0]][n.index + l] = t, o[l] = t;
        break;
      case "Circle":
        const h = (
          /** @type {import("../geom/Circle.js").default} */
          a
        );
        if (o[0] = t, o[1] = t, n.index === _c)
          this.changingFeature_ = !0, h.setCenter(t), this.changingFeature_ = !1;
        else {
          this.changingFeature_ = !0, this.getMap().getView().getProjection();
          let c = lr(
            pt(h.getCenter()),
            pt(t)
          );
          h.setRadius(c), this.changingFeature_ = !1;
        }
        break;
    }
    s && this.setGeometryCoordinates_(a, s);
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @override
   */
  handleDragEvent(t) {
    this.ignoreNextSingleClick_ = !1, this.willModifyFeatures_(
      t,
      this.dragSegments_.map(([o]) => o)
    );
    const e = [
      t.coordinate[0] + this.delta_[0],
      t.coordinate[1] + this.delta_[1]
    ], n = [], r = [], s = this.traceState_.active && !this.traceSegments_ ? this.traceState_.startCoord : null;
    if (s) {
      this.traceSegments_ = [];
      for (const o of this.dragSegments_) {
        const a = o[0];
        lr(
          ol(s, a.segment),
          s
        ) / t.map.getView().getResolution() < 1 && this.traceSegments_.push(o);
      }
    }
    for (let o = 0, a = this.dragSegments_.length; o < a; ++o) {
      const l = this.dragSegments_[o], h = l[0], c = h.feature;
      n.includes(c) || n.push(c);
      const d = h.geometry;
      r.includes(d) || r.push(d), this.updateGeometry_(e, l);
    }
    this.updateTrace_(t), this.createOrUpdateVertexFeature_(e, n, r, !0);
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(t) {
    if (!this.condition_(t))
      return !1;
    const e = t.coordinate, n = this.findInsertVerticesAndUpdateDragSegments_(e);
    if (n?.length && this.insertVertexCondition_(t) && (this.willModifyFeatures_(t, n), this.vertexFeature_)) {
      const r = this.vertexFeature_.getGeometry().getCoordinates();
      for (let s = n.length - 1; s >= 0; --s)
        this.insertVertex_(n[s], r);
      this.ignoreNextSingleClick_ = !0;
    }
    return !!this.vertexFeature_;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(t) {
    for (let e = this.dragSegments_.length - 1; e >= 0; --e) {
      const n = this.dragSegments_[e][0], r = n.geometry;
      if (r.getType() === "Circle") {
        const s = (
          /** @type {import("../geom/Circle.js").default} */
          r
        ), o = s.getCenter(), a = n.featureSegments[0], l = n.featureSegments[1];
        a.segment[0] = o, a.segment[1] = o, l.segment[0] = o, l.segment[1] = o, this.rBush_.update(vs(o), a);
        let h = s;
        this.rBush_.update(
          h.getExtent(),
          l
        );
      } else
        this.rBush_.update(Gt(n.segment), n);
    }
    return this.featuresBeingModified_ && (this.toggleTraceState_(t), this.dispatchEvent(
      new W2(
        V2.MODIFYEND,
        this.featuresBeingModified_,
        t
      )
    ), this.featuresBeingModified_ = null), !1;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */
  handlePointerMove_(t) {
    this.lastCoordinate_ = t.coordinate, this.handlePointerAtPixel_(this.lastCoordinate_);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate The pixel Coordinate.
   * @private
   */
  handlePointerAtPixel_(t) {
    const e = this.getMap(), n = e.getPixelFromCoordinate(t);
    e.getView().getProjection();
    const r = function(a, l) {
      return vc(t, a) - vc(t, l);
    };
    let s, o;
    if (this.hitDetection_) {
      const a = typeof this.hitDetection_ == "object" ? (l) => l === this.hitDetection_ : void 0;
      e.forEachFeatureAtPixel(
        n,
        (l, h, c) => {
          c && c.getType() === "Point" && (c = new de(
            kn(c.getCoordinates())
          ));
          const d = c || l.getGeometry();
          if (d && d.getType() === "Point" && l instanceof Lt && this.features_.getArray().includes(l)) {
            o = /** @type {Point} */
            d;
            const u = (
              /** @type {Point} */
              l.getGeometry().getFlatCoordinates().slice(0, 2)
            );
            s = [
              {
                feature: l,
                geometry: o,
                segment: [u, u]
              }
            ];
          }
          return !0;
        },
        { layerFilter: a }
      );
    }
    if (!s) {
      const a = Te(
        vs(t, yc)
      ), l = e.getView().getResolution() * this.pixelTolerance_, h = Yo(
        Ie(a, l, yc)
      );
      s = this.rBush_.getInExtent(h);
    }
    if (s && s.length > 0) {
      const a = s.sort(r)[0], l = a.segment;
      let h = xc(t, a);
      const c = e.getPixelFromCoordinate(h);
      let d = lr(n, c);
      if (o || d <= this.pixelTolerance_) {
        const u = {};
        if (u[Y(l)] = !0, this.snapToPointer_ || (this.delta_[0] = h[0] - t[0], this.delta_[1] = h[1] - t[1]), a.geometry.getType() === "Circle" && a.index === Es)
          this.snappedToVertex_ = !0, this.createOrUpdateVertexFeature_(
            h,
            [a.feature],
            [a.geometry],
            this.snappedToVertex_
          );
        else {
          const f = e.getPixelFromCoordinate(l[0]), g = e.getPixelFromCoordinate(l[1]), p = Pr(c, f), m = Pr(c, g);
          if (d = Math.sqrt(Math.min(p, m)), this.snappedToVertex_ = d <= this.pixelTolerance_, !this.snappedToVertex_ && !this.insertVertexCondition_(this.lastPointerEvent_)) {
            this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null);
            return;
          }
          this.snappedToVertex_ && (h = p > m ? l[1] : l[0]), this.createOrUpdateVertexFeature_(
            h,
            [a.feature],
            [a.geometry],
            this.snappedToVertex_
          );
          const _ = {};
          _[Y(a.geometry)] = !0;
          for (let y = 1, x = s.length; y < x; ++y) {
            const v = s[y].segment;
            if ($t(l[0], v[0]) && $t(l[1], v[1]) || $t(l[0], v[1]) && $t(l[1], v[0])) {
              const C = Y(s[y].geometry);
              C in _ || (_[C] = !0, u[Y(v)] = !0);
            } else
              break;
          }
        }
        this.vertexSegments_ = u;
        return;
      }
    }
    this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null);
  }
  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @return {boolean} A vertex was inserted.
   * @private
   */
  insertVertex_(t, e) {
    const n = t.segment, r = t.feature, s = t.geometry, o = t.depth, a = t.index;
    let l;
    for (; e.length < s.getStride(); )
      e.push(0);
    switch (s.getType()) {
      case "MultiLineString":
        l = s.getCoordinates(), l[o[0]].splice(a + 1, 0, e);
        break;
      case "Polygon":
        l = s.getCoordinates(), l[o[0]].splice(a + 1, 0, e);
        break;
      case "MultiPolygon":
        l = s.getCoordinates(), l[o[1]][o[0]].splice(a + 1, 0, e);
        break;
      case "LineString":
        l = s.getCoordinates(), l.splice(a + 1, 0, e);
        break;
      default:
        return !1;
    }
    this.setGeometryCoordinates_(s, l);
    const h = this.rBush_;
    h.remove(t), this.updateSegmentIndices_(s, a, o, 1);
    const c = {
      segment: [n[0], e],
      feature: r,
      geometry: s,
      depth: o,
      index: a
    };
    h.insert(Gt(c.segment), c), this.dragSegments_.push([c, 1]);
    const d = {
      segment: [e, n[1]],
      feature: r,
      geometry: s,
      depth: o,
      index: a + 1
    };
    return h.insert(Gt(d.segment), d), this.dragSegments_.push([d, 0]), !0;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
   * @return {import("../coordinate.js").Coordinate} The updated pointer coordinate.
   * @private
   */
  updatePointer_(t) {
    return t && this.findInsertVerticesAndUpdateDragSegments_(t), this.vertexFeature_?.getGeometry().getCoordinates();
  }
  /**
   * Get the current pointer position.
   * @return {import("../coordinate.js").Coordinate | null} The current pointer coordinate.
   */
  getPoint() {
    const t = this.vertexFeature_?.getGeometry().getCoordinates();
    return t ? kn(
      t,
      this.getMap().getView().getProjection()
    ) : null;
  }
  /**
   * Check if a point can be removed from the current linestring or polygon at the current
   * pointer position.
   * @return {boolean} A point can be deleted at the current pointer position.
   * @api
   */
  canRemovePoint() {
    if (!this.vertexFeature_ || this.vertexFeature_.get("geometries").every(
      (n) => n.getType() === "Circle" || n.getType().endsWith("Point")
    ))
      return !1;
    const t = this.vertexFeature_.getGeometry().getCoordinates();
    return this.rBush_.getInExtent(Gt([t])).some(
      ({ segment: n }) => $t(n[0], t) || $t(n[1], t)
    );
  }
  /**
   * Removes the vertex currently being pointed from the current linestring or polygon.
   * @param {import('../coordinate.js').Coordinate} [coordinate] If provided, the pointer
   * will be set to the provided coordinate. If not, the current pointer coordinate will be used.
   * @return {boolean} True when a vertex was removed.
   * @api
   */
  removePoint(t) {
    if (t && (t = pt(
      t,
      this.getMap().getView().getProjection()
    ), this.updatePointer_(t)), !this.lastPointerEvent_ || this.lastPointerEvent_ && this.lastPointerEvent_.type != rt.POINTERDRAG) {
      const e = this.lastPointerEvent_;
      this.willModifyFeatures_(
        e,
        this.dragSegments_.map(([r]) => r)
      );
      const n = this.removeVertex_();
      return this.featuresBeingModified_ && this.dispatchEvent(
        new W2(
          V2.MODIFYEND,
          this.featuresBeingModified_,
          e
        )
      ), this.featuresBeingModified_ = null, n;
    }
    return !1;
  }
  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */
  removeVertex_() {
    const t = this.dragSegments_, e = {};
    let n = !1, r, s, o, a, l, h, c, d, u, f, g;
    for (l = t.length - 1; l >= 0; --l)
      o = t[l], f = o[0], g = Y(f.feature), f.depth && (g += "-" + f.depth.join("-")), g in e || (e[g] = {}), o[1] === 0 ? (e[g].right = f, e[g].index = f.index) : o[1] == 1 && (e[g].left = f, e[g].index = f.index + 1);
    for (g in e) {
      switch (u = e[g].right, c = e[g].left, h = e[g].index, d = h - 1, c !== void 0 ? f = c : f = u, d < 0 && (d = 0), a = f.geometry, s = a.getCoordinates(), r = s, n = !1, a.getType()) {
        case "MultiLineString":
          s[f.depth[0]].length > 2 && (s[f.depth[0]].splice(h, 1), n = !0);
          break;
        case "LineString":
          s.length > 2 && (s.splice(h, 1), n = !0);
          break;
        case "MultiPolygon":
          r = r[f.depth[1]];
        /* falls through */
        case "Polygon":
          r = r[f.depth[0]], r.length > 4 && (h == r.length - 1 && (h = 0), r.splice(h, 1), n = !0, h === 0 && (r.pop(), r.push(r[0]), d = r.length - 1));
          break;
      }
      if (n) {
        this.setGeometryCoordinates_(a, s);
        const p = [];
        if (c !== void 0 && (this.rBush_.remove(c), p.push(c.segment[0])), u !== void 0 && (this.rBush_.remove(u), p.push(u.segment[1])), c !== void 0 && u !== void 0) {
          const m = {
            depth: f.depth,
            feature: f.feature,
            geometry: f.geometry,
            index: d,
            segment: p
          };
          this.rBush_.insert(
            Gt(m.segment),
            m
          );
        }
        this.updateSegmentIndices_(a, h, f.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), t.length = 0;
      }
    }
    return n;
  }
  /**
   * Check if a point can be inserted to the current linestring or polygon at the current
   * pointer position.
   * @return {boolean} A point can be inserted at the current pointer position.
   * @api
   */
  canInsertPoint() {
    if (!this.vertexFeature_ || this.vertexFeature_.get("geometries").every(
      (n) => n.getType() === "Circle" || n.getType().endsWith("Point")
    ))
      return !1;
    const t = this.vertexFeature_.getGeometry().getCoordinates();
    return this.rBush_.getInExtent(Gt([t])).some(
      ({ segment: n }) => !($t(n[0], t) || $t(n[1], t))
    );
  }
  /**
   * Inserts the vertex currently being pointed to the current linestring or polygon.
   * @param {import('../coordinate.js').Coordinate} [coordinate] If provided, the pointer
   * will be set to the provided coordinate. If not, the current pointer coordinate will be used.
   * @return {boolean} A vertex was inserted.
   * @api
   */
  insertPoint(t) {
    const e = t ? pt(t, this.getMap().getView().getProjection()) : this.vertexFeature_?.getGeometry().getCoordinates();
    return e ? this.findInsertVerticesAndUpdateDragSegments_(e).reduce(
      (r, s) => r || this.insertVertex_(s, e),
      !1
    ) : !1;
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */
  setGeometryCoordinates_(t, e) {
    this.changingFeature_ = !0, t.setCoordinates(e), this.changingFeature_ = !1;
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */
  updateSegmentIndices_(t, e, n, r) {
    this.rBush_.forEachInExtent(
      t.getExtent(),
      function(s) {
        s.geometry === t && (n === void 0 || s.depth === void 0 || Ci(s.depth, n)) && s.index > e && (s.index += r);
      }
    );
  }
}
function d9(i, t) {
  return i.index - t.index;
}
function vc(i, t, e) {
  const n = t.geometry;
  if (n.getType() === "Circle") {
    let s = (
      /** @type {import("../geom/Circle.js").default} */
      n
    );
    if (t.index === Es) {
      const o = Pr(
        s.getCenter(),
        pt(i)
      ), a = Math.sqrt(o) - s.getRadius();
      return a * a;
    }
  }
  const r = pt(i);
  return vr[0] = pt(t.segment[0]), vr[1] = pt(t.segment[1]), If(r, vr);
}
function xc(i, t, e) {
  const n = t.geometry;
  if (n.getType() === "Circle" && t.index === Es)
    return kn(
      /** @type {import("../geom/Circle.js").default} */
      n.getClosestPoint(
        pt(i)
      )
    );
  const r = pt(i);
  return vr[0] = pt(t.segment[0]), vr[1] = pt(t.segment[1]), kn(
    ol(r, vr)
  );
}
function u9() {
  const i = kd();
  return function(t, e) {
    return i.Point;
  };
}
const f9 = '.geolocation{top:85px;left:.5em}.geolocation button{background:var(--primary);color:var(--on-primary)}.geolocation button>svg{fill:var(--on-primary);min-inline-size:1.25rem!important;max-inline-size:1.25rem!important;min-block-size:1.25rem!important;max-block-size:1.25rem!important}.ol-touch.geolocation{top:100px}.loading-indicator{position:absolute;pointer-events:none!important;display:flex;align-items:center;justify-content:center;background-color:#0000}.loading-indicator.small{bottom:.5em;left:.5em;width:30px;height:30px}.loading-indicator.fullscreen{width:100%;height:100%}.disabled{filter:brightness(1.7);pointer-events:none}.ol-unselectable{pointer-events:none}.ol-control{background:none}.ol-control button,.ol-control button:hover,.ol-control button:focus{--_round: 32px;border-radius:var(--_round);background:var(--primary);color:var(--on-primary);width:32px;height:32px;cursor:pointer;border:none;outline:none;pointer-events:all;position:relative;font-size:1rem}.ol-control button:hover:after{background-size:15000%;opacity:.1;transition:background-size var(--speed2) linear;content:"";position:absolute;inset:0;z-index:1;border-radius:inherit;inline-size:100%;block-size:100%;background-position:center;background-image:radial-gradient(circle,currentColor 1%,transparent 1%)}.ol-control button.ol-zoom-in,.ol-control button.ol-zoom-in:hover{border-top-left-radius:var(--_round);border-top-right-radius:var(--_round);border-bottom-left-radius:.5rem;border-bottom-right-radius:.5rem;margin-bottom:.125rem}.ol-control button.ol-zoom-out,.ol-control button.ol-zoom-out:hover{border-top-left-radius:.5rem;border-top-right-radius:.5rem;border-bottom-left-radius:var(--_round);border-bottom-right-radius:var(--_round)}';
const g9 = (i, t, e) => {
  for (const n of t) if (n[0] === i) return (0, n[1])();
  return e?.();
};
class m9 extends bn {
  static get properties() {
    return {
      value: { attribute: "value", type: Number },
      enabled: { attribute: "enabled", type: String }
    };
  }
  constructor() {
    super(), this.value = 50, this.enabled = "true";
  }
  /**
   * Handles input events on the slider to update the comparison value.
   *
   * @param {Event & {target: { value: string } }} evt - input event
   **/
  #t(t) {
    this.value = parseInt(t.target.value);
  }
  render() {
    return gn`
      <style>
        :host {
          display: block;
          --thumb-size: 3rem;
        }
        .eox-map-compare {
          --thumb-bgc: #fff;
          --thumb-w: var(--thumb-size);

          position: relative;
          height: 100%;
        }
        .eox-map-compare::after {
          content: "";
          display: block;
        }
        .eox-map-compare__first,
        .eox-map-compare__second {
          height: 100%;
          object-fit: cover;
          position: absolute;
          top: 0;
          width: 100%;
        }
        .eox-map-compare__first {
          clip-path: polygon(
            0% 0%,
            ${this.value}% 0%,
            ${this.value}% 100%,
            0% 100%
          );
        }
        .eox-map-compare__second {
          clip-path: polygon(
            100% 0%,
            ${this.value}% 0%,
            ${this.value}% 100%,
            100% 100%
          );
        }
        .eox-map-compare__range {
          background-color: transparent;
          box-sizing: border-box;
          font-family: inherit;
          height: 100%;
          margin: 0;
          outline: none;
          position: absolute;
          top: 0;
          width: 100%;
          pointer-events: none;
        }
        .eox-map-compare__range::-moz-range-thumb {
          cursor: ew-resize;
          height: 100%;
          width: var(--thumb-w);
          pointer-events: all;
          background: transparent;
          border: none;
        }
        .eox-map-compare__range::-webkit-slider-thumb {
          cursor: ew-resize;
          height: 100%;
          width: var(--thumb-w);
          pointer-events: all;
          position: relative;
          background: transparent;
          border: none;
        }
        .eox-map-compare__range::-moz-range-track {
          background: transparent;
          background-size: 100%;
          box-sizing: border-box;
        }
        .eox-map-compare__range::-webkit-slider-runnable-track {
          background: transparent;
          background-size: 100%;
          box-sizing: border-box;
          height: 100%;
        }
        .eox-map-compare__range,
        .eox-map-compare__range::-webkit-slider-runnable-track,
        .eox-map-compare__range::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
        }
        .slider-bar,
        .slider-thumb {
          position: absolute;
          box-shadow: 0 0.125rem 0.125rem 0 rgb(0 0 0 / 0.32);
        }
        .slider-bar {
          pointer-events: none;
          top: 0;
          width: 0.3rem;
          height: 100%;
          background-color: var(--thumb-bgc);
          z-index: 2;
          left: calc(${this.value}% - 0.15rem);
          -webkit-clip-path: inset(0 -5px 0 -5px);
          clip-path: inset(0 -5px 0 -5px);
        }
        .slider-thumb {
          pointer-events: none;
          top: calc(50% - var(--thumb-size) / 2);
          background: var(--primary);
          z-index: 3;
          width: var(--thumb-size);
          aspect-ratio: 1;
          left: calc(${this.value}% - var(--thumb-size) / 2);
          border-radius: 50%;
          padding: 0.7rem;
          color: var(--on-primary);
          display: flex;
          align-items: center;
          justify-content: center;
          box-sizing: border-box;
        }
        .slider-thumb svg {
          fill: currentColor;
        }
      </style>
      ${g9(
      this.enabled,
      [
        ["first", () => gn`<slot name="first"></slot>`],
        ["second", () => gn`<slot name="second"></slot>`]
      ],
      () => gn`
          <div class="eox-map-compare">
            <div class="eox-map-compare__first">
              <slot name="first"></slot>
            </div>
            <div class="eox-map-compare__second">
              <slot name="second"></slot>
            </div>
            <input
              type="range"
              class="eox-map-compare__range"
              min="0"
              max="100"
              value=${this.value}
              @input=${this.#t}
            />
            <div class="slider-bar"></div>
            <div class="slider-thumb">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <title>arrow-left-right</title>
                <path
                  d="M6.45,17.45L1,12L6.45,6.55L7.86,7.96L4.83,11H19.17L16.14,7.96L17.55,6.55L23,12L17.55,17.45L16.14,16.04L19.17,13H4.83L7.86,16.04L6.45,17.45Z"
                />
              </svg>
            </div>
          </div>
        `
    )}
    `;
  }
}
customElements.define("eox-map-compare", m9);
class Bl {
  constructor() {
    this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */
    Lt, this.supportedMediaTypes = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */
  getReadOptions(t, e) {
    if (e) {
      let n = e.dataProjection ? tt(e.dataProjection) : this.readProjection(t);
      e.extent && n && n.getUnits() === "tile-pixels" && (n = tt(n), n.setWorldExtent(e.extent)), e = {
        dataProjection: n,
        featureProjection: e.featureProjection
      };
    }
    return this.adaptOptions(e);
  }
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */
  adaptOptions(t) {
    return Object.assign(
      {
        dataProjection: this.dataProjection,
        featureProjection: this.defaultFeatureProjection,
        featureClass: this.featureClass
      },
      t
    );
  }
  /**
   * @abstract
   * @return {Type} The format type.
   */
  getType() {
    return X();
  }
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {FeatureType|Array<FeatureType>} Feature.
   */
  readFeature(t, e) {
    return X();
  }
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<FeatureType>} Features.
   */
  readFeatures(t, e) {
    return X();
  }
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(t, e) {
    return X();
  }
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjection(t) {
    return X();
  }
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {Feature} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeature(t, e) {
    return X();
  }
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<Feature>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeatures(t, e) {
    return X();
  }
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeGeometry(t, e) {
    return X();
  }
}
function Bn(i, t, e) {
  const n = e ? tt(e.featureProjection) : null, r = e ? tt(e.dataProjection) : null;
  let s = i;
  if (n && r && !Qt(n, r)) {
    t && (s = /** @type {T} */
    i.clone());
    const o = t ? n : r, a = t ? r : n;
    o.getUnits() === "tile-pixels" ? s.transform(o, a) : s.applyTransform(In(o, a));
  }
  if (t && e && /** @type {WriteOptions} */
  e.decimals !== void 0) {
    const o = Math.pow(
      10,
      /** @type {WriteOptions} */
      e.decimals
    ), a = function(l) {
      for (let h = 0, c = l.length; h < c; ++h)
        l[h] = Math.round(l[h] * o) / o;
      return l;
    };
    s === i && (s = /** @type {T} */
    i.clone()), s.applyTransform(a);
  }
  return s;
}
const p9 = {
  Point: de,
  LineString: Kt,
  Polygon: jt,
  MultiPoint: nn,
  MultiLineString: oi,
  MultiPolygon: xi
};
function _9(i, t, e) {
  return Array.isArray(t[0]) ? (id(i, 0, t, e) || (i = i.slice(), va(i, 0, t, e)), i) : (wl(i, 0, t, e) || (i = i.slice(), uo(i, 0, t, e)), i);
}
function tu(i, t) {
  const e = i.geometry;
  if (!e)
    return [];
  if (Array.isArray(e))
    return e.map((s) => tu({ ...i, geometry: s })).flat();
  const n = e.type === "MultiPolygon" ? "Polygon" : e.type;
  if (n === "GeometryCollection" || n === "Circle")
    throw new Error("Unsupported geometry type: " + n);
  const r = e.layout.length;
  return Bn(
    new Xt(
      n,
      n === "Polygon" ? _9(e.flatCoordinates, e.ends, r) : e.flatCoordinates,
      e.ends?.flat(),
      r,
      i.properties || {},
      i.id
    ).enableSimplifyTransformed(),
    !1,
    t
  );
}
function Vl(i, t) {
  if (!i)
    return null;
  if (Array.isArray(i)) {
    const n = i.map(
      (r) => Vl(r, t)
    );
    return new Fe(n);
  }
  const e = p9[i.type];
  return Bn(
    new e(i.flatCoordinates, i.layout || "XY", i.ends),
    !1,
    t
  );
}
class eu extends Bl {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   * @override
   */
  getType() {
    return "json";
  }
  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {FeatureType|Array<FeatureType>} Feature.
   * @api
   * @override
   */
  readFeature(t, e) {
    return this.readFeatureFromObject(
      z0(t),
      this.getReadOptions(t, e)
    );
  }
  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<FeatureType>} Features.
   * @api
   * @override
   */
  readFeatures(t, e) {
    return this.readFeaturesFromObject(
      z0(t),
      this.getReadOptions(t, e)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {FeatureType|Array<FeatureType>} Feature.
   */
  readFeatureFromObject(t, e) {
    return X();
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<FeatureType>} Features.
   */
  readFeaturesFromObject(t, e) {
    return X();
  }
  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   * @override
   */
  readGeometry(t, e) {
    return this.readGeometryFromObject(
      z0(t),
      this.getReadOptions(t, e)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(t, e) {
    return X();
  }
  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   * @override
   */
  readProjection(t) {
    return this.readProjectionFromObject(z0(t));
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(t) {
    return X();
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   * @override
   */
  writeFeature(t, e) {
    return JSON.stringify(this.writeFeatureObject(t, e));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeatureObject(t, e) {
    return X();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   * @override
   */
  writeFeatures(t, e) {
    return JSON.stringify(this.writeFeaturesObject(t, e));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeaturesObject(t, e) {
    return X();
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   * @override
   */
  writeGeometry(t, e) {
    return JSON.stringify(this.writeGeometryObject(t, e));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeGeometryObject(t, e) {
    return X();
  }
}
function z0(i) {
  if (typeof i == "string") {
    const t = JSON.parse(i);
    return t || null;
  }
  return i !== null ? i : null;
}
class i2 extends eu {
  /**
   * @param {Options<FeatureType>} [options] Options.
   */
  constructor(t) {
    t = t || {}, super(), this.dataProjection = tt(
      t.dataProjection ? t.dataProjection : "EPSG:4326"
    ), t.featureProjection && (this.defaultFeatureProjection = tt(t.featureProjection)), t.featureClass && (this.featureClass = t.featureClass), this.geometryName_ = t.geometryName, this.extractGeometryName_ = t.extractGeometryName, this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {FeatureType|Array<FeatureType>} Feature.
   * @override
   */
  readFeatureFromObject(t, e) {
    let n = null;
    t.type === "Feature" ? n = /** @type {GeoJSONFeature} */
    t : n = {
      type: "Feature",
      geometry: (
        /** @type {GeoJSONGeometry} */
        t
      ),
      properties: null
    };
    const r = $l(n.geometry);
    if (this.featureClass === Xt)
      return (
        /** @type {FeatureType|Array<FeatureType>} */
        tu(
          {
            geometry: r,
            id: n.id,
            properties: n.properties
          },
          e
        )
      );
    const s = new Lt();
    return this.geometryName_ ? s.setGeometryName(this.geometryName_) : this.extractGeometryName_ && n.geometry_name && s.setGeometryName(n.geometry_name), s.setGeometry(Vl(r, e)), "id" in n && s.setId(n.id), n.properties && s.setProperties(n.properties, !0), /** @type {FeatureType|Array<FeatureType>} */
    s;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<FeatureType>} Features.
   * @override
   */
  readFeaturesFromObject(t, e) {
    const n = (
      /** @type {GeoJSONObject} */
      t
    );
    let r = null;
    if (n.type === "FeatureCollection") {
      const s = (
        /** @type {GeoJSONFeatureCollection} */
        t
      );
      r = [];
      const o = s.features;
      for (let a = 0, l = o.length; a < l; ++a) {
        const h = this.readFeatureFromObject(
          o[a],
          e
        );
        h && r.push(h);
      }
    } else
      r = [this.readFeatureFromObject(t, e)];
    return (
      /** @type {Array<FeatureType>} */
      r.flat()
    );
  }
  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @override
   */
  readGeometryFromObject(t, e) {
    return y9(t, e);
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   * @override
   */
  readProjectionFromObject(t) {
    const e = t.crs;
    let n;
    if (e)
      if (e.type == "name")
        n = tt(e.properties.name);
      else if (e.type === "EPSG")
        n = tt("EPSG:" + e.properties.code);
      else
        throw new Error("Unknown SRS type");
    else
      n = this.dataProjection;
    return (
      /** @type {import("../proj/Projection.js").default} */
      n
    );
  }
  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   * @override
   */
  writeFeatureObject(t, e) {
    e = this.adaptOptions(e);
    const n = {
      type: "Feature",
      geometry: null,
      properties: null
    }, r = t.getId();
    if (r !== void 0 && (n.id = r), !t.hasProperties())
      return n;
    const s = t.getProperties(), o = t.getGeometry();
    return o && (n.geometry = ka(o, e), delete s[t.getGeometryName()]), Zi(s) || (n.properties = s), n;
  }
  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   * @override
   */
  writeFeaturesObject(t, e) {
    e = this.adaptOptions(e);
    const n = [];
    for (let r = 0, s = t.length; r < s; ++r)
      n.push(this.writeFeatureObject(t[r], e));
    return {
      type: "FeatureCollection",
      features: n
    };
  }
  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   * @override
   */
  writeGeometryObject(t, e) {
    return ka(t, this.adaptOptions(e));
  }
}
function $l(i, t) {
  if (!i)
    return null;
  let e;
  switch (i.type) {
    case "Point": {
      e = x9(
        /** @type {GeoJSONPoint} */
        i
      );
      break;
    }
    case "LineString": {
      e = C9(
        /** @type {GeoJSONLineString} */
        i
      );
      break;
    }
    case "Polygon": {
      e = S9(
        /** @type {GeoJSONPolygon} */
        i
      );
      break;
    }
    case "MultiPoint": {
      e = w9(
        /** @type {GeoJSONMultiPoint} */
        i
      );
      break;
    }
    case "MultiLineString": {
      e = b9(
        /** @type {GeoJSONMultiLineString} */
        i
      );
      break;
    }
    case "MultiPolygon": {
      e = E9(
        /** @type {GeoJSONMultiPolygon} */
        i
      );
      break;
    }
    case "GeometryCollection": {
      e = v9(
        /** @type {GeoJSONGeometryCollection} */
        i
      );
      break;
    }
    default:
      throw new Error("Unsupported GeoJSON type: " + i.type);
  }
  return e;
}
function y9(i, t) {
  const e = $l(i);
  return Vl(e, t);
}
function v9(i, t) {
  return i.geometries.map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("./Feature.js").GeometryObject} geometry Geometry.
     */
    function(n) {
      return $l(n);
    }
  );
}
function x9(i) {
  const t = i.coordinates;
  return {
    type: "Point",
    flatCoordinates: t,
    layout: Dn(t.length)
  };
}
function C9(i) {
  const t = i.coordinates, e = t.flat();
  return {
    type: "LineString",
    flatCoordinates: e,
    ends: [e.length],
    layout: Dn(t[0]?.length || 2)
  };
}
function b9(i) {
  const t = i.coordinates, e = t[0]?.[0]?.length || 2, n = [], r = o0(n, 0, t, e);
  return {
    type: "MultiLineString",
    flatCoordinates: n,
    ends: r,
    layout: Dn(e)
  };
}
function w9(i) {
  const t = i.coordinates;
  return {
    type: "MultiPoint",
    flatCoordinates: t.flat(),
    layout: Dn(t[0]?.length || 2)
  };
}
function E9(i) {
  const t = i.coordinates, e = [], n = t[0]?.[0]?.[0].length || 2, r = H1(
    e,
    0,
    t,
    n
  );
  return {
    type: "MultiPolygon",
    flatCoordinates: e,
    ends: r,
    layout: Dn(n)
  };
}
function S9(i) {
  const t = i.coordinates, e = [], n = t[0]?.[0]?.length, r = o0(e, 0, t, n);
  return {
    type: "Polygon",
    flatCoordinates: e,
    ends: r,
    layout: Dn(n)
  };
}
function ka(i, t) {
  i = Bn(i, !0, t);
  const e = i.getType();
  let n;
  switch (e) {
    case "Point": {
      n = k9(
        /** @type {import("../geom/Point.js").default} */
        i
      );
      break;
    }
    case "LineString": {
      n = T9(
        /** @type {import("../geom/LineString.js").default} */
        i
      );
      break;
    }
    case "Polygon": {
      n = L9(
        /** @type {import("../geom/Polygon.js").default} */
        i,
        t
      );
      break;
    }
    case "MultiPoint": {
      n = P9(
        /** @type {import("../geom/MultiPoint.js").default} */
        i
      );
      break;
    }
    case "MultiLineString": {
      n = R9(
        /** @type {import("../geom/MultiLineString.js").default} */
        i
      );
      break;
    }
    case "MultiPolygon": {
      n = I9(
        /** @type {import("../geom/MultiPolygon.js").default} */
        i,
        t
      );
      break;
    }
    case "GeometryCollection": {
      n = M9(
        /** @type {import("../geom/GeometryCollection.js").default} */
        i,
        t
      );
      break;
    }
    case "Circle": {
      n = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + e);
  }
  return n;
}
function M9(i, t) {
  return t = Object.assign({}, t), delete t.featureProjection, {
    type: "GeometryCollection",
    geometries: i.getGeometriesArray().map(function(n) {
      return ka(n, t);
    })
  };
}
function T9(i, t) {
  return {
    type: "LineString",
    coordinates: i.getCoordinates()
  };
}
function R9(i, t) {
  return {
    type: "MultiLineString",
    coordinates: i.getCoordinates()
  };
}
function P9(i, t) {
  return {
    type: "MultiPoint",
    coordinates: i.getCoordinates()
  };
}
function I9(i, t) {
  let e;
  return t && (e = t.rightHanded), {
    type: "MultiPolygon",
    coordinates: i.getCoordinates(e)
  };
}
function k9(i, t) {
  return {
    type: "Point",
    coordinates: i.getCoordinates()
  };
}
function L9(i, t) {
  let e;
  return t && (e = t.rightHanded), {
    type: "Polygon",
    coordinates: i.getCoordinates(e)
  };
}
const iu = {
  dataProjection: "EPSG:4326",
  // Define the source projection
  featureProjection: "EPSG:3857"
  // Define the target projection for the map
};
function nu(i, t, e, n = !1, r = !1, s = !0) {
  const o = (
    /** @type {Array} **/
    n ? [i.feature] : i.features
  );
  r && t.getSource().clear();
  const a = t.getSource().getFeatures();
  if (!t.get("multipleFeatures") && (a.length || o.length > 1))
    return console.error("Multiple features detected!");
  o.forEach((c) => {
    const d = c.getGeometry();
    if (d instanceof Kt) {
      const f = A1(d, {
        radius: 6378137,
        projection: e.projection
      });
      c.set("measure", f);
    } else if (d instanceof jt) {
      const f = F1(d, {
        radius: 6378137,
        projection: e.projection
      });
      c.set("measure", f);
    }
    const u = Y(c);
    c.set("id", u), c.setId(u);
  }), !n && o.length && (t.getSource().addFeatures(o), e.map.getView().fit(t.getSource().getExtent(), {
    duration: s ? 750 : 0
  }));
  const l = new i2(), h = JSON.parse(
    l.writeFeatures(o, iu)
  );
  (n || r) && Cc(e, "drawend", i, h), Cc(e, "addfeatures", i, h);
}
function Cc(i, t, e, n) {
  const r = new CustomEvent(t, {
    detail: {
      originalEvent: e,
      geoJSON: n
    }
  });
  i.dispatchEvent(r);
}
function ru(i) {
  i.setRotation(i.getRotation());
}
class A9 extends eu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.layerName_ = t.layerName, this.layers_ = t.layers ? t.layers : null, this.dataProjection = tt(
      t.dataProjection ? t.dataProjection : "EPSG:4326"
    );
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   * @override
   */
  readFeaturesFromObject(t, e) {
    if (t.type == "Topology") {
      const n = (
        /** @type {TopoJSONTopology} */
        t
      );
      let r, s = null, o = null;
      n.transform && (r = n.transform, s = r.scale, o = r.translate);
      const a = n.arcs;
      r && B9(a, s, o);
      const l = [], h = n.objects, c = this.layerName_;
      let d;
      for (const u in h)
        this.layers_ && !this.layers_.includes(u) || (h[u].type === "GeometryCollection" ? (d = /** @type {TopoJSONGeometryCollection} */
        h[u], l.push.apply(
          l,
          U9(
            d,
            a,
            s,
            o,
            c,
            u,
            e
          )
        )) : (d = /** @type {TopoJSONGeometry} */
        h[u], l.push(
          su(
            d,
            a,
            s,
            o,
            c,
            u,
            e
          )
        )));
      return l;
    }
    return [];
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   * @override
   */
  readProjectionFromObject(t) {
    return this.dataProjection;
  }
}
const F9 = {
  Point: O9,
  LineString: N9,
  Polygon: z9,
  MultiPoint: G9,
  MultiLineString: D9,
  MultiPolygon: j9
};
function n2(i, t) {
  const e = [];
  let n;
  for (let r = 0, s = i.length; r < s; ++r)
    if (n = i[r], r > 0 && e.pop(), n >= 0) {
      const o = t[n];
      for (let a = 0, l = o.length; a < l; ++a)
        e.push(o[a].slice(0));
    } else {
      const o = t[~n];
      for (let a = o.length - 1; a >= 0; --a)
        e.push(o[a].slice(0));
    }
  return e;
}
function O9(i, t, e) {
  const n = i.coordinates;
  return t && e && Wl(n, t, e), new de(n);
}
function G9(i, t, e) {
  const n = i.coordinates;
  if (t && e)
    for (let r = 0, s = n.length; r < s; ++r)
      Wl(n[r], t, e);
  return new nn(n);
}
function N9(i, t) {
  const e = n2(i.arcs, t);
  return new Kt(e);
}
function D9(i, t) {
  const e = [];
  for (let n = 0, r = i.arcs.length; n < r; ++n)
    e[n] = n2(i.arcs[n], t);
  return new oi(e);
}
function z9(i, t) {
  const e = [];
  for (let n = 0, r = i.arcs.length; n < r; ++n)
    e[n] = n2(i.arcs[n], t);
  return new jt(e);
}
function j9(i, t) {
  const e = [];
  for (let n = 0, r = i.arcs.length; n < r; ++n) {
    const s = i.arcs[n], o = [];
    for (let a = 0, l = s.length; a < l; ++a)
      o[a] = n2(s[a], t);
    e[n] = o;
  }
  return new xi(e);
}
function U9(i, t, e, n, r, s, o) {
  const a = i.geometries, l = [];
  for (let h = 0, c = a.length; h < c; ++h)
    l[h] = su(
      a[h],
      t,
      e,
      n,
      r,
      s,
      o
    );
  return l;
}
function su(i, t, e, n, r, s, o) {
  let a = null;
  const l = i.type;
  if (l) {
    const d = F9[l];
    l === "Point" || l === "MultiPoint" ? a = d(i, e, n) : a = d(i, t), a = Bn(a, !1, o);
  }
  const h = new Lt({ geometry: a });
  i.id !== void 0 && h.setId(i.id);
  let c = i.properties;
  return r && (c || (c = {}), c[r] = s), c && h.setProperties(c, !0), h;
}
function B9(i, t, e) {
  for (let n = 0, r = i.length; n < r; ++n)
    V9(i[n], t, e);
}
function V9(i, t, e) {
  let n = 0, r = 0;
  for (let s = 0, o = i.length; s < o; ++s) {
    const a = i[s];
    n += a[0], r += a[1], a[0] = n, a[1] = r, Wl(a, t, e);
  }
}
function Wl(i, t, e) {
  i[0] = i[0] * t[0] + e[0], i[1] = i[1] * t[1] + e[1];
}
const bc = "http://www.w3.org/2001/XMLSchema-instance";
function f0(i, t) {
  return r2().createElementNS(i, t);
}
function wi(i, t) {
  return ou(i, t, []).join("");
}
function ou(i, t, e) {
  if (i.nodeType == Node.CDATA_SECTION_NODE || i.nodeType == Node.TEXT_NODE)
    e.push(i.nodeValue);
  else {
    let n;
    for (n = i.firstChild; n; n = n.nextSibling)
      ou(n, t, e);
  }
  return e;
}
function Ui(i) {
  return "documentElement" in i;
}
function Bi(i) {
  return new DOMParser().parseFromString(i, "application/xml");
}
function wc(i, t) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @this {*}
     */
    (function(e, n) {
      const r = i.call(t ?? this, e, n);
      if (r !== void 0) {
        const s = (
          /** @type {Array<*>} */
          n[n.length - 1]
        );
        ot(s, r);
      }
    })
  );
}
function Oi(i, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @this {*}
     */
    (function(e, n) {
      const r = i.call(t ?? this, e, n);
      r !== void 0 && /** @type {Array<*>} */
      n[n.length - 1].push(r);
    })
  );
}
function Yl(i, t) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @this {*}
     */
    (function(e, n) {
      const r = i.call(this, e, n);
      r !== void 0 && (n[n.length - 1] = r);
    })
  );
}
function D(i, t, e) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @this {*}
     */
    (function(n, r) {
      const s = i.call(this, n, r);
      if (s !== void 0) {
        const o = (
          /** @type {!Object} */
          r[r.length - 1]
        ), a = t !== void 0 ? t : n.localName;
        o[a] = s;
      }
    })
  );
}
function W(i, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {*} value Value to be written.
     * @param {Array<*>} objectStack Object stack.
     * @this {*}
     */
    (function(e, n, r) {
      i.call(this, e, n, r), /** @type {NodeStackItem} */
      r[r.length - 1].node.appendChild(e);
    })
  );
}
function Ei(i, t) {
  return (
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [newNodeName] Node name.
     * @return {Node} Node.
     */
    (function(e, n, r) {
      const o = /** @type {NodeStackItem} */ n[n.length - 1].node;
      let a = i;
      a === void 0 && (a = r);
      const l = o.namespaceURI;
      return f0(
        l,
        /** @type {string} */
        a
      );
    })
  );
}
const Oe = Ei();
function Ye(i, t) {
  const e = t.length, n = new Array(e);
  for (let r = 0; r < e; ++r)
    n[r] = i[t[r]];
  return n;
}
function B(i, t, e) {
  e = e !== void 0 ? e : {};
  let n, r;
  for (n = 0, r = i.length; n < r; ++n)
    e[i[n]] = t;
  return e;
}
function Yr(i, t, e, n) {
  let r;
  for (r = t.firstElementChild; r; r = r.nextElementSibling) {
    const s = i[r.namespaceURI];
    if (s !== void 0) {
      const o = s[r.localName];
      o !== void 0 && o.call(n, r, e);
    }
  }
}
function gt(i, t, e, n, r) {
  return n.push(i), Yr(t, e, n, r), /** @type {T} */
  n.pop();
}
function $9(i, t, e, n, r, s) {
  const o = (r !== void 0 ? r : e).length;
  let a, l;
  for (let h = 0; h < o; ++h)
    a = e[h], a !== void 0 && (l = t.call(
      s,
      a,
      n,
      r !== void 0 ? r[h] : void 0
    ), l !== void 0 && i[l.namespaceURI][l.localName].call(
      s,
      l,
      a,
      n
    ));
}
function Mt(i, t, e, n, r, s, o) {
  return r.push(i), $9(t, e, n, r, s, o), /** @type {O|undefined} */
  r.pop();
}
let Y2;
function W9() {
  return Y2 === void 0 && typeof XMLSerializer < "u" && (Y2 = new XMLSerializer()), Y2;
}
let X2;
function r2() {
  return X2 === void 0 && typeof document < "u" && (X2 = document.implementation.createDocument("", "", null)), X2;
}
class Y9 extends Bl {
  constructor() {
    super(), this.xmlSerializer_ = W9();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   * @override
   */
  getType() {
    return "xml";
  }
  /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   * @override
   */
  readFeature(t, e) {
    if (!t)
      return null;
    if (typeof t == "string") {
      const n = Bi(t);
      return this.readFeatureFromDocument(n, e);
    }
    return Ui(t) ? this.readFeatureFromDocument(
      /** @type {Document} */
      t,
      e
    ) : this.readFeatureFromNode(
      /** @type {Element} */
      t,
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromDocument(t, e) {
    const n = this.readFeaturesFromDocument(t, e);
    return n.length > 0 ? n[0] : null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(t, e) {
    return null;
  }
  /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   * @override
   */
  readFeatures(t, e) {
    if (!t)
      return [];
    if (typeof t == "string") {
      const n = Bi(t);
      return this.readFeaturesFromDocument(n, e);
    }
    return Ui(t) ? this.readFeaturesFromDocument(
      /** @type {Document} */
      t,
      e
    ) : this.readFeaturesFromNode(
      /** @type {Element} */
      t,
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromDocument(t, e) {
    const n = [];
    for (let r = t.firstChild; r; r = r.nextSibling)
      r.nodeType == Node.ELEMENT_NODE && ot(
        n,
        this.readFeaturesFromNode(
          /** @type {Element} */
          r,
          e
        )
      );
    return n;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(t, e) {
    return X();
  }
  /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @override
   */
  readGeometry(t, e) {
    if (!t)
      return null;
    if (typeof t == "string") {
      const n = Bi(t);
      return this.readGeometryFromDocument(n, e);
    }
    return Ui(t) ? this.readGeometryFromDocument(
      /** @type {Document} */
      t,
      e
    ) : this.readGeometryFromNode(
      /** @type {Element} */
      t,
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromDocument(t, e) {
    return null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(t, e) {
    return null;
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   * @override
   */
  readProjection(t) {
    if (!t)
      return null;
    if (typeof t == "string") {
      const e = Bi(t);
      return this.readProjectionFromDocument(e);
    }
    return Ui(t) ? this.readProjectionFromDocument(
      /** @type {Document} */
      t
    ) : this.readProjectionFromNode(
      /** @type {Element} */
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(t) {
    return this.dataProjection;
  }
  /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(t) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @override
   */
  writeFeature(t, e) {
    const n = this.writeFeatureNode(t, e);
    return this.xmlSerializer_.serializeToString(n);
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @protected
   * @return {Node} Node.
   */
  writeFeatureNode(t, e) {
    return null;
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Result.
   * @api
   * @override
   */
  writeFeatures(t, e) {
    const n = this.writeFeaturesNode(t, e);
    return this.xmlSerializer_.serializeToString(n);
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeFeaturesNode(t, e) {
    return null;
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @override
   */
  writeGeometry(t, e) {
    const n = this.writeGeometryNode(t, e);
    return this.xmlSerializer_.serializeToString(n);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeGeometryNode(t, e) {
    return null;
  }
}
function Ki(i) {
  const t = wi(i, !1);
  return X9(t);
}
function X9(i) {
  const t = /^\s*(true|1)|(false|0)\s*$/.exec(i);
  if (t)
    return t[1] !== void 0 || !1;
}
function vt(i) {
  const t = wi(i, !1);
  return Z9(t);
}
function Z9(i) {
  const t = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(i);
  if (t)
    return parseFloat(t[1]);
}
function Ht(i) {
  return wi(i, !1).trim();
}
function Gr(i, t) {
  Me(i, t ? "1" : "0");
}
function H9(i, t) {
  i.appendChild(r2().createCDATASection(t));
}
function xn(i, t) {
  const e = t.toPrecision();
  i.appendChild(r2().createTextNode(e));
}
const K9 = /^\s/, q9 = /\s$/, J9 = /(\n|\t|\r|<|&| {2})/;
function Me(i, t) {
  typeof t == "string" && (K9.test(t) || q9.test(t) || J9.test(t)) ? t.split("]]>").forEach((e, n, r) => {
    n < r.length - 1 && (e += "]]"), n > 0 && (e = ">" + e), H9(i, e);
  }) : i.appendChild(r2().createTextNode(t));
}
const Si = ["http://www.google.com/kml/ext/2.2"], U = [
  null,
  "http://earth.google.com/kml/2.0",
  "http://earth.google.com/kml/2.1",
  "http://earth.google.com/kml/2.2",
  "http://www.opengis.net/kml/2.2"
], Q9 = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd", Ec = {
  fraction: "fraction",
  pixels: "pixels",
  insetPixels: "pixels"
}, t5 = B(
  U,
  {
    ExtendedData: Cu,
    Region: bu,
    MultiGeometry: D(yu, "geometry"),
    LineString: D(pu, "geometry"),
    LinearRing: D(_u, "geometry"),
    Point: D(vu, "geometry"),
    Polygon: D(xu, "geometry"),
    Style: D(Hl),
    StyleMap: N5,
    address: D(Ht),
    description: D(Ht),
    name: D(Ht),
    open: D(Ki),
    phoneNumber: D(Ht),
    styleUrl: D(du),
    visibility: D(Ki)
  },
  B(Si, {
    MultiTrack: D(E5, "geometry"),
    Track: D(mu, "geometry")
  })
), e5 = B(U, {
  ExtendedData: Cu,
  Region: bu,
  Link: H5,
  address: D(Ht),
  description: D(Ht),
  name: D(Ht),
  open: D(Ki),
  phoneNumber: D(Ht),
  visibility: D(Ki)
}), i5 = B(U, {
  href: D(cu)
}), n5 = B(U, {
  Altitude: D(vt),
  Longitude: D(vt),
  Latitude: D(vt),
  Tilt: D(vt),
  AltitudeMode: D(Ht),
  Heading: D(vt),
  Roll: D(vt)
}), au = B(U, {
  LatLonAltBox: B5,
  Lod: $5
}), r5 = B(U, ["Document", "Placemark"]), s5 = B(U, {
  Document: W(n8),
  Placemark: W(Su)
});
let xr, H0 = null, La, Ss, Ms, Ts, So, Aa = null, Xl, Fa = null, Oa, Cn = null, Sc = null, Ga = null;
function Mo(i) {
  return 32 / Math.min(i[0], i[1]);
}
function o5() {
  xr = [255, 255, 255, 1], H0 = new Ne({
    color: xr
  }), La = [20, 2], Ss = "pixels", Ms = "pixels", Ts = [64, 64], So = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png", Aa = new Wr({
    anchor: La,
    anchorOrigin: "bottom-left",
    anchorXUnits: Ss,
    anchorYUnits: Ms,
    crossOrigin: "anonymous",
    rotation: 0,
    scale: Mo(Ts),
    size: Ts,
    src: So
  }), Xl = "NO_IMAGE", Fa = new Ae({
    color: xr,
    width: 1
  }), Oa = new Ae({
    color: [51, 51, 51, 1],
    width: 2
  }), Cn = new c0({
    font: "bold 16px Helvetica",
    fill: H0,
    stroke: Oa,
    scale: 0.8
  }), Sc = new At({
    fill: H0,
    image: Aa,
    text: Cn,
    stroke: Fa,
    zIndex: 0
  }), Ga = [Sc];
}
let j0;
function a5(i) {
  return i;
}
class l5 extends Y9 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, Ga || o5(), this.dataProjection = tt("EPSG:4326"), this.defaultStyle_ = t.defaultStyle ? t.defaultStyle : Ga, this.extractStyles_ = t.extractStyles !== void 0 ? t.extractStyles : !0, this.writeStyles_ = t.writeStyles !== void 0 ? t.writeStyles : !0, this.sharedStyles_ = {}, this.showPointNames_ = t.showPointNames !== void 0 ? t.showPointNames : !0, this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : "anonymous", this.iconUrlFunction_ = t.iconUrlFunction ? t.iconUrlFunction : a5, this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Array<Feature>|undefined} Features.
   */
  readDocumentOrFolder_(t, e) {
    const n = B(U, {
      Document: wc(this.readDocumentOrFolder_, this),
      Folder: wc(this.readDocumentOrFolder_, this),
      Placemark: Oi(this.readPlacemark_, this),
      Style: this.readSharedStyle_.bind(this),
      StyleMap: this.readSharedStyleMap_.bind(this)
    }), r = gt([], n, t, e, this);
    if (r)
      return r;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Feature|undefined} Feature.
   */
  readPlacemark_(t, e) {
    const n = gt(
      { geometry: null },
      t5,
      t,
      e,
      this
    );
    if (!n)
      return;
    const r = new Lt(), s = t.getAttribute("id");
    s !== null && r.setId(s);
    const o = (
      /** @type {import("./Feature.js").ReadOptions} */
      e[0]
    ), a = n.geometry;
    if (a && Bn(a, !1, o), r.setGeometry(a), delete n.geometry, this.extractStyles_) {
      const l = n.Style, h = n.styleUrl, c = c5(
        l,
        h,
        this.defaultStyle_,
        this.sharedStyles_,
        this.showPointNames_
      );
      r.setStyle(c);
    }
    return delete n.Style, r.setProperties(n, !0), r;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */
  readSharedStyle_(t, e) {
    const n = t.getAttribute("id");
    if (n !== null) {
      const r = Hl.call(this, t, e);
      if (r) {
        let s, o = t.baseURI;
        (!o || o == "about:blank") && (o = window.location.href), o ? s = new URL("#" + n, o).href : s = "#" + n, this.sharedStyles_[s] = r;
      }
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */
  readSharedStyleMap_(t, e) {
    const n = t.getAttribute("id");
    if (n === null)
      return;
    const r = fu.call(this, t, e);
    if (!r)
      return;
    let s, o = t.baseURI;
    (!o || o == "about:blank") && (o = window.location.href), o ? s = new URL("#" + n, o).href : s = "#" + n, this.sharedStyles_[s] = r;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   * @override
   */
  readFeatureFromNode(t, e) {
    if (!U.includes(t.namespaceURI))
      return null;
    const n = this.readPlacemark_(t, [
      this.getReadOptions(t, e)
    ]);
    return n || null;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @override
   */
  readFeaturesFromNode(t, e) {
    if (!U.includes(t.namespaceURI))
      return [];
    let n;
    const r = t.localName;
    if (r == "Document" || r == "Folder")
      return n = this.readDocumentOrFolder_(t, [
        this.getReadOptions(t, e)
      ]), n || [];
    if (r == "Placemark") {
      const s = this.readPlacemark_(t, [
        this.getReadOptions(t, e)
      ]);
      return s ? [s] : [];
    }
    if (r == "kml") {
      n = [];
      for (let s = t.firstElementChild; s; s = s.nextElementSibling) {
        const o = this.readFeaturesFromNode(s, e);
        o && ot(n, o);
      }
      return n;
    }
    return [];
  }
  /**
   * Read the name of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {string|undefined} Name.
   * @api
   */
  readName(t) {
    if (t) {
      if (typeof t == "string") {
        const e = Bi(t);
        return this.readNameFromDocument(e);
      }
      return Ui(t) ? this.readNameFromDocument(
        /** @type {Document} */
        t
      ) : this.readNameFromNode(
        /** @type {Element} */
        t
      );
    }
  }
  /**
   * @param {Document} doc Document.
   * @return {string|undefined} Name.
   */
  readNameFromDocument(t) {
    for (let e = (
      /** @type {Node} */
      t.firstChild
    ); e; e = e.nextSibling)
      if (e.nodeType == Node.ELEMENT_NODE) {
        const n = this.readNameFromNode(
          /** @type {Element} */
          e
        );
        if (n)
          return n;
      }
  }
  /**
   * @param {Element} node Node.
   * @return {string|undefined} Name.
   */
  readNameFromNode(t) {
    for (let e = t.firstElementChild; e; e = e.nextElementSibling)
      if (U.includes(e.namespaceURI) && e.localName == "name")
        return Ht(e);
    for (let e = t.firstElementChild; e; e = e.nextElementSibling) {
      const n = e.localName;
      if (U.includes(e.namespaceURI) && (n == "Document" || n == "Folder" || n == "Placemark" || n == "kml")) {
        const r = this.readNameFromNode(e);
        if (r)
          return r;
      }
    }
  }
  /**
   * Read the network links of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Network links.
   * @api
   */
  readNetworkLinks(t) {
    const e = [];
    if (typeof t == "string") {
      const n = Bi(t);
      ot(e, this.readNetworkLinksFromDocument(n));
    } else Ui(t) ? ot(
      e,
      this.readNetworkLinksFromDocument(
        /** @type {Document} */
        t
      )
    ) : ot(
      e,
      this.readNetworkLinksFromNode(
        /** @type {Element} */
        t
      )
    );
    return e;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Network links.
   */
  readNetworkLinksFromDocument(t) {
    const e = [];
    for (let n = (
      /** @type {Node} */
      t.firstChild
    ); n; n = n.nextSibling)
      n.nodeType == Node.ELEMENT_NODE && ot(
        e,
        this.readNetworkLinksFromNode(
          /** @type {Element} */
          n
        )
      );
    return e;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Network links.
   */
  readNetworkLinksFromNode(t) {
    const e = [];
    for (let n = t.firstElementChild; n; n = n.nextElementSibling)
      if (U.includes(n.namespaceURI) && n.localName == "NetworkLink") {
        const r = gt({}, e5, n, []);
        e.push(r);
      }
    for (let n = t.firstElementChild; n; n = n.nextElementSibling) {
      const r = n.localName;
      U.includes(n.namespaceURI) && (r == "Document" || r == "Folder" || r == "kml") && ot(e, this.readNetworkLinksFromNode(n));
    }
    return e;
  }
  /**
   * Read the regions of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Regions.
   * @api
   */
  readRegion(t) {
    const e = [];
    if (typeof t == "string") {
      const n = Bi(t);
      ot(e, this.readRegionFromDocument(n));
    } else Ui(t) ? ot(
      e,
      this.readRegionFromDocument(
        /** @type {Document} */
        t
      )
    ) : ot(e, this.readRegionFromNode(
      /** @type {Element} */
      t
    ));
    return e;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Region.
   */
  readRegionFromDocument(t) {
    const e = [];
    for (let n = (
      /** @type {Node} */
      t.firstChild
    ); n; n = n.nextSibling)
      n.nodeType == Node.ELEMENT_NODE && ot(e, this.readRegionFromNode(
        /** @type {Element} */
        n
      ));
    return e;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Region.
   * @api
   */
  readRegionFromNode(t) {
    const e = [];
    for (let n = t.firstElementChild; n; n = n.nextElementSibling)
      if (U.includes(n.namespaceURI) && n.localName == "Region") {
        const r = gt({}, au, n, []);
        e.push(r);
      }
    for (let n = t.firstElementChild; n; n = n.nextElementSibling) {
      const r = n.localName;
      U.includes(n.namespaceURI) && (r == "Document" || r == "Folder" || r == "kml") && ot(e, this.readRegionFromNode(n));
    }
    return e;
  }
  /**
   * @typedef {Object} KMLCamera Specifies the observer's viewpoint and associated view parameters.
   * @property {number} [Latitude] Latitude of the camera.
   * @property {number} [Longitude] Longitude of the camera.
   * @property {number} [Altitude] Altitude of the camera.
   * @property {string} [AltitudeMode] Floor-related altitude mode.
   * @property {number} [Heading] Horizontal camera rotation.
   * @property {number} [Tilt] Lateral camera rotation.
   * @property {number} [Roll] Vertical camera rotation.
   */
  /**
   * Read the cameras of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<KMLCamera>} Cameras.
   * @api
   */
  readCamera(t) {
    const e = [];
    if (typeof t == "string") {
      const n = Bi(t);
      ot(e, this.readCameraFromDocument(n));
    } else Ui(t) ? ot(
      e,
      this.readCameraFromDocument(
        /** @type {Document} */
        t
      )
    ) : ot(e, this.readCameraFromNode(
      /** @type {Element} */
      t
    ));
    return e;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<KMLCamera>} Cameras.
   */
  readCameraFromDocument(t) {
    const e = [];
    for (let n = (
      /** @type {Node} */
      t.firstChild
    ); n; n = n.nextSibling)
      n.nodeType === Node.ELEMENT_NODE && ot(e, this.readCameraFromNode(
        /** @type {Element} */
        n
      ));
    return e;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<KMLCamera>} Cameras.
   * @api
   */
  readCameraFromNode(t) {
    const e = [];
    for (let n = t.firstElementChild; n; n = n.nextElementSibling)
      if (U.includes(n.namespaceURI) && n.localName === "Camera") {
        const r = gt({}, n5, n, []);
        e.push(r);
      }
    for (let n = t.firstElementChild; n; n = n.nextElementSibling) {
      const r = n.localName;
      U.includes(n.namespaceURI) && (r === "Document" || r === "Folder" || r === "Placemark" || r === "kml") && ot(e, this.readCameraFromNode(n));
    }
    return e;
  }
  /**
   * Encode an array of features in the KML format as an XML node. GeometryCollections,
   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.
   *
   * @param {Array<Feature>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   * @override
   */
  writeFeaturesNode(t, e) {
    e = this.adaptOptions(e);
    const n = f0(U[4], "kml"), r = "http://www.w3.org/2000/xmlns/";
    n.setAttributeNS(r, "xmlns:gx", Si[0]), n.setAttributeNS(r, "xmlns:xsi", bc), n.setAttributeNS(
      bc,
      "xsi:schemaLocation",
      Q9
    );
    const s = {
      node: n
    }, o = {};
    t.length > 1 ? o.Document = t : t.length == 1 && (o.Placemark = t[0]);
    const a = r5[n.namespaceURI], l = Ye(o, a);
    return Mt(
      s,
      s5,
      Oe,
      l,
      [e],
      a,
      this
    ), n;
  }
}
function h5(i, t) {
  const e = [0, 0];
  let n = "start";
  const r = i.getImage();
  if (r) {
    const a = r.getSize();
    if (a && a.length == 2) {
      const l = r.getScaleArray(), h = r.getAnchor();
      e[0] = l[0] * (a[0] - h[0]), e[1] = l[1] * (a[1] / 2 - h[1]), n = "left";
    }
  }
  let s = i.getText();
  return s ? (s = s.clone(), s.setFont(s.getFont() || Cn.getFont()), s.setScale(s.getScale() || Cn.getScale()), s.setFill(s.getFill() || Cn.getFill()), s.setStroke(s.getStroke() || Oa)) : s = Cn.clone(), s.setText(t), s.setOffsetX(e[0]), s.setOffsetY(e[1]), s.setTextAlign(n), new At({
    image: r,
    text: s
  });
}
function c5(i, t, e, n, r) {
  return (
    /**
     * @param {Feature} feature feature.
     * @param {number} resolution Resolution.
     * @return {Array<Style>|Style} Style.
     */
    (function(s, o) {
      let a = r, l = "", h = [];
      if (a) {
        const d = s.getGeometry();
        if (d)
          if (d instanceof Fe)
            h = d.getGeometriesArrayRecursive().filter(function(u) {
              const f = u.getType();
              return f === "Point" || f === "MultiPoint";
            }), a = h.length > 0;
          else {
            const u = d.getType();
            a = u === "Point" || u === "MultiPoint";
          }
      }
      a && (l = /** @type {string} */
      s.get("name"), a = a && !!l, a && /&[^&]+;/.test(l) && (j0 || (j0 = document.createElement("textarea")), j0.innerHTML = l, l = j0.value));
      let c = e;
      if (i ? c = i : t && (c = lu(t, e, n)), a) {
        const d = h5(c[0], l);
        if (h.length > 0) {
          d.setGeometry(new Fe(h));
          const u = new At({
            geometry: c[0].getGeometry(),
            image: null,
            fill: c[0].getFill(),
            stroke: c[0].getStroke(),
            text: null
          });
          return [d, u].concat(c.slice(1));
        }
        return d;
      }
      return c;
    })
  );
}
function lu(i, t, e) {
  return Array.isArray(i) ? i : typeof i == "string" ? lu(e[i], t, e) : t;
}
function s2(i) {
  const t = wi(i, !1), e = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(t);
  if (e) {
    const n = e[1];
    return [
      parseInt(n.substr(6, 2), 16),
      parseInt(n.substr(4, 2), 16),
      parseInt(n.substr(2, 2), 16),
      parseInt(n.substr(0, 2), 16) / 255
    ];
  }
}
function hu(i) {
  let t = wi(i, !1);
  const e = [];
  t = t.replace(/\s*,\s*/g, ",");
  const n = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
  let r;
  for (; r = n.exec(t); ) {
    const s = parseFloat(r[1]), o = parseFloat(r[2]), a = r[3] ? parseFloat(r[3]) : 0;
    e.push(s, o, a), t = t.substr(r[0].length);
  }
  if (t === "")
    return e;
}
function cu(i) {
  const t = wi(i, !1).trim();
  let e = i.baseURI;
  return (!e || e == "about:blank") && (e = window.location.href), e ? new URL(t, e).href : t;
}
function du(i) {
  const t = wi(i, !1).trim().replace(/^(?!.*#)/, "#");
  let e = i.baseURI;
  return (!e || e == "about:blank") && (e = window.location.href), e ? new URL(t, e).href : t;
}
function d5(i) {
  const t = i.getAttribute("xunits"), e = i.getAttribute("yunits");
  let n;
  return t !== "insetPixels" ? e !== "insetPixels" ? n = "bottom-left" : n = "top-left" : e !== "insetPixels" ? n = "bottom-right" : n = "top-right", {
    x: parseFloat(i.getAttribute("x")),
    xunits: Ec[t],
    y: parseFloat(i.getAttribute("y")),
    yunits: Ec[e],
    origin: n
  };
}
function uu(i) {
  return vt(i);
}
const u5 = B(U, {
  Pair: G5
});
function fu(i, t) {
  return gt(void 0, u5, i, t, this);
}
const f5 = B(U, {
  Icon: D(T5),
  color: D(s2),
  heading: D(vt),
  hotSpot: D(d5),
  scale: D(uu)
});
function g5(i, t) {
  const e = gt({}, f5, i, t);
  if (!e)
    return;
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), r = "Icon" in e ? e.Icon : {}, s = !("Icon" in e) || Object.keys(r).length > 0;
  let o;
  const a = (
    /** @type {string|undefined} */
    r.href
  );
  a ? o = a : s && (o = So);
  let l, h, c, d = "bottom-left";
  const u = (
    /** @type {Vec2|undefined} */
    e.hotSpot
  );
  u ? (l = [u.x, u.y], h = u.xunits, c = u.yunits, d = u.origin) : /^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(o) && (o.includes("pushpin") ? (l = La, h = Ss, c = Ms) : o.includes("arrow-reverse") ? (l = [54, 42], h = Ss, c = Ms) : o.includes("paddle") && (l = [32, 1], h = Ss, c = Ms));
  let f;
  const g = (
    /** @type {number|undefined} */
    r.x
  ), p = (
    /** @type {number|undefined} */
    r.y
  );
  g !== void 0 && p !== void 0 && (f = [g, p]);
  let m;
  const _ = (
    /** @type {number|undefined} */
    r.w
  ), y = (
    /** @type {number|undefined} */
    r.h
  );
  _ !== void 0 && y !== void 0 && (m = [_, y]);
  let x;
  const v = (
    /** @type {number} */
    e.heading
  );
  v !== void 0 && (x = ie(v));
  const C = (
    /** @type {number|undefined} */
    e.scale
  ), b = (
    /** @type {Array<number>|undefined} */
    e.color
  );
  if (s) {
    o == So && (m = Ts);
    const w = new Wr({
      anchor: l,
      anchorOrigin: d,
      anchorXUnits: h,
      anchorYUnits: c,
      crossOrigin: this.crossOrigin_,
      offset: f,
      offsetOrigin: "bottom-left",
      rotation: x,
      scale: C,
      size: m,
      src: this.iconUrlFunction_(o),
      color: b
    }), E = w.getScaleArray()[0], S = w.getSize();
    if (S === null) {
      const R = w.getImageState();
      if (R === z.IDLE || R === z.LOADING) {
        const I = function() {
          const L = w.getImageState();
          if (!(L === z.IDLE || L === z.LOADING)) {
            const A = w.getSize();
            if (A && A.length == 2) {
              const N = Mo(A);
              w.setScale(E * N);
            }
            w.unlistenImageChange(I);
          }
        };
        w.listenImageChange(I), R === z.IDLE && w.load();
      }
    } else if (S.length == 2) {
      const R = Mo(S);
      w.setScale(E * R);
    }
    n.imageStyle = w;
  } else
    n.imageStyle = Xl;
}
const m5 = B(U, {
  color: D(s2),
  scale: D(uu)
});
function p5(i, t) {
  const e = gt({}, m5, i, t);
  if (!e)
    return;
  const n = t[t.length - 1], r = new c0({
    fill: new Ne({
      color: (
        /** @type {import("../color.js").Color} */
        "color" in e ? e.color : xr
      )
    }),
    scale: (
      /** @type {number|undefined} */
      e.scale
    )
  });
  n.textStyle = r;
}
const _5 = B(U, {
  color: D(s2),
  width: D(vt)
});
function y5(i, t) {
  const e = gt({}, _5, i, t);
  if (!e)
    return;
  const n = t[t.length - 1], r = new Ae({
    color: (
      /** @type {import("../color.js").Color} */
      "color" in e ? e.color : xr
    ),
    width: (
      /** @type {number} */
      "width" in e ? e.width : 1
    )
  });
  n.strokeStyle = r;
}
const v5 = B(U, {
  color: D(s2),
  fill: D(Ki),
  outline: D(Ki)
});
function x5(i, t) {
  const e = gt({}, v5, i, t);
  if (!e)
    return;
  const n = t[t.length - 1], r = new Ne({
    color: (
      /** @type {import("../color.js").Color} */
      "color" in e ? e.color : xr
    )
  });
  n.fillStyle = r;
  const s = (
    /** @type {boolean|undefined} */
    e.fill
  );
  s !== void 0 && (n.fill = s);
  const o = (
    /** @type {boolean|undefined} */
    e.outline
  );
  o !== void 0 && (n.outline = o);
}
const C5 = B(U, {
  coordinates: Yl(hu)
});
function gu(i, t) {
  return gt(null, C5, i, t);
}
function b5(i, t) {
  const n = /** @type {GxTrackObject} */ t[t.length - 1].coordinates, r = wi(i, !1), o = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(r);
  if (o) {
    const a = parseFloat(o[1]), l = parseFloat(o[2]), h = parseFloat(o[3]);
    n.push([a, l, h]);
  } else
    n.push([]);
}
const w5 = B(Si, {
  Track: Oi(mu)
});
function E5(i, t) {
  const e = gt(
    [],
    w5,
    i,
    t
  );
  if (e)
    return new oi(e);
}
const S5 = B(
  U,
  {
    when: K5
  },
  B(Si, {
    coord: b5
  })
);
function mu(i, t) {
  const e = gt(
    /** @type {GxTrackObject} */
    {
      coordinates: [],
      whens: []
    },
    S5,
    i,
    t
  );
  if (!e)
    return;
  const n = [], r = e.coordinates, s = e.whens;
  for (let o = 0, a = Math.min(r.length, s.length); o < a; ++o)
    r[o].length == 3 && n.push(
      r[o][0],
      r[o][1],
      r[o][2],
      s[o]
    );
  return new Kt(n, "XYZM");
}
const M5 = B(
  U,
  {
    href: D(cu)
  },
  B(Si, {
    x: D(vt),
    y: D(vt),
    w: D(vt),
    h: D(vt)
  })
);
function T5(i, t) {
  const e = gt({}, M5, i, t);
  return e || null;
}
const R5 = B(U, {
  coordinates: Yl(hu)
});
function Zl(i, t) {
  return gt(
    null,
    R5,
    i,
    t
  );
}
const o2 = B(U, {
  extrude: D(Ki),
  tessellate: D(Ki),
  altitudeMode: D(Ht)
});
function pu(i, t) {
  const e = gt(
    {},
    o2,
    i,
    t
  ), n = Zl(i, t);
  if (n) {
    const r = new Kt(n, "XYZ");
    return r.setProperties(e, !0), r;
  }
}
function _u(i, t) {
  const e = gt(
    {},
    o2,
    i,
    t
  ), n = Zl(i, t);
  if (n) {
    const r = new jt(n, "XYZ", [
      n.length
    ]);
    return r.setProperties(e, !0), r;
  }
}
const P5 = B(U, {
  LineString: Oi(pu),
  LinearRing: Oi(_u),
  MultiGeometry: Oi(yu),
  Point: Oi(vu),
  Polygon: Oi(xu)
});
function yu(i, t) {
  const e = gt(
    [],
    P5,
    i,
    t
  );
  if (!e)
    return null;
  if (e.length === 0)
    return new Fe(e);
  let n, r = !0;
  const s = e[0].getType();
  let o;
  for (let a = 1, l = e.length; a < l; ++a)
    if (o = e[a], o.getType() != s) {
      r = !1;
      break;
    }
  if (r) {
    let a, l;
    if (s == "Point") {
      const h = e[0];
      a = h.getLayout(), l = h.getFlatCoordinates();
      for (let c = 1, d = e.length; c < d; ++c)
        o = e[c], ot(l, o.getFlatCoordinates());
      n = new nn(l, a), Z2(n, e);
    } else if (s == "LineString")
      n = new oi(e), Z2(n, e);
    else if (s == "Polygon")
      n = new xi(e), Z2(n, e);
    else if (s == "GeometryCollection" || s.startsWith("Multi"))
      n = new Fe(e);
    else
      throw new Error("Unknown geometry type found");
  } else
    n = new Fe(e);
  return (
    /** @type {import("../geom/Geometry.js").default} */
    n
  );
}
function vu(i, t) {
  const e = gt(
    {},
    o2,
    i,
    t
  ), n = Zl(i, t);
  if (n) {
    const r = new de(n, "XYZ");
    return r.setProperties(e, !0), r;
  }
}
const I5 = B(U, {
  innerBoundaryIs: Y5,
  outerBoundaryIs: Z5
});
function xu(i, t) {
  const e = gt(
    /** @type {Object<string,*>} */
    {},
    o2,
    i,
    t
  ), n = gt(
    [null],
    I5,
    i,
    t
  );
  if (n && n[0]) {
    const r = n[0], s = [r.length];
    for (let a = 1, l = n.length; a < l; ++a)
      ot(r, n[a]), s.push(r.length);
    const o = new jt(r, "XYZ", s);
    return o.setProperties(e, !0), o;
  }
}
const k5 = B(U, {
  IconStyle: g5,
  LabelStyle: p5,
  LineStyle: y5,
  PolyStyle: x5
});
function Hl(i, t) {
  const e = gt(
    {},
    k5,
    i,
    t,
    this
  );
  if (!e)
    return null;
  let n = (
    /** @type {Fill} */
    "fillStyle" in e ? e.fillStyle : H0
  );
  const r = (
    /** @type {boolean|undefined} */
    e.fill
  );
  r !== void 0 && !r && (n = null);
  let s;
  "imageStyle" in e ? e.imageStyle != Xl && (s = /** @type {import("../style/Image.js").default} */
  e.imageStyle) : s = Aa;
  const o = (
    /** @type {Text} */
    "textStyle" in e ? e.textStyle : Cn
  ), a = (
    /** @type {Stroke} */
    "strokeStyle" in e ? e.strokeStyle : Fa
  ), l = (
    /** @type {boolean|undefined} */
    e.outline
  );
  return l !== void 0 && !l ? [
    new At({
      geometry: function(h) {
        const c = h.getGeometry(), d = c.getType();
        if (d === "GeometryCollection") {
          const u = (
            /** @type {import("../geom/GeometryCollection").default} */
            c
          );
          return new Fe(
            u.getGeometriesArrayRecursive().filter(function(f) {
              const g = f.getType();
              return g !== "Polygon" && g !== "MultiPolygon";
            })
          );
        }
        if (d !== "Polygon" && d !== "MultiPolygon")
          return c;
      },
      fill: n,
      image: s,
      stroke: a,
      text: o,
      zIndex: void 0
      // FIXME
    }),
    new At({
      geometry: function(h) {
        const c = h.getGeometry(), d = c.getType();
        if (d === "GeometryCollection") {
          const u = (
            /** @type {import("../geom/GeometryCollection").default} */
            c
          );
          return new Fe(
            u.getGeometriesArrayRecursive().filter(function(f) {
              const g = f.getType();
              return g === "Polygon" || g === "MultiPolygon";
            })
          );
        }
        if (d === "Polygon" || d === "MultiPolygon")
          return c;
      },
      fill: n,
      stroke: null,
      zIndex: void 0
      // FIXME
    })
  ] : [
    new At({
      fill: n,
      image: s,
      stroke: a,
      text: o,
      zIndex: void 0
      // FIXME
    })
  ];
}
function Z2(i, t) {
  const e = t.length, n = new Array(t.length), r = new Array(t.length), s = new Array(t.length);
  let o, a, l;
  o = !1, a = !1, l = !1;
  for (let h = 0; h < e; ++h) {
    const c = t[h];
    n[h] = c.get("extrude"), r[h] = c.get("tessellate"), s[h] = c.get("altitudeMode"), o = o || n[h] !== void 0, a = a || r[h] !== void 0, l = l || s[h];
  }
  o && i.set("extrude", n), a && i.set("tessellate", r), l && i.set("altitudeMode", s);
}
const L5 = B(U, {
  displayName: D(Ht),
  value: D(Ht)
});
function A5(i, t) {
  const e = i.getAttribute("name");
  Yr(L5, i, t);
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  );
  e && n.displayName ? n[e] = {
    value: n.value,
    displayName: n.displayName,
    toString: function() {
      return n.value;
    }
  } : e !== null ? n[e] = n.value : n.displayName !== null && (n[n.displayName] = n.value), delete n.value;
}
const F5 = B(U, {
  Data: A5,
  SchemaData: z5
});
function Cu(i, t) {
  Yr(F5, i, t);
}
function bu(i, t) {
  Yr(au, i, t);
}
const O5 = B(U, {
  Style: D(Hl),
  key: D(Ht),
  styleUrl: D(du)
});
function G5(i, t) {
  const e = gt({}, O5, i, t, this);
  if (!e)
    return;
  const n = (
    /** @type {string|undefined} */
    e.key
  );
  if (n && n == "normal") {
    const r = (
      /** @type {string|undefined} */
      e.styleUrl
    );
    r && (t[t.length - 1] = r);
    const s = (
      /** @type {Style} */
      e.Style
    );
    s && (t[t.length - 1] = s);
  }
}
function N5(i, t) {
  const e = fu.call(this, i, t);
  if (!e)
    return;
  const n = t[t.length - 1];
  if (Array.isArray(e))
    n.Style = e;
  else if (typeof e == "string")
    n.styleUrl = e;
  else
    throw new Error("`styleMapValue` has an unknown type");
}
const D5 = B(U, {
  SimpleData: j5
});
function z5(i, t) {
  Yr(D5, i, t);
}
function j5(i, t) {
  const e = i.getAttribute("name");
  if (e !== null) {
    const n = Ht(i), r = (
      /** @type {Object} */
      t[t.length - 1]
    );
    r[e] = n;
  }
}
const U5 = B(U, {
  altitudeMode: D(Ht),
  minAltitude: D(vt),
  maxAltitude: D(vt),
  north: D(vt),
  south: D(vt),
  east: D(vt),
  west: D(vt)
});
function B5(i, t) {
  const e = gt(
    {},
    U5,
    i,
    t
  );
  if (!e)
    return;
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), r = [
    parseFloat(e.west),
    parseFloat(e.south),
    parseFloat(e.east),
    parseFloat(e.north)
  ];
  n.extent = r, n.altitudeMode = e.altitudeMode, n.minAltitude = parseFloat(e.minAltitude), n.maxAltitude = parseFloat(e.maxAltitude);
}
const V5 = B(U, {
  minLodPixels: D(vt),
  maxLodPixels: D(vt),
  minFadeExtent: D(vt),
  maxFadeExtent: D(vt)
});
function $5(i, t) {
  const e = gt({}, V5, i, t);
  if (!e)
    return;
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  );
  n.minLodPixels = parseFloat(e.minLodPixels), n.maxLodPixels = parseFloat(e.maxLodPixels), n.minFadeExtent = parseFloat(e.minFadeExtent), n.maxFadeExtent = parseFloat(e.maxFadeExtent);
}
const W5 = B(U, {
  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth
  // allows multiple, so we parse multiple here too.
  LinearRing: Oi(gu)
});
function Y5(i, t) {
  const e = gt(
    /** @type {Array<Array<number>>} */
    [],
    W5,
    i,
    t
  );
  e.length > 0 && /** @type {Array<Array<number>>} */
  t[t.length - 1].push(...e);
}
const X5 = B(U, {
  LinearRing: Yl(gu)
});
function Z5(i, t) {
  const e = gt(
    void 0,
    X5,
    i,
    t
  );
  if (e) {
    const n = (
      /** @type {Array<Array<number>>} */
      t[t.length - 1]
    );
    n[0] = e;
  }
}
function H5(i, t) {
  Yr(i5, i, t);
}
function K5(i, t) {
  const n = /** @type {GxTrackObject} */ t[t.length - 1].whens, r = wi(i, !1), s = Date.parse(r);
  n.push(isNaN(s) ? 0 : s);
}
function a2(i, t) {
  const e = Ln(t), r = [(e.length == 4 ? e[3] : 1) * 255, e[2], e[1], e[0]];
  for (let s = 0; s < 4; ++s) {
    const o = Math.floor(
      /** @type {number} */
      r[s]
    ).toString(16);
    r[s] = o.length == 1 ? "0" + o : o;
  }
  Me(i, r.join(""));
}
function q5(i, t, e) {
  const n = e[e.length - 1], r = n.layout, s = n.stride;
  let o;
  if (r == "XY" || r == "XYM")
    o = 2;
  else if (r == "XYZ" || r == "XYZM")
    o = 3;
  else
    throw new Error("Invalid geometry layout");
  const a = t.length;
  let l = "";
  if (a > 0) {
    l += t[0];
    for (let h = 1; h < o; ++h)
      l += "," + t[h];
    for (let h = s; h < a; h += s) {
      l += " " + t[h];
      for (let c = 1; c < o; ++c)
        l += "," + t[h + c];
    }
  }
  Me(i, l);
}
const K0 = B(U, {
  Data: W(J5),
  value: W(t8),
  displayName: W(Q5)
});
function J5(i, t, e) {
  i.setAttribute("name", t.name);
  const n = { node: i }, r = t.value;
  typeof r == "object" ? (r !== null && r.displayName && Mt(
    n,
    K0,
    Oe,
    [r.displayName],
    e,
    ["displayName"]
  ), r !== null && r.value && Mt(
    n,
    K0,
    Oe,
    [r.value],
    e,
    ["value"]
  )) : Mt(
    n,
    K0,
    Oe,
    [r],
    e,
    ["value"]
  );
}
function Q5(i, t) {
  Me(i, t);
}
function t8(i, t) {
  Me(i, t);
}
const e8 = B(U, {
  Placemark: W(Su)
}), i8 = function(i, t, e) {
  const n = t[t.length - 1].node;
  return f0(n.namespaceURI, "Placemark");
};
function n8(i, t, e) {
  Mt(
    { node: i },
    e8,
    i8,
    t,
    e,
    void 0,
    this
  );
}
const r8 = Ei("Data");
function s8(i, t, e) {
  const n = { node: i }, r = t.names, s = t.values, o = r.length;
  for (let a = 0; a < o; a++)
    Mt(
      n,
      K0,
      r8,
      [{ name: r[a], value: s[a] }],
      e
    );
}
const Mc = B(
  U,
  ["href"],
  B(Si, ["x", "y", "w", "h"])
), Tc = B(
  U,
  {
    href: W(Me)
  },
  B(Si, {
    x: W(xn),
    y: W(xn),
    w: W(xn),
    h: W(xn)
  })
), o8 = function(i, t, e) {
  return f0(Si[0], "gx:" + e);
};
function a8(i, t, e) {
  const n = { node: i }, r = e[e.length - 1].node;
  let s = Mc[r.namespaceURI], o = Ye(t, s);
  Mt(
    n,
    Tc,
    Oe,
    o,
    e,
    s
  ), s = Mc[Si[0]], o = Ye(t, s), Mt(
    n,
    Tc,
    o8,
    o,
    e,
    s
  );
}
const l8 = B(U, [
  "scale",
  "heading",
  "Icon",
  "color",
  "hotSpot"
]), h8 = B(U, {
  Icon: W(a8),
  color: W(a2),
  heading: W(xn),
  hotSpot: W(G8),
  scale: W(Tu)
});
function c8(i, t, e) {
  const n = { node: i }, r = {}, s = t.getSrc(), o = t.getSize(), a = t.getImageSize(), l = {
    href: s
  };
  if (o) {
    l.w = o[0], l.h = o[1];
    const m = t.getAnchor(), _ = t.getOrigin();
    if (_ && a && _[0] !== 0 && _[1] !== o[1] && (l.x = _[0], l.y = a[1] - (_[1] + o[1])), m && (m[0] !== o[0] / 2 || m[1] !== o[1] / 2)) {
      const y = {
        x: m[0],
        xunits: "pixels",
        y: o[1] - m[1],
        yunits: "pixels"
      };
      r.hotSpot = y;
    }
  }
  r.Icon = l;
  let h = t.getScaleArray()[0], c = o;
  if (c === null && (c = Ts), c.length == 2) {
    const m = Mo(c);
    h = h / m;
  }
  h !== 1 && (r.scale = h);
  const d = t.getRotation();
  d !== 0 && (r.heading = d);
  const u = t.getColor();
  u && (r.color = u);
  const f = e[e.length - 1].node, g = l8[f.namespaceURI], p = Ye(r, g);
  Mt(
    n,
    h8,
    Oe,
    p,
    e,
    g
  );
}
const d8 = B(U, [
  "color",
  "scale"
]), u8 = B(U, {
  color: W(a2),
  scale: W(Tu)
});
function f8(i, t, e) {
  const n = { node: i }, r = {}, s = t.getFill();
  s && (r.color = s.getColor());
  const o = t.getScale();
  o && o !== 1 && (r.scale = o);
  const a = e[e.length - 1].node, l = d8[a.namespaceURI], h = Ye(r, l);
  Mt(
    n,
    u8,
    Oe,
    h,
    e,
    l
  );
}
const g8 = B(U, ["color", "width"]), m8 = B(U, {
  color: W(a2),
  width: W(xn)
});
function p8(i, t, e) {
  const n = { node: i }, r = {
    color: t.getColor(),
    width: Number(t.getWidth()) || 1
  }, s = e[e.length - 1].node, o = g8[s.namespaceURI], a = Ye(r, o);
  Mt(
    n,
    m8,
    Oe,
    a,
    e,
    o
  );
}
const _8 = {
  Point: "Point",
  LineString: "LineString",
  LinearRing: "LinearRing",
  Polygon: "Polygon",
  MultiPoint: "MultiGeometry",
  MultiLineString: "MultiGeometry",
  MultiPolygon: "MultiGeometry",
  GeometryCollection: "MultiGeometry"
}, wu = function(i, t, e) {
  if (i) {
    const n = t[t.length - 1].node;
    return f0(
      n.namespaceURI,
      _8[
        /** @type {import("../geom/Geometry.js").default} */
        i.getType()
      ]
    );
  }
}, y8 = Ei("Point"), v8 = Ei("LineString"), x8 = Ei("LinearRing"), C8 = Ei("Polygon"), b8 = B(U, {
  LineString: W(Cr),
  Point: W(Cr),
  Polygon: W(Mu),
  GeometryCollection: W(Eu)
});
function Eu(i, t, e) {
  const n = { node: i }, r = t.getType();
  let s = [], o;
  if (r === "GeometryCollection")
    t.getGeometriesArrayRecursive().forEach(function(a) {
      const l = a.getType();
      if (l === "MultiPoint")
        s = s.concat(
          /** @type {MultiPoint} */
          a.getPoints()
        );
      else if (l === "MultiLineString")
        s = s.concat(
          /** @type {MultiLineString} */
          a.getLineStrings()
        );
      else if (l === "MultiPolygon")
        s = s.concat(
          /** @type {MultiPolygon} */
          a.getPolygons()
        );
      else if (l === "Point" || l === "LineString" || l === "Polygon")
        s.push(a);
      else
        throw new Error("Unknown geometry type");
    }), o = wu;
  else if (r === "MultiPoint")
    s = /** @type {MultiPoint} */
    t.getPoints(), o = y8;
  else if (r === "MultiLineString")
    s = /** @type {MultiLineString} */
    t.getLineStrings(), o = v8;
  else if (r === "MultiPolygon")
    s = /** @type {MultiPolygon} */
    t.getPolygons(), o = C8;
  else
    throw new Error("Unknown geometry type");
  Mt(
    n,
    b8,
    o,
    s,
    e
  );
}
const w8 = B(U, {
  LinearRing: W(Cr)
});
function Rc(i, t, e) {
  Mt(
    { node: i },
    w8,
    x8,
    [t],
    e
  );
}
const H2 = B(U, {
  ExtendedData: W(s8),
  MultiGeometry: W(Eu),
  LineString: W(Cr),
  LinearRing: W(Cr),
  Point: W(Cr),
  Polygon: W(Mu),
  Style: W(O8),
  address: W(Me),
  description: W(Me),
  name: W(Me),
  open: W(Gr),
  phoneNumber: W(Me),
  styleUrl: W(Me),
  visibility: W(Gr)
}), E8 = B(U, [
  "name",
  "open",
  "visibility",
  "address",
  "phoneNumber",
  "description",
  "styleUrl",
  "Style"
]), S8 = Ei("ExtendedData");
function Su(i, t, e) {
  const n = { node: i };
  t.getId() && i.setAttribute(
    "id",
    /** @type {string} */
    t.getId()
  );
  const r = t.getProperties(), s = {
    address: 1,
    description: 1,
    name: 1,
    open: 1,
    phoneNumber: 1,
    styleUrl: 1,
    visibility: 1
  };
  s[t.getGeometryName()] = 1;
  const o = Object.keys(r || {}).sort().filter(function(f) {
    return !s[f];
  }), a = t.getStyleFunction();
  if (a) {
    const f = a(t, 0);
    if (f) {
      const g = Array.isArray(f) ? f : [f];
      let p = g;
      if (t.getGeometry() && (p = g.filter(function(m) {
        const _ = m.getGeometryFunction()(t);
        if (_) {
          const y = _.getType();
          return y === "GeometryCollection" ? (
            /** @type {GeometryCollection} */
            _.getGeometriesArrayRecursive().filter(function(x) {
              const v = x.getType();
              return v === "Point" || v === "MultiPoint";
            }).length
          ) : y === "Point" || y === "MultiPoint";
        }
      })), this.writeStyles_) {
        let m = g, _ = g;
        t.getGeometry() && (m = g.filter(function(y) {
          const x = y.getGeometryFunction()(t);
          if (x) {
            const v = x.getType();
            return v === "GeometryCollection" ? (
              /** @type {GeometryCollection} */
              x.getGeometriesArrayRecursive().filter(function(C) {
                const b = C.getType();
                return b === "LineString" || b === "MultiLineString";
              }).length
            ) : v === "LineString" || v === "MultiLineString";
          }
        }), _ = g.filter(function(y) {
          const x = y.getGeometryFunction()(t);
          if (x) {
            const v = x.getType();
            return v === "GeometryCollection" ? (
              /** @type {GeometryCollection} */
              x.getGeometriesArrayRecursive().filter(function(C) {
                const b = C.getType();
                return b === "Polygon" || b === "MultiPolygon";
              }).length
            ) : v === "Polygon" || v === "MultiPolygon";
          }
        })), r.Style = {
          pointStyles: p,
          lineStyles: m,
          polyStyles: _
        };
      }
      if (p.length && r.name === void 0) {
        const m = p[0].getText();
        m && (r.name = m.getText());
      }
    }
  }
  const l = e[e.length - 1].node, h = E8[l.namespaceURI], c = Ye(r, h);
  if (Mt(
    n,
    H2,
    Oe,
    c,
    e,
    h
  ), o.length > 0) {
    const f = Ye(r, o);
    Mt(
      n,
      H2,
      S8,
      [{ names: o, values: f }],
      e
    );
  }
  const d = (
    /** @type {import("./Feature.js").WriteOptions} */
    e[0]
  );
  let u = t.getGeometry();
  u && (u = Bn(u, !0, d)), Mt(
    n,
    H2,
    wu,
    [u],
    e
  );
}
const M8 = B(U, [
  "extrude",
  "tessellate",
  "altitudeMode",
  "coordinates"
]), T8 = B(U, {
  extrude: W(Gr),
  tessellate: W(Gr),
  altitudeMode: W(Me),
  coordinates: W(q5)
});
function Cr(i, t, e) {
  const n = t.getFlatCoordinates(), r = { node: i };
  r.layout = t.getLayout(), r.stride = t.getStride();
  const s = t.getProperties();
  s.coordinates = n;
  const o = e[e.length - 1].node, a = M8[o.namespaceURI], l = Ye(s, a);
  Mt(
    r,
    T8,
    Oe,
    l,
    e,
    a
  );
}
const R8 = B(U, [
  "color",
  "fill",
  "outline"
]), Pc = B(U, {
  outerBoundaryIs: W(Rc),
  innerBoundaryIs: W(Rc)
}), P8 = Ei("innerBoundaryIs"), I8 = Ei("outerBoundaryIs");
function Mu(i, t, e) {
  const n = t.getLinearRings(), r = n.shift(), s = { node: i };
  Mt(
    s,
    Pc,
    P8,
    n,
    e
  ), Mt(
    s,
    Pc,
    I8,
    [r],
    e
  );
}
const k8 = B(U, {
  color: W(a2),
  fill: W(Gr),
  outline: W(Gr)
});
function L8(i, t, e) {
  const n = { node: i }, r = t.getFill(), s = t.getStroke(), o = {
    color: r ? r.getColor() : void 0,
    fill: r ? void 0 : !1,
    outline: s ? void 0 : !1
  }, a = e[e.length - 1].node, l = R8[a.namespaceURI], h = Ye(o, l);
  Mt(
    n,
    k8,
    Oe,
    h,
    e,
    l
  );
}
function Tu(i, t) {
  xn(i, Math.round(t * 1e6) / 1e6);
}
const A8 = B(U, [
  "IconStyle",
  "LabelStyle",
  "LineStyle",
  "PolyStyle"
]), F8 = B(U, {
  IconStyle: W(c8),
  LabelStyle: W(f8),
  LineStyle: W(p8),
  PolyStyle: W(L8)
});
function O8(i, t, e) {
  const n = { node: i }, r = {};
  if (t.pointStyles.length) {
    const l = t.pointStyles[0].getText();
    l && (r.LabelStyle = l);
    const h = t.pointStyles[0].getImage();
    h && typeof /** @type {?} */
    h.getSrc == "function" && (r.IconStyle = h);
  }
  if (t.lineStyles.length) {
    const l = t.lineStyles[0].getStroke();
    l && (r.LineStyle = l);
  }
  if (t.polyStyles.length) {
    const l = t.polyStyles[0].getStroke();
    l && !r.LineStyle && (r.LineStyle = l), r.PolyStyle = t.polyStyles[0];
  }
  const s = e[e.length - 1].node, o = A8[s.namespaceURI], a = Ye(r, o);
  Mt(
    n,
    F8,
    Oe,
    a,
    e,
    o
  );
}
function G8(i, t) {
  i.setAttribute("x", String(t.x)), i.setAttribute("y", String(t.y)), i.setAttribute("xunits", t.xunits), i.setAttribute("yunits", t.yunits);
}
function N8(i, t) {
  const s = i.readFeatures(t)[0].getGeometry().getCoordinates();
  if (s && s.length > 0) {
    const o = Ru(s);
    if (typeof o == "number")
      return o >= -180 && o <= 180 ? "EPSG:4326" : "EPSG:3857";
  }
}
function Ru(i) {
  if (typeof i == "number")
    return i;
  if (Array.isArray(i) && i.length > 0)
    return Ru(i[0]);
}
function D8(i, t, e, n = !1, r = !0) {
  try {
    const s = z8(i);
    if (!s) {
      console.error("Unsupported format or invalid data");
      return;
    }
    const o = N8(s, i), a = s.readFeatures(i, {
      dataProjection: o || iu.dataProjection,
      featureProjection: e.projection
    });
    nu(
      { features: a },
      t,
      e,
      !1,
      n,
      r
    );
  } catch (s) {
    console.error("Error parsing data:", s);
  }
}
function z8(i) {
  return j8(i) ? new i2() : U8(i) ? new l5({ extractStyles: !1 }) : B8(i) ? new A9() : null;
}
function j8(i) {
  try {
    const t = JSON.parse(i);
    return t.type === "FeatureCollection" || t.type === "Feature";
  } catch {
    return !1;
  }
}
function U8(i) {
  return i.includes("<kml") && i.includes("</kml>");
}
function B8(i) {
  try {
    const t = JSON.parse(i);
    return t.type === "Topology" && t.objects;
  } catch {
    return !1;
  }
}
function V8(i) {
  i("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), i("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), i("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  for (var t = 1; t <= 60; ++t)
    i("EPSG:" + (32600 + t), "+proj=utm +zone=" + t + " +datum=WGS84 +units=m"), i("EPSG:" + (32700 + t), "+proj=utm +zone=" + t + " +south +datum=WGS84 +units=m");
  i("EPSG:5041", "+title=WGS 84 / UPS North (E,N) +proj=stere +lat_0=90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +datum=WGS84 +units=m"), i("EPSG:5042", "+title=WGS 84 / UPS South (E,N) +proj=stere +lat_0=-90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +datum=WGS84 +units=m"), i.WGS84 = i["EPSG:4326"], i["EPSG:3785"] = i["EPSG:3857"], i.GOOGLE = i["EPSG:3857"], i["EPSG:900913"] = i["EPSG:3857"], i["EPSG:102113"] = i["EPSG:3857"];
}
var Fn = 1, On = 2, br = 3, $8 = 4, Na = 5, Ic = 6378137, W8 = 6356752314e-3, kc = 0.0066943799901413165, Rs = 484813681109536e-20, T = Math.PI / 2, Y8 = 0.16666666666666666, X8 = 0.04722222222222222, Z8 = 0.022156084656084655, k = 1e-10, Ct = 0.017453292519943295, ce = 57.29577951308232, lt = Math.PI / 4, Zs = Math.PI * 2, St = 3.14159265359, ue = {};
ue.greenwich = 0;
ue.lisbon = -9.131906111111;
ue.paris = 2.337229166667;
ue.bogota = -74.080916666667;
ue.madrid = -3.687938888889;
ue.rome = 12.452333333333;
ue.bern = 7.439583333333;
ue.jakarta = 106.807719444444;
ue.ferro = -17.666666666667;
ue.brussels = 4.367975;
ue.stockholm = 18.058277777778;
ue.athens = 23.7163375;
ue.oslo = 10.722916666667;
const H8 = {
  mm: { to_meter: 1e-3 },
  cm: { to_meter: 0.01 },
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 },
  fath: { to_meter: 1.8288 },
  kmi: { to_meter: 1852 },
  "us-ch": { to_meter: 20.1168402336805 },
  "us-mi": { to_meter: 1609.34721869444 },
  km: { to_meter: 1e3 },
  "ind-ft": { to_meter: 0.30479841 },
  "ind-yd": { to_meter: 0.91439523 },
  mi: { to_meter: 1609.344 },
  yd: { to_meter: 0.9144 },
  ch: { to_meter: 20.1168 },
  link: { to_meter: 0.201168 },
  dm: { to_meter: 0.1 },
  in: { to_meter: 0.0254 },
  "ind-ch": { to_meter: 20.11669506 },
  "us-in": { to_meter: 0.025400050800101 },
  "us-yd": { to_meter: 0.914401828803658 }
};
var Lc = /[\s_\-\/\(\)]/g;
function qi(i, t) {
  if (i[t])
    return i[t];
  for (var e = Object.keys(i), n = t.toLowerCase().replace(Lc, ""), r = -1, s, o; ++r < e.length; )
    if (s = e[r], o = s.toLowerCase().replace(Lc, ""), o === n)
      return i[s];
}
function Da(i) {
  var t = {}, e = i.split("+").map(function(a) {
    return a.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(a, l) {
    var h = l.split("=");
    return h.push(!0), a[h[0].toLowerCase()] = h[1], a;
  }, {}), n, r, s, o = {
    proj: "projName",
    datum: "datumCode",
    rf: function(a) {
      t.rf = parseFloat(a);
    },
    lat_0: function(a) {
      t.lat0 = a * Ct;
    },
    lat_1: function(a) {
      t.lat1 = a * Ct;
    },
    lat_2: function(a) {
      t.lat2 = a * Ct;
    },
    lat_ts: function(a) {
      t.lat_ts = a * Ct;
    },
    lon_0: function(a) {
      t.long0 = a * Ct;
    },
    lon_1: function(a) {
      t.long1 = a * Ct;
    },
    lon_2: function(a) {
      t.long2 = a * Ct;
    },
    alpha: function(a) {
      t.alpha = parseFloat(a) * Ct;
    },
    gamma: function(a) {
      t.rectified_grid_angle = parseFloat(a) * Ct;
    },
    lonc: function(a) {
      t.longc = a * Ct;
    },
    x_0: function(a) {
      t.x0 = parseFloat(a);
    },
    y_0: function(a) {
      t.y0 = parseFloat(a);
    },
    k_0: function(a) {
      t.k0 = parseFloat(a);
    },
    k: function(a) {
      t.k0 = parseFloat(a);
    },
    a: function(a) {
      t.a = parseFloat(a);
    },
    b: function(a) {
      t.b = parseFloat(a);
    },
    r: function(a) {
      t.a = t.b = parseFloat(a);
    },
    r_a: function() {
      t.R_A = !0;
    },
    zone: function(a) {
      t.zone = parseInt(a, 10);
    },
    south: function() {
      t.utmSouth = !0;
    },
    towgs84: function(a) {
      t.datum_params = a.split(",").map(function(l) {
        return parseFloat(l);
      });
    },
    to_meter: function(a) {
      t.to_meter = parseFloat(a);
    },
    units: function(a) {
      t.units = a;
      var l = qi(H8, a);
      l && (t.to_meter = l.to_meter);
    },
    from_greenwich: function(a) {
      t.from_greenwich = a * Ct;
    },
    pm: function(a) {
      var l = qi(ue, a);
      t.from_greenwich = (l || parseFloat(a)) * Ct;
    },
    nadgrids: function(a) {
      a === "@null" ? t.datumCode = "none" : t.nadgrids = a;
    },
    axis: function(a) {
      var l = "ewnsud";
      a.length === 3 && l.indexOf(a.substr(0, 1)) !== -1 && l.indexOf(a.substr(1, 1)) !== -1 && l.indexOf(a.substr(2, 1)) !== -1 && (t.axis = a);
    },
    approx: function() {
      t.approx = !0;
    },
    over: function() {
      t.over = !0;
    }
  };
  for (n in e)
    r = e[n], n in o ? (s = o[n], typeof s == "function" ? s(r) : t[s] = r) : t[n] = r;
  return typeof t.datumCode == "string" && t.datumCode !== "WGS84" && (t.datumCode = t.datumCode.toLowerCase()), t.projStr = i, t;
}
class Pu {
  static getId(t) {
    const e = t.find((n) => Array.isArray(n) && n[0] === "ID");
    return e && e.length >= 3 ? {
      authority: e[1],
      code: parseInt(e[2], 10)
    } : null;
  }
  static convertUnit(t, e = "unit") {
    if (!t || t.length < 3)
      return { type: e, name: "unknown", conversion_factor: null };
    const n = t[1], r = parseFloat(t[2]) || null, s = t.find((a) => Array.isArray(a) && a[0] === "ID"), o = s ? {
      authority: s[1],
      code: parseInt(s[2], 10)
    } : null;
    return {
      type: e,
      name: n,
      conversion_factor: r,
      id: o
    };
  }
  static convertAxis(t) {
    const e = t[1] || "Unknown";
    let n;
    const r = e.match(/^\((.)\)$/);
    if (r) {
      const h = r[1].toUpperCase();
      if (h === "E") n = "east";
      else if (h === "N") n = "north";
      else if (h === "U") n = "up";
      else throw new Error(`Unknown axis abbreviation: ${h}`);
    } else
      n = t[2] ? t[2].toLowerCase() : "unknown";
    const s = t.find((h) => Array.isArray(h) && h[0] === "ORDER"), o = s ? parseInt(s[1], 10) : null, a = t.find(
      (h) => Array.isArray(h) && (h[0] === "LENGTHUNIT" || h[0] === "ANGLEUNIT" || h[0] === "SCALEUNIT")
    ), l = this.convertUnit(a);
    return {
      name: e,
      direction: n,
      // Use the valid PROJJSON direction value
      unit: l,
      order: o
    };
  }
  static extractAxes(t) {
    return t.filter((e) => Array.isArray(e) && e[0] === "AXIS").map((e) => this.convertAxis(e)).sort((e, n) => (e.order || 0) - (n.order || 0));
  }
  static convert(t, e = {}) {
    switch (t[0]) {
      case "PROJCRS":
        e.type = "ProjectedCRS", e.name = t[1], e.base_crs = t.find((u) => Array.isArray(u) && u[0] === "BASEGEOGCRS") ? this.convert(t.find((u) => Array.isArray(u) && u[0] === "BASEGEOGCRS")) : null, e.conversion = t.find((u) => Array.isArray(u) && u[0] === "CONVERSION") ? this.convert(t.find((u) => Array.isArray(u) && u[0] === "CONVERSION")) : null;
        const n = t.find((u) => Array.isArray(u) && u[0] === "CS");
        n && (e.coordinate_system = {
          type: n[1],
          axis: this.extractAxes(t)
        });
        const r = t.find((u) => Array.isArray(u) && u[0] === "LENGTHUNIT");
        if (r) {
          const u = this.convertUnit(r);
          e.coordinate_system.unit = u;
        }
        e.id = this.getId(t);
        break;
      case "BASEGEOGCRS":
      case "GEOGCRS":
        e.type = "GeographicCRS", e.name = t[1];
        const s = t.find(
          (u) => Array.isArray(u) && (u[0] === "DATUM" || u[0] === "ENSEMBLE")
        );
        if (s) {
          const u = this.convert(s);
          s[0] === "ENSEMBLE" ? e.datum_ensemble = u : e.datum = u;
          const f = t.find((g) => Array.isArray(g) && g[0] === "PRIMEM");
          f && f[1] !== "Greenwich" && (u.prime_meridian = {
            name: f[1],
            longitude: parseFloat(f[2])
          });
        }
        e.coordinate_system = {
          type: "ellipsoidal",
          axis: this.extractAxes(t)
        }, e.id = this.getId(t);
        break;
      case "DATUM":
        e.type = "GeodeticReferenceFrame", e.name = t[1], e.ellipsoid = t.find((u) => Array.isArray(u) && u[0] === "ELLIPSOID") ? this.convert(t.find((u) => Array.isArray(u) && u[0] === "ELLIPSOID")) : null;
        break;
      case "ENSEMBLE":
        e.type = "DatumEnsemble", e.name = t[1], e.members = t.filter((u) => Array.isArray(u) && u[0] === "MEMBER").map((u) => ({
          type: "DatumEnsembleMember",
          name: u[1],
          id: this.getId(u)
          // Extract ID as { authority, code }
        }));
        const o = t.find((u) => Array.isArray(u) && u[0] === "ENSEMBLEACCURACY");
        o && (e.accuracy = parseFloat(o[1]));
        const a = t.find((u) => Array.isArray(u) && u[0] === "ELLIPSOID");
        a && (e.ellipsoid = this.convert(a)), e.id = this.getId(t);
        break;
      case "ELLIPSOID":
        e.type = "Ellipsoid", e.name = t[1], e.semi_major_axis = parseFloat(t[2]), e.inverse_flattening = parseFloat(t[3]), t.find((u) => Array.isArray(u) && u[0] === "LENGTHUNIT") && this.convert(t.find((u) => Array.isArray(u) && u[0] === "LENGTHUNIT"), e);
        break;
      case "CONVERSION":
        e.type = "Conversion", e.name = t[1], e.method = t.find((u) => Array.isArray(u) && u[0] === "METHOD") ? this.convert(t.find((u) => Array.isArray(u) && u[0] === "METHOD")) : null, e.parameters = t.filter((u) => Array.isArray(u) && u[0] === "PARAMETER").map((u) => this.convert(u));
        break;
      case "METHOD":
        e.type = "Method", e.name = t[1], e.id = this.getId(t);
        break;
      case "PARAMETER":
        e.type = "Parameter", e.name = t[1], e.value = parseFloat(t[2]), e.unit = this.convertUnit(
          t.find(
            (u) => Array.isArray(u) && (u[0] === "LENGTHUNIT" || u[0] === "ANGLEUNIT" || u[0] === "SCALEUNIT")
          )
        ), e.id = this.getId(t);
        break;
      case "BOUNDCRS":
        e.type = "BoundCRS";
        const l = t.find((u) => Array.isArray(u) && u[0] === "SOURCECRS");
        if (l) {
          const u = l.find((f) => Array.isArray(f));
          e.source_crs = u ? this.convert(u) : null;
        }
        const h = t.find((u) => Array.isArray(u) && u[0] === "TARGETCRS");
        if (h) {
          const u = h.find((f) => Array.isArray(f));
          e.target_crs = u ? this.convert(u) : null;
        }
        const c = t.find((u) => Array.isArray(u) && u[0] === "ABRIDGEDTRANSFORMATION");
        c ? e.transformation = this.convert(c) : e.transformation = null;
        break;
      case "ABRIDGEDTRANSFORMATION":
        if (e.type = "Transformation", e.name = t[1], e.method = t.find((u) => Array.isArray(u) && u[0] === "METHOD") ? this.convert(t.find((u) => Array.isArray(u) && u[0] === "METHOD")) : null, e.parameters = t.filter((u) => Array.isArray(u) && (u[0] === "PARAMETER" || u[0] === "PARAMETERFILE")).map((u) => {
          if (u[0] === "PARAMETER")
            return this.convert(u);
          if (u[0] === "PARAMETERFILE")
            return {
              name: u[1],
              value: u[2],
              id: {
                authority: "EPSG",
                code: 8656
              }
            };
        }), e.parameters.length === 7) {
          const u = e.parameters[6];
          u.name === "Scale difference" && (u.value = Math.round((u.value - 1) * 1e12) / 1e6);
        }
        e.id = this.getId(t);
        break;
      case "AXIS":
        e.coordinate_system || (e.coordinate_system = { type: "unspecified", axis: [] }), e.coordinate_system.axis.push(this.convertAxis(t));
        break;
      case "LENGTHUNIT":
        const d = this.convertUnit(t, "LinearUnit");
        e.coordinate_system && e.coordinate_system.axis && e.coordinate_system.axis.forEach((u) => {
          u.unit || (u.unit = d);
        }), d.conversion_factor && d.conversion_factor !== 1 && e.semi_major_axis && (e.semi_major_axis = {
          value: e.semi_major_axis,
          unit: d
        });
        break;
      default:
        e.keyword = t[0];
        break;
    }
    return e;
  }
}
class K8 extends Pu {
  static convert(t, e = {}) {
    return super.convert(t, e), e.coordinate_system && e.coordinate_system.subtype === "Cartesian" && delete e.coordinate_system, e.usage && delete e.usage, e;
  }
}
class q8 extends Pu {
  static convert(t, e = {}) {
    super.convert(t, e);
    const n = t.find((s) => Array.isArray(s) && s[0] === "CS");
    n && (e.coordinate_system = {
      subtype: n[1],
      axis: this.extractAxes(t)
    });
    const r = t.find((s) => Array.isArray(s) && s[0] === "USAGE");
    if (r) {
      const s = r.find((l) => Array.isArray(l) && l[0] === "SCOPE"), o = r.find((l) => Array.isArray(l) && l[0] === "AREA"), a = r.find((l) => Array.isArray(l) && l[0] === "BBOX");
      e.usage = {}, s && (e.usage.scope = s[1]), o && (e.usage.area = o[1]), a && (e.usage.bbox = a.slice(1));
    }
    return e;
  }
}
function J8(i) {
  return i.find((t) => Array.isArray(t) && t[0] === "USAGE") ? "2019" : (i.find((t) => Array.isArray(t) && t[0] === "CS") || i[0] === "BOUNDCRS" || i[0] === "PROJCRS" || i[0] === "GEOGCRS", "2015");
}
function Q8(i) {
  return (J8(i) === "2019" ? q8 : K8).convert(i);
}
function tp(i) {
  const t = i.toUpperCase();
  return t.includes("PROJCRS") || t.includes("GEOGCRS") || t.includes("BOUNDCRS") || t.includes("VERTCRS") || t.includes("LENGTHUNIT") || t.includes("ANGLEUNIT") || t.includes("SCALEUNIT") ? "WKT2" : (t.includes("PROJCS") || t.includes("GEOGCS") || t.includes("LOCAL_CS") || t.includes("VERT_CS") || t.includes("UNIT"), "WKT1");
}
var Hs = 1, Iu = 2, ku = 3, To = 4, Lu = 5, Kl = -1, ep = /\s/, ip = /[A-Za-z]/, np = /[A-Za-z84_]/, l2 = /[,\]]/, Au = /[\d\.E\-\+]/;
function Mi(i) {
  if (typeof i != "string")
    throw new Error("not a string");
  this.text = i.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Hs;
}
Mi.prototype.readCharicter = function() {
  var i = this.text[this.place++];
  if (this.state !== To)
    for (; ep.test(i); ) {
      if (this.place >= this.text.length)
        return;
      i = this.text[this.place++];
    }
  switch (this.state) {
    case Hs:
      return this.neutral(i);
    case Iu:
      return this.keyword(i);
    case To:
      return this.quoted(i);
    case Lu:
      return this.afterquote(i);
    case ku:
      return this.number(i);
    case Kl:
      return;
  }
};
Mi.prototype.afterquote = function(i) {
  if (i === '"') {
    this.word += '"', this.state = To;
    return;
  }
  if (l2.test(i)) {
    this.word = this.word.trim(), this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in afterquote yet, index ' + this.place);
};
Mi.prototype.afterItem = function(i) {
  if (i === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = Hs;
    return;
  }
  if (i === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = Hs, this.currentObject = this.stack.pop(), this.currentObject || (this.state = Kl);
    return;
  }
};
Mi.prototype.number = function(i) {
  if (Au.test(i)) {
    this.word += i;
    return;
  }
  if (l2.test(i)) {
    this.word = parseFloat(this.word), this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in number yet, index ' + this.place);
};
Mi.prototype.quoted = function(i) {
  if (i === '"') {
    this.state = Lu;
    return;
  }
  this.word += i;
};
Mi.prototype.keyword = function(i) {
  if (np.test(i)) {
    this.word += i;
    return;
  }
  if (i === "[") {
    var t = [];
    t.push(this.word), this.level++, this.root === null ? this.root = t : this.currentObject.push(t), this.stack.push(this.currentObject), this.currentObject = t, this.state = Hs;
    return;
  }
  if (l2.test(i)) {
    this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in keyword yet, index ' + this.place);
};
Mi.prototype.neutral = function(i) {
  if (ip.test(i)) {
    this.word = i, this.state = Iu;
    return;
  }
  if (i === '"') {
    this.word = "", this.state = To;
    return;
  }
  if (Au.test(i)) {
    this.word = i, this.state = ku;
    return;
  }
  if (l2.test(i)) {
    this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in neutral yet, index ' + this.place);
};
Mi.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === Kl)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function rp(i) {
  var t = new Mi(i);
  return t.output();
}
function K2(i, t, e) {
  Array.isArray(t) && (e.unshift(t), t = null);
  var n = t ? {} : i, r = e.reduce(function(s, o) {
    return dr(o, s), s;
  }, n);
  t && (i[t] = r);
}
function dr(i, t) {
  if (!Array.isArray(i)) {
    t[i] = !0;
    return;
  }
  var e = i.shift();
  if (e === "PARAMETER" && (e = i.shift()), i.length === 1) {
    if (Array.isArray(i[0])) {
      t[e] = {}, dr(i[0], t[e]);
      return;
    }
    t[e] = i[0];
    return;
  }
  if (!i.length) {
    t[e] = !0;
    return;
  }
  if (e === "TOWGS84") {
    t[e] = i;
    return;
  }
  if (e === "AXIS") {
    e in t || (t[e] = []), t[e].push(i);
    return;
  }
  Array.isArray(e) || (t[e] = {});
  var n;
  switch (e) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      t[e] = {
        name: i[0].toLowerCase(),
        convert: i[1]
      }, i.length === 3 && dr(i[2], t[e]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      t[e] = {
        name: i[0],
        a: i[1],
        rf: i[2]
      }, i.length === 4 && dr(i[3], t[e]);
      return;
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "LOCAL_DATUM":
    case "DATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
      i[0] = ["name", i[0]], K2(t, e, i);
      return;
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "FITTED_CS":
    // the followings are the crs defined in
    // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "ENGCRS":
    case "ENGINEERINGCRS":
      i[0] = ["name", i[0]], K2(t, e, i), t[e].type = e;
      return;
    default:
      for (n = -1; ++n < i.length; )
        if (!Array.isArray(i[n]))
          return dr(i, t[e]);
      return K2(t, e, i);
  }
}
var sp = 0.017453292519943295;
function je(i) {
  return i * sp;
}
function Fu(i) {
  const t = (i.projName || "").toLowerCase().replace(/_/g, " ");
  !i.long0 && i.longc && (t === "albers conic equal area" || t === "lambert azimuthal equal area") && (i.long0 = i.longc), !i.lat_ts && i.lat1 && (t === "stereographic south pole" || t === "polar stereographic (variant b)") ? (i.lat0 = je(i.lat1 > 0 ? 90 : -90), i.lat_ts = i.lat1, delete i.lat1) : !i.lat_ts && i.lat0 && (t === "polar stereographic" || t === "polar stereographic (variant a)") && (i.lat_ts = i.lat0, i.lat0 = je(i.lat0 > 0 ? 90 : -90), delete i.lat1);
}
function Ac(i) {
  let t = { units: null, to_meter: void 0 };
  return typeof i == "string" ? (t.units = i.toLowerCase(), t.units === "metre" && (t.units = "meter"), t.units === "meter" && (t.to_meter = 1)) : i && i.name && (t.units = i.name.toLowerCase(), t.units === "metre" && (t.units = "meter"), t.to_meter = i.conversion_factor), t;
}
function Fc(i) {
  return typeof i == "object" ? i.value * i.unit.conversion_factor : i;
}
function Oc(i, t) {
  i.ellipsoid.radius ? (t.a = i.ellipsoid.radius, t.rf = 0) : (t.a = Fc(i.ellipsoid.semi_major_axis), i.ellipsoid.inverse_flattening !== void 0 ? t.rf = i.ellipsoid.inverse_flattening : i.ellipsoid.semi_major_axis !== void 0 && i.ellipsoid.semi_minor_axis !== void 0 && (t.rf = t.a / (t.a - Fc(i.ellipsoid.semi_minor_axis))));
}
function Ro(i, t = {}) {
  return !i || typeof i != "object" ? i : i.type === "BoundCRS" ? (Ro(i.source_crs, t), i.transformation && (i.transformation.method && i.transformation.method.name === "NTv2" ? t.nadgrids = i.transformation.parameters[0].value : t.datum_params = i.transformation.parameters.map((e) => e.value)), t) : (Object.keys(i).forEach((e) => {
    const n = i[e];
    if (n !== null)
      switch (e) {
        case "name":
          if (t.srsCode)
            break;
          t.name = n, t.srsCode = n;
          break;
        case "type":
          n === "GeographicCRS" ? t.projName = "longlat" : n === "ProjectedCRS" && i.conversion && i.conversion.method && (t.projName = i.conversion.method.name);
          break;
        case "datum":
        case "datum_ensemble":
          n.ellipsoid && (t.ellps = n.ellipsoid.name, Oc(n, t)), n.prime_meridian && (t.from_greenwich = n.prime_meridian.longitude * Math.PI / 180);
          break;
        case "ellipsoid":
          t.ellps = n.name, Oc(n, t);
          break;
        case "prime_meridian":
          t.long0 = (n.longitude || 0) * Math.PI / 180;
          break;
        case "coordinate_system":
          if (n.axis) {
            if (t.axis = n.axis.map((r) => {
              const s = r.direction;
              if (s === "east") return "e";
              if (s === "north") return "n";
              if (s === "west") return "w";
              if (s === "south") return "s";
              throw new Error(`Unknown axis direction: ${s}`);
            }).join("") + "u", n.unit) {
              const { units: r, to_meter: s } = Ac(n.unit);
              t.units = r, t.to_meter = s;
            } else if (n.axis[0] && n.axis[0].unit) {
              const { units: r, to_meter: s } = Ac(n.axis[0].unit);
              t.units = r, t.to_meter = s;
            }
          }
          break;
        case "id":
          n.authority && n.code && (t.title = n.authority + ":" + n.code);
          break;
        case "conversion":
          n.method && n.method.name && (t.projName = n.method.name), n.parameters && n.parameters.forEach((r) => {
            const s = r.name.toLowerCase().replace(/\s+/g, "_"), o = r.value;
            r.unit && r.unit.conversion_factor ? t[s] = o * r.unit.conversion_factor : r.unit === "degree" ? t[s] = o * Math.PI / 180 : t[s] = o;
          });
          break;
        case "unit":
          n.name && (t.units = n.name.toLowerCase(), t.units === "metre" && (t.units = "meter")), n.conversion_factor && (t.to_meter = n.conversion_factor);
          break;
        case "base_crs":
          Ro(n, t), t.datumCode = n.id ? n.id.authority + "_" + n.id.code : n.name;
          break;
      }
  }), t.latitude_of_false_origin !== void 0 && (t.lat0 = t.latitude_of_false_origin), t.longitude_of_false_origin !== void 0 && (t.long0 = t.longitude_of_false_origin), t.latitude_of_standard_parallel !== void 0 && (t.lat0 = t.latitude_of_standard_parallel, t.lat1 = t.latitude_of_standard_parallel), t.latitude_of_1st_standard_parallel !== void 0 && (t.lat1 = t.latitude_of_1st_standard_parallel), t.latitude_of_2nd_standard_parallel !== void 0 && (t.lat2 = t.latitude_of_2nd_standard_parallel), t.latitude_of_projection_centre !== void 0 && (t.lat0 = t.latitude_of_projection_centre), t.longitude_of_projection_centre !== void 0 && (t.longc = t.longitude_of_projection_centre), t.easting_at_false_origin !== void 0 && (t.x0 = t.easting_at_false_origin), t.northing_at_false_origin !== void 0 && (t.y0 = t.northing_at_false_origin), t.latitude_of_natural_origin !== void 0 && (t.lat0 = t.latitude_of_natural_origin), t.longitude_of_natural_origin !== void 0 && (t.long0 = t.longitude_of_natural_origin), t.longitude_of_origin !== void 0 && (t.long0 = t.longitude_of_origin), t.false_easting !== void 0 && (t.x0 = t.false_easting), t.easting_at_projection_centre && (t.x0 = t.easting_at_projection_centre), t.false_northing !== void 0 && (t.y0 = t.false_northing), t.northing_at_projection_centre && (t.y0 = t.northing_at_projection_centre), t.standard_parallel_1 !== void 0 && (t.lat1 = t.standard_parallel_1), t.standard_parallel_2 !== void 0 && (t.lat2 = t.standard_parallel_2), t.scale_factor_at_natural_origin !== void 0 && (t.k0 = t.scale_factor_at_natural_origin), t.scale_factor_at_projection_centre !== void 0 && (t.k0 = t.scale_factor_at_projection_centre), t.scale_factor_on_pseudo_standard_parallel !== void 0 && (t.k0 = t.scale_factor_on_pseudo_standard_parallel), t.azimuth !== void 0 && (t.alpha = t.azimuth), t.azimuth_at_projection_centre !== void 0 && (t.alpha = t.azimuth_at_projection_centre), t.angle_from_rectified_to_skew_grid && (t.rectified_grid_angle = t.angle_from_rectified_to_skew_grid), Fu(t), t);
}
var op = [
  "PROJECTEDCRS",
  "PROJCRS",
  "GEOGCS",
  "GEOCCS",
  "PROJCS",
  "LOCAL_CS",
  "GEODCRS",
  "GEODETICCRS",
  "GEODETICDATUM",
  "ENGCRS",
  "ENGINEERINGCRS"
];
function ap(i, t) {
  var e = t[0], n = t[1];
  !(e in i) && n in i && (i[e] = i[n], t.length === 3 && (i[e] = t[2](i[e])));
}
function Ou(i) {
  for (var t = Object.keys(i), e = 0, n = t.length; e < n; ++e) {
    var r = t[e];
    op.indexOf(r) !== -1 && lp(i[r]), typeof i[r] == "object" && Ou(i[r]);
  }
}
function lp(i) {
  if (i.AUTHORITY) {
    var t = Object.keys(i.AUTHORITY)[0];
    t && t in i.AUTHORITY && (i.title = t + ":" + i.AUTHORITY[t]);
  }
  if (i.type === "GEOGCS" ? i.projName = "longlat" : i.type === "LOCAL_CS" ? (i.projName = "identity", i.local = !0) : typeof i.PROJECTION == "object" ? i.projName = Object.keys(i.PROJECTION)[0] : i.projName = i.PROJECTION, i.AXIS) {
    for (var e = "", n = 0, r = i.AXIS.length; n < r; ++n) {
      var s = [i.AXIS[n][0].toLowerCase(), i.AXIS[n][1].toLowerCase()];
      s[0].indexOf("north") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "north" ? e += "n" : s[0].indexOf("south") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "south" ? e += "s" : s[0].indexOf("east") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "east" ? e += "e" : (s[0].indexOf("west") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "west") && (e += "w");
    }
    e.length === 2 && (e += "u"), e.length === 3 && (i.axis = e);
  }
  i.UNIT && (i.units = i.UNIT.name.toLowerCase(), i.units === "metre" && (i.units = "meter"), i.UNIT.convert && (i.type === "GEOGCS" ? i.DATUM && i.DATUM.SPHEROID && (i.to_meter = i.UNIT.convert * i.DATUM.SPHEROID.a) : i.to_meter = i.UNIT.convert));
  var o = i.GEOGCS;
  i.type === "GEOGCS" && (o = i), o && (o.DATUM ? i.datumCode = o.DATUM.name.toLowerCase() : i.datumCode = o.name.toLowerCase(), i.datumCode.slice(0, 2) === "d_" && (i.datumCode = i.datumCode.slice(2)), i.datumCode === "new_zealand_1949" && (i.datumCode = "nzgd49"), (i.datumCode === "wgs_1984" || i.datumCode === "world_geodetic_system_1984") && (i.PROJECTION === "Mercator_Auxiliary_Sphere" && (i.sphere = !0), i.datumCode = "wgs84"), i.datumCode === "belge_1972" && (i.datumCode = "rnb72"), o.DATUM && o.DATUM.SPHEROID && (i.ellps = o.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), i.ellps.toLowerCase().slice(0, 13) === "international" && (i.ellps = "intl"), i.a = o.DATUM.SPHEROID.a, i.rf = parseFloat(o.DATUM.SPHEROID.rf, 10)), o.DATUM && o.DATUM.TOWGS84 && (i.datum_params = o.DATUM.TOWGS84), ~i.datumCode.indexOf("osgb_1936") && (i.datumCode = "osgb36"), ~i.datumCode.indexOf("osni_1952") && (i.datumCode = "osni52"), (~i.datumCode.indexOf("tm65") || ~i.datumCode.indexOf("geodetic_datum_of_1965")) && (i.datumCode = "ire65"), i.datumCode === "ch1903+" && (i.datumCode = "ch1903"), ~i.datumCode.indexOf("israel") && (i.datumCode = "isr93")), i.b && !isFinite(i.b) && (i.b = i.a), i.rectified_grid_angle && (i.rectified_grid_angle = je(i.rectified_grid_angle));
  function a(c) {
    var d = i.to_meter || 1;
    return c * d;
  }
  var l = function(c) {
    return ap(i, c);
  }, h = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", je],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", je],
    ["x0", "false_easting", a],
    ["y0", "false_northing", a],
    ["long0", "central_meridian", je],
    ["lat0", "latitude_of_origin", je],
    ["lat0", "standard_parallel_1", je],
    ["lat1", "standard_parallel_1", je],
    ["lat2", "standard_parallel_2", je],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", je],
    ["srsCode", "name"]
  ];
  h.forEach(l), Fu(i);
}
function Po(i) {
  if (typeof i == "object")
    return Ro(i);
  const t = tp(i);
  var e = rp(i);
  if (t === "WKT2") {
    const s = Q8(e);
    return Ro(s);
  }
  var n = e[0], r = {};
  return dr(e, r), Ou(r), r[n];
}
function Nt(i) {
  var t = this;
  if (arguments.length === 2) {
    var e = arguments[1];
    typeof e == "string" ? e.charAt(0) === "+" ? Nt[
      /** @type {string} */
      i
    ] = Da(arguments[1]) : Nt[
      /** @type {string} */
      i
    ] = Po(arguments[1]) : e && typeof e == "object" && !("projName" in e) ? Nt[
      /** @type {string} */
      i
    ] = Po(arguments[1]) : (Nt[
      /** @type {string} */
      i
    ] = e, e || delete Nt[
      /** @type {string} */
      i
    ]);
  } else if (arguments.length === 1) {
    if (Array.isArray(i))
      return i.map(function(n) {
        return Array.isArray(n) ? Nt.apply(t, n) : Nt(n);
      });
    if (typeof i == "string") {
      if (i in Nt)
        return Nt[i];
    } else "EPSG" in i ? Nt["EPSG:" + i.EPSG] = i : "ESRI" in i ? Nt["ESRI:" + i.ESRI] = i : "IAU2000" in i ? Nt["IAU2000:" + i.IAU2000] = i : console.log(i);
    return;
  }
}
V8(Nt);
function hp(i) {
  return typeof i == "string";
}
function cp(i) {
  return i in Nt;
}
function dp(i) {
  return i.indexOf("+") !== 0 && i.indexOf("[") !== -1 || typeof i == "object" && !("srsCode" in i);
}
var up = ["3857", "900913", "3785", "102113"];
function fp(i) {
  var t = qi(i, "authority");
  if (t) {
    var e = qi(t, "epsg");
    return e && up.indexOf(e) > -1;
  }
}
function gp(i) {
  var t = qi(i, "extension");
  if (t)
    return qi(t, "proj4");
}
function mp(i) {
  return i[0] === "+";
}
function pp(i) {
  if (hp(i)) {
    if (cp(i))
      return Nt[i];
    if (dp(i)) {
      var t = Po(i);
      if (fp(t))
        return Nt["EPSG:3857"];
      var e = gp(t);
      return e ? Da(e) : t;
    }
    if (mp(i))
      return Da(i);
  } else return "projName" in i ? i : Po(i);
}
function Gc(i, t) {
  i = i || {};
  var e, n;
  if (!t)
    return i;
  for (n in t)
    e = t[n], e !== void 0 && (i[n] = e);
  return i;
}
function ai(i, t, e) {
  var n = i * t;
  return e / Math.sqrt(1 - n * n);
}
function g0(i) {
  return i < 0 ? -1 : 1;
}
function O(i, t) {
  return t || Math.abs(i) <= St ? i : i - g0(i) * Zs;
}
function $e(i, t, e) {
  var n = i * e, r = 0.5 * i;
  return n = Math.pow((1 - n) / (1 + n), r), Math.tan(0.5 * (T - t)) / n;
}
function Ks(i, t) {
  for (var e = 0.5 * i, n, r, s = T - 2 * Math.atan(t), o = 0; o <= 15; o++)
    if (n = i * Math.sin(s), r = T - 2 * Math.atan(t * Math.pow((1 - n) / (1 + n), e)) - s, s += r, Math.abs(r) <= 1e-10)
      return s;
  return -9999;
}
function _p() {
  var i = this.b / this.a;
  this.es = 1 - i * i, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = ai(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function yp(i) {
  var t = i.x, e = i.y;
  if (e * ce > 90 && e * ce < -90 && t * ce > 180 && t * ce < -180)
    return null;
  var n, r;
  if (Math.abs(Math.abs(e) - T) <= k)
    return null;
  if (this.sphere)
    n = this.x0 + this.a * this.k0 * O(t - this.long0, this.over), r = this.y0 + this.a * this.k0 * Math.log(Math.tan(lt + 0.5 * e));
  else {
    var s = Math.sin(e), o = $e(this.e, e, s);
    n = this.x0 + this.a * this.k0 * O(t - this.long0, this.over), r = this.y0 - this.a * this.k0 * Math.log(o);
  }
  return i.x = n, i.y = r, i;
}
function vp(i) {
  var t = i.x - this.x0, e = i.y - this.y0, n, r;
  if (this.sphere)
    r = T - 2 * Math.atan(Math.exp(-e / (this.a * this.k0)));
  else {
    var s = Math.exp(-e / (this.a * this.k0));
    if (r = Ks(this.e, s), r === -9999)
      return null;
  }
  return n = O(this.long0 + t / (this.a * this.k0), this.over), i.x = n, i.y = r, i;
}
var xp = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "Mercator_Variant_A", "merc"];
const Cp = {
  init: _p,
  forward: yp,
  inverse: vp,
  names: xp
};
function bp() {
}
function Nc(i) {
  return i;
}
var Gu = ["longlat", "identity"];
const wp = {
  init: bp,
  forward: Nc,
  inverse: Nc,
  names: Gu
};
var Ep = [Cp, wp], un = {}, ur = [];
function Nu(i, t) {
  var e = ur.length;
  return i.names ? (ur[e] = i, i.names.forEach(function(n) {
    un[n.toLowerCase()] = e;
  }), this) : (console.log(t), !0);
}
function Du(i) {
  return i.replace(/[-\(\)\s]+/g, " ").trim().replace(/ /g, "_");
}
function Sp(i) {
  if (!i)
    return !1;
  var t = i.toLowerCase();
  if (typeof un[t] < "u" && ur[un[t]] || (t = Du(t), t in un && ur[un[t]]))
    return ur[un[t]];
}
function Mp() {
  Ep.forEach(Nu);
}
const Tp = {
  start: Mp,
  add: Nu,
  get: Sp
};
var zu = {
  MERIT: {
    a: 6378137,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  },
  SGS85: {
    a: 6378136,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  },
  GRS80: {
    a: 6378137,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  },
  IAU76: {
    a: 6378140,
    rf: 298.257,
    ellipseName: "IAU 1976"
  },
  airy: {
    a: 6377563396e-3,
    b: 635625691e-2,
    ellipseName: "Airy 1830"
  },
  APL4: {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  },
  NWL9D: {
    a: 6378145,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  },
  mod_airy: {
    a: 6377340189e-3,
    b: 6356034446e-3,
    ellipseName: "Modified Airy"
  },
  andrae: {
    a: 637710443e-2,
    rf: 300,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  },
  aust_SA: {
    a: 6378160,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  },
  GRS67: {
    a: 6378160,
    rf: 298.247167427,
    ellipseName: "GRS 67(IUGG 1967)"
  },
  bessel: {
    a: 6377397155e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  },
  bess_nam: {
    a: 6377483865e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  },
  clrk66: {
    a: 63782064e-1,
    b: 63565838e-1,
    ellipseName: "Clarke 1866"
  },
  clrk80: {
    a: 6378249145e-3,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  },
  clrk80ign: {
    a: 63782492e-1,
    b: 6356515,
    rf: 293.4660213,
    ellipseName: "Clarke 1880 (IGN)"
  },
  clrk58: {
    a: 6378293645208759e-9,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  },
  CPM: {
    a: 63757387e-1,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  },
  delmbr: {
    a: 6376428,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  },
  engelis: {
    a: 637813605e-2,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  },
  evrst30: {
    a: 6377276345e-3,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  },
  evrst48: {
    a: 6377304063e-3,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  },
  evrst56: {
    a: 6377301243e-3,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  },
  evrst69: {
    a: 6377295664e-3,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  },
  evrstSS: {
    a: 6377298556e-3,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  },
  fschr60: {
    a: 6378166,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  },
  fschr60m: {
    a: 6378155,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  },
  fschr68: {
    a: 6378150,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  },
  helmert: {
    a: 6378200,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  },
  hough: {
    a: 6378270,
    rf: 297,
    ellipseName: "Hough"
  },
  intl: {
    a: 6378388,
    rf: 297,
    ellipseName: "International 1909 (Hayford)"
  },
  kaula: {
    a: 6378163,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  },
  lerch: {
    a: 6378139,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  },
  mprts: {
    a: 6397300,
    rf: 191,
    ellipseName: "Maupertius 1738"
  },
  new_intl: {
    a: 63781575e-1,
    b: 63567722e-1,
    ellipseName: "New International 1967"
  },
  plessis: {
    a: 6376523,
    rf: 6355863,
    ellipseName: "Plessis 1817 (France)"
  },
  krass: {
    a: 6378245,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  },
  SEasia: {
    a: 6378155,
    b: 63567733205e-4,
    ellipseName: "Southeast Asia"
  },
  walbeck: {
    a: 6376896,
    b: 63558348467e-4,
    ellipseName: "Walbeck"
  },
  WGS60: {
    a: 6378165,
    rf: 298.3,
    ellipseName: "WGS 60"
  },
  WGS66: {
    a: 6378145,
    rf: 298.25,
    ellipseName: "WGS 66"
  },
  WGS7: {
    a: 6378135,
    rf: 298.26,
    ellipseName: "WGS 72"
  },
  WGS84: {
    a: 6378137,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  },
  sphere: {
    a: 6370997,
    b: 6370997,
    ellipseName: "Normal Sphere (r=6370997)"
  }
};
const Rp = zu.WGS84;
function Pp(i, t, e, n) {
  var r = i * i, s = t * t, o = (r - s) / r, a = 0;
  n ? (i *= 1 - o * (Y8 + o * (X8 + o * Z8)), r = i * i, o = 0) : a = Math.sqrt(o);
  var l = (r - s) / s;
  return {
    es: o,
    e: a,
    ep2: l
  };
}
function Ip(i, t, e, n, r) {
  if (!i) {
    var s = qi(zu, n);
    s || (s = Rp), i = s.a, t = s.b, e = s.rf;
  }
  return e && !t && (t = (1 - 1 / e) * i), (e === 0 || Math.abs(i - t) < k) && (r = !0, t = i), {
    a: i,
    b: t,
    rf: e,
    sphere: r
  };
}
var q0 = {
  wgs84: {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  },
  ch1903: {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  },
  ggrs87: {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  },
  nad83: {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  },
  nad27: {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  },
  potsdam: {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  },
  carthage: {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  },
  hermannskogel: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  },
  mgi: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Militar-Geographische Institut"
  },
  osni52: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  },
  ire65: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  },
  rassadiran: {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  },
  nzgd49: {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  },
  osgb36: {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Ordnance Survey of Great Britain 1936"
  },
  s_jtsk: {
    towgs84: "589,76,480",
    ellipse: "bessel",
    datumName: "S-JTSK (Ferro)"
  },
  beduaram: {
    towgs84: "-106,-87,188",
    ellipse: "clrk80",
    datumName: "Beduaram"
  },
  gunung_segara: {
    towgs84: "-403,684,41",
    ellipse: "bessel",
    datumName: "Gunung Segara Jakarta"
  },
  rnb72: {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  },
  EPSG_5451: {
    towgs84: "6.41,-49.05,-11.28,1.5657,0.5242,6.9718,-5.7649"
  },
  IGNF_LURESG: {
    towgs84: "-192.986,13.673,-39.309,-0.4099,-2.9332,2.6881,0.43"
  },
  EPSG_4614: {
    towgs84: "-119.4248,-303.65872,-11.00061,1.164298,0.174458,1.096259,3.657065"
  },
  EPSG_4615: {
    towgs84: "-494.088,-312.129,279.877,-1.423,-1.013,1.59,-0.748"
  },
  ESRI_37241: {
    towgs84: "-76.822,257.457,-12.817,2.136,-0.033,-2.392,-0.031"
  },
  ESRI_37249: {
    towgs84: "-440.296,58.548,296.265,1.128,10.202,4.559,-0.438"
  },
  ESRI_37245: {
    towgs84: "-511.151,-181.269,139.609,1.05,2.703,1.798,3.071"
  },
  EPSG_4178: {
    towgs84: "24.9,-126.4,-93.2,-0.063,-0.247,-0.041,1.01"
  },
  EPSG_4622: {
    towgs84: "-472.29,-5.63,-304.12,0.4362,-0.8374,0.2563,1.8984"
  },
  EPSG_4625: {
    towgs84: "126.93,547.94,130.41,-2.7867,5.1612,-0.8584,13.8227"
  },
  EPSG_5252: {
    towgs84: "0.023,0.036,-0.068,0.00176,0.00912,-0.01136,0.00439"
  },
  EPSG_4314: {
    towgs84: "597.1,71.4,412.1,0.894,0.068,-1.563,7.58"
  },
  EPSG_4282: {
    towgs84: "-178.3,-316.7,-131.5,5.278,6.077,10.979,19.166"
  },
  EPSG_4231: {
    towgs84: "-83.11,-97.38,-117.22,0.0276,-0.2167,0.2147,0.1218"
  },
  EPSG_4274: {
    towgs84: "-230.994,102.591,25.199,0.633,-0.239,0.9,1.95"
  },
  EPSG_4134: {
    towgs84: "-180.624,-225.516,173.919,-0.81,-1.898,8.336,16.71006"
  },
  EPSG_4254: {
    towgs84: "18.38,192.45,96.82,0.056,-0.142,-0.2,-0.0013"
  },
  EPSG_4159: {
    towgs84: "-194.513,-63.978,-25.759,-3.4027,3.756,-3.352,-0.9175"
  },
  EPSG_4687: {
    towgs84: "0.072,-0.507,-0.245,0.0183,-0.0003,0.007,-0.0093"
  },
  EPSG_4227: {
    towgs84: "-83.58,-397.54,458.78,-17.595,-2.847,4.256,3.225"
  },
  EPSG_4746: {
    towgs84: "599.4,72.4,419.2,-0.062,-0.022,-2.723,6.46"
  },
  EPSG_4745: {
    towgs84: "612.4,77,440.2,-0.054,0.057,-2.797,2.55"
  },
  EPSG_6311: {
    towgs84: "8.846,-4.394,-1.122,-0.00237,-0.146528,0.130428,0.783926"
  },
  EPSG_4289: {
    towgs84: "565.7381,50.4018,465.2904,-1.91514,1.60363,-9.09546,4.07244"
  },
  EPSG_4230: {
    towgs84: "-68.863,-134.888,-111.49,-0.53,-0.14,0.57,-3.4"
  },
  EPSG_4154: {
    towgs84: "-123.02,-158.95,-168.47"
  },
  EPSG_4156: {
    towgs84: "570.8,85.7,462.8,4.998,1.587,5.261,3.56"
  },
  EPSG_4299: {
    towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
  },
  EPSG_4179: {
    towgs84: "33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84"
  },
  EPSG_4313: {
    towgs84: "-106.8686,52.2978,-103.7239,0.3366,-0.457,1.8422,-1.2747"
  },
  EPSG_4194: {
    towgs84: "163.511,127.533,-159.789"
  },
  EPSG_4195: {
    towgs84: "105,326,-102.5"
  },
  EPSG_4196: {
    towgs84: "-45,417,-3.5"
  },
  EPSG_4611: {
    towgs84: "-162.619,-276.959,-161.764,0.067753,-2.243649,-1.158827,-1.094246"
  },
  EPSG_4633: {
    towgs84: "137.092,131.66,91.475,-1.9436,-11.5993,-4.3321,-7.4824"
  },
  EPSG_4641: {
    towgs84: "-408.809,366.856,-412.987,1.8842,-0.5308,2.1655,-121.0993"
  },
  EPSG_4643: {
    towgs84: "-480.26,-438.32,-643.429,16.3119,20.1721,-4.0349,-111.7002"
  },
  EPSG_4300: {
    towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
  },
  EPSG_4188: {
    towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
  },
  EPSG_4660: {
    towgs84: "982.6087,552.753,-540.873,32.39344,-153.25684,-96.2266,16.805"
  },
  EPSG_4662: {
    towgs84: "97.295,-263.247,310.882,-1.5999,0.8386,3.1409,13.3259"
  },
  EPSG_3906: {
    towgs84: "577.88891,165.22205,391.18289,4.9145,-0.94729,-13.05098,7.78664"
  },
  EPSG_4307: {
    towgs84: "-209.3622,-87.8162,404.6198,0.0046,3.4784,0.5805,-1.4547"
  },
  EPSG_6892: {
    towgs84: "-76.269,-16.683,68.562,-6.275,10.536,-4.286,-13.686"
  },
  EPSG_4690: {
    towgs84: "221.597,152.441,176.523,2.403,1.3893,0.884,11.4648"
  },
  EPSG_4691: {
    towgs84: "218.769,150.75,176.75,3.5231,2.0037,1.288,10.9817"
  },
  EPSG_4629: {
    towgs84: "72.51,345.411,79.241,-1.5862,-0.8826,-0.5495,1.3653"
  },
  EPSG_4630: {
    towgs84: "165.804,216.213,180.26,-0.6251,-0.4515,-0.0721,7.4111"
  },
  EPSG_4692: {
    towgs84: "217.109,86.452,23.711,0.0183,-0.0003,0.007,-0.0093"
  },
  EPSG_9333: {
    towgs84: "0,0,0,-8.393,0.749,-10.276,0"
  },
  EPSG_9059: {
    towgs84: "0,0,0"
  },
  EPSG_4312: {
    towgs84: "601.705,84.263,485.227,4.7354,1.3145,5.393,-2.3887"
  },
  EPSG_4123: {
    towgs84: "-96.062,-82.428,-121.753,4.801,0.345,-1.376,1.496"
  },
  EPSG_4309: {
    towgs84: "-124.45,183.74,44.64,-0.4384,0.5446,-0.9706,-2.1365"
  },
  ESRI_104106: {
    towgs84: "-283.088,-70.693,117.445,-1.157,0.059,-0.652,-4.058"
  },
  EPSG_4281: {
    towgs84: "-219.247,-73.802,269.529"
  },
  EPSG_4322: {
    towgs84: "0,0,4.5"
  },
  EPSG_4324: {
    towgs84: "0,0,1.9"
  },
  EPSG_4284: {
    towgs84: "43.822,-108.842,-119.585,1.455,-0.761,0.737,0.549"
  },
  EPSG_4277: {
    towgs84: "446.448,-125.157,542.06,0.15,0.247,0.842,-20.489"
  },
  EPSG_4207: {
    towgs84: "-282.1,-72.2,120,-1.529,0.145,-0.89,-4.46"
  },
  EPSG_4688: {
    towgs84: "347.175,1077.618,2623.677,33.9058,-70.6776,9.4013,186.0647"
  },
  EPSG_4689: {
    towgs84: "410.793,54.542,80.501,-2.5596,-2.3517,-0.6594,17.3218"
  },
  EPSG_4720: {
    towgs84: "0,0,4.5"
  },
  EPSG_4273: {
    towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
  },
  EPSG_4240: {
    towgs84: "204.64,834.74,293.8"
  },
  EPSG_4817: {
    towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
  },
  ESRI_104131: {
    towgs84: "426.62,142.62,460.09,4.98,4.49,-12.42,-17.1"
  },
  EPSG_4265: {
    towgs84: "-104.1,-49.1,-9.9,0.971,-2.917,0.714,-11.68"
  },
  EPSG_4263: {
    towgs84: "-111.92,-87.85,114.5,1.875,0.202,0.219,0.032"
  },
  EPSG_4298: {
    towgs84: "-689.5937,623.84046,-65.93566,-0.02331,1.17094,-0.80054,5.88536"
  },
  EPSG_4270: {
    towgs84: "-253.4392,-148.452,386.5267,0.15605,0.43,-0.1013,-0.0424"
  },
  EPSG_4229: {
    towgs84: "-121.8,98.1,-10.7"
  },
  EPSG_4220: {
    towgs84: "-55.5,-348,-229.2"
  },
  EPSG_4214: {
    towgs84: "12.646,-155.176,-80.863"
  },
  EPSG_4232: {
    towgs84: "-345,3,223"
  },
  EPSG_4238: {
    towgs84: "-1.977,-13.06,-9.993,0.364,0.254,0.689,-1.037"
  },
  EPSG_4168: {
    towgs84: "-170,33,326"
  },
  EPSG_4131: {
    towgs84: "199,931,318.9"
  },
  EPSG_4152: {
    towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
  },
  EPSG_5228: {
    towgs84: "572.213,85.334,461.94,4.9732,1.529,5.2484,3.5378"
  },
  EPSG_8351: {
    towgs84: "485.021,169.465,483.839,7.786342,4.397554,4.102655,0"
  },
  EPSG_4683: {
    towgs84: "-127.62,-67.24,-47.04,-3.068,4.903,1.578,-1.06"
  },
  EPSG_4133: {
    towgs84: "0,0,0"
  },
  EPSG_7373: {
    towgs84: "0.819,-0.5762,-1.6446,-0.00378,-0.03317,0.00318,0.0693"
  },
  EPSG_9075: {
    towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
  },
  EPSG_9072: {
    towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
  },
  EPSG_9294: {
    towgs84: "1.16835,-1.42001,-2.24431,-0.00822,-0.05508,0.01818,0.23388"
  },
  EPSG_4212: {
    towgs84: "-267.434,173.496,181.814,-13.4704,8.7154,7.3926,14.7492"
  },
  EPSG_4191: {
    towgs84: "-44.183,-0.58,-38.489,2.3867,2.7072,-3.5196,-8.2703"
  },
  EPSG_4237: {
    towgs84: "52.684,-71.194,-13.975,-0.312,-0.1063,-0.3729,1.0191"
  },
  EPSG_4740: {
    towgs84: "-1.08,-0.27,-0.9"
  },
  EPSG_4124: {
    towgs84: "419.3836,99.3335,591.3451,0.850389,1.817277,-7.862238,-0.99496"
  },
  EPSG_5681: {
    towgs84: "584.9636,107.7175,413.8067,1.1155,0.2824,-3.1384,7.9922"
  },
  EPSG_4141: {
    towgs84: "23.772,17.49,17.859,-0.3132,-1.85274,1.67299,-5.4262"
  },
  EPSG_4204: {
    towgs84: "-85.645,-273.077,-79.708,2.289,-1.421,2.532,3.194"
  },
  EPSG_4319: {
    towgs84: "226.702,-193.337,-35.371,-2.229,-4.391,9.238,0.9798"
  },
  EPSG_4200: {
    towgs84: "24.82,-131.21,-82.66"
  },
  EPSG_4130: {
    towgs84: "0,0,0"
  },
  EPSG_4127: {
    towgs84: "-82.875,-57.097,-156.768,-2.158,1.524,-0.982,-0.359"
  },
  EPSG_4149: {
    towgs84: "674.374,15.056,405.346"
  },
  EPSG_4617: {
    towgs84: "-0.991,1.9072,0.5129,1.25033e-7,4.6785e-8,5.6529e-8,0"
  },
  EPSG_4663: {
    towgs84: "-210.502,-66.902,-48.476,2.094,-15.067,-5.817,0.485"
  },
  EPSG_4664: {
    towgs84: "-211.939,137.626,58.3,-0.089,0.251,0.079,0.384"
  },
  EPSG_4665: {
    towgs84: "-105.854,165.589,-38.312,-0.003,-0.026,0.024,-0.048"
  },
  EPSG_4666: {
    towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
  },
  EPSG_4756: {
    towgs84: "-192.873,-39.382,-111.202,-0.00205,-0.0005,0.00335,0.0188"
  },
  EPSG_4723: {
    towgs84: "-179.483,-69.379,-27.584,-7.862,8.163,6.042,-13.925"
  },
  EPSG_4726: {
    towgs84: "8.853,-52.644,180.304,-0.393,-2.323,2.96,-24.081"
  },
  EPSG_4267: {
    towgs84: "-8.0,160.0,176.0"
  },
  EPSG_5365: {
    towgs84: "-0.16959,0.35312,0.51846,0.03385,-0.16325,0.03446,0.03693"
  },
  EPSG_4218: {
    towgs84: "304.5,306.5,-318.1"
  },
  EPSG_4242: {
    towgs84: "-33.722,153.789,94.959,-8.581,-4.478,4.54,8.95"
  },
  EPSG_4216: {
    towgs84: "-292.295,248.758,429.447,4.9971,2.99,6.6906,1.0289"
  },
  ESRI_104105: {
    towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
  },
  ESRI_104129: {
    towgs84: "0,0,0"
  },
  EPSG_4673: {
    towgs84: "174.05,-25.49,112.57"
  },
  EPSG_4202: {
    towgs84: "-124,-60,154"
  },
  EPSG_4203: {
    towgs84: "-117.763,-51.51,139.061,0.292,0.443,0.277,-0.191"
  },
  EPSG_3819: {
    towgs84: "595.48,121.69,515.35,4.115,-2.9383,0.853,-3.408"
  },
  EPSG_8694: {
    towgs84: "-93.799,-132.737,-219.073,-1.844,0.648,-6.37,-0.169"
  },
  EPSG_4145: {
    towgs84: "275.57,676.78,229.6"
  },
  EPSG_4283: {
    towgs84: "61.55,-10.87,-40.19,39.4924,32.7221,32.8979,-9.994"
  },
  EPSG_4317: {
    towgs84: "2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266"
  },
  EPSG_4272: {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993"
  },
  EPSG_4248: {
    towgs84: "-307.7,265.3,-363.5"
  },
  EPSG_5561: {
    towgs84: "24,-121,-76"
  },
  EPSG_5233: {
    towgs84: "-0.293,766.95,87.713,0.195704,1.695068,3.473016,-0.039338"
  },
  ESRI_104130: {
    towgs84: "-86,-98,-119"
  },
  ESRI_104102: {
    towgs84: "682,-203,480"
  },
  ESRI_37207: {
    towgs84: "7,-10,-26"
  },
  EPSG_4675: {
    towgs84: "59.935,118.4,-10.871"
  },
  ESRI_104109: {
    towgs84: "-89.121,-348.182,260.871"
  },
  ESRI_104112: {
    towgs84: "-185.583,-230.096,281.361"
  },
  ESRI_104113: {
    towgs84: "25.1,-275.6,222.6"
  },
  IGNF_WGS72G: {
    towgs84: "0,12,6"
  },
  IGNF_NTFG: {
    towgs84: "-168,-60,320"
  },
  IGNF_EFATE57G: {
    towgs84: "-127,-769,472"
  },
  IGNF_PGP50G: {
    towgs84: "324.8,153.6,172.1"
  },
  IGNF_REUN47G: {
    towgs84: "94,-948,-1262"
  },
  IGNF_CSG67G: {
    towgs84: "-186,230,110"
  },
  IGNF_GUAD48G: {
    towgs84: "-467,-16,-300"
  },
  IGNF_TAHI51G: {
    towgs84: "162,117,154"
  },
  IGNF_TAHAAG: {
    towgs84: "65,342,77"
  },
  IGNF_NUKU72G: {
    towgs84: "84,274,65"
  },
  IGNF_PETRELS72G: {
    towgs84: "365,194,166"
  },
  IGNF_WALL78G: {
    towgs84: "253,-133,-127"
  },
  IGNF_MAYO50G: {
    towgs84: "-382,-59,-262"
  },
  IGNF_TANNAG: {
    towgs84: "-139,-967,436"
  },
  IGNF_IGN72G: {
    towgs84: "-13,-348,292"
  },
  IGNF_ATIGG: {
    towgs84: "1118,23,66"
  },
  IGNF_FANGA84G: {
    towgs84: "150.57,158.33,118.32"
  },
  IGNF_RUSAT84G: {
    towgs84: "202.13,174.6,-15.74"
  },
  IGNF_KAUE70G: {
    towgs84: "126.74,300.1,-75.49"
  },
  IGNF_MOP90G: {
    towgs84: "-10.8,-1.8,12.77"
  },
  IGNF_MHPF67G: {
    towgs84: "338.08,212.58,-296.17"
  },
  IGNF_TAHI79G: {
    towgs84: "160.61,116.05,153.69"
  },
  IGNF_ANAA92G: {
    towgs84: "1.5,3.84,4.81"
  },
  IGNF_MARQUI72G: {
    towgs84: "330.91,-13.92,58.56"
  },
  IGNF_APAT86G: {
    towgs84: "143.6,197.82,74.05"
  },
  IGNF_TUBU69G: {
    towgs84: "237.17,171.61,-77.84"
  },
  IGNF_STPM50G: {
    towgs84: "11.363,424.148,373.13"
  },
  EPSG_4150: {
    towgs84: "674.374,15.056,405.346"
  },
  EPSG_4754: {
    towgs84: "-208.4058,-109.8777,-2.5764"
  },
  ESRI_104101: {
    towgs84: "374,150,588"
  },
  EPSG_4693: {
    towgs84: "0,-0.15,0.68"
  },
  EPSG_6207: {
    towgs84: "293.17,726.18,245.36"
  },
  EPSG_4153: {
    towgs84: "-133.63,-157.5,-158.62"
  },
  EPSG_4132: {
    towgs84: "-241.54,-163.64,396.06"
  },
  EPSG_4221: {
    towgs84: "-154.5,150.7,100.4"
  },
  EPSG_4266: {
    towgs84: "-80.7,-132.5,41.1"
  },
  EPSG_4193: {
    towgs84: "-70.9,-151.8,-41.4"
  },
  EPSG_5340: {
    towgs84: "-0.41,0.46,-0.35"
  },
  EPSG_4246: {
    towgs84: "-294.7,-200.1,525.5"
  },
  EPSG_4318: {
    towgs84: "-3.2,-5.7,2.8"
  },
  EPSG_4121: {
    towgs84: "-199.87,74.79,246.62"
  },
  EPSG_4223: {
    towgs84: "-260.1,5.5,432.2"
  },
  EPSG_4158: {
    towgs84: "-0.465,372.095,171.736"
  },
  EPSG_4285: {
    towgs84: "-128.16,-282.42,21.93"
  },
  EPSG_4613: {
    towgs84: "-404.78,685.68,45.47"
  },
  EPSG_4607: {
    towgs84: "195.671,332.517,274.607"
  },
  EPSG_4475: {
    towgs84: "-381.788,-57.501,-256.673"
  },
  EPSG_4208: {
    towgs84: "-157.84,308.54,-146.6"
  },
  EPSG_4743: {
    towgs84: "70.995,-335.916,262.898"
  },
  EPSG_4710: {
    towgs84: "-323.65,551.39,-491.22"
  },
  EPSG_7881: {
    towgs84: "-0.077,0.079,0.086"
  },
  EPSG_4682: {
    towgs84: "283.729,735.942,261.143"
  },
  EPSG_4739: {
    towgs84: "-156,-271,-189"
  },
  EPSG_4679: {
    towgs84: "-80.01,253.26,291.19"
  },
  EPSG_4750: {
    towgs84: "-56.263,16.136,-22.856"
  },
  EPSG_4644: {
    towgs84: "-10.18,-350.43,291.37"
  },
  EPSG_4695: {
    towgs84: "-103.746,-9.614,-255.95"
  },
  EPSG_4292: {
    towgs84: "-355,21,72"
  },
  EPSG_4302: {
    towgs84: "-61.702,284.488,472.052"
  },
  EPSG_4143: {
    towgs84: "-124.76,53,466.79"
  },
  EPSG_4606: {
    towgs84: "-153,153,307"
  },
  EPSG_4699: {
    towgs84: "-770.1,158.4,-498.2"
  },
  EPSG_4247: {
    towgs84: "-273.5,110.6,-357.9"
  },
  EPSG_4160: {
    towgs84: "8.88,184.86,106.69"
  },
  EPSG_4161: {
    towgs84: "-233.43,6.65,173.64"
  },
  EPSG_9251: {
    towgs84: "-9.5,122.9,138.2"
  },
  EPSG_9253: {
    towgs84: "-78.1,101.6,133.3"
  },
  EPSG_4297: {
    towgs84: "-198.383,-240.517,-107.909"
  },
  EPSG_4269: {
    towgs84: "0,0,0"
  },
  EPSG_4301: {
    towgs84: "-147,506,687"
  },
  EPSG_4618: {
    towgs84: "-59,-11,-52"
  },
  EPSG_4612: {
    towgs84: "0,0,0"
  },
  EPSG_4678: {
    towgs84: "44.585,-131.212,-39.544"
  },
  EPSG_4250: {
    towgs84: "-130,29,364"
  },
  EPSG_4144: {
    towgs84: "214,804,268"
  },
  EPSG_4147: {
    towgs84: "-17.51,-108.32,-62.39"
  },
  EPSG_4259: {
    towgs84: "-254.1,-5.36,-100.29"
  },
  EPSG_4164: {
    towgs84: "-76,-138,67"
  },
  EPSG_4211: {
    towgs84: "-378.873,676.002,-46.255"
  },
  EPSG_4182: {
    towgs84: "-422.651,-172.995,84.02"
  },
  EPSG_4224: {
    towgs84: "-143.87,243.37,-33.52"
  },
  EPSG_4225: {
    towgs84: "-205.57,168.77,-4.12"
  },
  EPSG_5527: {
    towgs84: "-67.35,3.88,-38.22"
  },
  EPSG_4752: {
    towgs84: "98,390,-22"
  },
  EPSG_4310: {
    towgs84: "-30,190,89"
  },
  EPSG_9248: {
    towgs84: "-192.26,65.72,132.08"
  },
  EPSG_4680: {
    towgs84: "124.5,-63.5,-281"
  },
  EPSG_4701: {
    towgs84: "-79.9,-158,-168.9"
  },
  EPSG_4706: {
    towgs84: "-146.21,112.63,4.05"
  },
  EPSG_4805: {
    towgs84: "682,-203,480"
  },
  EPSG_4201: {
    towgs84: "-165,-11,206"
  },
  EPSG_4210: {
    towgs84: "-157,-2,-299"
  },
  EPSG_4183: {
    towgs84: "-104,167,-38"
  },
  EPSG_4139: {
    towgs84: "11,72,-101"
  },
  EPSG_4668: {
    towgs84: "-86,-98,-119"
  },
  EPSG_4717: {
    towgs84: "-2,151,181"
  },
  EPSG_4732: {
    towgs84: "102,52,-38"
  },
  EPSG_4280: {
    towgs84: "-377,681,-50"
  },
  EPSG_4209: {
    towgs84: "-138,-105,-289"
  },
  EPSG_4261: {
    towgs84: "31,146,47"
  },
  EPSG_4658: {
    towgs84: "-73,46,-86"
  },
  EPSG_4721: {
    towgs84: "265.025,384.929,-194.046"
  },
  EPSG_4222: {
    towgs84: "-136,-108,-292"
  },
  EPSG_4601: {
    towgs84: "-255,-15,71"
  },
  EPSG_4602: {
    towgs84: "725,685,536"
  },
  EPSG_4603: {
    towgs84: "72,213.7,93"
  },
  EPSG_4605: {
    towgs84: "9,183,236"
  },
  EPSG_4621: {
    towgs84: "137,248,-430"
  },
  EPSG_4657: {
    towgs84: "-28,199,5"
  },
  EPSG_4316: {
    towgs84: "103.25,-100.4,-307.19"
  },
  EPSG_4642: {
    towgs84: "-13,-348,292"
  },
  EPSG_4698: {
    towgs84: "145,-187,103"
  },
  EPSG_4192: {
    towgs84: "-206.1,-174.7,-87.7"
  },
  EPSG_4311: {
    towgs84: "-265,120,-358"
  },
  EPSG_4135: {
    towgs84: "58,-283,-182"
  },
  ESRI_104138: {
    towgs84: "198,-226,-347"
  },
  EPSG_4245: {
    towgs84: "-11,851,5"
  },
  EPSG_4142: {
    towgs84: "-125,53,467"
  },
  EPSG_4213: {
    towgs84: "-106,-87,188"
  },
  EPSG_4253: {
    towgs84: "-133,-77,-51"
  },
  EPSG_4129: {
    towgs84: "-132,-110,-335"
  },
  EPSG_4713: {
    towgs84: "-77,-128,142"
  },
  EPSG_4239: {
    towgs84: "217,823,299"
  },
  EPSG_4146: {
    towgs84: "295,736,257"
  },
  EPSG_4155: {
    towgs84: "-83,37,124"
  },
  EPSG_4165: {
    towgs84: "-173,253,27"
  },
  EPSG_4672: {
    towgs84: "175,-38,113"
  },
  EPSG_4236: {
    towgs84: "-637,-549,-203"
  },
  EPSG_4251: {
    towgs84: "-90,40,88"
  },
  EPSG_4271: {
    towgs84: "-2,374,172"
  },
  EPSG_4175: {
    towgs84: "-88,4,101"
  },
  EPSG_4716: {
    towgs84: "298,-304,-375"
  },
  EPSG_4315: {
    towgs84: "-23,259,-9"
  },
  EPSG_4744: {
    towgs84: "-242.2,-144.9,370.3"
  },
  EPSG_4244: {
    towgs84: "-97,787,86"
  },
  EPSG_4293: {
    towgs84: "616,97,-251"
  },
  EPSG_4714: {
    towgs84: "-127,-769,472"
  },
  EPSG_4736: {
    towgs84: "260,12,-147"
  },
  EPSG_6883: {
    towgs84: "-235,-110,393"
  },
  EPSG_6894: {
    towgs84: "-63,176,185"
  },
  EPSG_4205: {
    towgs84: "-43,-163,45"
  },
  EPSG_4256: {
    towgs84: "41,-220,-134"
  },
  EPSG_4262: {
    towgs84: "639,405,60"
  },
  EPSG_4604: {
    towgs84: "174,359,365"
  },
  EPSG_4169: {
    towgs84: "-115,118,426"
  },
  EPSG_4620: {
    towgs84: "-106,-129,165"
  },
  EPSG_4184: {
    towgs84: "-203,141,53"
  },
  EPSG_4616: {
    towgs84: "-289,-124,60"
  },
  EPSG_9403: {
    towgs84: "-307,-92,127"
  },
  EPSG_4684: {
    towgs84: "-133,-321,50"
  },
  EPSG_4708: {
    towgs84: "-491,-22,435"
  },
  EPSG_4707: {
    towgs84: "114,-116,-333"
  },
  EPSG_4709: {
    towgs84: "145,75,-272"
  },
  EPSG_4712: {
    towgs84: "-205,107,53"
  },
  EPSG_4711: {
    towgs84: "124,-234,-25"
  },
  EPSG_4718: {
    towgs84: "230,-199,-752"
  },
  EPSG_4719: {
    towgs84: "211,147,111"
  },
  EPSG_4724: {
    towgs84: "208,-435,-229"
  },
  EPSG_4725: {
    towgs84: "189,-79,-202"
  },
  EPSG_4735: {
    towgs84: "647,1777,-1124"
  },
  EPSG_4722: {
    towgs84: "-794,119,-298"
  },
  EPSG_4728: {
    towgs84: "-307,-92,127"
  },
  EPSG_4734: {
    towgs84: "-632,438,-609"
  },
  EPSG_4727: {
    towgs84: "912,-58,1227"
  },
  EPSG_4729: {
    towgs84: "185,165,42"
  },
  EPSG_4730: {
    towgs84: "170,42,84"
  },
  EPSG_4733: {
    towgs84: "276,-57,149"
  },
  ESRI_37218: {
    towgs84: "230,-199,-752"
  },
  ESRI_37240: {
    towgs84: "-7,215,225"
  },
  ESRI_37221: {
    towgs84: "252,-209,-751"
  },
  ESRI_4305: {
    towgs84: "-123,-206,219"
  },
  ESRI_104139: {
    towgs84: "-73,-247,227"
  },
  EPSG_4748: {
    towgs84: "51,391,-36"
  },
  EPSG_4219: {
    towgs84: "-384,664,-48"
  },
  EPSG_4255: {
    towgs84: "-333,-222,114"
  },
  EPSG_4257: {
    towgs84: "-587.8,519.75,145.76"
  },
  EPSG_4646: {
    towgs84: "-963,510,-359"
  },
  EPSG_6881: {
    towgs84: "-24,-203,268"
  },
  EPSG_6882: {
    towgs84: "-183,-15,273"
  },
  EPSG_4715: {
    towgs84: "-104,-129,239"
  },
  IGNF_RGF93GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGM04GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGSPM06GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGTAAF07GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGFG95GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGNCG: {
    towgs84: "0,0,0"
  },
  IGNF_RGPFGDD: {
    towgs84: "0,0,0"
  },
  IGNF_ETRS89G: {
    towgs84: "0,0,0"
  },
  IGNF_RGR92GDD: {
    towgs84: "0,0,0"
  },
  EPSG_4173: {
    towgs84: "0,0,0"
  },
  EPSG_4180: {
    towgs84: "0,0,0"
  },
  EPSG_4619: {
    towgs84: "0,0,0"
  },
  EPSG_4667: {
    towgs84: "0,0,0"
  },
  EPSG_4075: {
    towgs84: "0,0,0"
  },
  EPSG_6706: {
    towgs84: "0,0,0"
  },
  EPSG_7798: {
    towgs84: "0,0,0"
  },
  EPSG_4661: {
    towgs84: "0,0,0"
  },
  EPSG_4669: {
    towgs84: "0,0,0"
  },
  EPSG_8685: {
    towgs84: "0,0,0"
  },
  EPSG_4151: {
    towgs84: "0,0,0"
  },
  EPSG_9702: {
    towgs84: "0,0,0"
  },
  EPSG_4758: {
    towgs84: "0,0,0"
  },
  EPSG_4761: {
    towgs84: "0,0,0"
  },
  EPSG_4765: {
    towgs84: "0,0,0"
  },
  EPSG_8997: {
    towgs84: "0,0,0"
  },
  EPSG_4023: {
    towgs84: "0,0,0"
  },
  EPSG_4670: {
    towgs84: "0,0,0"
  },
  EPSG_4694: {
    towgs84: "0,0,0"
  },
  EPSG_4148: {
    towgs84: "0,0,0"
  },
  EPSG_4163: {
    towgs84: "0,0,0"
  },
  EPSG_4167: {
    towgs84: "0,0,0"
  },
  EPSG_4189: {
    towgs84: "0,0,0"
  },
  EPSG_4190: {
    towgs84: "0,0,0"
  },
  EPSG_4176: {
    towgs84: "0,0,0"
  },
  EPSG_4659: {
    towgs84: "0,0,0"
  },
  EPSG_3824: {
    towgs84: "0,0,0"
  },
  EPSG_3889: {
    towgs84: "0,0,0"
  },
  EPSG_4046: {
    towgs84: "0,0,0"
  },
  EPSG_4081: {
    towgs84: "0,0,0"
  },
  EPSG_4558: {
    towgs84: "0,0,0"
  },
  EPSG_4483: {
    towgs84: "0,0,0"
  },
  EPSG_5013: {
    towgs84: "0,0,0"
  },
  EPSG_5264: {
    towgs84: "0,0,0"
  },
  EPSG_5324: {
    towgs84: "0,0,0"
  },
  EPSG_5354: {
    towgs84: "0,0,0"
  },
  EPSG_5371: {
    towgs84: "0,0,0"
  },
  EPSG_5373: {
    towgs84: "0,0,0"
  },
  EPSG_5381: {
    towgs84: "0,0,0"
  },
  EPSG_5393: {
    towgs84: "0,0,0"
  },
  EPSG_5489: {
    towgs84: "0,0,0"
  },
  EPSG_5593: {
    towgs84: "0,0,0"
  },
  EPSG_6135: {
    towgs84: "0,0,0"
  },
  EPSG_6365: {
    towgs84: "0,0,0"
  },
  EPSG_5246: {
    towgs84: "0,0,0"
  },
  EPSG_7886: {
    towgs84: "0,0,0"
  },
  EPSG_8431: {
    towgs84: "0,0,0"
  },
  EPSG_8427: {
    towgs84: "0,0,0"
  },
  EPSG_8699: {
    towgs84: "0,0,0"
  },
  EPSG_8818: {
    towgs84: "0,0,0"
  },
  EPSG_4757: {
    towgs84: "0,0,0"
  },
  EPSG_9140: {
    towgs84: "0,0,0"
  },
  EPSG_8086: {
    towgs84: "0,0,0"
  },
  EPSG_4686: {
    towgs84: "0,0,0"
  },
  EPSG_4737: {
    towgs84: "0,0,0"
  },
  EPSG_4702: {
    towgs84: "0,0,0"
  },
  EPSG_4747: {
    towgs84: "0,0,0"
  },
  EPSG_4749: {
    towgs84: "0,0,0"
  },
  EPSG_4674: {
    towgs84: "0,0,0"
  },
  EPSG_4755: {
    towgs84: "0,0,0"
  },
  EPSG_4759: {
    towgs84: "0,0,0"
  },
  EPSG_4762: {
    towgs84: "0,0,0"
  },
  EPSG_4763: {
    towgs84: "0,0,0"
  },
  EPSG_4764: {
    towgs84: "0,0,0"
  },
  EPSG_4166: {
    towgs84: "0,0,0"
  },
  EPSG_4170: {
    towgs84: "0,0,0"
  },
  EPSG_5546: {
    towgs84: "0,0,0"
  },
  EPSG_7844: {
    towgs84: "0,0,0"
  },
  EPSG_4818: {
    towgs84: "589,76,480"
  }
};
for (var kp in q0) {
  var q2 = q0[kp];
  q2.datumName && (q0[q2.datumName] = q2);
}
function Lp(i, t, e, n, r, s, o) {
  var a = {};
  return i === void 0 || i === "none" ? a.datum_type = Na : a.datum_type = $8, t && (a.datum_params = t.map(parseFloat), (a.datum_params[0] !== 0 || a.datum_params[1] !== 0 || a.datum_params[2] !== 0) && (a.datum_type = Fn), a.datum_params.length > 3 && (a.datum_params[3] !== 0 || a.datum_params[4] !== 0 || a.datum_params[5] !== 0 || a.datum_params[6] !== 0) && (a.datum_type = On, a.datum_params[3] *= Rs, a.datum_params[4] *= Rs, a.datum_params[5] *= Rs, a.datum_params[6] = a.datum_params[6] / 1e6 + 1)), o && (a.datum_type = br, a.grids = o), a.a = e, a.b = n, a.es = r, a.ep2 = s, a;
}
var ql = {};
function Ap(i, t, e) {
  return t instanceof ArrayBuffer ? Fp(i, t, e) : { ready: Op(i, t) };
}
function Fp(i, t, e) {
  var n = !0;
  e !== void 0 && e.includeErrorFields === !1 && (n = !1);
  var r = new DataView(t), s = Dp(r), o = zp(r, s), a = jp(r, o, s, n), l = { header: o, subgrids: a };
  return ql[i] = l, l;
}
async function Op(i, t) {
  for (var e = [], n = await t.getImageCount(), r = n - 1; r >= 0; r--) {
    var s = await t.getImage(r), o = await s.readRasters(), a = o, l = [s.getWidth(), s.getHeight()], h = s.getBoundingBox().map(Dc), c = [s.fileDirectory.ModelPixelScale[0], s.fileDirectory.ModelPixelScale[1]].map(Dc), d = h[0] + (l[0] - 1) * c[0], u = h[3] - (l[1] - 1) * c[1], f = a[0], g = a[1], p = [];
    for (let y = l[1] - 1; y >= 0; y--)
      for (let x = l[0] - 1; x >= 0; x--) {
        var m = y * l[0] + x;
        p.push([-Vi(g[m]), Vi(f[m])]);
      }
    e.push({
      del: c,
      lim: l,
      ll: [-d, u],
      cvs: p
    });
  }
  var _ = {
    header: {
      nSubgrids: n
    },
    subgrids: e
  };
  return ql[i] = _, _;
}
function Gp(i) {
  if (i === void 0)
    return null;
  var t = i.split(",");
  return t.map(Np);
}
function Np(i) {
  if (i.length === 0)
    return null;
  var t = i[0] === "@";
  return t && (i = i.slice(1)), i === "null" ? { name: "null", mandatory: !t, grid: null, isNull: !0 } : {
    name: i,
    mandatory: !t,
    grid: ql[i] || null,
    isNull: !1
  };
}
function Dc(i) {
  return i * Math.PI / 180;
}
function Vi(i) {
  return i / 3600 * Math.PI / 180;
}
function Dp(i) {
  var t = i.getInt32(8, !1);
  return t === 11 ? !1 : (t = i.getInt32(8, !0), t !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function zp(i, t) {
  return {
    nFields: i.getInt32(8, t),
    nSubgridFields: i.getInt32(24, t),
    nSubgrids: i.getInt32(40, t),
    shiftType: za(i, 56, 64).trim(),
    fromSemiMajorAxis: i.getFloat64(120, t),
    fromSemiMinorAxis: i.getFloat64(136, t),
    toSemiMajorAxis: i.getFloat64(152, t),
    toSemiMinorAxis: i.getFloat64(168, t)
  };
}
function za(i, t, e) {
  return String.fromCharCode.apply(null, new Uint8Array(i.buffer.slice(t, e)));
}
function jp(i, t, e, n) {
  for (var r = 176, s = [], o = 0; o < t.nSubgrids; o++) {
    var a = Bp(i, r, e), l = Vp(i, r, a, e, n), h = Math.round(
      1 + (a.upperLongitude - a.lowerLongitude) / a.longitudeInterval
    ), c = Math.round(
      1 + (a.upperLatitude - a.lowerLatitude) / a.latitudeInterval
    );
    s.push({
      ll: [Vi(a.lowerLongitude), Vi(a.lowerLatitude)],
      del: [Vi(a.longitudeInterval), Vi(a.latitudeInterval)],
      lim: [h, c],
      count: a.gridNodeCount,
      cvs: Up(l)
    });
    var d = 16;
    n === !1 && (d = 8), r += 176 + a.gridNodeCount * d;
  }
  return s;
}
function Up(i) {
  return i.map(function(t) {
    return [Vi(t.longitudeShift), Vi(t.latitudeShift)];
  });
}
function Bp(i, t, e) {
  return {
    name: za(i, t + 8, t + 16).trim(),
    parent: za(i, t + 24, t + 24 + 8).trim(),
    lowerLatitude: i.getFloat64(t + 72, e),
    upperLatitude: i.getFloat64(t + 88, e),
    lowerLongitude: i.getFloat64(t + 104, e),
    upperLongitude: i.getFloat64(t + 120, e),
    latitudeInterval: i.getFloat64(t + 136, e),
    longitudeInterval: i.getFloat64(t + 152, e),
    gridNodeCount: i.getInt32(t + 168, e)
  };
}
function Vp(i, t, e, n, r) {
  var s = t + 176, o = 16;
  r === !1 && (o = 8);
  for (var a = [], l = 0; l < e.gridNodeCount; l++) {
    var h = {
      latitudeShift: i.getFloat32(s + l * o, n),
      longitudeShift: i.getFloat32(s + l * o + 4, n)
    };
    r !== !1 && (h.latitudeAccuracy = i.getFloat32(s + l * o + 8, n), h.longitudeAccuracy = i.getFloat32(s + l * o + 12, n)), a.push(h);
  }
  return a;
}
function Ge(i, t) {
  if (!(this instanceof Ge))
    return new Ge(i);
  this.forward = null, this.inverse = null, this.init = null, this.name, this.names = null, this.title, t = t || function(h) {
    if (h)
      throw h;
  };
  var e = pp(i);
  if (typeof e != "object") {
    t("Could not parse to valid json: " + i);
    return;
  }
  var n = Ge.projections.get(e.projName);
  if (!n) {
    t("Could not get projection name from: " + i);
    return;
  }
  if (e.datumCode && e.datumCode !== "none") {
    var r = qi(q0, e.datumCode);
    r && (e.datum_params = e.datum_params || (r.towgs84 ? r.towgs84.split(",") : null), e.ellps = r.ellipse, e.datumName = r.datumName ? r.datumName : e.datumCode);
  }
  e.k0 = e.k0 || 1, e.axis = e.axis || "enu", e.ellps = e.ellps || "wgs84", e.lat1 = e.lat1 || e.lat0;
  var s = Ip(e.a, e.b, e.rf, e.ellps, e.sphere), o = Pp(s.a, s.b, s.rf, e.R_A), a = Gp(e.nadgrids), l = e.datum || Lp(
    e.datumCode,
    e.datum_params,
    s.a,
    s.b,
    o.es,
    o.ep2,
    a
  );
  Gc(this, e), Gc(this, n), this.a = s.a, this.b = s.b, this.rf = s.rf, this.sphere = s.sphere, this.es = o.es, this.e = o.e, this.ep2 = o.ep2, this.datum = l, "init" in this && typeof this.init == "function" && this.init(), t(null, this);
}
Ge.projections = Tp;
Ge.projections.start();
function $p(i, t) {
  return i.datum_type !== t.datum_type || i.a !== t.a || Math.abs(i.es - t.es) > 5e-11 ? !1 : i.datum_type === Fn ? i.datum_params[0] === t.datum_params[0] && i.datum_params[1] === t.datum_params[1] && i.datum_params[2] === t.datum_params[2] : i.datum_type === On ? i.datum_params[0] === t.datum_params[0] && i.datum_params[1] === t.datum_params[1] && i.datum_params[2] === t.datum_params[2] && i.datum_params[3] === t.datum_params[3] && i.datum_params[4] === t.datum_params[4] && i.datum_params[5] === t.datum_params[5] && i.datum_params[6] === t.datum_params[6] : !0;
}
function ju(i, t, e) {
  var n = i.x, r = i.y, s = i.z ? i.z : 0, o, a, l, h;
  if (r < -T && r > -1.001 * T)
    r = -T;
  else if (r > T && r < 1.001 * T)
    r = T;
  else {
    if (r < -T)
      return { x: -1 / 0, y: -1 / 0, z: i.z };
    if (r > T)
      return { x: 1 / 0, y: 1 / 0, z: i.z };
  }
  return n > Math.PI && (n -= 2 * Math.PI), a = Math.sin(r), h = Math.cos(r), l = a * a, o = e / Math.sqrt(1 - t * l), {
    x: (o + s) * h * Math.cos(n),
    y: (o + s) * h * Math.sin(n),
    z: (o * (1 - t) + s) * a
  };
}
function Uu(i, t, e, n) {
  var r = 1e-12, s = r * r, o = 30, a, l, h, c, d, u, f, g, p, m, _, y, x, v = i.x, C = i.y, b = i.z ? i.z : 0, w, E, S;
  if (a = Math.sqrt(v * v + C * C), l = Math.sqrt(v * v + C * C + b * b), a / e < r) {
    if (w = 0, l / e < r)
      return E = T, S = -n, {
        x: i.x,
        y: i.y,
        z: i.z
      };
  } else
    w = Math.atan2(C, v);
  h = b / l, c = a / l, d = 1 / Math.sqrt(1 - t * (2 - t) * c * c), g = c * (1 - t) * d, p = h * d, x = 0;
  do
    x++, f = e / Math.sqrt(1 - t * p * p), S = a * g + b * p - f * (1 - t * p * p), u = t * f / (f + S), d = 1 / Math.sqrt(1 - u * (2 - u) * c * c), m = c * (1 - u) * d, _ = h * d, y = _ * g - m * p, g = m, p = _;
  while (y * y > s && x < o);
  return E = Math.atan(_ / Math.abs(m)), {
    x: w,
    y: E,
    z: S
  };
}
function Wp(i, t, e) {
  if (t === Fn)
    return {
      x: i.x + e[0],
      y: i.y + e[1],
      z: i.z + e[2]
    };
  if (t === On) {
    var n = e[0], r = e[1], s = e[2], o = e[3], a = e[4], l = e[5], h = e[6];
    return {
      x: h * (i.x - l * i.y + a * i.z) + n,
      y: h * (l * i.x + i.y - o * i.z) + r,
      z: h * (-a * i.x + o * i.y + i.z) + s
    };
  }
}
function Yp(i, t, e) {
  if (t === Fn)
    return {
      x: i.x - e[0],
      y: i.y - e[1],
      z: i.z - e[2]
    };
  if (t === On) {
    var n = e[0], r = e[1], s = e[2], o = e[3], a = e[4], l = e[5], h = e[6], c = (i.x - n) / h, d = (i.y - r) / h, u = (i.z - s) / h;
    return {
      x: c + l * d - a * u,
      y: -l * c + d + o * u,
      z: a * c - o * d + u
    };
  }
}
function U0(i) {
  return i === Fn || i === On;
}
function Xp(i, t, e) {
  if ($p(i, t) || i.datum_type === Na || t.datum_type === Na)
    return e;
  var n = i.a, r = i.es;
  if (i.datum_type === br) {
    var s = zc(i, !1, e);
    if (s !== 0)
      return;
    n = Ic, r = kc;
  }
  var o = t.a, a = t.b, l = t.es;
  if (t.datum_type === br && (o = Ic, a = W8, l = kc), r === l && n === o && !U0(i.datum_type) && !U0(t.datum_type))
    return e;
  if (e = ju(e, r, n), U0(i.datum_type) && (e = Wp(e, i.datum_type, i.datum_params)), U0(t.datum_type) && (e = Yp(e, t.datum_type, t.datum_params)), e = Uu(e, l, o, a), t.datum_type === br) {
    var h = zc(t, !0, e);
    if (h !== 0)
      return;
  }
  return e;
}
function zc(i, t, e) {
  if (i.grids === null || i.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  var n = { x: -e.x, y: e.y }, r = { x: Number.NaN, y: Number.NaN }, s = [];
  t:
    for (var o = 0; o < i.grids.length; o++) {
      var a = i.grids[o];
      if (s.push(a.name), a.isNull) {
        r = n;
        break;
      }
      if (a.grid === null) {
        if (a.mandatory)
          return console.log("Unable to find mandatory grid '" + a.name + "'"), -1;
        continue;
      }
      for (var l = a.grid.subgrids, h = 0, c = l.length; h < c; h++) {
        var d = l[h], u = (Math.abs(d.del[1]) + Math.abs(d.del[0])) / 1e4, f = d.ll[0] - u, g = d.ll[1] - u, p = d.ll[0] + (d.lim[0] - 1) * d.del[0] + u, m = d.ll[1] + (d.lim[1] - 1) * d.del[1] + u;
        if (!(g > n.y || f > n.x || m < n.y || p < n.x) && (r = Zp(n, t, d), !isNaN(r.x)))
          break t;
      }
    }
  return isNaN(r.x) ? (console.log("Failed to find a grid shift table for location '" + -n.x * ce + " " + n.y * ce + " tried: '" + s + "'"), -1) : (e.x = -r.x, e.y = r.y, 0);
}
function Zp(i, t, e) {
  var n = { x: Number.NaN, y: Number.NaN };
  if (isNaN(i.x))
    return n;
  var r = { x: i.x, y: i.y };
  r.x -= e.ll[0], r.y -= e.ll[1], r.x = O(r.x - Math.PI) + Math.PI;
  var s = jc(r, e);
  if (t) {
    if (isNaN(s.x))
      return n;
    s.x = r.x - s.x, s.y = r.y - s.y;
    var o = 9, a = 1e-12, l, h;
    do {
      if (h = jc(s, e), isNaN(h.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      l = { x: r.x - (h.x + s.x), y: r.y - (h.y + s.y) }, s.x += l.x, s.y += l.y;
    } while (o-- && Math.abs(l.x) > a && Math.abs(l.y) > a);
    if (o < 0)
      return console.log("Inverse grid shift iterator failed to converge."), n;
    n.x = O(s.x + e.ll[0]), n.y = s.y + e.ll[1];
  } else
    isNaN(s.x) || (n.x = i.x + s.x, n.y = i.y + s.y);
  return n;
}
function jc(i, t) {
  var e = { x: i.x / t.del[0], y: i.y / t.del[1] }, n = { x: Math.floor(e.x), y: Math.floor(e.y) }, r = { x: e.x - 1 * n.x, y: e.y - 1 * n.y }, s = { x: Number.NaN, y: Number.NaN }, o;
  if (n.x < 0 || n.x >= t.lim[0] || n.y < 0 || n.y >= t.lim[1])
    return s;
  o = n.y * t.lim[0] + n.x;
  var a = { x: t.cvs[o][0], y: t.cvs[o][1] };
  o++;
  var l = { x: t.cvs[o][0], y: t.cvs[o][1] };
  o += t.lim[0];
  var h = { x: t.cvs[o][0], y: t.cvs[o][1] };
  o--;
  var c = { x: t.cvs[o][0], y: t.cvs[o][1] }, d = r.x * r.y, u = r.x * (1 - r.y), f = (1 - r.x) * (1 - r.y), g = (1 - r.x) * r.y;
  return s.x = f * a.x + u * l.x + g * c.x + d * h.x, s.y = f * a.y + u * l.y + g * c.y + d * h.y, s;
}
function Uc(i, t, e) {
  var n = e.x, r = e.y, s = e.z || 0, o, a, l, h = {};
  for (l = 0; l < 3; l++)
    if (!(t && l === 2 && e.z === void 0))
      switch (l === 0 ? (o = n, "ew".indexOf(i.axis[l]) !== -1 ? a = "x" : a = "y") : l === 1 ? (o = r, "ns".indexOf(i.axis[l]) !== -1 ? a = "y" : a = "x") : (o = s, a = "z"), i.axis[l]) {
        case "e":
          h[a] = o;
          break;
        case "w":
          h[a] = -o;
          break;
        case "n":
          h[a] = o;
          break;
        case "s":
          h[a] = -o;
          break;
        case "u":
          e[a] !== void 0 && (h.z = o);
          break;
        case "d":
          e[a] !== void 0 && (h.z = -o);
          break;
        default:
          return null;
      }
  return h;
}
function Bu(i) {
  var t = {
    x: i[0],
    y: i[1]
  };
  return i.length > 2 && (t.z = i[2]), i.length > 3 && (t.m = i[3]), t;
}
function Hp(i) {
  Bc(i.x), Bc(i.y);
}
function Bc(i) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(i))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof i != "number" || i !== i || !isFinite(i))
    throw new TypeError("coordinates must be finite numbers");
}
function Kp(i, t) {
  return (i.datum.datum_type === Fn || i.datum.datum_type === On || i.datum.datum_type === br) && t.datumCode !== "WGS84" || (t.datum.datum_type === Fn || t.datum.datum_type === On || t.datum.datum_type === br) && i.datumCode !== "WGS84";
}
function Io(i, t, e, n) {
  var r;
  Array.isArray(e) ? e = Bu(e) : e = {
    x: e.x,
    y: e.y,
    z: e.z,
    m: e.m
  };
  var s = e.z !== void 0;
  if (Hp(e), i.datum && t.datum && Kp(i, t) && (r = new Ge("WGS84"), e = Io(i, r, e, n), i = r), n && i.axis !== "enu" && (e = Uc(i, !1, e)), i.projName === "longlat")
    e = {
      x: e.x * Ct,
      y: e.y * Ct,
      z: e.z || 0
    };
  else if (i.to_meter && (e = {
    x: e.x * i.to_meter,
    y: e.y * i.to_meter,
    z: e.z || 0
  }), e = i.inverse(e), !e)
    return;
  if (i.from_greenwich && (e.x += i.from_greenwich), e = Xp(i.datum, t.datum, e), !!e)
    return e = /** @type {import('./core').InterfaceCoordinates} */
    e, t.from_greenwich && (e = {
      x: e.x - t.from_greenwich,
      y: e.y,
      z: e.z || 0
    }), t.projName === "longlat" ? e = {
      x: e.x * ce,
      y: e.y * ce,
      z: e.z || 0
    } : (e = t.forward(e), t.to_meter && (e = {
      x: e.x / t.to_meter,
      y: e.y / t.to_meter,
      z: e.z || 0
    })), n && t.axis !== "enu" ? Uc(t, !0, e) : (e && !s && delete e.z, e);
}
var Vc = Ge("WGS84");
function J2(i, t, e, n) {
  var r, s, o;
  return Array.isArray(e) ? (r = Io(i, t, e, n) || { x: NaN, y: NaN }, e.length > 2 ? typeof i.name < "u" && i.name === "geocent" || typeof t.name < "u" && t.name === "geocent" ? typeof r.z == "number" ? (
    /** @type {T} */
    [r.x, r.y, r.z].concat(e.slice(3))
  ) : (
    /** @type {T} */
    [r.x, r.y, e[2]].concat(e.slice(3))
  ) : (
    /** @type {T} */
    [r.x, r.y].concat(e.slice(2))
  ) : (
    /** @type {T} */
    [r.x, r.y]
  )) : (s = Io(i, t, e, n), o = Object.keys(e), o.length === 2 || o.forEach(function(a) {
    if (typeof i.name < "u" && i.name === "geocent" || typeof t.name < "u" && t.name === "geocent") {
      if (a === "x" || a === "y" || a === "z")
        return;
    } else if (a === "x" || a === "y")
      return;
    s[a] = e[a];
  }), /** @type {T} */
  s);
}
function B0(i) {
  return i instanceof Ge ? i : typeof i == "object" && "oProj" in i ? i.oProj : Ge(
    /** @type {string | PROJJSONDefinition} */
    i
  );
}
function qp(i, t, e) {
  var n, r, s = !1, o;
  return typeof t > "u" ? (r = B0(i), n = Vc, s = !0) : (typeof /** @type {?} */
  t.x < "u" || Array.isArray(t)) && (e = /** @type {T} */
  /** @type {?} */
  t, r = B0(i), n = Vc, s = !0), n || (n = B0(i)), r || (r = B0(
    /** @type {string | PROJJSONDefinition | proj } */
    t
  )), e ? J2(n, r, e) : (o = {
    /**
     * @template {TemplateCoordinates} T
     * @param {T} coords
     * @param {boolean=} enforceAxis
     * @returns {T}
     */
    forward: function(a, l) {
      return J2(n, r, a, l);
    },
    /**
     * @template {TemplateCoordinates} T
     * @param {T} coords
     * @param {boolean=} enforceAxis
     * @returns {T}
     */
    inverse: function(a, l) {
      return J2(r, n, a, l);
    }
  }, s && (o.oProj = r), o);
}
var $c = 6, Vu = "AJSAJS", $u = "AFAFAF", fr = 65, se = 73, Ee = 79, ms = 86, ps = 90;
const Jp = {
  forward: Wu,
  inverse: Qp,
  toPoint: Yu
};
function Wu(i, t) {
  return t = t || 5, i6(t6({
    lat: i[1],
    lon: i[0]
  }), t);
}
function Qp(i) {
  var t = Jl(Zu(i.toUpperCase()));
  return t.lat && t.lon ? [t.lon, t.lat, t.lon, t.lat] : [t.left, t.bottom, t.right, t.top];
}
function Yu(i) {
  var t = Jl(Zu(i.toUpperCase()));
  return t.lat && t.lon ? [t.lon, t.lat] : [(t.left + t.right) / 2, (t.top + t.bottom) / 2];
}
function Q2(i) {
  return i * (Math.PI / 180);
}
function Wc(i) {
  return 180 * (i / Math.PI);
}
function t6(i) {
  var t = i.lat, e = i.lon, n = 6378137, r = 669438e-8, s = 0.9996, o, a, l, h, c, d, u, f = Q2(t), g = Q2(e), p, m;
  m = Math.floor((e + 180) / 6) + 1, e === 180 && (m = 60), t >= 56 && t < 64 && e >= 3 && e < 12 && (m = 32), t >= 72 && t < 84 && (e >= 0 && e < 9 ? m = 31 : e >= 9 && e < 21 ? m = 33 : e >= 21 && e < 33 ? m = 35 : e >= 33 && e < 42 && (m = 37)), o = (m - 1) * 6 - 180 + 3, p = Q2(o), a = r / (1 - r), l = n / Math.sqrt(1 - r * Math.sin(f) * Math.sin(f)), h = Math.tan(f) * Math.tan(f), c = a * Math.cos(f) * Math.cos(f), d = Math.cos(f) * (g - p), u = n * ((1 - r / 4 - 3 * r * r / 64 - 5 * r * r * r / 256) * f - (3 * r / 8 + 3 * r * r / 32 + 45 * r * r * r / 1024) * Math.sin(2 * f) + (15 * r * r / 256 + 45 * r * r * r / 1024) * Math.sin(4 * f) - 35 * r * r * r / 3072 * Math.sin(6 * f));
  var _ = s * l * (d + (1 - h + c) * d * d * d / 6 + (5 - 18 * h + h * h + 72 * c - 58 * a) * d * d * d * d * d / 120) + 5e5, y = s * (u + l * Math.tan(f) * (d * d / 2 + (5 - h + 9 * c + 4 * c * c) * d * d * d * d / 24 + (61 - 58 * h + h * h + 600 * c - 330 * a) * d * d * d * d * d * d / 720));
  return t < 0 && (y += 1e7), {
    northing: Math.round(y),
    easting: Math.round(_),
    zoneNumber: m,
    zoneLetter: e6(t)
  };
}
function Jl(i) {
  var t = i.northing, e = i.easting, n = i.zoneLetter, r = i.zoneNumber;
  if (r < 0 || r > 60)
    return null;
  var s = 0.9996, o = 6378137, a = 669438e-8, l, h = (1 - Math.sqrt(1 - a)) / (1 + Math.sqrt(1 - a)), c, d, u, f, g, p, m, _, y, x = e - 5e5, v = t;
  n < "N" && (v -= 1e7), m = (r - 1) * 6 - 180 + 3, l = a / (1 - a), p = v / s, _ = p / (o * (1 - a / 4 - 3 * a * a / 64 - 5 * a * a * a / 256)), y = _ + (3 * h / 2 - 27 * h * h * h / 32) * Math.sin(2 * _) + (21 * h * h / 16 - 55 * h * h * h * h / 32) * Math.sin(4 * _) + 151 * h * h * h / 96 * Math.sin(6 * _), c = o / Math.sqrt(1 - a * Math.sin(y) * Math.sin(y)), d = Math.tan(y) * Math.tan(y), u = l * Math.cos(y) * Math.cos(y), f = o * (1 - a) / Math.pow(1 - a * Math.sin(y) * Math.sin(y), 1.5), g = x / (c * s);
  var C = y - c * Math.tan(y) / f * (g * g / 2 - (5 + 3 * d + 10 * u - 4 * u * u - 9 * l) * g * g * g * g / 24 + (61 + 90 * d + 298 * u + 45 * d * d - 252 * l - 3 * u * u) * g * g * g * g * g * g / 720);
  C = Wc(C);
  var b = (g - (1 + 2 * d + u) * g * g * g / 6 + (5 - 2 * u + 28 * d - 3 * u * u + 8 * l + 24 * d * d) * g * g * g * g * g / 120) / Math.cos(y);
  b = m + Wc(b);
  var w;
  if (i.accuracy) {
    var E = Jl({
      northing: i.northing + i.accuracy,
      easting: i.easting + i.accuracy,
      zoneLetter: i.zoneLetter,
      zoneNumber: i.zoneNumber
    });
    w = {
      top: E.lat,
      right: E.lon,
      bottom: C,
      left: b
    };
  } else
    w = {
      lat: C,
      lon: b
    };
  return w;
}
function e6(i) {
  var t = "Z";
  return 84 >= i && i >= 72 ? t = "X" : 72 > i && i >= 64 ? t = "W" : 64 > i && i >= 56 ? t = "V" : 56 > i && i >= 48 ? t = "U" : 48 > i && i >= 40 ? t = "T" : 40 > i && i >= 32 ? t = "S" : 32 > i && i >= 24 ? t = "R" : 24 > i && i >= 16 ? t = "Q" : 16 > i && i >= 8 ? t = "P" : 8 > i && i >= 0 ? t = "N" : 0 > i && i >= -8 ? t = "M" : -8 > i && i >= -16 ? t = "L" : -16 > i && i >= -24 ? t = "K" : -24 > i && i >= -32 ? t = "J" : -32 > i && i >= -40 ? t = "H" : -40 > i && i >= -48 ? t = "G" : -48 > i && i >= -56 ? t = "F" : -56 > i && i >= -64 ? t = "E" : -64 > i && i >= -72 ? t = "D" : -72 > i && i >= -80 && (t = "C"), t;
}
function i6(i, t) {
  var e = "00000" + i.easting, n = "00000" + i.northing;
  return i.zoneNumber + i.zoneLetter + n6(i.easting, i.northing, i.zoneNumber) + e.substr(e.length - 5, t) + n.substr(n.length - 5, t);
}
function n6(i, t, e) {
  var n = Xu(e), r = Math.floor(i / 1e5), s = Math.floor(t / 1e5) % 20;
  return r6(r, s, n);
}
function Xu(i) {
  var t = i % $c;
  return t === 0 && (t = $c), t;
}
function r6(i, t, e) {
  var n = e - 1, r = Vu.charCodeAt(n), s = $u.charCodeAt(n), o = r + i - 1, a = s + t, l = !1;
  o > ps && (o = o - ps + fr - 1, l = !0), (o === se || r < se && o > se || (o > se || r < se) && l) && o++, (o === Ee || r < Ee && o > Ee || (o > Ee || r < Ee) && l) && (o++, o === se && o++), o > ps && (o = o - ps + fr - 1), a > ms ? (a = a - ms + fr - 1, l = !0) : l = !1, (a === se || s < se && a > se || (a > se || s < se) && l) && a++, (a === Ee || s < Ee && a > Ee || (a > Ee || s < Ee) && l) && (a++, a === se && a++), a > ms && (a = a - ms + fr - 1);
  var h = String.fromCharCode(o) + String.fromCharCode(a);
  return h;
}
function Zu(i) {
  if (i && i.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var t = i.length, e = null, n = "", r, s = 0; !/[A-Z]/.test(r = i.charAt(s)); ) {
    if (s >= 2)
      throw "MGRSPoint bad conversion from: " + i;
    n += r, s++;
  }
  var o = parseInt(n, 10);
  if (s === 0 || s + 3 > t)
    throw "MGRSPoint bad conversion from: " + i;
  var a = i.charAt(s++);
  if (a <= "A" || a === "B" || a === "Y" || a >= "Z" || a === "I" || a === "O")
    throw "MGRSPoint zone letter " + a + " not handled: " + i;
  e = i.substring(s, s += 2);
  for (var l = Xu(o), h = s6(e.charAt(0), l), c = o6(e.charAt(1), l); c < a6(a); )
    c += 2e6;
  var d = t - s;
  if (d % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + i;
  var u = d / 2, f = 0, g = 0, p, m, _, y, x;
  return u > 0 && (p = 1e5 / Math.pow(10, u), m = i.substring(s, s + u), f = parseFloat(m) * p, _ = i.substring(s + u), g = parseFloat(_) * p), y = f + h, x = g + c, {
    easting: y,
    northing: x,
    zoneLetter: a,
    zoneNumber: o,
    accuracy: p
  };
}
function s6(i, t) {
  for (var e = Vu.charCodeAt(t - 1), n = 1e5, r = !1; e !== i.charCodeAt(0); ) {
    if (e++, e === se && e++, e === Ee && e++, e > ps) {
      if (r)
        throw "Bad character: " + i;
      e = fr, r = !0;
    }
    n += 1e5;
  }
  return n;
}
function o6(i, t) {
  if (i > "V")
    throw "MGRSPoint given invalid Northing " + i;
  for (var e = $u.charCodeAt(t - 1), n = 0, r = !1; e !== i.charCodeAt(0); ) {
    if (e++, e === se && e++, e === Ee && e++, e > ms) {
      if (r)
        throw "Bad character: " + i;
      e = fr, r = !0;
    }
    n += 1e5;
  }
  return n;
}
function a6(i) {
  var t;
  switch (i) {
    case "C":
      t = 11e5;
      break;
    case "D":
      t = 2e6;
      break;
    case "E":
      t = 28e5;
      break;
    case "F":
      t = 37e5;
      break;
    case "G":
      t = 46e5;
      break;
    case "H":
      t = 55e5;
      break;
    case "J":
      t = 64e5;
      break;
    case "K":
      t = 73e5;
      break;
    case "L":
      t = 82e5;
      break;
    case "M":
      t = 91e5;
      break;
    case "N":
      t = 0;
      break;
    case "P":
      t = 8e5;
      break;
    case "Q":
      t = 17e5;
      break;
    case "R":
      t = 26e5;
      break;
    case "S":
      t = 35e5;
      break;
    case "T":
      t = 44e5;
      break;
    case "U":
      t = 53e5;
      break;
    case "V":
      t = 62e5;
      break;
    case "W":
      t = 7e6;
      break;
    case "X":
      t = 79e5;
      break;
    default:
      t = -1;
  }
  if (t >= 0)
    return t;
  throw "Invalid zone letter: " + i;
}
function Nr(i, t, e) {
  if (!(this instanceof Nr))
    return new Nr(i, t, e);
  if (Array.isArray(i))
    this.x = i[0], this.y = i[1], this.z = i[2] || 0;
  else if (typeof i == "object")
    this.x = i.x, this.y = i.y, this.z = i.z || 0;
  else if (typeof i == "string" && typeof t > "u") {
    var n = i.split(",");
    this.x = parseFloat(n[0]), this.y = parseFloat(n[1]), this.z = parseFloat(n[2]) || 0;
  } else
    this.x = i, this.y = t, this.z = e || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Nr.fromMGRS = function(i) {
  return new Nr(Yu(i));
};
Nr.prototype.toMGRS = function(i) {
  return Wu([this.x, this.y], i);
};
var l6 = 1, h6 = 0.25, Yc = 0.046875, Xc = 0.01953125, Zc = 0.01068115234375, c6 = 0.75, d6 = 0.46875, u6 = 0.013020833333333334, f6 = 0.007120768229166667, g6 = 0.3645833333333333, m6 = 0.005696614583333333, p6 = 0.3076171875;
function Ql(i) {
  var t = [];
  t[0] = l6 - i * (h6 + i * (Yc + i * (Xc + i * Zc))), t[1] = i * (c6 - i * (Yc + i * (Xc + i * Zc)));
  var e = i * i;
  return t[2] = e * (d6 - i * (u6 + i * f6)), e *= i, t[3] = e * (g6 - i * m6), t[4] = e * i * p6, t;
}
function Xr(i, t, e, n) {
  return e *= t, t *= t, n[0] * i - e * (n[1] + t * (n[2] + t * (n[3] + t * n[4])));
}
var _6 = 20;
function th(i, t, e) {
  for (var n = 1 / (1 - t), r = i, s = _6; s; --s) {
    var o = Math.sin(r), a = 1 - t * o * o;
    if (a = (Xr(r, o, Math.cos(r), e) - i) * (a * Math.sqrt(a)) * n, r -= a, Math.abs(a) < k)
      return r;
  }
  return r;
}
function y6() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = Ql(this.es), this.ml0 = Xr(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function v6(i) {
  var t = i.x, e = i.y, n = O(t - this.long0, this.over), r, s, o, a = Math.sin(e), l = Math.cos(e);
  if (this.es) {
    var c = l * n, d = Math.pow(c, 2), u = this.ep2 * Math.pow(l, 2), f = Math.pow(u, 2), g = Math.abs(l) > k ? Math.tan(e) : 0, p = Math.pow(g, 2), m = Math.pow(p, 2);
    r = 1 - this.es * Math.pow(a, 2), c = c / Math.sqrt(r);
    var _ = Xr(e, a, l, this.en);
    s = this.a * (this.k0 * c * (1 + d / 6 * (1 - p + u + d / 20 * (5 - 18 * p + m + 14 * u - 58 * p * u + d / 42 * (61 + 179 * m - m * p - 479 * p))))) + this.x0, o = this.a * (this.k0 * (_ - this.ml0 + a * n * c / 2 * (1 + d / 12 * (5 - p + 9 * u + 4 * f + d / 30 * (61 + m - 58 * p + 270 * u - 330 * p * u + d / 56 * (1385 + 543 * m - m * p - 3111 * p)))))) + this.y0;
  } else {
    var h = l * Math.sin(n);
    if (Math.abs(Math.abs(h) - 1) < k)
      return 93;
    if (s = 0.5 * this.a * this.k0 * Math.log((1 + h) / (1 - h)) + this.x0, o = l * Math.cos(n) / Math.sqrt(1 - Math.pow(h, 2)), h = Math.abs(o), h >= 1) {
      if (h - 1 > k)
        return 93;
      o = 0;
    } else
      o = Math.acos(o);
    e < 0 && (o = -o), o = this.a * this.k0 * (o - this.lat0) + this.y0;
  }
  return i.x = s, i.y = o, i;
}
function x6(i) {
  var t, e, n, r, s = (i.x - this.x0) * (1 / this.a), o = (i.y - this.y0) * (1 / this.a);
  if (this.es)
    if (t = this.ml0 + o / this.k0, e = th(t, this.es, this.en), Math.abs(e) < T) {
      var d = Math.sin(e), u = Math.cos(e), f = Math.abs(u) > k ? Math.tan(e) : 0, g = this.ep2 * Math.pow(u, 2), p = Math.pow(g, 2), m = Math.pow(f, 2), _ = Math.pow(m, 2);
      t = 1 - this.es * Math.pow(d, 2);
      var y = s * Math.sqrt(t) / this.k0, x = Math.pow(y, 2);
      t = t * f, n = e - t * x / (1 - this.es) * 0.5 * (1 - x / 12 * (5 + 3 * m - 9 * g * m + g - 4 * p - x / 30 * (61 + 90 * m - 252 * g * m + 45 * _ + 46 * g - x / 56 * (1385 + 3633 * m + 4095 * _ + 1574 * _ * m)))), r = O(this.long0 + y * (1 - x / 6 * (1 + 2 * m + g - x / 20 * (5 + 28 * m + 24 * _ + 8 * g * m + 6 * g - x / 42 * (61 + 662 * m + 1320 * _ + 720 * _ * m)))) / u, this.over);
    } else
      n = T * g0(o), r = 0;
  else {
    var a = Math.exp(s / this.k0), l = 0.5 * (a - 1 / a), h = this.lat0 + o / this.k0, c = Math.cos(h);
    t = Math.sqrt((1 - Math.pow(c, 2)) / (1 + Math.pow(l, 2))), n = Math.asin(t), o < 0 && (n = -n), l === 0 && c === 0 ? r = 0 : r = O(Math.atan2(l, c) + this.long0, this.over);
  }
  return i.x = r, i.y = n, i;
}
var C6 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const J0 = {
  init: y6,
  forward: v6,
  inverse: x6,
  names: C6
};
function Hu(i) {
  var t = Math.exp(i);
  return t = (t - 1 / t) / 2, t;
}
function he(i, t) {
  i = Math.abs(i), t = Math.abs(t);
  var e = Math.max(i, t), n = Math.min(i, t) / (e || 1);
  return e * Math.sqrt(1 + Math.pow(n, 2));
}
function b6(i) {
  var t = 1 + i, e = t - 1;
  return e === 0 ? i : i * Math.log(t) / e;
}
function w6(i) {
  var t = Math.abs(i);
  return t = b6(t * (1 + t / (he(1, t) + 1))), i < 0 ? -t : t;
}
function eh(i, t) {
  for (var e = 2 * Math.cos(2 * t), n = i.length - 1, r = i[n], s = 0, o; --n >= 0; )
    o = -s + e * r + i[n], s = r, r = o;
  return t + o * Math.sin(2 * t);
}
function E6(i, t) {
  for (var e = 2 * Math.cos(t), n = i.length - 1, r = i[n], s = 0, o; --n >= 0; )
    o = -s + e * r + i[n], s = r, r = o;
  return Math.sin(t) * o;
}
function S6(i) {
  var t = Math.exp(i);
  return t = (t + 1 / t) / 2, t;
}
function Ku(i, t, e) {
  for (var n = Math.sin(t), r = Math.cos(t), s = Hu(e), o = S6(e), a = 2 * r * o, l = -2 * n * s, h = i.length - 1, c = i[h], d = 0, u = 0, f = 0, g, p; --h >= 0; )
    g = u, p = d, u = c, d = f, c = -g + a * u - l * d + i[h], f = -p + l * u + a * d;
  return a = n * o, l = r * s, [a * c - l * f, a * f + l * c];
}
function M6() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (J0.init.apply(this), this.forward = J0.forward, this.inverse = J0.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var i = this.es / (1 + Math.sqrt(1 - this.es)), t = i / (2 - i), e = t;
  this.cgb[0] = t * (2 + t * (-2 / 3 + t * (-2 + t * (116 / 45 + t * (26 / 45 + t * (-2854 / 675)))))), this.cbg[0] = t * (-2 + t * (2 / 3 + t * (4 / 3 + t * (-82 / 45 + t * (32 / 45 + t * (4642 / 4725)))))), e = e * t, this.cgb[1] = e * (7 / 3 + t * (-8 / 5 + t * (-227 / 45 + t * (2704 / 315 + t * (2323 / 945))))), this.cbg[1] = e * (5 / 3 + t * (-16 / 15 + t * (-13 / 9 + t * (904 / 315 + t * (-1522 / 945))))), e = e * t, this.cgb[2] = e * (56 / 15 + t * (-136 / 35 + t * (-1262 / 105 + t * (73814 / 2835)))), this.cbg[2] = e * (-26 / 15 + t * (34 / 21 + t * (8 / 5 + t * (-12686 / 2835)))), e = e * t, this.cgb[3] = e * (4279 / 630 + t * (-332 / 35 + t * (-399572 / 14175))), this.cbg[3] = e * (1237 / 630 + t * (-12 / 5 + t * (-24832 / 14175))), e = e * t, this.cgb[4] = e * (4174 / 315 + t * (-144838 / 6237)), this.cbg[4] = e * (-734 / 315 + t * (109598 / 31185)), e = e * t, this.cgb[5] = e * (601676 / 22275), this.cbg[5] = e * (444337 / 155925), e = Math.pow(t, 2), this.Qn = this.k0 / (1 + t) * (1 + e * (1 / 4 + e * (1 / 64 + e / 256))), this.utg[0] = t * (-0.5 + t * (2 / 3 + t * (-37 / 96 + t * (1 / 360 + t * (81 / 512 + t * (-96199 / 604800)))))), this.gtu[0] = t * (0.5 + t * (-2 / 3 + t * (5 / 16 + t * (41 / 180 + t * (-127 / 288 + t * (7891 / 37800)))))), this.utg[1] = e * (-1 / 48 + t * (-1 / 15 + t * (437 / 1440 + t * (-46 / 105 + t * (1118711 / 3870720))))), this.gtu[1] = e * (13 / 48 + t * (-3 / 5 + t * (557 / 1440 + t * (281 / 630 + t * (-1983433 / 1935360))))), e = e * t, this.utg[2] = e * (-17 / 480 + t * (37 / 840 + t * (209 / 4480 + t * (-5569 / 90720)))), this.gtu[2] = e * (61 / 240 + t * (-103 / 140 + t * (15061 / 26880 + t * (167603 / 181440)))), e = e * t, this.utg[3] = e * (-4397 / 161280 + t * (11 / 504 + t * (830251 / 7257600))), this.gtu[3] = e * (49561 / 161280 + t * (-179 / 168 + t * (6601661 / 7257600))), e = e * t, this.utg[4] = e * (-4583 / 161280 + t * (108847 / 3991680)), this.gtu[4] = e * (34729 / 80640 + t * (-3418889 / 1995840)), e = e * t, this.utg[5] = e * (-20648693 / 638668800), this.gtu[5] = e * (212378941 / 319334400);
  var n = eh(this.cbg, this.lat0);
  this.Zb = -this.Qn * (n + E6(this.gtu, 2 * n));
}
function T6(i) {
  var t = O(i.x - this.long0, this.over), e = i.y;
  e = eh(this.cbg, e);
  var n = Math.sin(e), r = Math.cos(e), s = Math.sin(t), o = Math.cos(t);
  e = Math.atan2(n, o * r), t = Math.atan2(s * r, he(n, r * o)), t = w6(Math.tan(t));
  var a = Ku(this.gtu, 2 * e, 2 * t);
  e = e + a[0], t = t + a[1];
  var l, h;
  return Math.abs(t) <= 2.623395162778 ? (l = this.a * (this.Qn * t) + this.x0, h = this.a * (this.Qn * e + this.Zb) + this.y0) : (l = 1 / 0, h = 1 / 0), i.x = l, i.y = h, i;
}
function R6(i) {
  var t = (i.x - this.x0) * (1 / this.a), e = (i.y - this.y0) * (1 / this.a);
  e = (e - this.Zb) / this.Qn, t = t / this.Qn;
  var n, r;
  if (Math.abs(t) <= 2.623395162778) {
    var s = Ku(this.utg, 2 * e, 2 * t);
    e = e + s[0], t = t + s[1], t = Math.atan(Hu(t));
    var o = Math.sin(e), a = Math.cos(e), l = Math.sin(t), h = Math.cos(t);
    e = Math.atan2(o * h, he(l, h * a)), t = Math.atan2(l, h * a), n = O(t + this.long0, this.over), r = eh(this.cgb, e);
  } else
    n = 1 / 0, r = 1 / 0;
  return i.x = n, i.y = r, i;
}
var P6 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
const Q0 = {
  init: M6,
  forward: T6,
  inverse: R6,
  names: P6
};
function I6(i, t) {
  if (i === void 0) {
    if (i = Math.floor((O(t) + Math.PI) * 30 / Math.PI) + 1, i < 0)
      return 0;
    if (i > 60)
      return 60;
  }
  return i;
}
var k6 = "etmerc";
function L6() {
  var i = I6(this.zone, this.long0);
  if (i === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(i) - 183) * Ct, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, Q0.init.apply(this), this.forward = Q0.forward, this.inverse = Q0.inverse;
}
var A6 = ["Universal Transverse Mercator System", "utm"];
const F6 = {
  init: L6,
  names: A6,
  dependsOn: k6
};
function ih(i, t) {
  return Math.pow((1 - i) / (1 + i), t);
}
var O6 = 20;
function G6() {
  var i = Math.sin(this.lat0), t = Math.cos(this.lat0);
  t *= t, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * i * i), this.C = Math.sqrt(1 + this.es * t * t / (1 - this.es)), this.phic0 = Math.asin(i / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + lt) / (Math.pow(Math.tan(0.5 * this.lat0 + lt), this.C) * ih(this.e * i, this.ratexp));
}
function N6(i) {
  var t = i.x, e = i.y;
  return i.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * e + lt), this.C) * ih(this.e * Math.sin(e), this.ratexp)) - T, i.x = this.C * t, i;
}
function D6(i) {
  for (var t = 1e-14, e = i.x / this.C, n = i.y, r = Math.pow(Math.tan(0.5 * n + lt) / this.K, 1 / this.C), s = O6; s > 0 && (n = 2 * Math.atan(r * ih(this.e * Math.sin(i.y), -0.5 * this.e)) - T, !(Math.abs(n - i.y) < t)); --s)
    i.y = n;
  return s ? (i.x = e, i.y = n, i) : null;
}
const nh = {
  init: G6,
  forward: N6,
  inverse: D6
};
function z6() {
  nh.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function j6(i) {
  var t, e, n, r;
  return i.x = O(i.x - this.long0, this.over), nh.forward.apply(this, [i]), t = Math.sin(i.y), e = Math.cos(i.y), n = Math.cos(i.x), r = this.k0 * this.R2 / (1 + this.sinc0 * t + this.cosc0 * e * n), i.x = r * e * Math.sin(i.x), i.y = r * (this.cosc0 * t - this.sinc0 * e * n), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
}
function U6(i) {
  var t, e, n, r, s;
  if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, s = he(i.x, i.y)) {
    var o = 2 * Math.atan2(s, this.R2);
    t = Math.sin(o), e = Math.cos(o), r = Math.asin(e * this.sinc0 + i.y * t * this.cosc0 / s), n = Math.atan2(i.x * t, s * this.cosc0 * e - i.y * this.sinc0 * t);
  } else
    r = this.phic0, n = 0;
  return i.x = n, i.y = r, nh.inverse.apply(this, [i]), i.x = O(i.x + this.long0, this.over), i;
}
var B6 = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const V6 = {
  init: z6,
  forward: j6,
  inverse: U6,
  names: B6
};
function rh(i, t, e) {
  return t *= e, Math.tan(0.5 * (T + i)) * Math.pow((1 - t) / (1 + t), 0.5 * e);
}
function $6() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= k && (this.k0 = 0.5 * (1 + g0(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= k && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= k && Math.abs(Math.cos(this.lat_ts)) > k && (this.k0 = 0.5 * this.cons * ai(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / $e(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = ai(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(rh(this.lat0, this.sinlat0, this.e)) - T, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function W6(i) {
  var t = i.x, e = i.y, n = Math.sin(e), r = Math.cos(e), s, o, a, l, h, c, d = O(t - this.long0, this.over);
  return Math.abs(Math.abs(t - this.long0) - Math.PI) <= k && Math.abs(e + this.lat0) <= k ? (i.x = NaN, i.y = NaN, i) : this.sphere ? (s = 2 * this.k0 / (1 + this.sinlat0 * n + this.coslat0 * r * Math.cos(d)), i.x = this.a * s * r * Math.sin(d) + this.x0, i.y = this.a * s * (this.coslat0 * n - this.sinlat0 * r * Math.cos(d)) + this.y0, i) : (o = 2 * Math.atan(rh(e, n, this.e)) - T, l = Math.cos(o), a = Math.sin(o), Math.abs(this.coslat0) <= k ? (h = $e(this.e, e * this.con, this.con * n), c = 2 * this.a * this.k0 * h / this.cons, i.x = this.x0 + c * Math.sin(t - this.long0), i.y = this.y0 - this.con * c * Math.cos(t - this.long0), i) : (Math.abs(this.sinlat0) < k ? (s = 2 * this.a * this.k0 / (1 + l * Math.cos(d)), i.y = s * a) : (s = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * a + this.cosX0 * l * Math.cos(d))), i.y = s * (this.cosX0 * a - this.sinX0 * l * Math.cos(d)) + this.y0), i.x = s * l * Math.sin(d) + this.x0, i));
}
function Y6(i) {
  i.x -= this.x0, i.y -= this.y0;
  var t, e, n, r, s, o = Math.sqrt(i.x * i.x + i.y * i.y);
  if (this.sphere) {
    var a = 2 * Math.atan(o / (2 * this.a * this.k0));
    return t = this.long0, e = this.lat0, o <= k ? (i.x = t, i.y = e, i) : (e = Math.asin(Math.cos(a) * this.sinlat0 + i.y * Math.sin(a) * this.coslat0 / o), Math.abs(this.coslat0) < k ? this.lat0 > 0 ? t = O(this.long0 + Math.atan2(i.x, -1 * i.y), this.over) : t = O(this.long0 + Math.atan2(i.x, i.y), this.over) : t = O(this.long0 + Math.atan2(i.x * Math.sin(a), o * this.coslat0 * Math.cos(a) - i.y * this.sinlat0 * Math.sin(a)), this.over), i.x = t, i.y = e, i);
  } else if (Math.abs(this.coslat0) <= k) {
    if (o <= k)
      return e = this.lat0, t = this.long0, i.x = t, i.y = e, i;
    i.x *= this.con, i.y *= this.con, n = o * this.cons / (2 * this.a * this.k0), e = this.con * Ks(this.e, n), t = this.con * O(this.con * this.long0 + Math.atan2(i.x, -1 * i.y), this.over);
  } else
    r = 2 * Math.atan(o * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), t = this.long0, o <= k ? s = this.X0 : (s = Math.asin(Math.cos(r) * this.sinX0 + i.y * Math.sin(r) * this.cosX0 / o), t = O(this.long0 + Math.atan2(i.x * Math.sin(r), o * this.cosX0 * Math.cos(r) - i.y * this.sinX0 * Math.sin(r)), this.over)), e = -1 * Ks(this.e, Math.tan(0.5 * (T + s)));
  return i.x = t, i.y = e, i;
}
var X6 = ["stere", "Stereographic_South_Pole", "Polar_Stereographic_variant_A", "Polar_Stereographic_variant_B", "Polar_Stereographic"];
const Z6 = {
  init: $6,
  forward: W6,
  inverse: Y6,
  names: X6,
  ssfn_: rh
};
function H6() {
  var i = this.lat0;
  this.lambda0 = this.long0;
  var t = Math.sin(i), e = this.a, n = this.rf, r = 1 / n, s = 2 * r - Math.pow(r, 2), o = this.e = Math.sqrt(s);
  this.R = this.k0 * e * Math.sqrt(1 - s) / (1 - s * Math.pow(t, 2)), this.alpha = Math.sqrt(1 + s / (1 - s) * Math.pow(Math.cos(i), 4)), this.b0 = Math.asin(t / this.alpha);
  var a = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), l = Math.log(Math.tan(Math.PI / 4 + i / 2)), h = Math.log((1 + o * t) / (1 - o * t));
  this.K = a - this.alpha * l + this.alpha * o / 2 * h;
}
function K6(i) {
  var t = Math.log(Math.tan(Math.PI / 4 - i.y / 2)), e = this.e / 2 * Math.log((1 + this.e * Math.sin(i.y)) / (1 - this.e * Math.sin(i.y))), n = -this.alpha * (t + e) + this.K, r = 2 * (Math.atan(Math.exp(n)) - Math.PI / 4), s = this.alpha * (i.x - this.lambda0), o = Math.atan(Math.sin(s) / (Math.sin(this.b0) * Math.tan(r) + Math.cos(this.b0) * Math.cos(s))), a = Math.asin(Math.cos(this.b0) * Math.sin(r) - Math.sin(this.b0) * Math.cos(r) * Math.cos(s));
  return i.y = this.R / 2 * Math.log((1 + Math.sin(a)) / (1 - Math.sin(a))) + this.y0, i.x = this.R * o + this.x0, i;
}
function q6(i) {
  for (var t = i.x - this.x0, e = i.y - this.y0, n = t / this.R, r = 2 * (Math.atan(Math.exp(e / this.R)) - Math.PI / 4), s = Math.asin(Math.cos(this.b0) * Math.sin(r) + Math.sin(this.b0) * Math.cos(r) * Math.cos(n)), o = Math.atan(Math.sin(n) / (Math.cos(this.b0) * Math.cos(n) - Math.sin(this.b0) * Math.tan(r))), a = this.lambda0 + o / this.alpha, l = 0, h = s, c = -1e3, d = 0; Math.abs(h - c) > 1e-7; ) {
    if (++d > 20)
      return;
    l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + s / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(h)) / 2)), c = h, h = 2 * Math.atan(Math.exp(l)) - Math.PI / 2;
  }
  return i.x = a, i.y = h, i;
}
var J6 = ["somerc"];
const Q6 = {
  init: H6,
  forward: K6,
  inverse: q6,
  names: J6
};
var or = 1e-7;
function t7(i) {
  var t = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], e = typeof i.projName == "object" ? Object.keys(i.projName)[0] : i.projName;
  return "no_uoff" in i || "no_off" in i || t.indexOf(e) !== -1 || t.indexOf(Du(e)) !== -1;
}
function e7() {
  var i, t, e, n, r, s, o, a, l, h, c = 0, d, u = 0, f = 0, g = 0, p = 0, m = 0, _ = 0;
  this.no_off = t7(this), this.no_rot = "no_rot" in this;
  var y = !1;
  "alpha" in this && (y = !0);
  var x = !1;
  if ("rectified_grid_angle" in this && (x = !0), y && (_ = this.alpha), x && (c = this.rectified_grid_angle), y || x)
    u = this.longc;
  else if (f = this.long1, p = this.lat1, g = this.long2, m = this.lat2, Math.abs(p - m) <= or || (i = Math.abs(p)) <= or || Math.abs(i - T) <= or || Math.abs(Math.abs(this.lat0) - T) <= or || Math.abs(Math.abs(m) - T) <= or)
    throw new Error();
  var v = 1 - this.es;
  t = Math.sqrt(v), Math.abs(this.lat0) > k ? (a = Math.sin(this.lat0), e = Math.cos(this.lat0), i = 1 - this.es * a * a, this.B = e * e, this.B = Math.sqrt(1 + this.es * this.B * this.B / v), this.A = this.B * this.k0 * t / i, n = this.B * t / (e * Math.sqrt(i)), r = n * n - 1, r <= 0 ? r = 0 : (r = Math.sqrt(r), this.lat0 < 0 && (r = -r)), this.E = r += n, this.E *= Math.pow($e(this.e, this.lat0, a), this.B)) : (this.B = 1 / t, this.A = this.k0, this.E = n = r = 1), y || x ? (y ? (d = Math.asin(Math.sin(_) / n), x || (c = _)) : (d = c, _ = Math.asin(n * Math.sin(d))), this.lam0 = u - Math.asin(0.5 * (r - 1 / r) * Math.tan(d)) / this.B) : (s = Math.pow($e(this.e, p, Math.sin(p)), this.B), o = Math.pow($e(this.e, m, Math.sin(m)), this.B), r = this.E / s, l = (o - s) / (o + s), h = this.E * this.E, h = (h - o * s) / (h + o * s), i = f - g, i < -Math.PI ? g -= Zs : i > Math.PI && (g += Zs), this.lam0 = O(0.5 * (f + g) - Math.atan(h * Math.tan(0.5 * this.B * (f - g)) / l) / this.B, this.over), d = Math.atan(2 * Math.sin(this.B * O(f - this.lam0, this.over)) / (r - 1 / r)), c = _ = Math.asin(n * Math.sin(d))), this.singam = Math.sin(d), this.cosgam = Math.cos(d), this.sinrot = Math.sin(c), this.cosrot = Math.cos(c), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(n * n - 1) / Math.cos(_))), this.lat0 < 0 && (this.u_0 = -this.u_0)), r = 0.5 * d, this.v_pole_n = this.ArB * Math.log(Math.tan(lt - r)), this.v_pole_s = this.ArB * Math.log(Math.tan(lt + r));
}
function i7(i) {
  var t = {}, e, n, r, s, o, a, l, h;
  if (i.x = i.x - this.lam0, Math.abs(Math.abs(i.y) - T) > k) {
    if (o = this.E / Math.pow($e(this.e, i.y, Math.sin(i.y)), this.B), a = 1 / o, e = 0.5 * (o - a), n = 0.5 * (o + a), s = Math.sin(this.B * i.x), r = (e * this.singam - s * this.cosgam) / n, Math.abs(Math.abs(r) - 1) < k)
      throw new Error();
    h = 0.5 * this.ArB * Math.log((1 - r) / (1 + r)), a = Math.cos(this.B * i.x), Math.abs(a) < or ? l = this.A * i.x : l = this.ArB * Math.atan2(e * this.cosgam + s * this.singam, a);
  } else
    h = i.y > 0 ? this.v_pole_n : this.v_pole_s, l = this.ArB * i.y;
  return this.no_rot ? (t.x = l, t.y = h) : (l -= this.u_0, t.x = h * this.cosrot + l * this.sinrot, t.y = l * this.cosrot - h * this.sinrot), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
}
function n7(i) {
  var t, e, n, r, s, o, a, l = {};
  if (i.x = (i.x - this.x0) * (1 / this.a), i.y = (i.y - this.y0) * (1 / this.a), this.no_rot ? (e = i.y, t = i.x) : (e = i.x * this.cosrot - i.y * this.sinrot, t = i.y * this.cosrot + i.x * this.sinrot + this.u_0), n = Math.exp(-this.BrA * e), r = 0.5 * (n - 1 / n), s = 0.5 * (n + 1 / n), o = Math.sin(this.BrA * t), a = (o * this.cosgam + r * this.singam) / s, Math.abs(Math.abs(a) - 1) < k)
    l.x = 0, l.y = a < 0 ? -T : T;
  else {
    if (l.y = this.E / Math.sqrt((1 + a) / (1 - a)), l.y = Ks(this.e, Math.pow(l.y, 1 / this.B)), l.y === 1 / 0)
      throw new Error();
    l.x = -this.rB * Math.atan2(r * this.cosgam - o * this.singam, Math.cos(this.BrA * t));
  }
  return l.x += this.lam0, l;
}
var r7 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Variant_B", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const s7 = {
  init: e7,
  forward: i7,
  inverse: n7,
  names: r7
};
function o7() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < k)) {
    var i = this.b / this.a;
    this.e = Math.sqrt(1 - i * i);
    var t = Math.sin(this.lat1), e = Math.cos(this.lat1), n = ai(this.e, t, e), r = $e(this.e, this.lat1, t), s = Math.sin(this.lat2), o = Math.cos(this.lat2), a = ai(this.e, s, o), l = $e(this.e, this.lat2, s), h = Math.abs(Math.abs(this.lat0) - T) < k ? 0 : $e(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > k ? this.ns = Math.log(n / a) / Math.log(r / l) : this.ns = t, isNaN(this.ns) && (this.ns = t), this.f0 = n / (this.ns * Math.pow(r, this.ns)), this.rh = this.a * this.f0 * Math.pow(h, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function a7(i) {
  var t = i.x, e = i.y;
  Math.abs(2 * Math.abs(e) - Math.PI) <= k && (e = g0(e) * (T - 2 * k));
  var n = Math.abs(Math.abs(e) - T), r, s;
  if (n > k)
    r = $e(this.e, e, Math.sin(e)), s = this.a * this.f0 * Math.pow(r, this.ns);
  else {
    if (n = e * this.ns, n <= 0)
      return null;
    s = 0;
  }
  var o = this.ns * O(t - this.long0, this.over);
  return i.x = this.k0 * (s * Math.sin(o)) + this.x0, i.y = this.k0 * (this.rh - s * Math.cos(o)) + this.y0, i;
}
function l7(i) {
  var t, e, n, r, s, o = (i.x - this.x0) / this.k0, a = this.rh - (i.y - this.y0) / this.k0;
  this.ns > 0 ? (t = Math.sqrt(o * o + a * a), e = 1) : (t = -Math.sqrt(o * o + a * a), e = -1);
  var l = 0;
  if (t !== 0 && (l = Math.atan2(e * o, e * a)), t !== 0 || this.ns > 0) {
    if (e = 1 / this.ns, n = Math.pow(t / (this.a * this.f0), e), r = Ks(this.e, n), r === -9999)
      return null;
  } else
    r = -T;
  return s = O(l / this.ns + this.long0, this.over), i.x = s, i.y = r, i;
}
var h7 = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const c7 = {
  init: o7,
  forward: a7,
  inverse: l7,
  names: h7
};
function d7() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function u7(i) {
  var t, e, n, r, s, o, a, l = i.x, h = i.y, c = O(l - this.long0, this.over);
  return t = Math.pow((1 + this.e * Math.sin(h)) / (1 - this.e * Math.sin(h)), this.alfa * this.e / 2), e = 2 * (Math.atan(this.k * Math.pow(Math.tan(h / 2 + this.s45), this.alfa) / t) - this.s45), n = -c * this.alfa, r = Math.asin(Math.cos(this.ad) * Math.sin(e) + Math.sin(this.ad) * Math.cos(e) * Math.cos(n)), s = Math.asin(Math.cos(e) * Math.sin(n) / Math.cos(r)), o = this.n * s, a = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(r / 2 + this.s45), this.n), i.y = a * Math.cos(o) / 1, i.x = a * Math.sin(o) / 1, this.czech || (i.y *= -1, i.x *= -1), i;
}
function f7(i) {
  var t, e, n, r, s, o, a, l, h = i.x;
  i.x = i.y, i.y = h, this.czech || (i.y *= -1, i.x *= -1), o = Math.sqrt(i.x * i.x + i.y * i.y), s = Math.atan2(i.y, i.x), r = s / Math.sin(this.s0), n = 2 * (Math.atan(Math.pow(this.ro0 / o, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), t = Math.asin(Math.cos(this.ad) * Math.sin(n) - Math.sin(this.ad) * Math.cos(n) * Math.cos(r)), e = Math.asin(Math.cos(n) * Math.sin(r) / Math.cos(t)), i.x = this.long0 - e / this.alfa, a = t, l = 0;
  var c = 0;
  do
    i.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(t / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(a)) / (1 - this.e * Math.sin(a)), this.e / 2)) - this.s45), Math.abs(a - i.y) < 1e-10 && (l = 1), a = i.y, c += 1;
  while (l === 0 && c < 15);
  return c >= 15 ? null : i;
}
var g7 = ["Krovak", "krovak"];
const m7 = {
  init: d7,
  forward: u7,
  inverse: f7,
  names: g7
};
function ee(i, t, e, n, r) {
  return i * r - t * Math.sin(2 * r) + e * Math.sin(4 * r) - n * Math.sin(6 * r);
}
function m0(i) {
  return 1 - 0.25 * i * (1 + i / 16 * (3 + 1.25 * i));
}
function p0(i) {
  return 0.375 * i * (1 + 0.25 * i * (1 + 0.46875 * i));
}
function _0(i) {
  return 0.05859375 * i * i * (1 + 0.75 * i);
}
function y0(i) {
  return i * i * i * (35 / 3072);
}
function sh(i, t, e) {
  var n = t * e;
  return i / Math.sqrt(1 - n * n);
}
function rn(i) {
  return Math.abs(i) < T ? i : i - g0(i) * Math.PI;
}
function ko(i, t, e, n, r) {
  var s, o;
  s = i / t;
  for (var a = 0; a < 15; a++)
    if (o = (i - (t * s - e * Math.sin(2 * s) + n * Math.sin(4 * s) - r * Math.sin(6 * s))) / (t - 2 * e * Math.cos(2 * s) + 4 * n * Math.cos(4 * s) - 6 * r * Math.cos(6 * s)), s += o, Math.abs(o) <= 1e-10)
      return s;
  return NaN;
}
function p7() {
  this.sphere || (this.e0 = m0(this.es), this.e1 = p0(this.es), this.e2 = _0(this.es), this.e3 = y0(this.es), this.ml0 = this.a * ee(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function _7(i) {
  var t, e, n = i.x, r = i.y;
  if (n = O(n - this.long0, this.over), this.sphere)
    t = this.a * Math.asin(Math.cos(r) * Math.sin(n)), e = this.a * (Math.atan2(Math.tan(r), Math.cos(n)) - this.lat0);
  else {
    var s = Math.sin(r), o = Math.cos(r), a = sh(this.a, this.e, s), l = Math.tan(r) * Math.tan(r), h = n * Math.cos(r), c = h * h, d = this.es * o * o / (1 - this.es), u = this.a * ee(this.e0, this.e1, this.e2, this.e3, r);
    t = a * h * (1 - c * l * (1 / 6 - (8 - l + 8 * d) * c / 120)), e = u - this.ml0 + a * s / o * c * (0.5 + (5 - l + 6 * d) * c / 24);
  }
  return i.x = t + this.x0, i.y = e + this.y0, i;
}
function y7(i) {
  i.x -= this.x0, i.y -= this.y0;
  var t = i.x / this.a, e = i.y / this.a, n, r;
  if (this.sphere) {
    var s = e + this.lat0;
    n = Math.asin(Math.sin(s) * Math.cos(t)), r = Math.atan2(Math.tan(t), Math.cos(s));
  } else {
    var o = this.ml0 / this.a + e, a = ko(o, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(a) - T) <= k)
      return i.x = this.long0, i.y = T, e < 0 && (i.y *= -1), i;
    var l = sh(this.a, this.e, Math.sin(a)), h = l * l * l / this.a / this.a * (1 - this.es), c = Math.pow(Math.tan(a), 2), d = t * this.a / l, u = d * d;
    n = a - l * Math.tan(a) / h * d * d * (0.5 - (1 + 3 * c) * d * d / 24), r = d * (1 - u * (c / 3 + (1 + 3 * c) * c * u / 15)) / Math.cos(a);
  }
  return i.x = O(r + this.long0, this.over), i.y = rn(n), i;
}
var v7 = ["Cassini", "Cassini_Soldner", "cass"];
const x7 = {
  init: p7,
  forward: _7,
  inverse: y7,
  names: v7
};
function Xi(i, t) {
  var e;
  return i > 1e-7 ? (e = i * t, (1 - i * i) * (t / (1 - e * e) - 0.5 / i * Math.log((1 - e) / (1 + e)))) : 2 * t;
}
var ja = 1, Ua = 2, Ba = 3, to = 4;
function C7() {
  var i = Math.abs(this.lat0);
  if (Math.abs(i - T) < k ? this.mode = this.lat0 < 0 ? ja : Ua : Math.abs(i) < k ? this.mode = Ba : this.mode = to, this.es > 0) {
    var t;
    switch (this.qp = Xi(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = I7(this.es), this.mode) {
      case Ua:
        this.dd = 1;
        break;
      case ja:
        this.dd = 1;
        break;
      case Ba:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case to:
        this.rq = Math.sqrt(0.5 * this.qp), t = Math.sin(this.lat0), this.sinb1 = Xi(this.e, t) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * t * t) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === to && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function b7(i) {
  var t, e, n, r, s, o, a, l, h, c, d = i.x, u = i.y;
  if (d = O(d - this.long0, this.over), this.sphere) {
    if (s = Math.sin(u), c = Math.cos(u), n = Math.cos(d), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (e = this.mode === this.EQUIT ? 1 + c * n : 1 + this.sinph0 * s + this.cosph0 * c * n, e <= k)
        return null;
      e = Math.sqrt(2 / e), t = e * c * Math.sin(d), e *= this.mode === this.EQUIT ? s : this.cosph0 * s - this.sinph0 * c * n;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (n = -n), Math.abs(u + this.lat0) < k)
        return null;
      e = lt - u * 0.5, e = 2 * (this.mode === this.S_POLE ? Math.cos(e) : Math.sin(e)), t = e * Math.sin(d), e *= n;
    }
  } else {
    switch (a = 0, l = 0, h = 0, n = Math.cos(d), r = Math.sin(d), s = Math.sin(u), o = Xi(this.e, s), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (a = o / this.qp, l = Math.sqrt(1 - a * a)), this.mode) {
      case this.OBLIQ:
        h = 1 + this.sinb1 * a + this.cosb1 * l * n;
        break;
      case this.EQUIT:
        h = 1 + l * n;
        break;
      case this.N_POLE:
        h = T + u, o = this.qp - o;
        break;
      case this.S_POLE:
        h = u - T, o = this.qp + o;
        break;
    }
    if (Math.abs(h) < k)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        h = Math.sqrt(2 / h), this.mode === this.OBLIQ ? e = this.ymf * h * (this.cosb1 * a - this.sinb1 * l * n) : e = (h = Math.sqrt(2 / (1 + l * n))) * a * this.ymf, t = this.xmf * h * l * r;
        break;
      case this.N_POLE:
      case this.S_POLE:
        o >= 0 ? (t = (h = Math.sqrt(o)) * r, e = n * (this.mode === this.S_POLE ? h : -h)) : t = e = 0;
        break;
    }
  }
  return i.x = this.a * t + this.x0, i.y = this.a * e + this.y0, i;
}
function w7(i) {
  i.x -= this.x0, i.y -= this.y0;
  var t = i.x / this.a, e = i.y / this.a, n, r, s, o, a, l, h;
  if (this.sphere) {
    var c = 0, d, u = 0;
    if (d = Math.sqrt(t * t + e * e), r = d * 0.5, r > 1)
      return null;
    switch (r = 2 * Math.asin(r), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (u = Math.sin(r), c = Math.cos(r)), this.mode) {
      case this.EQUIT:
        r = Math.abs(d) <= k ? 0 : Math.asin(e * u / d), t *= u, e = c * d;
        break;
      case this.OBLIQ:
        r = Math.abs(d) <= k ? this.lat0 : Math.asin(c * this.sinph0 + e * u * this.cosph0 / d), t *= u * this.cosph0, e = (c - Math.sin(r) * this.sinph0) * d;
        break;
      case this.N_POLE:
        e = -e, r = T - r;
        break;
      case this.S_POLE:
        r -= T;
        break;
    }
    n = e === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(t, e);
  } else {
    if (h = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (t /= this.dd, e *= this.dd, l = Math.sqrt(t * t + e * e), l < k)
        return i.x = this.long0, i.y = this.lat0, i;
      o = 2 * Math.asin(0.5 * l / this.rq), s = Math.cos(o), t *= o = Math.sin(o), this.mode === this.OBLIQ ? (h = s * this.sinb1 + e * o * this.cosb1 / l, a = this.qp * h, e = l * this.cosb1 * s - e * this.sinb1 * o) : (h = e * o / l, a = this.qp * h, e = l * s);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (e = -e), a = t * t + e * e, !a)
        return i.x = this.long0, i.y = this.lat0, i;
      h = 1 - a / this.qp, this.mode === this.S_POLE && (h = -h);
    }
    n = Math.atan2(t, e), r = k7(Math.asin(h), this.apa);
  }
  return i.x = O(this.long0 + n, this.over), i.y = r, i;
}
var E7 = 0.3333333333333333, S7 = 0.17222222222222222, M7 = 0.10257936507936508, T7 = 0.06388888888888888, R7 = 0.0664021164021164, P7 = 0.016415012942191543;
function I7(i) {
  var t, e = [];
  return e[0] = i * E7, t = i * i, e[0] += t * S7, e[1] = t * T7, t *= i, e[0] += t * M7, e[1] += t * R7, e[2] = t * P7, e;
}
function k7(i, t) {
  var e = i + i;
  return i + t[0] * Math.sin(e) + t[1] * Math.sin(e + e) + t[2] * Math.sin(e + e + e);
}
var L7 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const A7 = {
  init: C7,
  forward: b7,
  inverse: w7,
  names: L7,
  S_POLE: ja,
  N_POLE: Ua,
  EQUIT: Ba,
  OBLIQ: to
};
function Ji(i) {
  return Math.abs(i) > 1 && (i = i > 1 ? 1 : -1), Math.asin(i);
}
function F7() {
  Math.abs(this.lat1 + this.lat2) < k || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = ai(this.e3, this.sin_po, this.cos_po), this.qs1 = Xi(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = ai(this.e3, this.sin_po, this.cos_po), this.qs2 = Xi(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Xi(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > k ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function O7(i) {
  var t = i.x, e = i.y;
  this.sin_phi = Math.sin(e), this.cos_phi = Math.cos(e);
  var n = Xi(this.e3, this.sin_phi), r = this.a * Math.sqrt(this.c - this.ns0 * n) / this.ns0, s = this.ns0 * O(t - this.long0, this.over), o = r * Math.sin(s) + this.x0, a = this.rh - r * Math.cos(s) + this.y0;
  return i.x = o, i.y = a, i;
}
function G7(i) {
  var t, e, n, r, s, o;
  return i.x -= this.x0, i.y = this.rh - i.y + this.y0, this.ns0 >= 0 ? (t = Math.sqrt(i.x * i.x + i.y * i.y), n = 1) : (t = -Math.sqrt(i.x * i.x + i.y * i.y), n = -1), r = 0, t !== 0 && (r = Math.atan2(n * i.x, n * i.y)), n = t * this.ns0 / this.a, this.sphere ? o = Math.asin((this.c - n * n) / (2 * this.ns0)) : (e = (this.c - n * n) / this.ns0, o = this.phi1z(this.e3, e)), s = O(r / this.ns0 + this.long0, this.over), i.x = s, i.y = o, i;
}
function N7(i, t) {
  var e, n, r, s, o, a = Ji(0.5 * t);
  if (i < k)
    return a;
  for (var l = i * i, h = 1; h <= 25; h++)
    if (e = Math.sin(a), n = Math.cos(a), r = i * e, s = 1 - r * r, o = 0.5 * s * s / n * (t / (1 - l) - e / s + 0.5 / i * Math.log((1 - r) / (1 + r))), a = a + o, Math.abs(o) <= 1e-7)
      return a;
  return null;
}
var D7 = ["Albers_Conic_Equal_Area", "Albers_Equal_Area", "Albers", "aea"];
const z7 = {
  init: F7,
  forward: O7,
  inverse: G7,
  names: D7,
  phi1z: N7
};
function j7() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function U7(i) {
  var t, e, n, r, s, o, a, l, h = i.x, c = i.y;
  return n = O(h - this.long0, this.over), t = Math.sin(c), e = Math.cos(c), r = Math.cos(n), o = this.sin_p14 * t + this.cos_p14 * e * r, s = 1, o > 0 || Math.abs(o) <= k ? (a = this.x0 + this.a * s * e * Math.sin(n) / o, l = this.y0 + this.a * s * (this.cos_p14 * t - this.sin_p14 * e * r) / o) : (a = this.x0 + this.infinity_dist * e * Math.sin(n), l = this.y0 + this.infinity_dist * (this.cos_p14 * t - this.sin_p14 * e * r)), i.x = a, i.y = l, i;
}
function B7(i) {
  var t, e, n, r, s, o;
  return i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, (t = Math.sqrt(i.x * i.x + i.y * i.y)) ? (r = Math.atan2(t, this.rc), e = Math.sin(r), n = Math.cos(r), o = Ji(n * this.sin_p14 + i.y * e * this.cos_p14 / t), s = Math.atan2(i.x * e, t * this.cos_p14 * n - i.y * this.sin_p14 * e), s = O(this.long0 + s, this.over)) : (o = this.phic0, s = 0), i.x = s, i.y = o, i;
}
var V7 = ["gnom"];
const $7 = {
  init: j7,
  forward: U7,
  inverse: B7,
  names: V7
};
function W7(i, t) {
  var e = 1 - (1 - i * i) / (2 * i) * Math.log((1 - i) / (1 + i));
  if (Math.abs(Math.abs(t) - e) < 1e-6)
    return t < 0 ? -1 * T : T;
  for (var n = Math.asin(0.5 * t), r, s, o, a, l = 0; l < 30; l++)
    if (s = Math.sin(n), o = Math.cos(n), a = i * s, r = Math.pow(1 - a * a, 2) / (2 * o) * (t / (1 - i * i) - s / (1 - a * a) + 0.5 / i * Math.log((1 - a) / (1 + a))), n += r, Math.abs(r) <= 1e-10)
      return n;
  return NaN;
}
function Y7() {
  this.sphere || (this.k0 = ai(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function X7(i) {
  var t = i.x, e = i.y, n, r, s = O(t - this.long0, this.over);
  if (this.sphere)
    n = this.x0 + this.a * s * Math.cos(this.lat_ts), r = this.y0 + this.a * Math.sin(e) / Math.cos(this.lat_ts);
  else {
    var o = Xi(this.e, Math.sin(e));
    n = this.x0 + this.a * this.k0 * s, r = this.y0 + this.a * o * 0.5 / this.k0;
  }
  return i.x = n, i.y = r, i;
}
function Z7(i) {
  i.x -= this.x0, i.y -= this.y0;
  var t, e;
  return this.sphere ? (t = O(this.long0 + i.x / this.a / Math.cos(this.lat_ts), this.over), e = Math.asin(i.y / this.a * Math.cos(this.lat_ts))) : (e = W7(this.e, 2 * i.y * this.k0 / this.a), t = O(this.long0 + i.x / (this.a * this.k0), this.over)), i.x = t, i.y = e, i;
}
var H7 = ["cea"];
const K7 = {
  init: Y7,
  forward: X7,
  inverse: Z7,
  names: H7
};
function q7() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function J7(i) {
  var t = i.x, e = i.y, n = O(t - this.long0, this.over), r = rn(e - this.lat0);
  return i.x = this.x0 + this.a * n * this.rc, i.y = this.y0 + this.a * r, i;
}
function Q7(i) {
  var t = i.x, e = i.y;
  return i.x = O(this.long0 + (t - this.x0) / (this.a * this.rc), this.over), i.y = rn(this.lat0 + (e - this.y0) / this.a), i;
}
var t_ = ["Equirectangular", "Equidistant_Cylindrical", "Equidistant_Cylindrical_Spherical", "eqc"];
const e_ = {
  init: q7,
  forward: J7,
  inverse: Q7,
  names: t_
};
var Hc = 20;
function i_() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = m0(this.es), this.e1 = p0(this.es), this.e2 = _0(this.es), this.e3 = y0(this.es), this.ml0 = this.a * ee(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function n_(i) {
  var t = i.x, e = i.y, n, r, s, o = O(t - this.long0, this.over);
  if (s = o * Math.sin(e), this.sphere)
    Math.abs(e) <= k ? (n = this.a * o, r = -1 * this.a * this.lat0) : (n = this.a * Math.sin(s) / Math.tan(e), r = this.a * (rn(e - this.lat0) + (1 - Math.cos(s)) / Math.tan(e)));
  else if (Math.abs(e) <= k)
    n = this.a * o, r = -1 * this.ml0;
  else {
    var a = sh(this.a, this.e, Math.sin(e)) / Math.tan(e);
    n = a * Math.sin(s), r = this.a * ee(this.e0, this.e1, this.e2, this.e3, e) - this.ml0 + a * (1 - Math.cos(s));
  }
  return i.x = n + this.x0, i.y = r + this.y0, i;
}
function r_(i) {
  var t, e, n, r, s, o, a, l, h;
  if (n = i.x - this.x0, r = i.y - this.y0, this.sphere)
    if (Math.abs(r + this.a * this.lat0) <= k)
      t = O(n / this.a + this.long0, this.over), e = 0;
    else {
      o = this.lat0 + r / this.a, a = n * n / this.a / this.a + o * o, l = o;
      var c;
      for (s = Hc; s; --s)
        if (c = Math.tan(l), h = -1 * (o * (l * c + 1) - l - 0.5 * (l * l + a) * c) / ((l - o) / c - 1), l += h, Math.abs(h) <= k) {
          e = l;
          break;
        }
      t = O(this.long0 + Math.asin(n * Math.tan(l) / this.a) / Math.sin(e), this.over);
    }
  else if (Math.abs(r + this.ml0) <= k)
    e = 0, t = O(this.long0 + n / this.a, this.over);
  else {
    o = (this.ml0 + r) / this.a, a = n * n / this.a / this.a + o * o, l = o;
    var d, u, f, g, p;
    for (s = Hc; s; --s)
      if (p = this.e * Math.sin(l), d = Math.sqrt(1 - p * p) * Math.tan(l), u = this.a * ee(this.e0, this.e1, this.e2, this.e3, l), f = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), g = u / this.a, h = (o * (d * g + 1) - g - 0.5 * d * (g * g + a)) / (this.es * Math.sin(2 * l) * (g * g + a - 2 * o * g) / (4 * d) + (o - g) * (d * f - 2 / Math.sin(2 * l)) - f), l -= h, Math.abs(h) <= k) {
        e = l;
        break;
      }
    d = Math.sqrt(1 - this.es * Math.pow(Math.sin(e), 2)) * Math.tan(e), t = O(this.long0 + Math.asin(n * d / this.a) / Math.sin(e), this.over);
  }
  return i.x = t, i.y = e, i;
}
var s_ = ["Polyconic", "American_Polyconic", "poly"];
const o_ = {
  init: i_,
  forward: n_,
  inverse: r_,
  names: s_
};
function a_() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function l_(i) {
  var t, e = i.x, n = i.y, r = n - this.lat0, s = e - this.long0, o = r / Rs * 1e-5, a = s, l = 1, h = 0;
  for (t = 1; t <= 10; t++)
    l = l * o, h = h + this.A[t] * l;
  var c = h, d = a, u = 1, f = 0, g, p, m = 0, _ = 0;
  for (t = 1; t <= 6; t++)
    g = u * c - f * d, p = f * c + u * d, u = g, f = p, m = m + this.B_re[t] * u - this.B_im[t] * f, _ = _ + this.B_im[t] * u + this.B_re[t] * f;
  return i.x = _ * this.a + this.x0, i.y = m * this.a + this.y0, i;
}
function h_(i) {
  var t, e = i.x, n = i.y, r = e - this.x0, s = n - this.y0, o = s / this.a, a = r / this.a, l = 1, h = 0, c, d, u = 0, f = 0;
  for (t = 1; t <= 6; t++)
    c = l * o - h * a, d = h * o + l * a, l = c, h = d, u = u + this.C_re[t] * l - this.C_im[t] * h, f = f + this.C_im[t] * l + this.C_re[t] * h;
  for (var g = 0; g < this.iterations; g++) {
    var p = u, m = f, _, y, x = o, v = a;
    for (t = 2; t <= 6; t++)
      _ = p * u - m * f, y = m * u + p * f, p = _, m = y, x = x + (t - 1) * (this.B_re[t] * p - this.B_im[t] * m), v = v + (t - 1) * (this.B_im[t] * p + this.B_re[t] * m);
    p = 1, m = 0;
    var C = this.B_re[1], b = this.B_im[1];
    for (t = 2; t <= 6; t++)
      _ = p * u - m * f, y = m * u + p * f, p = _, m = y, C = C + t * (this.B_re[t] * p - this.B_im[t] * m), b = b + t * (this.B_im[t] * p + this.B_re[t] * m);
    var w = C * C + b * b;
    u = (x * C + v * b) / w, f = (v * C - x * b) / w;
  }
  var E = u, S = f, R = 1, I = 0;
  for (t = 1; t <= 9; t++)
    R = R * E, I = I + this.D[t] * R;
  var L = this.lat0 + I * Rs * 1e5, A = this.long0 + S;
  return i.x = A, i.y = L, i;
}
var c_ = ["New_Zealand_Map_Grid", "nzmg"];
const d_ = {
  init: a_,
  forward: l_,
  inverse: h_,
  names: c_
};
function u_() {
}
function f_(i) {
  var t = i.x, e = i.y, n = O(t - this.long0, this.over), r = this.x0 + this.a * n, s = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + e / 2.5)) * 1.25;
  return i.x = r, i.y = s, i;
}
function g_(i) {
  i.x -= this.x0, i.y -= this.y0;
  var t = O(this.long0 + i.x / this.a, this.over), e = 2.5 * (Math.atan(Math.exp(0.8 * i.y / this.a)) - Math.PI / 4);
  return i.x = t, i.y = e, i;
}
var m_ = ["Miller_Cylindrical", "mill"];
const p_ = {
  init: u_,
  forward: f_,
  inverse: g_,
  names: m_
};
var __ = 20;
function y_() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = Ql(this.es);
}
function v_(i) {
  var t, e, n = i.x, r = i.y;
  if (n = O(n - this.long0, this.over), this.sphere) {
    if (!this.m)
      r = this.n !== 1 ? Math.asin(this.n * Math.sin(r)) : r;
    else
      for (var s = this.n * Math.sin(r), o = __; o; --o) {
        var a = (this.m * r + Math.sin(r) - s) / (this.m + Math.cos(r));
        if (r -= a, Math.abs(a) < k)
          break;
      }
    t = this.a * this.C_x * n * (this.m + Math.cos(r)), e = this.a * this.C_y * r;
  } else {
    var l = Math.sin(r), h = Math.cos(r);
    e = this.a * Xr(r, l, h, this.en), t = this.a * n * h / Math.sqrt(1 - this.es * l * l);
  }
  return i.x = t, i.y = e, i;
}
function x_(i) {
  var t, e, n, r;
  return i.x -= this.x0, n = i.x / this.a, i.y -= this.y0, t = i.y / this.a, this.sphere ? (t /= this.C_y, n = n / (this.C_x * (this.m + Math.cos(t))), this.m ? t = Ji((this.m * t + Math.sin(t)) / this.n) : this.n !== 1 && (t = Ji(Math.sin(t) / this.n)), n = O(n + this.long0, this.over), t = rn(t)) : (t = th(i.y / this.a, this.es, this.en), r = Math.abs(t), r < T ? (r = Math.sin(t), e = this.long0 + i.x * Math.sqrt(1 - this.es * r * r) / (this.a * Math.cos(t)), n = O(e, this.over)) : r - k < T && (n = this.long0)), i.x = n, i.y = t, i;
}
var C_ = ["Sinusoidal", "sinu"];
const b_ = {
  init: y_,
  forward: v_,
  inverse: x_,
  names: C_
};
function w_() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0;
}
function E_(i) {
  for (var t = i.x, e = i.y, n = O(t - this.long0, this.over), r = e, s = Math.PI * Math.sin(e); ; ) {
    var o = -(r + Math.sin(r) - s) / (1 + Math.cos(r));
    if (r += o, Math.abs(o) < k)
      break;
  }
  r /= 2, Math.PI / 2 - Math.abs(e) < k && (n = 0);
  var a = 0.900316316158 * this.a * n * Math.cos(r) + this.x0, l = 1.4142135623731 * this.a * Math.sin(r) + this.y0;
  return i.x = a, i.y = l, i;
}
function S_(i) {
  var t, e;
  i.x -= this.x0, i.y -= this.y0, e = i.y / (1.4142135623731 * this.a), Math.abs(e) > 0.999999999999 && (e = 0.999999999999), t = Math.asin(e);
  var n = O(this.long0 + i.x / (0.900316316158 * this.a * Math.cos(t)), this.over);
  n < -Math.PI && (n = -Math.PI), n > Math.PI && (n = Math.PI), e = (2 * t + Math.sin(2 * t)) / Math.PI, Math.abs(e) > 1 && (e = 1);
  var r = Math.asin(e);
  return i.x = n, i.y = r, i;
}
var M_ = ["Mollweide", "moll"];
const T_ = {
  init: w_,
  forward: E_,
  inverse: S_,
  names: M_
};
function R_() {
  Math.abs(this.lat1 + this.lat2) < k || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = m0(this.es), this.e1 = p0(this.es), this.e2 = _0(this.es), this.e3 = y0(this.es), this.sin_phi = Math.sin(this.lat1), this.cos_phi = Math.cos(this.lat1), this.ms1 = ai(this.e, this.sin_phi, this.cos_phi), this.ml1 = ee(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < k ? this.ns = this.sin_phi : (this.sin_phi = Math.sin(this.lat2), this.cos_phi = Math.cos(this.lat2), this.ms2 = ai(this.e, this.sin_phi, this.cos_phi), this.ml2 = ee(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = ee(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function P_(i) {
  var t = i.x, e = i.y, n;
  if (this.sphere)
    n = this.a * (this.g - e);
  else {
    var r = ee(this.e0, this.e1, this.e2, this.e3, e);
    n = this.a * (this.g - r);
  }
  var s = this.ns * O(t - this.long0, this.over), o = this.x0 + n * Math.sin(s), a = this.y0 + this.rh - n * Math.cos(s);
  return i.x = o, i.y = a, i;
}
function I_(i) {
  i.x -= this.x0, i.y = this.rh - i.y + this.y0;
  var t, e, n, r;
  this.ns >= 0 ? (e = Math.sqrt(i.x * i.x + i.y * i.y), t = 1) : (e = -Math.sqrt(i.x * i.x + i.y * i.y), t = -1);
  var s = 0;
  if (e !== 0 && (s = Math.atan2(t * i.x, t * i.y)), this.sphere)
    return r = O(this.long0 + s / this.ns, this.over), n = rn(this.g - e / this.a), i.x = r, i.y = n, i;
  var o = this.g - e / this.a;
  return n = ko(o, this.e0, this.e1, this.e2, this.e3), r = O(this.long0 + s / this.ns, this.over), i.x = r, i.y = n, i;
}
var k_ = ["Equidistant_Conic", "eqdc"];
const L_ = {
  init: R_,
  forward: P_,
  inverse: I_,
  names: k_
};
function A_() {
  this.R = this.a;
}
function F_(i) {
  var t = i.x, e = i.y, n = O(t - this.long0, this.over), r, s;
  Math.abs(e) <= k && (r = this.x0 + this.R * n, s = this.y0);
  var o = Ji(2 * Math.abs(e / Math.PI));
  (Math.abs(n) <= k || Math.abs(Math.abs(e) - T) <= k) && (r = this.x0, e >= 0 ? s = this.y0 + Math.PI * this.R * Math.tan(0.5 * o) : s = this.y0 + Math.PI * this.R * -Math.tan(0.5 * o));
  var a = 0.5 * Math.abs(Math.PI / n - n / Math.PI), l = a * a, h = Math.sin(o), c = Math.cos(o), d = c / (h + c - 1), u = d * d, f = d * (2 / h - 1), g = f * f, p = Math.PI * this.R * (a * (d - g) + Math.sqrt(l * (d - g) * (d - g) - (g + l) * (u - g))) / (g + l);
  n < 0 && (p = -p), r = this.x0 + p;
  var m = l + d;
  return p = Math.PI * this.R * (f * m - a * Math.sqrt((g + l) * (l + 1) - m * m)) / (g + l), e >= 0 ? s = this.y0 + p : s = this.y0 - p, i.x = r, i.y = s, i;
}
function O_(i) {
  var t, e, n, r, s, o, a, l, h, c, d, u, f;
  return i.x -= this.x0, i.y -= this.y0, d = Math.PI * this.R, n = i.x / d, r = i.y / d, s = n * n + r * r, o = -Math.abs(r) * (1 + s), a = o - 2 * r * r + n * n, l = -2 * o + 1 + 2 * r * r + s * s, f = r * r / l + (2 * a * a * a / l / l / l - 9 * o * a / l / l) / 27, h = (o - a * a / 3 / l) / l, c = 2 * Math.sqrt(-h / 3), d = 3 * f / h / c, Math.abs(d) > 1 && (d >= 0 ? d = 1 : d = -1), u = Math.acos(d) / 3, i.y >= 0 ? e = (-c * Math.cos(u + Math.PI / 3) - a / 3 / l) * Math.PI : e = -(-c * Math.cos(u + Math.PI / 3) - a / 3 / l) * Math.PI, Math.abs(n) < k ? t = this.long0 : t = O(this.long0 + Math.PI * (s - 1 + Math.sqrt(1 + 2 * (n * n - r * r) + s * s)) / 2 / n, this.over), i.x = t, i.y = e, i;
}
var G_ = ["Van_der_Grinten_I", "VanDerGrinten", "Van_der_Grinten", "vandg"];
const N_ = {
  init: A_,
  forward: F_,
  inverse: O_,
  names: G_
};
function D_(i, t, e, n, r, s) {
  const o = n - t, a = Math.atan((1 - s) * Math.tan(i)), l = Math.atan((1 - s) * Math.tan(e)), h = Math.sin(a), c = Math.cos(a), d = Math.sin(l), u = Math.cos(l);
  let f = o, g, p = 100, m, _, y, x, v, C, b, w, E, S, R, I, L, A;
  do {
    if (m = Math.sin(f), _ = Math.cos(f), y = Math.sqrt(
      u * m * (u * m) + (c * d - h * u * _) * (c * d - h * u * _)
    ), y === 0)
      return { azi1: 0, s12: 0 };
    x = h * d + c * u * _, v = Math.atan2(y, x), C = c * u * m / y, b = 1 - C * C, w = b !== 0 ? x - 2 * h * d / b : 0, E = s / 16 * b * (4 + s * (4 - 3 * b)), g = f, f = o + (1 - E) * s * C * (v + E * y * (w + E * x * (-1 + 2 * w * w)));
  } while (Math.abs(f - g) > 1e-12 && --p > 0);
  return p === 0 ? { azi1: NaN, s12: NaN } : (S = b * (r * r - r * (1 - s) * (r * (1 - s))) / (r * (1 - s) * (r * (1 - s))), R = 1 + S / 16384 * (4096 + S * (-768 + S * (320 - 175 * S))), I = S / 1024 * (256 + S * (-128 + S * (74 - 47 * S))), L = I * y * (w + I / 4 * (x * (-1 + 2 * w * w) - I / 6 * w * (-3 + 4 * y * y) * (-3 + 4 * w * w))), A = r * (1 - s) * R * (v - L), { azi1: Math.atan2(u * m, c * d - h * u * _), s12: A });
}
function z_(i, t, e, n, r, s) {
  const o = Math.atan((1 - s) * Math.tan(i)), a = Math.sin(o), l = Math.cos(o), h = Math.sin(e), c = Math.cos(e), d = Math.atan2(a, l * c), u = l * h, f = 1 - u * u, g = f * (r * r - r * (1 - s) * (r * (1 - s))) / (r * (1 - s) * (r * (1 - s))), p = 1 + g / 16384 * (4096 + g * (-768 + g * (320 - 175 * g))), m = g / 1024 * (256 + g * (-128 + g * (74 - 47 * g)));
  let _ = n / (r * (1 - s) * p), y, x = 100, v, C, b, w;
  do
    v = Math.cos(2 * d + _), C = Math.sin(_), b = Math.cos(_), w = m * C * (v + m / 4 * (b * (-1 + 2 * v * v) - m / 6 * v * (-3 + 4 * C * C) * (-3 + 4 * v * v))), y = _, _ = n / (r * (1 - s) * p) + w;
  while (Math.abs(_ - y) > 1e-12 && --x > 0);
  if (x === 0)
    return { lat2: NaN, lon2: NaN };
  const E = a * C - l * b * c, S = Math.atan2(
    a * b + l * C * c,
    (1 - s) * Math.sqrt(u * u + E * E)
  ), R = Math.atan2(
    C * h,
    l * b - a * C * c
  ), I = s / 16 * f * (4 + s * (4 - 3 * f)), L = R - (1 - I) * s * u * (_ + I * C * (v + I * b * (-1 + 2 * v * v))), A = t + L;
  return { lat2: S, lon2: A };
}
function j_() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0), this.f = this.es / (1 + Math.sqrt(1 - this.es));
}
function U_(i) {
  var t = i.x, e = i.y, n = Math.sin(i.y), r = Math.cos(i.y), s = O(t - this.long0, this.over), o, a, l, h, c, d, u, f, g, p, m;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= k ? (i.x = this.x0 + this.a * (T - e) * Math.sin(s), i.y = this.y0 - this.a * (T - e) * Math.cos(s), i) : Math.abs(this.sin_p12 + 1) <= k ? (i.x = this.x0 + this.a * (T + e) * Math.sin(s), i.y = this.y0 + this.a * (T + e) * Math.cos(s), i) : (g = this.sin_p12 * n + this.cos_p12 * r * Math.cos(s), u = Math.acos(g), f = u ? u / Math.sin(u) : 1, i.x = this.x0 + this.a * f * r * Math.sin(s), i.y = this.y0 + this.a * f * (this.cos_p12 * n - this.sin_p12 * r * Math.cos(s)), i) : (o = m0(this.es), a = p0(this.es), l = _0(this.es), h = y0(this.es), Math.abs(this.sin_p12 - 1) <= k ? (c = this.a * ee(o, a, l, h, T), d = this.a * ee(o, a, l, h, e), i.x = this.x0 + (c - d) * Math.sin(s), i.y = this.y0 - (c - d) * Math.cos(s), i) : Math.abs(this.sin_p12 + 1) <= k ? (c = this.a * ee(o, a, l, h, T), d = this.a * ee(o, a, l, h, e), i.x = this.x0 + (c + d) * Math.sin(s), i.y = this.y0 + (c + d) * Math.cos(s), i) : Math.abs(t) < k && Math.abs(e - this.lat0) < k ? (i.x = i.y = 0, i) : (p = D_(this.lat0, this.long0, e, t, this.a, this.f), m = p.azi1, i.x = p.s12 * Math.sin(m), i.y = p.s12 * Math.cos(m), i));
}
function B_(i) {
  i.x -= this.x0, i.y -= this.y0;
  var t, e, n, r, s, o, a, l, h, c, d, u, f, g, p, m;
  return this.sphere ? (t = Math.sqrt(i.x * i.x + i.y * i.y), t > 2 * T * this.a ? void 0 : (e = t / this.a, n = Math.sin(e), r = Math.cos(e), s = this.long0, Math.abs(t) <= k ? o = this.lat0 : (o = Ji(r * this.sin_p12 + i.y * n * this.cos_p12 / t), a = Math.abs(this.lat0) - T, Math.abs(a) <= k ? this.lat0 >= 0 ? s = O(this.long0 + Math.atan2(i.x, -i.y), this.over) : s = O(this.long0 - Math.atan2(-i.x, i.y), this.over) : s = O(this.long0 + Math.atan2(i.x * n, t * this.cos_p12 * r - i.y * this.sin_p12 * n), this.over)), i.x = s, i.y = o, i)) : (l = m0(this.es), h = p0(this.es), c = _0(this.es), d = y0(this.es), Math.abs(this.sin_p12 - 1) <= k ? (u = this.a * ee(l, h, c, d, T), t = Math.sqrt(i.x * i.x + i.y * i.y), f = u - t, o = ko(f / this.a, l, h, c, d), s = O(this.long0 + Math.atan2(i.x, -1 * i.y), this.over), i.x = s, i.y = o, i) : Math.abs(this.sin_p12 + 1) <= k ? (u = this.a * ee(l, h, c, d, T), t = Math.sqrt(i.x * i.x + i.y * i.y), f = t - u, o = ko(f / this.a, l, h, c, d), s = O(this.long0 + Math.atan2(i.x, i.y), this.over), i.x = s, i.y = o, i) : (g = Math.atan2(i.x, i.y), p = Math.sqrt(i.x * i.x + i.y * i.y), m = z_(this.lat0, this.long0, g, p, this.a, this.f), i.x = m.lon2, i.y = m.lat2, i));
}
var V_ = ["Azimuthal_Equidistant", "aeqd"];
const $_ = {
  init: j_,
  forward: U_,
  inverse: B_,
  names: V_
};
function W_() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function Y_(i) {
  var t, e, n, r, s, o, a, l, h = i.x, c = i.y;
  return n = O(h - this.long0, this.over), t = Math.sin(c), e = Math.cos(c), r = Math.cos(n), o = this.sin_p14 * t + this.cos_p14 * e * r, s = 1, (o > 0 || Math.abs(o) <= k) && (a = this.a * s * e * Math.sin(n), l = this.y0 + this.a * s * (this.cos_p14 * t - this.sin_p14 * e * r)), i.x = a, i.y = l, i;
}
function X_(i) {
  var t, e, n, r, s, o, a;
  return i.x -= this.x0, i.y -= this.y0, t = Math.sqrt(i.x * i.x + i.y * i.y), e = Ji(t / this.a), n = Math.sin(e), r = Math.cos(e), o = this.long0, Math.abs(t) <= k ? (a = this.lat0, i.x = o, i.y = a, i) : (a = Ji(r * this.sin_p14 + i.y * n * this.cos_p14 / t), s = Math.abs(this.lat0) - T, Math.abs(s) <= k ? (this.lat0 >= 0 ? o = O(this.long0 + Math.atan2(i.x, -i.y), this.over) : o = O(this.long0 - Math.atan2(-i.x, i.y), this.over), i.x = o, i.y = a, i) : (o = O(this.long0 + Math.atan2(i.x * n, t * this.cos_p14 * r - i.y * this.sin_p14 * n), this.over), i.x = o, i.y = a, i));
}
var Z_ = ["ortho"];
const H_ = {
  init: W_,
  forward: Y_,
  inverse: X_,
  names: Z_
};
var yt = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, ht = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function K_() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= T - lt / 2 ? this.face = yt.TOP : this.lat0 <= -(T - lt / 2) ? this.face = yt.BOTTOM : Math.abs(this.long0) <= lt ? this.face = yt.FRONT : Math.abs(this.long0) <= T + lt ? this.face = this.long0 > 0 ? yt.RIGHT : yt.LEFT : this.face = yt.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function q_(i) {
  var t = { x: 0, y: 0 }, e, n, r, s, o, a, l = { value: 0 };
  if (i.x -= this.long0, this.es !== 0 ? e = Math.atan(this.one_minus_f_squared * Math.tan(i.y)) : e = i.y, n = i.x, this.face === yt.TOP)
    s = T - e, n >= lt && n <= T + lt ? (l.value = ht.AREA_0, r = n - T) : n > T + lt || n <= -(T + lt) ? (l.value = ht.AREA_1, r = n > 0 ? n - St : n + St) : n > -(T + lt) && n <= -lt ? (l.value = ht.AREA_2, r = n + T) : (l.value = ht.AREA_3, r = n);
  else if (this.face === yt.BOTTOM)
    s = T + e, n >= lt && n <= T + lt ? (l.value = ht.AREA_0, r = -n + T) : n < lt && n >= -lt ? (l.value = ht.AREA_1, r = -n) : n < -lt && n >= -(T + lt) ? (l.value = ht.AREA_2, r = -n - T) : (l.value = ht.AREA_3, r = n > 0 ? -n + St : -n - St);
  else {
    var h, c, d, u, f, g, p;
    this.face === yt.RIGHT ? n = wr(n, +T) : this.face === yt.BACK ? n = wr(n, +St) : this.face === yt.LEFT && (n = wr(n, -T)), u = Math.sin(e), f = Math.cos(e), g = Math.sin(n), p = Math.cos(n), h = f * p, c = f * g, d = u, this.face === yt.FRONT ? (s = Math.acos(h), r = V0(s, d, c, l)) : this.face === yt.RIGHT ? (s = Math.acos(c), r = V0(s, d, -h, l)) : this.face === yt.BACK ? (s = Math.acos(-h), r = V0(s, d, -c, l)) : this.face === yt.LEFT ? (s = Math.acos(-c), r = V0(s, d, h, l)) : (s = r = 0, l.value = ht.AREA_0);
  }
  return a = Math.atan(12 / St * (r + Math.acos(Math.sin(r) * Math.cos(lt)) - T)), o = Math.sqrt((1 - Math.cos(s)) / (Math.cos(a) * Math.cos(a)) / (1 - Math.cos(Math.atan(1 / Math.cos(r))))), l.value === ht.AREA_1 ? a += T : l.value === ht.AREA_2 ? a += St : l.value === ht.AREA_3 && (a += 1.5 * St), t.x = o * Math.cos(a), t.y = o * Math.sin(a), t.x = t.x * this.a + this.x0, t.y = t.y * this.a + this.y0, i.x = t.x, i.y = t.y, i;
}
function J_(i) {
  var t = { lam: 0, phi: 0 }, e, n, r, s, o, a, l, h, c, d = { value: 0 };
  if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, n = Math.atan(Math.sqrt(i.x * i.x + i.y * i.y)), e = Math.atan2(i.y, i.x), i.x >= 0 && i.x >= Math.abs(i.y) ? d.value = ht.AREA_0 : i.y >= 0 && i.y >= Math.abs(i.x) ? (d.value = ht.AREA_1, e -= T) : i.x < 0 && -i.x >= Math.abs(i.y) ? (d.value = ht.AREA_2, e = e < 0 ? e + St : e - St) : (d.value = ht.AREA_3, e += T), c = St / 12 * Math.tan(e), o = Math.sin(c) / (Math.cos(c) - 1 / Math.sqrt(2)), a = Math.atan(o), r = Math.cos(e), s = Math.tan(n), l = 1 - r * r * s * s * (1 - Math.cos(Math.atan(1 / Math.cos(a)))), l < -1 ? l = -1 : l > 1 && (l = 1), this.face === yt.TOP)
    h = Math.acos(l), t.phi = T - h, d.value === ht.AREA_0 ? t.lam = a + T : d.value === ht.AREA_1 ? t.lam = a < 0 ? a + St : a - St : d.value === ht.AREA_2 ? t.lam = a - T : t.lam = a;
  else if (this.face === yt.BOTTOM)
    h = Math.acos(l), t.phi = h - T, d.value === ht.AREA_0 ? t.lam = -a + T : d.value === ht.AREA_1 ? t.lam = -a : d.value === ht.AREA_2 ? t.lam = -a - T : t.lam = a < 0 ? -a - St : -a + St;
  else {
    var u, f, g;
    u = l, c = u * u, c >= 1 ? g = 0 : g = Math.sqrt(1 - c) * Math.sin(a), c += g * g, c >= 1 ? f = 0 : f = Math.sqrt(1 - c), d.value === ht.AREA_1 ? (c = f, f = -g, g = c) : d.value === ht.AREA_2 ? (f = -f, g = -g) : d.value === ht.AREA_3 && (c = f, f = g, g = -c), this.face === yt.RIGHT ? (c = u, u = -f, f = c) : this.face === yt.BACK ? (u = -u, f = -f) : this.face === yt.LEFT && (c = u, u = f, f = -c), t.phi = Math.acos(-g) - T, t.lam = Math.atan2(f, u), this.face === yt.RIGHT ? t.lam = wr(t.lam, -T) : this.face === yt.BACK ? t.lam = wr(t.lam, -St) : this.face === yt.LEFT && (t.lam = wr(t.lam, +T));
  }
  if (this.es !== 0) {
    var p, m, _;
    p = t.phi < 0 ? 1 : 0, m = Math.tan(t.phi), _ = this.b / Math.sqrt(m * m + this.one_minus_f_squared), t.phi = Math.atan(Math.sqrt(this.a * this.a - _ * _) / (this.one_minus_f * _)), p && (t.phi = -t.phi);
  }
  return t.lam += this.long0, i.x = t.lam, i.y = t.phi, i;
}
function V0(i, t, e, n) {
  var r;
  return i < k ? (n.value = ht.AREA_0, r = 0) : (r = Math.atan2(t, e), Math.abs(r) <= lt ? n.value = ht.AREA_0 : r > lt && r <= T + lt ? (n.value = ht.AREA_1, r -= T) : r > T + lt || r <= -(T + lt) ? (n.value = ht.AREA_2, r = r >= 0 ? r - St : r + St) : (n.value = ht.AREA_3, r += T)), r;
}
function wr(i, t) {
  var e = i + t;
  return e < -St ? e += Zs : e > +St && (e -= Zs), e;
}
var Q_ = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const ty = {
  init: K_,
  forward: q_,
  inverse: J_,
  names: Q_
};
var Va = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], _s = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], qu = 0.8487, Ju = 1.3523, Qu = ce / 5, ey = 1 / Qu, gr = 18, Lo = function(i, t) {
  return i[0] + t * (i[1] + t * (i[2] + t * i[3]));
}, iy = function(i, t) {
  return i[1] + t * (2 * i[2] + t * 3 * i[3]);
};
function ny(i, t, e, n) {
  for (var r = t; n; --n) {
    var s = i(r);
    if (r -= s, Math.abs(s) < e)
      break;
  }
  return r;
}
function ry() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function sy(i) {
  var t = O(i.x - this.long0, this.over), e = Math.abs(i.y), n = Math.floor(e * Qu);
  n < 0 ? n = 0 : n >= gr && (n = gr - 1), e = ce * (e - ey * n);
  var r = {
    x: Lo(Va[n], e) * t,
    y: Lo(_s[n], e)
  };
  return i.y < 0 && (r.y = -r.y), r.x = r.x * this.a * qu + this.x0, r.y = r.y * this.a * Ju + this.y0, r;
}
function oy(i) {
  var t = {
    x: (i.x - this.x0) / (this.a * qu),
    y: Math.abs(i.y - this.y0) / (this.a * Ju)
  };
  if (t.y >= 1)
    t.x /= Va[gr][0], t.y = i.y < 0 ? -T : T;
  else {
    var e = Math.floor(t.y * gr);
    for (e < 0 ? e = 0 : e >= gr && (e = gr - 1); ; )
      if (_s[e][0] > t.y)
        --e;
      else if (_s[e + 1][0] <= t.y)
        ++e;
      else
        break;
    var n = _s[e], r = 5 * (t.y - n[0]) / (_s[e + 1][0] - n[0]);
    r = ny(function(s) {
      return (Lo(n, s) - t.y) / iy(n, s);
    }, r, k, 100), t.x /= Lo(Va[e], r), t.y = (5 * e + r) * Ct, i.y < 0 && (t.y = -t.y);
  }
  return t.x = O(t.x + this.long0, this.over), t;
}
var ay = ["Robinson", "robin"];
const ly = {
  init: ry,
  forward: sy,
  inverse: oy,
  names: ay
};
function hy() {
  this.name = "geocent";
}
function cy(i) {
  var t = ju(i, this.es, this.a);
  return t;
}
function dy(i) {
  var t = Uu(i, this.es, this.a, this.b);
  return t;
}
var uy = ["Geocentric", "geocentric", "geocent", "Geocent"];
const fy = {
  init: hy,
  forward: cy,
  inverse: dy,
  names: uy
};
var Wt = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, ss = {
  h: { def: 1e5, num: !0 },
  // default is Karman line, no default in PROJ.7
  azi: { def: 0, num: !0, degrees: !0 },
  // default is North
  tilt: { def: 0, num: !0, degrees: !0 },
  // default is Nadir
  long0: { def: 0, num: !0 },
  // default is Greenwich, conversion to rad is automatic
  lat0: { def: 0, num: !0 }
  // default is Equator, conversion to rad is automatic
};
function gy() {
  if (Object.keys(ss).forEach((function(e) {
    if (typeof this[e] > "u")
      this[e] = ss[e].def;
    else {
      if (ss[e].num && isNaN(this[e]))
        throw new Error("Invalid parameter value, must be numeric " + e + " = " + this[e]);
      ss[e].num && (this[e] = parseFloat(this[e]));
    }
    ss[e].degrees && (this[e] = this[e] * Ct);
  }).bind(this)), Math.abs(Math.abs(this.lat0) - T) < k ? this.mode = this.lat0 < 0 ? Wt.S_POLE : Wt.N_POLE : Math.abs(this.lat0) < k ? this.mode = Wt.EQUIT : (this.mode = Wt.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var i = this.tilt, t = this.azi;
  this.cg = Math.cos(t), this.sg = Math.sin(t), this.cw = Math.cos(i), this.sw = Math.sin(i);
}
function my(i) {
  i.x -= this.long0;
  var t = Math.sin(i.y), e = Math.cos(i.y), n = Math.cos(i.x), r, s;
  switch (this.mode) {
    case Wt.OBLIQ:
      s = this.sinph0 * t + this.cosph0 * e * n;
      break;
    case Wt.EQUIT:
      s = e * n;
      break;
    case Wt.S_POLE:
      s = -t;
      break;
    case Wt.N_POLE:
      s = t;
      break;
  }
  switch (s = this.pn1 / (this.p - s), r = s * e * Math.sin(i.x), this.mode) {
    case Wt.OBLIQ:
      s *= this.cosph0 * t - this.sinph0 * e * n;
      break;
    case Wt.EQUIT:
      s *= t;
      break;
    case Wt.N_POLE:
      s *= -(e * n);
      break;
    case Wt.S_POLE:
      s *= e * n;
      break;
  }
  var o, a;
  return o = s * this.cg + r * this.sg, a = 1 / (o * this.sw * this.h1 + this.cw), r = (r * this.cg - s * this.sg) * this.cw * a, s = o * a, i.x = r * this.a, i.y = s * this.a, i;
}
function py(i) {
  i.x /= this.a, i.y /= this.a;
  var t = { x: i.x, y: i.y }, e, n, r;
  r = 1 / (this.pn1 - i.y * this.sw), e = this.pn1 * i.x * r, n = this.pn1 * i.y * this.cw * r, i.x = e * this.cg + n * this.sg, i.y = n * this.cg - e * this.sg;
  var s = he(i.x, i.y);
  if (Math.abs(s) < k)
    t.x = 0, t.y = i.y;
  else {
    var o, a;
    switch (a = 1 - s * s * this.pfact, a = (this.p - Math.sqrt(a)) / (this.pn1 / s + s / this.pn1), o = Math.sqrt(1 - a * a), this.mode) {
      case Wt.OBLIQ:
        t.y = Math.asin(o * this.sinph0 + i.y * a * this.cosph0 / s), i.y = (o - this.sinph0 * Math.sin(t.y)) * s, i.x *= a * this.cosph0;
        break;
      case Wt.EQUIT:
        t.y = Math.asin(i.y * a / s), i.y = o * s, i.x *= a;
        break;
      case Wt.N_POLE:
        t.y = Math.asin(o), i.y = -i.y;
        break;
      case Wt.S_POLE:
        t.y = -Math.asin(o);
        break;
    }
    t.x = Math.atan2(i.x, i.y);
  }
  return i.x = t.x + this.long0, i.y = t.y, i;
}
var _y = ["Tilted_Perspective", "tpers"];
const yy = {
  init: gy,
  forward: my,
  inverse: py,
  names: _y
};
function vy() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var i = 1 - this.es, t = 1 / i;
    this.radius_p = Math.sqrt(i), this.radius_p2 = i, this.radius_p_inv2 = t, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function xy(i) {
  var t = i.x, e = i.y, n, r, s, o;
  if (t = t - this.long0, this.shape === "ellipse") {
    e = Math.atan(this.radius_p2 * Math.tan(e));
    var a = this.radius_p / he(this.radius_p * Math.cos(e), Math.sin(e));
    if (r = a * Math.cos(t) * Math.cos(e), s = a * Math.sin(t) * Math.cos(e), o = a * Math.sin(e), (this.radius_g - r) * r - s * s - o * o * this.radius_p_inv2 < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    n = this.radius_g - r, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(s / he(o, n)), i.y = this.radius_g_1 * Math.atan(o / n)) : (i.x = this.radius_g_1 * Math.atan(s / n), i.y = this.radius_g_1 * Math.atan(o / he(s, n)));
  } else this.shape === "sphere" && (n = Math.cos(e), r = Math.cos(t) * n, s = Math.sin(t) * n, o = Math.sin(e), n = this.radius_g - r, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(s / he(o, n)), i.y = this.radius_g_1 * Math.atan(o / n)) : (i.x = this.radius_g_1 * Math.atan(s / n), i.y = this.radius_g_1 * Math.atan(o / he(s, n))));
  return i.x = i.x * this.a, i.y = i.y * this.a, i;
}
function Cy(i) {
  var t = -1, e = 0, n = 0, r, s, o, a;
  if (i.x = i.x / this.a, i.y = i.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (n = Math.tan(i.y / this.radius_g_1), e = Math.tan(i.x / this.radius_g_1) * he(1, n)) : (e = Math.tan(i.x / this.radius_g_1), n = Math.tan(i.y / this.radius_g_1) * he(1, e));
    var l = n / this.radius_p;
    if (r = e * e + l * l + t * t, s = 2 * this.radius_g * t, o = s * s - 4 * r * this.C, o < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    a = (-s - Math.sqrt(o)) / (2 * r), t = this.radius_g + a * t, e *= a, n *= a, i.x = Math.atan2(e, t), i.y = Math.atan(n * Math.cos(i.x) / t), i.y = Math.atan(this.radius_p_inv2 * Math.tan(i.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (n = Math.tan(i.y / this.radius_g_1), e = Math.tan(i.x / this.radius_g_1) * Math.sqrt(1 + n * n)) : (e = Math.tan(i.x / this.radius_g_1), n = Math.tan(i.y / this.radius_g_1) * Math.sqrt(1 + e * e)), r = e * e + n * n + t * t, s = 2 * this.radius_g * t, o = s * s - 4 * r * this.C, o < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    a = (-s - Math.sqrt(o)) / (2 * r), t = this.radius_g + a * t, e *= a, n *= a, i.x = Math.atan2(e, t), i.y = Math.atan(n * Math.cos(i.x) / t);
  }
  return i.x = i.x + this.long0, i;
}
var by = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const wy = {
  init: vy,
  forward: xy,
  inverse: Cy,
  names: by
};
var Ps = 1.340264, Is = -0.081106, ks = 893e-6, Ls = 3796e-6, Ao = Math.sqrt(3) / 2;
function Ey() {
  this.es = 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0;
}
function Sy(i) {
  var t = O(i.x - this.long0, this.over), e = i.y, n = Math.asin(Ao * Math.sin(e)), r = n * n, s = r * r * r;
  return i.x = t * Math.cos(n) / (Ao * (Ps + 3 * Is * r + s * (7 * ks + 9 * Ls * r))), i.y = n * (Ps + Is * r + s * (ks + Ls * r)), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
}
function My(i) {
  i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a;
  var t = 1e-9, e = 12, n = i.y, r, s, o, a, l, h;
  for (h = 0; h < e && (r = n * n, s = r * r * r, o = n * (Ps + Is * r + s * (ks + Ls * r)) - i.y, a = Ps + 3 * Is * r + s * (7 * ks + 9 * Ls * r), n -= l = o / a, !(Math.abs(l) < t)); ++h)
    ;
  return r = n * n, s = r * r * r, i.x = Ao * i.x * (Ps + 3 * Is * r + s * (7 * ks + 9 * Ls * r)) / Math.cos(n), i.y = Math.asin(Math.sin(n) / Ao), i.x = O(i.x + this.long0, this.over), i;
}
var Ty = ["eqearth", "Equal Earth", "Equal_Earth"];
const Ry = {
  init: Ey,
  forward: Sy,
  inverse: My,
  names: Ty
};
var qs = 1e-10;
function Py() {
  var i;
  if (this.phi1 = this.lat1, Math.abs(this.phi1) < qs)
    throw new Error();
  this.es ? (this.en = Ql(this.es), this.m1 = Xr(
    this.phi1,
    this.am1 = Math.sin(this.phi1),
    i = Math.cos(this.phi1),
    this.en
  ), this.am1 = i / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1), this.inverse = ky, this.forward = Iy) : (Math.abs(this.phi1) + qs >= T ? this.cphi1 = 0 : this.cphi1 = 1 / Math.tan(this.phi1), this.inverse = Ay, this.forward = Ly);
}
function Iy(i) {
  var t = O(i.x - (this.long0 || 0), this.over), e = i.y, n, r, s;
  return n = this.am1 + this.m1 - Xr(e, r = Math.sin(e), s = Math.cos(e), this.en), r = s * t / (n * Math.sqrt(1 - this.es * r * r)), i.x = n * Math.sin(r), i.y = this.am1 - n * Math.cos(r), i.x = this.a * i.x + (this.x0 || 0), i.y = this.a * i.y + (this.y0 || 0), i;
}
function ky(i) {
  i.x = (i.x - (this.x0 || 0)) / this.a, i.y = (i.y - (this.y0 || 0)) / this.a;
  var t, e, n, r;
  if (e = he(i.x, i.y = this.am1 - i.y), r = th(this.am1 + this.m1 - e, this.es, this.en), (t = Math.abs(r)) < T)
    t = Math.sin(r), n = e * Math.atan2(i.x, i.y) * Math.sqrt(1 - this.es * t * t) / Math.cos(r);
  else if (Math.abs(t - T) <= qs)
    n = 0;
  else
    throw new Error();
  return i.x = O(n + (this.long0 || 0), this.over), i.y = rn(r), i;
}
function Ly(i) {
  var t = O(i.x - (this.long0 || 0), this.over), e = i.y, n, r;
  return r = this.cphi1 + this.phi1 - e, Math.abs(r) > qs ? (i.x = r * Math.sin(n = t * Math.cos(e) / r), i.y = this.cphi1 - r * Math.cos(n)) : i.x = i.y = 0, i.x = this.a * i.x + (this.x0 || 0), i.y = this.a * i.y + (this.y0 || 0), i;
}
function Ay(i) {
  i.x = (i.x - (this.x0 || 0)) / this.a, i.y = (i.y - (this.y0 || 0)) / this.a;
  var t, e, n = he(i.x, i.y = this.cphi1 - i.y);
  if (e = this.cphi1 + this.phi1 - n, Math.abs(e) > T)
    throw new Error();
  return Math.abs(Math.abs(e) - T) <= qs ? t = 0 : t = n * Math.atan2(i.x, i.y) / Math.cos(e), i.x = O(t + (this.long0 || 0), this.over), i.y = rn(e), i;
}
var Fy = ["bonne", "Bonne (Werner lat_1=90)"];
const Oy = {
  init: Py,
  names: Fy
}, Kc = {
  OBLIQUE: {
    forward: jy,
    inverse: By
  },
  TRANSVERSE: {
    forward: Uy,
    inverse: Vy
  }
}, Fo = {
  ROTATE: {
    o_alpha: "oAlpha",
    o_lon_c: "oLongC",
    o_lat_c: "oLatC"
  },
  NEW_POLE: {
    o_lat_p: "oLatP",
    o_lon_p: "oLongP"
  },
  NEW_EQUATOR: {
    o_lon_1: "oLong1",
    o_lat_1: "oLat1",
    o_lon_2: "oLong2",
    o_lat_2: "oLat2"
  }
};
function Gy() {
  if (this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.title = this.title || "General Oblique Transformation", this.isIdentity = Gu.includes(this.o_proj), !this.o_proj)
    throw new Error("Missing parameter: o_proj");
  if (this.o_proj === "ob_tran")
    throw new Error("Invalid value for o_proj: " + this.o_proj);
  const i = this.projStr.replace("+proj=ob_tran", "").replace("+o_proj=", "+proj=").trim(), t = Ge(i);
  if (!t)
    throw new Error("Invalid parameter: o_proj. Unknown projection " + this.o_proj);
  t.long0 = 0, this.obliqueProjection = t;
  let e;
  const n = Object.keys(Fo), r = (a) => {
    if (typeof this[a] > "u")
      return;
    const l = parseFloat(this[a]) * Ct;
    if (isNaN(l))
      throw new Error("Invalid value for " + a + ": " + this[a]);
    return l;
  };
  for (let a = 0; a < n.length; a++) {
    const l = n[a], h = Fo[l], c = Object.entries(h);
    if (c.some(
      ([u]) => typeof this[u] < "u"
    )) {
      e = h;
      for (let u = 0; u < c.length; u++) {
        const [f, g] = c[u], p = r(f);
        if (typeof p > "u")
          throw new Error("Missing parameter: " + f + ".");
        this[g] = p;
      }
      break;
    }
  }
  if (!e)
    throw new Error("No valid parameters provided for ob_tran projection.");
  const { lamp: s, phip: o } = zy(this, e);
  this.lamp = s, Math.abs(o) > k ? (this.cphip = Math.cos(o), this.sphip = Math.sin(o), this.projectionType = Kc.OBLIQUE) : this.projectionType = Kc.TRANSVERSE;
}
function Ny(i) {
  return this.projectionType.forward(this, i);
}
function Dy(i) {
  return this.projectionType.inverse(this, i);
}
function zy(i, t) {
  let e, n;
  if (t === Fo.ROTATE) {
    let r = i.oLongC, s = i.oLatC, o = i.oAlpha;
    if (Math.abs(Math.abs(s) - T) <= k)
      throw new Error("Invalid value for o_lat_c: " + i.o_lat_c + " should be < 90");
    n = r + Math.atan2(-1 * Math.cos(o), -1 * Math.sin(o) * Math.sin(s)), e = Math.asin(Math.cos(s) * Math.sin(o));
  } else if (t === Fo.NEW_POLE)
    n = i.oLongP, e = i.oLatP;
  else {
    let r = i.oLong1, s = i.oLat1, o = i.oLong2, a = i.oLat2, l = Math.abs(s);
    if (Math.abs(s) > T - k)
      throw new Error("Invalid value for o_lat_1: " + i.o_lat_1 + " should be < 90");
    if (Math.abs(a) > T - k)
      throw new Error("Invalid value for o_lat_2: " + i.o_lat_2 + " should be < 90");
    if (Math.abs(s - a) < k)
      throw new Error("Invalid value for o_lat_1 and o_lat_2: o_lat_1 should be different from o_lat_2");
    if (l < k)
      throw new Error("Invalid value for o_lat_1: o_lat_1 should be different from zero");
    n = Math.atan2(
      Math.cos(s) * Math.sin(a) * Math.cos(r) - Math.sin(s) * Math.cos(a) * Math.cos(o),
      Math.sin(s) * Math.cos(a) * Math.sin(o) - Math.cos(s) * Math.sin(a) * Math.sin(r)
    ), e = Math.atan(-1 * Math.cos(n - r) / Math.tan(s));
  }
  return { lamp: n, phip: e };
}
function jy(i, t) {
  let { x: e, y: n } = t;
  e += i.long0;
  const r = Math.cos(e), s = Math.sin(n), o = Math.cos(n);
  t.x = O(
    Math.atan2(
      o * Math.sin(e),
      i.sphip * o * r + i.cphip * s
    ) + i.lamp
  ), t.y = Math.asin(
    i.sphip * s - i.cphip * o * r
  );
  const a = i.obliqueProjection.forward(t);
  return i.isIdentity && (a.x *= ce, a.y *= ce), a;
}
function Uy(i, t) {
  let { x: e, y: n } = t;
  e += i.long0;
  const r = Math.cos(n), s = Math.cos(e);
  t.x = O(
    Math.atan2(
      r * Math.sin(e),
      Math.sin(n)
    ) + i.lamp
  ), t.y = Math.asin(-1 * r * s);
  const o = i.obliqueProjection.forward(t);
  return i.isIdentity && (o.x *= ce, o.y *= ce), o;
}
function By(i, t) {
  i.isIdentity && (t.x *= Ct, t.y *= Ct);
  const e = i.obliqueProjection.inverse(t);
  let { x: n, y: r } = e;
  if (n < Number.MAX_VALUE) {
    n -= i.lamp;
    const s = Math.cos(n), o = Math.sin(r), a = Math.cos(r);
    t.x = Math.atan2(
      a * Math.sin(n),
      i.sphip * a * s - i.cphip * o
    ), t.y = Math.asin(
      i.sphip * o + i.cphip * a * s
    );
  }
  return t.x = O(t.x + i.long0), t;
}
function Vy(i, t) {
  i.isIdentity && (t.x *= Ct, t.y *= Ct);
  const e = i.obliqueProjection.inverse(t);
  let { x: n, y: r } = e;
  if (n < Number.MAX_VALUE) {
    const s = Math.cos(r);
    n -= i.lamp, t.x = Math.atan2(
      s * Math.sin(n),
      -1 * Math.sin(r)
    ), t.y = Math.asin(
      s * Math.cos(n)
    );
  }
  return t.x = O(t.x + i.long0), t;
}
var $y = ["General Oblique Transformation", "General_Oblique_Transformation", "ob_tran"];
const Wy = {
  init: Gy,
  forward: Ny,
  inverse: Dy,
  names: $y
};
function Yy(i) {
  i.Proj.projections.add(J0), i.Proj.projections.add(Q0), i.Proj.projections.add(F6), i.Proj.projections.add(V6), i.Proj.projections.add(Z6), i.Proj.projections.add(Q6), i.Proj.projections.add(s7), i.Proj.projections.add(c7), i.Proj.projections.add(m7), i.Proj.projections.add(x7), i.Proj.projections.add(A7), i.Proj.projections.add(z7), i.Proj.projections.add($7), i.Proj.projections.add(K7), i.Proj.projections.add(e_), i.Proj.projections.add(o_), i.Proj.projections.add(d_), i.Proj.projections.add(p_), i.Proj.projections.add(b_), i.Proj.projections.add(T_), i.Proj.projections.add(L_), i.Proj.projections.add(N_), i.Proj.projections.add($_), i.Proj.projections.add(H_), i.Proj.projections.add(ty), i.Proj.projections.add(ly), i.Proj.projections.add(fy), i.Proj.projections.add(yy), i.Proj.projections.add(wy), i.Proj.projections.add(Ry), i.Proj.projections.add(Oy), i.Proj.projections.add(Wy);
}
const En = Object.assign(qp, {
  defaultDatum: "WGS84",
  Proj: Ge,
  WGS84: new Ge("WGS84"),
  Point: Nr,
  toPoint: Bu,
  defs: Nt,
  nadgrid: Ap,
  transform: Io,
  mgrs: Jp,
  version: "__VERSION__"
});
Yy(En);
let t3 = null;
function h2(i) {
  t3 = i;
  const t = Object.keys(i.defs), e = t.length;
  let n, r;
  for (n = 0; n < e; ++n) {
    const s = t[n];
    if (!mr(s)) {
      const o = i.defs(s);
      let a = (
        /** @type {import("./Units.js").Units} */
        o.units
      );
      !a && o.projName === "longlat" && (a = "degrees"), ho(
        new r0({
          code: s,
          axisOrientation: o.axis,
          metersPerUnit: o.to_meter,
          units: a
        })
      );
    }
  }
  for (n = 0; n < e; ++n) {
    const s = t[n], o = mr(s);
    for (r = 0; r < e; ++r) {
      const a = t[r], l = mr(a);
      if (!Z0(s, a))
        if (i.defs[s] === i.defs[a])
          ma([o, l]);
        else {
          const h = i(s, a);
          sg(
            o,
            l,
            zh(o, l, h.forward),
            zh(l, o, h.inverse)
          );
        }
    }
  }
}
let Xy = async function(i) {
  const t = await fetch(`https://epsg.io/${i}.proj4`);
  if (!t.ok)
    throw new Error(`Unexpected response from epsg.io: ${t.status}`);
  return t.text();
};
async function Zy(i) {
  typeof i == "string" && (i = parseInt(i.split(":").pop(), 10));
  const t = t3;
  if (!t)
    throw new Error("Proj4 must be registered first with register(proj4)");
  const e = "EPSG:" + i;
  return t.defs(e) || (t.defs(e, await Xy(i)), h2(t)), mr(e);
}
function Hy(i, t, e = void 0) {
  En.defs(i, t), h2(En), typeof e < "u" && tt(i).setExtent(e);
}
async function Ky(i) {
  return h2(En), await Zy(i);
}
function qy(i) {
  return new i2().writeFeaturesObject(i);
}
function e3(i, t, e = void 0) {
  return e || (e = "EPSG:4326"), tn(i, t, e);
}
function i3(i, t, e = void 0) {
  return e || (e = "EPSG:4326"), Cs(i, t, e);
}
function qc(i, t = !1) {
  t ? (i.addInteraction(
    new po({
      condition: Xh
    })
  ), "ontouchstart" in window || navigator.maxTouchPoints > 0 ? i.addInteraction(
    new bs({
      condition: function(n) {
        return this.getPointerCount() === 2 || Xh(n);
      }
    })
  ) : i.addInteraction(new bs())) : (i.addInteraction(new po()), i.addInteraction(new bs()));
}
function Jy(i) {
  i.getInteractions().getArray().forEach((t) => {
    (t instanceof po || t instanceof bs) && i.removeInteraction(t);
  });
}
function Qy(i, t, e = 1e-3) {
  let n = !0;
  for (let r = i.length - 1; r >= 0; --r)
    if (!tv(i[r], t[r], e)) {
      n = !1;
      break;
    }
  return n;
}
function tv(i, t, e = 1e-3) {
  return Math.abs(i - t) < e;
}
function n3(i) {
  if (i) {
    const t = i;
    return !$t(t, [0, 0]) && t[0] >= -180 && t[0] <= 180 && t[1] >= -90 && t[1] <= 90 ? og(t) : t;
  }
  return [0, 0];
}
function ev(i, t, e) {
  const n = Object.assign({}, e);
  if (i.interactions[n.id])
    throw Error(`Interaction with id: ${n.id} already exists.`);
  n.modify = typeof n.modify == "boolean" ? n.modify : !0;
  const r = t.getSource();
  n.type === "Box" && (n.geometryFunction = l9(), n.type = "Circle");
  const s = new o9({
    ...n,
    source: r
  });
  n.active === !1 && s.setActive(!1), s.on("drawend", (l) => {
    t.get("isDrawingEnabled") && nu(l, t, i, !0);
  }), i.map.addInteraction(s), i.interactions[n.id] = s;
  const o = new c9({
    source: r
  });
  o.setActive(n.modify), i.map.addInteraction(o), i.interactions[`${n.id}_modify`] = o;
  const a = () => {
    i.getLayerById(t.get("id")) || (i.removeInteraction(n.id), i.removeInteraction(`${n.id}_modify`), i.map.getLayerGroup().un("change", a));
  };
  i.map.getLayerGroup().on("change", a);
}
const Vt = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
class r3 extends De {
  /**
   * @param {Options} options Overlay options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, this.options = t, this.id = t.id, this.insertFirst = t.insertFirst !== void 0 ? t.insertFirst : !0, this.stopEvent = t.stopEvent !== void 0 ? t.stopEvent : !0, this.element = document.createElement("div"), this.element.className = t.className !== void 0 ? t.className : "ol-overlay-container " + zg, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = t.autoPan === !0 ? {} : t.autoPan || void 0, this.rendered = {
      transform_: "",
      visible: !0
    }, this.mapPostrenderListenerKey = null, this.addChangeListener(Vt.ELEMENT, this.handleElementChanged), this.addChangeListener(Vt.MAP, this.handleMapChanged), this.addChangeListener(Vt.OFFSET, this.handleOffsetChanged), this.addChangeListener(Vt.POSITION, this.handlePositionChanged), this.addChangeListener(Vt.POSITIONING, this.handlePositioningChanged), t.element !== void 0 && this.setElement(t.element), this.setOffset(t.offset !== void 0 ? t.offset : [0, 0]), this.setPositioning(t.positioning || "top-left"), t.position !== void 0 && this.setPosition(t.position);
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  getElement() {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(Vt.ELEMENT)
    );
  }
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id;
  }
  /**
   * Get the map associated with this overlay.
   * @return {import("./Map.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */
  getMap() {
    return (
      /** @type {import("./Map.js").default|null} */
      this.get(Vt.MAP) || null
    );
  }
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */
  getOffset() {
    return (
      /** @type {Array<number>} */
      this.get(Vt.OFFSET)
    );
  }
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Vt.POSITION)
    );
  }
  /**
   * Get the current positioning of this overlay.
   * @return {Positioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */
  getPositioning() {
    return (
      /** @type {Positioning} */
      this.get(Vt.POSITIONING)
    );
  }
  /**
   * @protected
   */
  handleElementChanged() {
    sd(this.element);
    const t = this.getElement();
    t && this.element.appendChild(t);
  }
  /**
   * @protected
   */
  handleMapChanged() {
    this.mapPostrenderListenerKey && (this.element?.remove(), dt(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
    const t = this.getMap();
    if (t) {
      this.mapPostrenderListenerKey = Q(
        t,
        Je.POSTRENDER,
        this.render,
        this
      ), this.updatePixelPosition();
      const e = this.stopEvent ? t.getOverlayContainerStopEvent() : t.getOverlayContainer();
      this.insertFirst ? e.insertBefore(this.element, e.childNodes[0] || null) : e.appendChild(this.element), this.performAutoPan();
    }
  }
  /**
   * @protected
   */
  render() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handlePositionChanged() {
    this.updatePixelPosition(), this.performAutoPan();
  }
  /**
   * @protected
   */
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */
  setElement(t) {
    this.set(Vt.ELEMENT, t);
  }
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./Map.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */
  setMap(t) {
    this.set(Vt.MAP, t);
  }
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */
  setOffset(t) {
    this.set(Vt.OFFSET, t);
  }
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */
  setPosition(t) {
    this.set(Vt.POSITION, t);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */
  performAutoPan() {
    this.autoPan && this.panIntoView(this.autoPan);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
   * @api
   */
  panIntoView(t) {
    const e = this.getMap();
    if (!e || !e.getTargetElement() || !this.get(Vt.POSITION))
      return;
    const n = this.getRect(e.getTargetElement(), e.getSize()), r = this.getElement(), s = this.getRect(r, [
      Ug(r),
      Bg(r)
    ]);
    t = t || {};
    const o = t.margin === void 0 ? 20 : t.margin;
    if (!Be(n, s)) {
      const a = s[0] - n[0], l = n[2] - s[2], h = s[1] - n[1], c = n[3] - s[3], d = [0, 0];
      if (a < 0 ? d[0] = a - o : l < 0 && (d[0] = Math.abs(l) + o), h < 0 ? d[1] = h - o : c < 0 && (d[1] = Math.abs(c) + o), d[0] !== 0 || d[1] !== 0) {
        const u = (
          /** @type {import("./coordinate.js").Coordinate} */
          e.getView().getCenterInternal()
        ), f = e.getPixelFromCoordinateInternal(u);
        if (!f)
          return;
        const g = [f[0] + d[0], f[1] + d[1]], p = t.animation || {};
        e.getView().animateInternal({
          center: e.getCoordinateFromPixelInternal(g),
          duration: p.duration,
          easing: p.easing
        });
      }
    }
  }
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */
  getRect(t, e) {
    const n = t.getBoundingClientRect(), r = n.left + window.pageXOffset, s = n.top + window.pageYOffset;
    return [r, s, r + e[0], s + e[1]];
  }
  /**
   * Set the positioning for this overlay.
   * @param {Positioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */
  setPositioning(t) {
    this.set(Vt.POSITIONING, t);
  }
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */
  setVisible(t) {
    this.rendered.visible !== t && (this.element.style.display = t ? "" : "none", this.rendered.visible = t);
  }
  /**
   * Update pixel position.
   * @protected
   */
  updatePixelPosition() {
    const t = this.getMap(), e = this.getPosition();
    if (!t || !t.isRendered() || !e) {
      this.setVisible(!1);
      return;
    }
    const n = t.getPixelFromCoordinate(e), r = t.getSize();
    this.updateRenderedPosition(n, r);
  }
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */
  updateRenderedPosition(t, e) {
    const n = this.element.style, r = this.getOffset(), s = this.getPositioning();
    this.setVisible(!0);
    const o = `${t[0] + r[0]}px`, a = `${t[1] + r[1]}px`;
    let l = "0%", h = "0%";
    s == "bottom-right" || s == "center-right" || s == "top-right" ? l = "-100%" : (s == "bottom-center" || s == "center-center" || s == "top-center") && (l = "-50%"), s == "bottom-left" || s == "bottom-center" || s == "bottom-right" ? h = "-100%" : (s == "center-left" || s == "center-center" || s == "center-right") && (h = "-50%");
    const c = `translate(${l}, ${h}) translate(${o}, ${a})`;
    this.rendered.transform_ != c && (this.rendered.transform_ = c, n.transform = c);
  }
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */
  getOptions() {
    return this.options;
  }
}
class iv extends bn {
  static get properties() {
    return {
      feature: { attribute: !1, property: !0, type: Object },
      propertyTransform: { attribute: !1, property: !0, type: Function }
    };
  }
  constructor() {
    super(), this.feature = null, this.propertyTransform = (t, e) => t;
  }
  render() {
    return this.feature ? gn` <style>
            ul {
              margin: 0;
              padding: 1rem 1rem 1rem 2rem;
              border-radius: 0.5rem;
              max-width: 250px;
              font-size: small;
              background-color: var(--inverse-surface);
              color: var(--inverse-on-surface);
              box-shadow: 0 0.25rem 0.5rem 0 rgb(0 0 0 / 0.4);
              line-height: normal;
              white-space: normal;
            }
            span {
              font-weight: bold;
            }
          </style>
          <ul>
            ${Object.entries(this.feature.getProperties()).map(
      ([t, e]) => this.propertyTransform({ key: t, value: e }, this.feature)
    ).filter((t) => t).map(
      ({ key: t, value: e }) => gn`<li><span>${t}</span>: ${e}</li>`
    )}
          </ul>` : kt;
  }
}
customElements.define("eox-map-tooltip", iv);
const $a = 65536 * 65536, Jc = 1 / $a, nv = 12, Qc = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8"), ta = 0, $0 = 1, os = 2, W0 = 5;
class rv {
  /**
   * @param {Uint8Array | ArrayBuffer} [buf]
   */
  constructor(t = new Uint8Array(16)) {
    this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
  }
  // === READING =================================================================
  /**
   * @template T
   * @param {(tag: number, result: T, pbf: Pbf) => void} readField
   * @param {T} result
   * @param {number} [end]
   */
  readFields(t, e, n = this.length) {
    for (; this.pos < n; ) {
      const r = this.readVarint(), s = r >> 3, o = this.pos;
      this.type = r & 7, t(s, e, this), this.pos === o && this.skip(r);
    }
    return e;
  }
  /**
   * @template T
   * @param {(tag: number, result: T, pbf: Pbf) => void} readField
   * @param {T} result
   */
  readMessage(t, e) {
    return this.readFields(t, e, this.readVarint() + this.pos);
  }
  readFixed32() {
    const t = this.dataView.getUint32(this.pos, !0);
    return this.pos += 4, t;
  }
  readSFixed32() {
    const t = this.dataView.getInt32(this.pos, !0);
    return this.pos += 4, t;
  }
  // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
  readFixed64() {
    const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * $a;
    return this.pos += 8, t;
  }
  readSFixed64() {
    const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * $a;
    return this.pos += 8, t;
  }
  readFloat() {
    const t = this.dataView.getFloat32(this.pos, !0);
    return this.pos += 4, t;
  }
  readDouble() {
    const t = this.dataView.getFloat64(this.pos, !0);
    return this.pos += 8, t;
  }
  /**
   * @param {boolean} [isSigned]
   */
  readVarint(t) {
    const e = this.buf;
    let n, r;
    return r = e[this.pos++], n = r & 127, r < 128 || (r = e[this.pos++], n |= (r & 127) << 7, r < 128) || (r = e[this.pos++], n |= (r & 127) << 14, r < 128) || (r = e[this.pos++], n |= (r & 127) << 21, r < 128) ? n : (r = e[this.pos], n |= (r & 15) << 28, sv(n, t, this));
  }
  readVarint64() {
    return this.readVarint(!0);
  }
  readSVarint() {
    const t = this.readVarint();
    return t % 2 === 1 ? (t + 1) / -2 : t / 2;
  }
  readBoolean() {
    return !!this.readVarint();
  }
  readString() {
    const t = this.readVarint() + this.pos, e = this.pos;
    return this.pos = t, t - e >= nv && Qc ? Qc.decode(this.buf.subarray(e, t)) : yv(this.buf, e, t);
  }
  readBytes() {
    const t = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t);
    return this.pos = t, e;
  }
  // verbose for performance reasons; doesn't affect gzipped size
  /**
   * @param {number[]} [arr]
   * @param {boolean} [isSigned]
   */
  readPackedVarint(t = [], e) {
    const n = this.readPackedEnd();
    for (; this.pos < n; ) t.push(this.readVarint(e));
    return t;
  }
  /** @param {number[]} [arr] */
  readPackedSVarint(t = []) {
    const e = this.readPackedEnd();
    for (; this.pos < e; ) t.push(this.readSVarint());
    return t;
  }
  /** @param {boolean[]} [arr] */
  readPackedBoolean(t = []) {
    const e = this.readPackedEnd();
    for (; this.pos < e; ) t.push(this.readBoolean());
    return t;
  }
  /** @param {number[]} [arr] */
  readPackedFloat(t = []) {
    const e = this.readPackedEnd();
    for (; this.pos < e; ) t.push(this.readFloat());
    return t;
  }
  /** @param {number[]} [arr] */
  readPackedDouble(t = []) {
    const e = this.readPackedEnd();
    for (; this.pos < e; ) t.push(this.readDouble());
    return t;
  }
  /** @param {number[]} [arr] */
  readPackedFixed32(t = []) {
    const e = this.readPackedEnd();
    for (; this.pos < e; ) t.push(this.readFixed32());
    return t;
  }
  /** @param {number[]} [arr] */
  readPackedSFixed32(t = []) {
    const e = this.readPackedEnd();
    for (; this.pos < e; ) t.push(this.readSFixed32());
    return t;
  }
  /** @param {number[]} [arr] */
  readPackedFixed64(t = []) {
    const e = this.readPackedEnd();
    for (; this.pos < e; ) t.push(this.readFixed64());
    return t;
  }
  /** @param {number[]} [arr] */
  readPackedSFixed64(t = []) {
    const e = this.readPackedEnd();
    for (; this.pos < e; ) t.push(this.readSFixed64());
    return t;
  }
  readPackedEnd() {
    return this.type === os ? this.readVarint() + this.pos : this.pos + 1;
  }
  /** @param {number} val */
  skip(t) {
    const e = t & 7;
    if (e === ta) for (; this.buf[this.pos++] > 127; )
      ;
    else if (e === os) this.pos = this.readVarint() + this.pos;
    else if (e === W0) this.pos += 4;
    else if (e === $0) this.pos += 8;
    else throw new Error(`Unimplemented type: ${e}`);
  }
  // === WRITING =================================================================
  /**
   * @param {number} tag
   * @param {number} type
   */
  writeTag(t, e) {
    this.writeVarint(t << 3 | e);
  }
  /** @param {number} min */
  realloc(t) {
    let e = this.length || 16;
    for (; e < this.pos + t; ) e *= 2;
    if (e !== this.length) {
      const n = new Uint8Array(e);
      n.set(this.buf), this.buf = n, this.dataView = new DataView(n.buffer), this.length = e;
    }
  }
  finish() {
    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
  }
  /** @param {number} val */
  writeFixed32(t) {
    this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4;
  }
  /** @param {number} val */
  writeSFixed32(t) {
    this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4;
  }
  /** @param {number} val */
  writeFixed64(t) {
    this.realloc(8), this.dataView.setInt32(this.pos, t & -1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * Jc), !0), this.pos += 8;
  }
  /** @param {number} val */
  writeSFixed64(t) {
    this.realloc(8), this.dataView.setInt32(this.pos, t & -1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * Jc), !0), this.pos += 8;
  }
  /** @param {number} val */
  writeVarint(t) {
    if (t = +t || 0, t > 268435455 || t < 0) {
      ov(t, this);
      return;
    }
    this.realloc(4), this.buf[this.pos++] = t & 127 | (t > 127 ? 128 : 0), !(t <= 127) && (this.buf[this.pos++] = (t >>>= 7) & 127 | (t > 127 ? 128 : 0), !(t <= 127) && (this.buf[this.pos++] = (t >>>= 7) & 127 | (t > 127 ? 128 : 0), !(t <= 127) && (this.buf[this.pos++] = t >>> 7 & 127)));
  }
  /** @param {number} val */
  writeSVarint(t) {
    this.writeVarint(t < 0 ? -t * 2 - 1 : t * 2);
  }
  /** @param {boolean} val */
  writeBoolean(t) {
    this.writeVarint(+t);
  }
  /** @param {string} str */
  writeString(t) {
    t = String(t), this.realloc(t.length * 4), this.pos++;
    const e = this.pos;
    this.pos = vv(this.buf, t, this.pos);
    const n = this.pos - e;
    n >= 128 && t1(e, n, this), this.pos = e - 1, this.writeVarint(n), this.pos += n;
  }
  /** @param {number} val */
  writeFloat(t) {
    this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4;
  }
  /** @param {number} val */
  writeDouble(t) {
    this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8;
  }
  /** @param {Uint8Array} buffer */
  writeBytes(t) {
    const e = t.length;
    this.writeVarint(e), this.realloc(e);
    for (let n = 0; n < e; n++) this.buf[this.pos++] = t[n];
  }
  /**
   * @template T
   * @param {(obj: T, pbf: Pbf) => void} fn
   * @param {T} obj
   */
  writeRawMessage(t, e) {
    this.pos++;
    const n = this.pos;
    t(e, this);
    const r = this.pos - n;
    r >= 128 && t1(n, r, this), this.pos = n - 1, this.writeVarint(r), this.pos += r;
  }
  /**
   * @template T
   * @param {number} tag
   * @param {(obj: T, pbf: Pbf) => void} fn
   * @param {T} obj
   */
  writeMessage(t, e, n) {
    this.writeTag(t, os), this.writeRawMessage(e, n);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedVarint(t, e) {
    e.length && this.writeMessage(t, hv, e);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedSVarint(t, e) {
    e.length && this.writeMessage(t, cv, e);
  }
  /**
   * @param {number} tag
   * @param {boolean[]} arr
   */
  writePackedBoolean(t, e) {
    e.length && this.writeMessage(t, fv, e);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedFloat(t, e) {
    e.length && this.writeMessage(t, dv, e);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedDouble(t, e) {
    e.length && this.writeMessage(t, uv, e);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedFixed32(t, e) {
    e.length && this.writeMessage(t, gv, e);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedSFixed32(t, e) {
    e.length && this.writeMessage(t, mv, e);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedFixed64(t, e) {
    e.length && this.writeMessage(t, pv, e);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedSFixed64(t, e) {
    e.length && this.writeMessage(t, _v, e);
  }
  /**
   * @param {number} tag
   * @param {Uint8Array} buffer
   */
  writeBytesField(t, e) {
    this.writeTag(t, os), this.writeBytes(e);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeFixed32Field(t, e) {
    this.writeTag(t, W0), this.writeFixed32(e);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeSFixed32Field(t, e) {
    this.writeTag(t, W0), this.writeSFixed32(e);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeFixed64Field(t, e) {
    this.writeTag(t, $0), this.writeFixed64(e);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeSFixed64Field(t, e) {
    this.writeTag(t, $0), this.writeSFixed64(e);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeVarintField(t, e) {
    this.writeTag(t, ta), this.writeVarint(e);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeSVarintField(t, e) {
    this.writeTag(t, ta), this.writeSVarint(e);
  }
  /**
   * @param {number} tag
   * @param {string} str
   */
  writeStringField(t, e) {
    this.writeTag(t, os), this.writeString(e);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeFloatField(t, e) {
    this.writeTag(t, W0), this.writeFloat(e);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeDoubleField(t, e) {
    this.writeTag(t, $0), this.writeDouble(e);
  }
  /**
   * @param {number} tag
   * @param {boolean} val
   */
  writeBooleanField(t, e) {
    this.writeVarintField(t, +e);
  }
}
function sv(i, t, e) {
  const n = e.buf;
  let r, s;
  if (s = n[e.pos++], r = (s & 112) >> 4, s < 128 || (s = n[e.pos++], r |= (s & 127) << 3, s < 128) || (s = n[e.pos++], r |= (s & 127) << 10, s < 128) || (s = n[e.pos++], r |= (s & 127) << 17, s < 128) || (s = n[e.pos++], r |= (s & 127) << 24, s < 128) || (s = n[e.pos++], r |= (s & 1) << 31, s < 128)) return Jn(i, r, t);
  throw new Error("Expected varint not more than 10 bytes");
}
function Jn(i, t, e) {
  return e ? t * 4294967296 + (i >>> 0) : (t >>> 0) * 4294967296 + (i >>> 0);
}
function ov(i, t) {
  let e, n;
  if (i >= 0 ? (e = i % 4294967296 | 0, n = i / 4294967296 | 0) : (e = ~(-i % 4294967296), n = ~(-i / 4294967296), e ^ 4294967295 ? e = e + 1 | 0 : (e = 0, n = n + 1 | 0)), i >= 18446744073709552e3 || i < -18446744073709552e3)
    throw new Error("Given varint doesn't fit into 10 bytes");
  t.realloc(10), av(e, n, t), lv(n, t);
}
function av(i, t, e) {
  e.buf[e.pos++] = i & 127 | 128, i >>>= 7, e.buf[e.pos++] = i & 127 | 128, i >>>= 7, e.buf[e.pos++] = i & 127 | 128, i >>>= 7, e.buf[e.pos++] = i & 127 | 128, i >>>= 7, e.buf[e.pos] = i & 127;
}
function lv(i, t) {
  const e = (i & 7) << 4;
  t.buf[t.pos++] |= e | ((i >>>= 3) ? 128 : 0), i && (t.buf[t.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (t.buf[t.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (t.buf[t.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (t.buf[t.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (t.buf[t.pos++] = i & 127)))));
}
function t1(i, t, e) {
  const n = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (Math.LN2 * 7));
  e.realloc(n);
  for (let r = e.pos - 1; r >= i; r--) e.buf[r + n] = e.buf[r];
}
function hv(i, t) {
  for (let e = 0; e < i.length; e++) t.writeVarint(i[e]);
}
function cv(i, t) {
  for (let e = 0; e < i.length; e++) t.writeSVarint(i[e]);
}
function dv(i, t) {
  for (let e = 0; e < i.length; e++) t.writeFloat(i[e]);
}
function uv(i, t) {
  for (let e = 0; e < i.length; e++) t.writeDouble(i[e]);
}
function fv(i, t) {
  for (let e = 0; e < i.length; e++) t.writeBoolean(i[e]);
}
function gv(i, t) {
  for (let e = 0; e < i.length; e++) t.writeFixed32(i[e]);
}
function mv(i, t) {
  for (let e = 0; e < i.length; e++) t.writeSFixed32(i[e]);
}
function pv(i, t) {
  for (let e = 0; e < i.length; e++) t.writeFixed64(i[e]);
}
function _v(i, t) {
  for (let e = 0; e < i.length; e++) t.writeSFixed64(i[e]);
}
function yv(i, t, e) {
  let n = "", r = t;
  for (; r < e; ) {
    const s = i[r];
    let o = null, a = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
    if (r + a > e) break;
    let l, h, c;
    a === 1 ? s < 128 && (o = s) : a === 2 ? (l = i[r + 1], (l & 192) === 128 && (o = (s & 31) << 6 | l & 63, o <= 127 && (o = null))) : a === 3 ? (l = i[r + 1], h = i[r + 2], (l & 192) === 128 && (h & 192) === 128 && (o = (s & 15) << 12 | (l & 63) << 6 | h & 63, (o <= 2047 || o >= 55296 && o <= 57343) && (o = null))) : a === 4 && (l = i[r + 1], h = i[r + 2], c = i[r + 3], (l & 192) === 128 && (h & 192) === 128 && (c & 192) === 128 && (o = (s & 15) << 18 | (l & 63) << 12 | (h & 63) << 6 | c & 63, (o <= 65535 || o >= 1114112) && (o = null))), o === null ? (o = 65533, a = 1) : o > 65535 && (o -= 65536, n += String.fromCharCode(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), n += String.fromCharCode(o), r += a;
  }
  return n;
}
function vv(i, t, e) {
  for (let n = 0, r, s; n < t.length; n++) {
    if (r = t.charCodeAt(n), r > 55295 && r < 57344)
      if (s)
        if (r < 56320) {
          i[e++] = 239, i[e++] = 191, i[e++] = 189, s = r;
          continue;
        } else
          r = s - 55296 << 10 | r - 56320 | 65536, s = null;
      else {
        r > 56319 || n + 1 === t.length ? (i[e++] = 239, i[e++] = 191, i[e++] = 189) : s = r;
        continue;
      }
    else s && (i[e++] = 239, i[e++] = 191, i[e++] = 189, s = null);
    r < 128 ? i[e++] = r : (r < 2048 ? i[e++] = r >> 6 | 192 : (r < 65536 ? i[e++] = r >> 12 | 224 : (i[e++] = r >> 18 | 240, i[e++] = r >> 12 & 63 | 128), i[e++] = r >> 6 & 63 | 128), i[e++] = r & 63 | 128);
  }
  return e;
}
class xv extends Bl {
  /**
   * @param {Options<FeatureType>} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.dataProjection = new r0({
      code: "",
      units: "tile-pixels"
    }), this.featureClass = t.featureClass ? t.featureClass : (
      /** @type {import('./Feature.js').FeatureToFeatureClass<FeatureType>} */
      Xt
    ), this.geometryName_ = t.geometryName, this.layerName_ = t.layerName ? t.layerName : "layer", this.layers_ = t.layers ? t.layers : null, this.idProperty_ = t.idProperty, this.supportedMediaTypes = [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ];
  }
  /**
   * Read the raw geometry from the pbf offset stored in a raw feature's geometry
   * property.
   * @param {PBF} pbf PBF.
   * @param {Object} feature Raw feature.
   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
   * @param {Array<number>} ends Array to store ends in.
   * @private
   */
  readRawGeometry_(t, e, n, r) {
    t.pos = e.geometry;
    const s = t.readVarint() + t.pos;
    let o = 1, a = 0, l = 0, h = 0, c = 0, d = 0;
    for (; t.pos < s; ) {
      if (!a) {
        const u = t.readVarint();
        o = u & 7, a = u >> 3;
      }
      if (a--, o === 1 || o === 2)
        l += t.readSVarint(), h += t.readSVarint(), o === 1 && c > d && (r.push(c), d = c), n.push(l, h), c += 2;
      else if (o === 7)
        c > d && (n.push(
          n[d],
          n[d + 1]
        ), c += 2);
      else
        throw new Error("Invalid command found in the PBF");
    }
    c > d && (r.push(c), d = c);
  }
  /**
   * @private
   * @param {PBF} pbf PBF
   * @param {Object} rawFeature Raw Mapbox feature.
   * @param {import("./Feature.js").ReadOptions} options Read options.
   * @return {FeatureType|null} Feature.
   */
  createFeature_(t, e, n) {
    const r = e.type;
    if (r === 0)
      return null;
    let s;
    const o = e.properties;
    let a;
    this.idProperty_ ? (a = o[this.idProperty_], delete o[this.idProperty_]) : a = e.id, o[this.layerName_] = e.layer.name;
    const l = (
      /** @type {Array<number>} */
      []
    ), h = (
      /** @type {Array<number>} */
      []
    );
    this.readRawGeometry_(t, e, l, h);
    const c = Sv(r, h.length);
    if (this.featureClass === Xt)
      s = new /** @type {import('./Feature.js').FeatureToFeatureClass<RenderFeature>} */
      this.featureClass(c, l, h, 2, o, a), s.transform(n.dataProjection);
    else {
      let d;
      if (c == "Polygon") {
        const g = nd(l, h);
        d = g.length > 1 ? new xi(l, "XY", g) : new jt(l, "XY", h);
      } else
        d = c === "Point" ? new de(l, "XY") : c === "LineString" ? new Kt(l, "XY") : c === "MultiPoint" ? new nn(l, "XY") : c === "MultiLineString" ? new oi(l, "XY", h) : null;
      const u = (
        /** @type {typeof import("../Feature.js").default} */
        this.featureClass
      );
      s = new u(), this.geometryName_ && s.setGeometryName(this.geometryName_);
      const f = Bn(d, !1, n);
      s.setGeometry(f), a !== void 0 && s.setId(a), s.setProperties(o, !0);
    }
    return (
      /** @type {FeatureType} */
      s
    );
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   * @override
   */
  getType() {
    return "arraybuffer";
  }
  /**
   * Read all features.
   *
   * @param {ArrayBuffer} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<FeatureType>} Features.
   * @api
   * @override
   */
  readFeatures(t, e) {
    const n = this.layers_;
    e = this.adaptOptions(e);
    const r = tt(e.dataProjection);
    r.setWorldExtent(e.extent), e.dataProjection = r;
    const s = new rv(
      /** @type {ArrayBuffer} */
      t
    ), o = s.readFields(Cv, {}), a = [];
    for (const l in o) {
      if (n && !n.includes(l))
        continue;
      const h = o[l], c = h ? [0, 0, h.extent, h.extent] : null;
      r.setExtent(c);
      for (let d = 0, u = h.length; d < u; ++d) {
        const f = Ev(s, h, d), g = this.createFeature_(s, f, e);
        g !== null && a.push(g);
      }
    }
    return (
      /** @type {Array<FeatureType>} */
      a
    );
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   * @override
   */
  readProjection(t) {
    return this.dataProjection;
  }
  /**
   * Sets the layers that features will be read from.
   * @param {Array<string>} layers Layers.
   * @api
   */
  setLayers(t) {
    this.layers_ = t;
  }
}
function Cv(i, t, e) {
  if (i === 3) {
    const n = {
      keys: [],
      values: [],
      features: []
    }, r = e.readVarint() + e.pos;
    e.readFields(bv, n, r), n.length = n.features.length, n.length && (t[n.name] = n);
  }
}
function bv(i, t, e) {
  if (i === 15)
    t.version = e.readVarint();
  else if (i === 1)
    t.name = e.readString();
  else if (i === 5)
    t.extent = e.readVarint();
  else if (i === 2)
    t.features.push(e.pos);
  else if (i === 3)
    t.keys.push(e.readString());
  else if (i === 4) {
    let n = null;
    const r = e.readVarint() + e.pos;
    for (; e.pos < r; )
      i = e.readVarint() >> 3, n = i === 1 ? e.readString() : i === 2 ? e.readFloat() : i === 3 ? e.readDouble() : i === 4 ? e.readVarint64() : i === 5 ? e.readVarint() : i === 6 ? e.readSVarint() : i === 7 ? e.readBoolean() : null;
    t.values.push(n);
  }
}
function wv(i, t, e) {
  if (i == 1)
    t.id = e.readVarint();
  else if (i == 2) {
    const n = e.readVarint() + e.pos;
    for (; e.pos < n; ) {
      const r = t.layer.keys[e.readVarint()], s = t.layer.values[e.readVarint()];
      t.properties[r] = s;
    }
  } else i == 3 ? t.type = e.readVarint() : i == 4 && (t.geometry = e.pos);
}
function Ev(i, t, e) {
  i.pos = t.features[e];
  const n = i.readVarint() + i.pos, r = {
    layer: t,
    type: 0,
    properties: {}
  };
  return i.readFields(wv, r, n), r;
}
function Sv(i, t) {
  let e;
  return i === 1 ? e = t === 1 ? "Point" : "MultiPoint" : i === 2 ? e = t === 1 ? "LineString" : "MultiLineString" : i === 3 && (e = "Polygon"), e;
}
class Mv extends jl {
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */
  constructor(t) {
    super(t), this.image = null;
  }
  /**
   * @return {import('../../DataTile.js').ImageLike} Image.
   */
  getImage() {
    return this.image ? this.image.getImage() : null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(t) {
    const e = t.layerStatesArray[t.layerIndex], n = t.pixelRatio, r = t.viewState, s = r.resolution, o = this.getLayer().getSource(), a = t.viewHints;
    let l = t.extent;
    if (e.extent !== void 0 && (l = Ve(
      l,
      Te(e.extent, r.projection)
    )), !a[mt.ANIMATING] && !a[mt.INTERACTING] && !Qi(l))
      if (o) {
        const h = r.projection, c = o.getImage(
          l,
          s,
          n,
          h
        );
        c && (this.loadImage(c) ? this.image = c : c.getState() === z.EMPTY && (this.image = null));
      } else
        this.image = null;
    return !!this.image;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   * @override
   */
  getData(t) {
    const e = this.frameState;
    if (!e)
      return null;
    const n = this.getLayer(), r = Tt(
      e.pixelToCoordinateTransform,
      t.slice()
    ), s = n.getExtent();
    if (s && !Rn(s, r))
      return null;
    const o = this.image.getExtent(), a = this.image.getImage(), l = it(o), h = Math.floor(
      a.width * ((r[0] - o[0]) / l)
    );
    if (h < 0 || h >= a.width)
      return null;
    const c = Rt(o), d = Math.floor(
      a.height * ((o[3] - r[1]) / c)
    );
    return d < 0 || d >= a.height ? null : this.getImageData(a, h, d);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(t, e) {
    const n = this.image, r = n.getExtent(), s = n.getResolution(), [o, a] = Array.isArray(s) ? s : [s, s], l = n.getPixelRatio(), h = t.layerStatesArray[t.layerIndex], c = t.pixelRatio, d = t.viewState, u = d.center, f = d.resolution, g = c * o / (f * l), p = c * a / (f * l);
    this.prepareContainer(t, e);
    const m = this.context.canvas.width, _ = this.context.canvas.height, y = this.getRenderContext(t);
    let x = !1, v = !0;
    if (h.extent) {
      const S = Te(
        h.extent,
        d.projection
      );
      v = bt(S, t.extent), x = v && !Be(S, t.extent), x && this.clipUnrotated(y, t, S);
    }
    const C = n.getImage(), b = ri(
      this.tempTransform,
      m / 2,
      _ / 2,
      g,
      p,
      0,
      l * (r[0] - u[0]) / o,
      l * (u[1] - r[3]) / a
    );
    this.renderedResolution = a * c / l;
    const w = C.width * b[0], E = C.height * b[3];
    if (this.getLayer().getSource().getInterpolate() || (y.imageSmoothingEnabled = !1), this.preRender(y, t), v && w >= 0.5 && E >= 0.5) {
      const S = b[4], R = b[5], I = h.opacity;
      I !== 1 && (y.save(), y.globalAlpha = I), y.drawImage(C, 0, 0, +C.width, +C.height, S, R, w, E), I !== 1 && y.restore();
    }
    return this.postRender(this.context, t), x && y.restore(), y.imageSmoothingEnabled = !0, this.container;
  }
}
class Tv extends l0 {
  /**
   * @param {Options<ImageSourceType>} [options] Layer options.
   */
  constructor(t) {
    t = t || {}, super(t);
  }
}
class Rv extends Tv {
  /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
   */
  constructor(t) {
    super(t);
  }
  /**
   * @override
   */
  createRenderer() {
    return new Mv(this);
  }
  /**
   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
   * source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   * @override
   */
  getData(t) {
    return super.getData(t);
  }
}
class v0 extends e0 {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(t, e, n) {
    super(), n = n || {}, this.tileCoord = t, this.state = e, this.key = "", this.transition_ = n.transition === void 0 ? 250 : n.transition, this.transitionStarts_ = {}, this.interpolate = !!n.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(V.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.setState(F.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(t) {
    if (this.state !== F.EMPTY) {
      if (this.state !== F.ERROR && this.state > t)
        throw new Error("Tile load sequence violation");
      this.state = t, this.changed();
    }
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    X();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(t, e) {
    if (!this.transition_)
      return 1;
    let n = this.transitionStarts_[t];
    if (!n)
      n = e, this.transitionStarts_[t] = n;
    else if (n === -1)
      return 1;
    const r = e - n + 1e3 / 60;
    return r >= this.transition_ ? 1 : L1(r / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(t) {
    return this.transition_ ? this.transitionStarts_[t] !== -1 : !1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(t) {
    this.transition_ && (this.transitionStarts_[t] = -1);
  }
  /**
   * @override
   */
  disposeInternal() {
    this.release(), super.disposeInternal();
  }
}
function Wa(i) {
  return i instanceof Image || i instanceof HTMLCanvasElement || i instanceof HTMLVideoElement || i instanceof ImageBitmap ? i : null;
}
const Pv = new Error("disposed"), Iv = [256, 256];
class e1 extends v0 {
  /**
   * @param {Options} options Tile options.
   */
  constructor(t) {
    const e = F.IDLE;
    super(t.tileCoord, e, {
      transition: t.transition,
      interpolate: t.interpolate
    }), this.loader_ = t.loader, this.data_ = null, this.error_ = null, this.size_ = t.size || null, this.controller_ = t.controller || null;
  }
  /**
   * Get the tile size.
   * @return {import('./size.js').Size} Tile size.
   */
  getSize() {
    if (this.size_)
      return this.size_;
    const t = Wa(this.data_);
    return t ? [t.width, t.height] : Iv;
  }
  /**
   * Get the data for the tile.
   * @return {Data} Tile data.
   * @api
   */
  getData() {
    return this.data_;
  }
  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @api
   */
  getError() {
    return this.error_;
  }
  /**
   * Load the tile data.
   * @api
   * @override
   */
  load() {
    if (this.state !== F.IDLE && this.state !== F.ERROR)
      return;
    this.state = F.LOADING, this.changed();
    const t = this;
    this.loader_().then(function(e) {
      t.data_ = e, t.state = F.LOADED, t.changed();
    }).catch(function(e) {
      t.error_ = e, t.state = F.ERROR, t.changed();
    });
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.controller_ && (this.controller_.abort(Pv), this.controller_ = null), super.disposeInternal();
  }
}
class s3 extends v0 {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(t, e, n, r, s, o) {
    super(t, e, o), this.crossOrigin_ = r, this.src_ = n, this.key = n, this.image_, ye ? this.image_ = new OffscreenCanvas(1, 1) : (this.image_ = new Image(), r !== null && (this.image_.crossOrigin = r)), this.unlisten_ = null, this.tileLoadFunction_ = s;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, OffscreenCanvas, Image, or Video).
   * @return {HTMLCanvasElement|OffscreenCanvas|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|OffscreenCanvas|HTMLImageElement} element Element.
   */
  setImage(t) {
    this.image_ = t, this.state = F.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Get the cross origin of the ImageTile.
   * @return {string} Cross origin.
   */
  getCrossOrigin() {
    return this.crossOrigin_;
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = F.ERROR, this.unlistenImage_(), this.image_ = kv(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    if (ye)
      this.state = F.LOADED;
    else {
      const t = (
        /** @type {HTMLImageElement} */
        this.image_
      );
      t.naturalWidth && t.naturalHeight ? this.state = F.LOADED : this.state = F.EMPTY;
    }
    this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   * @api
   * @override
   */
  load() {
    this.state == F.ERROR && (this.state = F.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == F.IDLE && (this.state = F.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = Hm(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
  /**
   * @override
   */
  disposeInternal() {
    this.unlistenImage_(), this.image_ = null, super.disposeInternal();
  }
}
function kv() {
  const i = Pt(1, 1);
  return i.fillStyle = "rgba(0,0,0,0)", i.fillRect(0, 0, 1, 1), i.canvas;
}
class oh {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(t, e, n, r) {
    this.minX = t, this.maxX = e, this.minY = n, this.maxY = r;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(t) {
    return this.containsXY(t[1], t[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(t) {
    return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(t, e) {
    return this.minX <= t && t <= this.maxX && this.minY <= e && e <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(t) {
    return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(t) {
    t.minX < this.minX && (this.minX = t.minX), t.maxX > this.maxX && (this.maxX = t.maxX), t.minY < this.minY && (this.minY = t.minY), t.maxY > this.maxY && (this.maxY = t.maxY);
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(t) {
    return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY;
  }
}
function Qn(i, t, e, n, r) {
  return r !== void 0 ? (r.minX = i, r.maxX = t, r.minY = e, r.maxY = n, r) : new oh(i, t, e, n);
}
let ea;
const Er = [];
function i1(i, t, e, n, r) {
  i.beginPath(), i.moveTo(0, 0), i.lineTo(t, e), i.lineTo(n, r), i.closePath(), i.save(), i.clip(), i.fillRect(0, 0, Math.max(t, n) + 1, Math.max(e, r)), i.restore();
}
function ia(i, t) {
  return Math.abs(i[t * 4] - 210) > 2 || Math.abs(i[t * 4 + 3] - 0.75 * 255) > 2;
}
function Lv() {
  if (ea === void 0) {
    const i = Pt(6, 6, Er);
    i.globalCompositeOperation = "lighter", i.fillStyle = "rgba(210, 0, 0, 0.75)", i1(i, 4, 5, 4, 0), i1(i, 4, 5, 0, 5);
    const t = i.getImageData(0, 0, 3, 3).data;
    ea = ia(t, 0) || ia(t, 4) || ia(t, 8), a0(i), Er.push(i.canvas);
  }
  return ea;
}
function Js(i, t, e, n) {
  const r = tn(e, t, i);
  let s = Lr(
    t,
    n,
    e
  );
  const o = t.getMetersPerUnit();
  o !== void 0 && (s *= o);
  const a = i.getMetersPerUnit();
  a !== void 0 && (s /= a);
  const l = i.getExtent();
  if (!l || Rn(l, r)) {
    const h = Lr(i, s, r) / s;
    isFinite(h) && h > 0 && (s /= h);
  }
  return s;
}
function Av(i, t, e, n) {
  const r = ni(e);
  let s = Js(
    i,
    t,
    r,
    n
  );
  return (!isFinite(s) || s <= 0) && rl(e, function(o) {
    return s = Js(
      i,
      t,
      o,
      n
    ), isFinite(s) && s > 0;
  }), s;
}
function o3(i, t, e, n, r, s, o, a, l, h, c, d, u, f) {
  const g = Pt(
    Math.round(e * i),
    Math.round(e * t),
    Er
  );
  if (d || (g.imageSmoothingEnabled = !1), l.length === 0)
    return g.canvas;
  g.scale(e, e);
  function p(C) {
    return Math.round(C * e) / e;
  }
  g.globalCompositeOperation = "lighter";
  const m = ne();
  l.forEach(function(C, b, w) {
    Ds(m, C.extent);
  });
  let _;
  const y = e / n, x = (d ? 1 : 1 + Math.pow(2, -24)) / y;
  if (!u || l.length !== 1 || h !== 0) {
    if (_ = Pt(
      Math.round(it(m) * y),
      Math.round(Rt(m) * y),
      Er
    ), d || (_.imageSmoothingEnabled = !1), r && f) {
      const C = (r[0] - m[0]) * y, b = -(r[3] - m[3]) * y, w = it(r) * y, E = Rt(r) * y;
      _.rect(C, b, w, E), _.clip();
    }
    l.forEach(function(C, b, w) {
      if (C.image.width > 0 && C.image.height > 0) {
        if (C.clipExtent) {
          _.save();
          const L = (C.clipExtent[0] - m[0]) * y, A = -(C.clipExtent[3] - m[3]) * y, N = it(C.clipExtent) * y, K = Rt(C.clipExtent) * y;
          _.rect(
            d ? L : Math.round(L),
            d ? A : Math.round(A),
            d ? N : Math.round(L + N) - Math.round(L),
            d ? K : Math.round(A + K) - Math.round(A)
          ), _.clip();
        }
        const E = (C.extent[0] - m[0]) * y, S = -(C.extent[3] - m[3]) * y, R = it(C.extent) * y, I = Rt(C.extent) * y;
        _.drawImage(
          C.image,
          h,
          h,
          C.image.width - 2 * h,
          C.image.height - 2 * h,
          d ? E : Math.round(E),
          d ? S : Math.round(S),
          d ? R : Math.round(E + R) - Math.round(E),
          d ? I : Math.round(S + I) - Math.round(S)
        ), C.clipExtent && _.restore();
      }
    });
  }
  const v = Xe(o);
  return a.getTriangles().forEach(function(C, b, w) {
    const E = C.source, S = C.target;
    let R = E[0][0], I = E[0][1], L = E[1][0], A = E[1][1], N = E[2][0], K = E[2][1];
    const G = p((S[0][0] - v[0]) / s), H = p(
      -(S[0][1] - v[1]) / s
    ), j = p((S[1][0] - v[0]) / s), q = p(
      -(S[1][1] - v[1]) / s
    ), et = p((S[2][0] - v[0]) / s), ut = p(
      -(S[2][1] - v[1]) / s
    ), P = R, Ut = I;
    R = 0, I = 0, L -= P, A -= Ut, N -= P, K -= Ut;
    const qt = [
      [L, A, 0, 0, j - G],
      [N, K, 0, 0, et - G],
      [0, 0, L, A, q - H],
      [0, 0, N, K, ut - H]
    ], wt = vf(qt);
    if (!wt)
      return;
    if (g.save(), g.beginPath(), Lv() || !d) {
      g.moveTo(j, q);
      const Bt = 4, He = G - j, ze = H - q;
      for (let ge = 0; ge < Bt; ge++)
        g.lineTo(
          j + p((ge + 1) * He / Bt),
          q + p(ge * ze / (Bt - 1))
        ), ge != Bt - 1 && g.lineTo(
          j + p((ge + 1) * He / Bt),
          q + p((ge + 1) * ze / (Bt - 1))
        );
      g.lineTo(et, ut);
    } else
      g.moveTo(j, q), g.lineTo(G, H), g.lineTo(et, ut);
    g.clip(), g.transform(
      wt[0],
      wt[2],
      wt[1],
      wt[3],
      G,
      H
    ), g.translate(
      m[0] - P,
      m[3] - Ut
    );
    let fe;
    if (_)
      fe = _.canvas, g.scale(x, -x);
    else {
      const Bt = l[0], He = Bt.extent;
      fe = Bt.image, g.scale(
        it(He) / fe.width,
        -Rt(He) / fe.height
      );
    }
    g.drawImage(fe, 0, 0), g.restore();
  }), _ && (a0(_), Er.push(_.canvas)), c && (g.save(), g.globalCompositeOperation = "source-over", g.strokeStyle = "black", g.lineWidth = 1, a.getTriangles().forEach(function(C, b, w) {
    const E = C.target, S = (E[0][0] - v[0]) / s, R = -(E[0][1] - v[1]) / s, I = (E[1][0] - v[0]) / s, L = -(E[1][1] - v[1]) / s, A = (E[2][0] - v[0]) / s, N = -(E[2][1] - v[1]) / s;
    g.beginPath(), g.moveTo(I, L), g.lineTo(S, R), g.lineTo(A, N), g.closePath(), g.stroke();
  }), g.restore()), g.canvas;
}
const Fv = 10, n1 = 0.25;
class a3 {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   * @param {import("../transform.js").Transform} [sourceMatrix] Source transform matrix.
   */
  constructor(t, e, n, r, s, o, a) {
    this.sourceProj_ = t, this.targetProj_ = e;
    let l = {};
    const h = a ? pa(
      (x) => Tt(
        a,
        tn(x, this.targetProj_, this.sourceProj_)
      )
    ) : In(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(x) {
      const v = x[0] + "/" + x[1];
      return l[v] || (l[v] = h(x)), l[v];
    }, this.maxSourceExtent_ = r, this.errorThresholdSquared_ = s * s, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!r && !!this.sourceProj_.getExtent() && it(r) >= it(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? it(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? it(this.targetProj_.getExtent()) : null;
    const c = Xe(n), d = n0(n), u = Br(n), f = Rr(n), g = this.transformInv_(c), p = this.transformInv_(d), m = this.transformInv_(u), _ = this.transformInv_(f), y = Fv + (o ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          oo(n) / (o * o * 256 * 256)
        )
      )
    ) : 0);
    if (this.addQuad_(
      c,
      d,
      u,
      f,
      g,
      p,
      m,
      _,
      y
    ), this.wrapsXInSource_) {
      let x = 1 / 0;
      this.triangles_.forEach(function(v, C, b) {
        x = Math.min(
          x,
          v.source[0][0],
          v.source[1][0],
          v.source[2][0]
        );
      }), this.triangles_.forEach((v) => {
        if (Math.max(
          v.source[0][0],
          v.source[1][0],
          v.source[2][0]
        ) - x > this.sourceWorldWidth_ / 2) {
          const C = [
            [v.source[0][0], v.source[0][1]],
            [v.source[1][0], v.source[1][1]],
            [v.source[2][0], v.source[2][1]]
          ];
          C[0][0] - x > this.sourceWorldWidth_ / 2 && (C[0][0] -= this.sourceWorldWidth_), C[1][0] - x > this.sourceWorldWidth_ / 2 && (C[1][0] -= this.sourceWorldWidth_), C[2][0] - x > this.sourceWorldWidth_ / 2 && (C[2][0] -= this.sourceWorldWidth_);
          const b = Math.min(
            C[0][0],
            C[1][0],
            C[2][0]
          );
          Math.max(
            C[0][0],
            C[1][0],
            C[2][0]
          ) - b < this.sourceWorldWidth_ / 2 && (v.source = C);
        }
      });
    }
    l = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(t, e, n, r, s, o) {
    this.triangles_.push({
      source: [r, s, o],
      target: [t, e, n]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(t, e, n, r, s, o, a, l, h) {
    const c = Gt([s, o, a, l]), d = this.sourceWorldWidth_ ? it(c) / this.sourceWorldWidth_ : null, u = (
      /** @type {number} */
      this.sourceWorldWidth_
    ), f = this.sourceProj_.canWrapX() && d > 0.5 && d < 1;
    let g = !1;
    if (h > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const m = Gt([t, e, n, r]);
        g = it(m) / this.targetWorldWidth_ > n1 || g;
      }
      !f && this.sourceProj_.isGlobal() && d && (g = d > n1 || g);
    }
    if (!g && this.maxSourceExtent_ && isFinite(c[0]) && isFinite(c[1]) && isFinite(c[2]) && isFinite(c[3]) && !bt(c, this.maxSourceExtent_))
      return;
    let p = 0;
    if (!g && (!isFinite(s[0]) || !isFinite(s[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(a[0]) || !isFinite(a[1]) || !isFinite(l[0]) || !isFinite(l[1]))) {
      if (h > 0)
        g = !0;
      else if (p = (!isFinite(s[0]) || !isFinite(s[1]) ? 8 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 4 : 0) + (!isFinite(a[0]) || !isFinite(a[1]) ? 2 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 1 : 0), p != 1 && p != 2 && p != 4 && p != 8)
        return;
    }
    if (h > 0) {
      if (!g) {
        const m = [(t[0] + n[0]) / 2, (t[1] + n[1]) / 2], _ = this.transformInv_(m);
        let y;
        f ? y = (wn(s[0], u) + wn(a[0], u)) / 2 - wn(_[0], u) : y = (s[0] + a[0]) / 2 - _[0];
        const x = (s[1] + a[1]) / 2 - _[1];
        g = y * y + x * x > this.errorThresholdSquared_;
      }
      if (g) {
        if (Math.abs(t[0] - n[0]) <= Math.abs(t[1] - n[1])) {
          const m = [(e[0] + n[0]) / 2, (e[1] + n[1]) / 2], _ = this.transformInv_(m), y = [(r[0] + t[0]) / 2, (r[1] + t[1]) / 2], x = this.transformInv_(y);
          this.addQuad_(
            t,
            e,
            m,
            y,
            s,
            o,
            _,
            x,
            h - 1
          ), this.addQuad_(
            y,
            m,
            n,
            r,
            x,
            _,
            a,
            l,
            h - 1
          );
        } else {
          const m = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2], _ = this.transformInv_(m), y = [(n[0] + r[0]) / 2, (n[1] + r[1]) / 2], x = this.transformInv_(y);
          this.addQuad_(
            t,
            m,
            y,
            r,
            s,
            _,
            x,
            l,
            h - 1
          ), this.addQuad_(
            m,
            e,
            n,
            y,
            _,
            o,
            a,
            x,
            h - 1
          );
        }
        return;
      }
    }
    if (f) {
      if (!this.canWrapXInSource_)
        return;
      this.wrapsXInSource_ = !0;
    }
    (p & 11) == 0 && this.addTriangle_(t, n, r, s, a, l), (p & 14) == 0 && this.addTriangle_(t, n, e, s, a, o), p && ((p & 13) == 0 && this.addTriangle_(e, r, t, o, l, s), (p & 7) == 0 && this.addTriangle_(e, r, n, o, l, a));
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const t = ne();
    return this.triangles_.forEach(function(e, n, r) {
      const s = e.source;
      xs(t, s[0]), xs(t, s[1]), xs(t, s[2]);
    }), t;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}
const l3 = 0.5;
class h3 extends v0 {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(t, e, n, r, s, o, a, l, h, c, d, u) {
    super(s, F.IDLE, u), this.renderEdges_ = d !== void 0 ? d : !1, this.pixelRatio_ = a, this.gutter_ = l, this.canvas_ = null, this.sourceTileGrid_ = e, this.targetTileGrid_ = r, this.wrappedTileCoord_ = o || s, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0, this.clipExtent_ = t.canWrapX() ? t.getExtent() : void 0;
    const f = r.getTileCoordExtent(
      this.wrappedTileCoord_
    ), g = this.targetTileGrid_.getExtent();
    let p = this.sourceTileGrid_.getExtent();
    const m = g ? Ve(f, g) : f;
    if (oo(m) === 0) {
      this.state = F.EMPTY;
      return;
    }
    const _ = t.getExtent();
    _ && (p ? p = Ve(p, _) : p = _);
    const y = r.getResolution(
      this.wrappedTileCoord_[0]
    ), x = Av(
      t,
      n,
      m,
      y
    );
    if (!isFinite(x) || x <= 0) {
      this.state = F.EMPTY;
      return;
    }
    const v = c !== void 0 ? c : l3;
    if (this.triangulation_ = new a3(
      t,
      n,
      m,
      p,
      x * v,
      y
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = F.EMPTY;
      return;
    }
    this.sourceZ_ = e.getZForResolution(x);
    let C = this.triangulation_.calculateSourceExtent();
    if (p && (t.canWrapX() ? (C[1] = ft(
      C[1],
      p[1],
      p[3]
    ), C[3] = ft(
      C[3],
      p[1],
      p[3]
    )) : C = Ve(C, p)), !oo(C))
      this.state = F.EMPTY;
    else {
      let b = 0, w = 0;
      t.canWrapX() && (b = it(_), w = Math.floor(
        (C[0] - _[0]) / b
      )), I1(
        C.slice(),
        t,
        !0
      ).forEach((S) => {
        const R = e.getTileRangeForExtentAndZ(
          S,
          this.sourceZ_
        );
        for (let I = R.minX; I <= R.maxX; I++)
          for (let L = R.minY; L <= R.maxY; L++) {
            const A = h(this.sourceZ_, I, L, a);
            if (A) {
              const N = w * b;
              this.sourceTiles_.push({ tile: A, offset: N });
            }
          }
        ++w;
      }), this.sourceTiles_.length === 0 && (this.state = F.EMPTY);
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement|OffscreenCanvas} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const t = [];
    if (this.sourceTiles_.forEach((e) => {
      const n = e.tile;
      if (n && n.getState() == F.LOADED) {
        const r = this.sourceTileGrid_.getTileCoordExtent(n.tileCoord);
        r[0] += e.offset, r[2] += e.offset;
        const s = this.clipExtent_?.slice();
        s && (s[0] += e.offset, s[2] += e.offset), t.push({
          extent: r,
          clipExtent: s,
          image: n.getImage()
        });
      }
    }), this.sourceTiles_.length = 0, t.length === 0)
      this.state = F.ERROR;
    else {
      const e = this.wrappedTileCoord_[0], n = this.targetTileGrid_.getTileSize(e), r = typeof n == "number" ? n : n[0], s = typeof n == "number" ? n : n[1], o = this.targetTileGrid_.getResolution(e), a = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      ), l = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = o3(
        r,
        s,
        this.pixelRatio_,
        a,
        this.sourceTileGrid_.getExtent(),
        o,
        l,
        this.triangulation_,
        t,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      ), this.state = F.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state == F.IDLE) {
      this.state = F.LOADING, this.changed();
      let t = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: e }) => {
        const n = e.getState();
        if (n == F.IDLE || n == F.LOADING) {
          t++;
          const r = Q(e, V.CHANGE, (s) => {
            const o = e.getState();
            (o == F.LOADED || o == F.ERROR || o == F.EMPTY) && (dt(r), t--, t === 0 && (this.unlistenSources_(), this.reproject_()));
          });
          this.sourcesListenerKeys_.push(r);
        }
      }), t === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: e }, n, r) {
        e.getState() == F.IDLE && e.load();
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(dt), this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   * @override
   */
  release() {
    this.canvas_ && (a0(
      /** @type {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} */
      this.canvas_.getContext("2d")
    ), Er.push(this.canvas_), this.canvas_ = null), super.release();
  }
}
class r1 {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(t) {
    this.highWaterMark = t !== void 0 ? t : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  deleteOldest() {
    const t = this.pop();
    t instanceof jo && t.dispose();
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
   * the entry will be disposed.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(t) {
    for (; this.canExpireCache(); )
      this.deleteOldest();
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    for (; this.oldest_; )
      this.deleteOldest();
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(t) {
    return this.entries_.hasOwnProperty(t);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(t) {
    let e = this.oldest_;
    for (; e; )
      t(e.value_, e.key_, this), e = e.newer;
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(t, e) {
    const n = this.entries_[t];
    return at(
      n !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), n === this.newest_ || (n === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    this.oldest_.newer, this.oldest_.older = null) : (n.newer.older = n.older, n.older.newer = n.newer), n.newer = null, n.older = this.newest_, this.newest_.newer = n, this.newest_ = n), n.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(t) {
    const e = this.entries_[t];
    return at(
      e !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), e === this.newest_ ? (this.newest_ = /** @type {Entry} */
    e.older, this.newest_ && (this.newest_.newer = null)) : e === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    e.newer, this.oldest_ && (this.oldest_.older = null)) : (e.newer.older = e.older, e.older.newer = e.newer), delete this.entries_[t], --this.count_, e.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const t = new Array(this.count_);
    let e = 0, n;
    for (n = this.newest_; n; n = n.older)
      t[e++] = n.key_;
    return t;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const t = new Array(this.count_);
    let e = 0, n;
    for (n = this.newest_; n; n = n.older)
      t[e++] = n.value_;
    return t;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(t) {
    return this.entries_[t]?.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const t = this.oldest_;
    return delete this.entries_[t.key_], t.newer && (t.newer.older = null), this.oldest_ = /** @type {Entry} */
    t.newer, this.oldest_ || (this.newest_ = null), --this.count_, t.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(t, e) {
    this.get(t), this.entries_[t].value_ = e;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(t, e) {
    at(
      !(t in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const n = {
      key_: t,
      newer: null,
      older: this.newest_,
      value_: e
    };
    this.newest_ ? this.newest_.newer = n : this.oldest_ = n, this.newest_ = n, this.entries_[t] = n, ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(t) {
    this.highWaterMark = t;
  }
}
function Oo(i, t, e, n) {
  return n !== void 0 ? (n[0] = i, n[1] = t, n[2] = e, n) : [i, t, e];
}
function Ov(i, t, e) {
  return i + "/" + t + "/" + e;
}
function eo(i, t, e, n, r) {
  return `${Y(i)},${t},${Ov(e, n, r)}`;
}
function c3(i) {
  return Gv(i[0], i[1], i[2]);
}
function Gv(i, t, e) {
  return (t << i) + e;
}
function Nv(i, t) {
  const e = i[0], n = i[1], r = i[2];
  if (t.getMinZoom() > e || e > t.getMaxZoom())
    return !1;
  const s = t.getFullTileRange(e);
  return s ? s.containsXY(n, r) : !0;
}
function na(i, t, e) {
  if (!(e in i))
    return i[e] = /* @__PURE__ */ new Set([t]), !0;
  const n = i[e], r = n.has(t);
  return r || n.add(t), !r;
}
function Dv(i, t, e) {
  const n = i[e];
  return n ? n.delete(t) : !1;
}
function s1(i, t) {
  const e = i.layerStatesArray[i.layerIndex];
  e.extent && (t = Ve(
    t,
    Te(e.extent, i.viewState.projection)
  ));
  const n = (
    /** @type {import("../../source/Tile.js").default} */
    e.layer.getRenderSource()
  );
  if (!n.getWrapX()) {
    const r = n.getTileGridForProjection(i.viewState.projection).getExtent();
    r && (t = Ve(t, r));
  }
  return t;
}
class d3 extends jl {
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} [options] Options.
   */
  constructor(t, e) {
    super(t), e = e || {}, this.extentChanged = !0, this.renderComplete = !1, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedTiles = [], this.renderedSourceKey_, this.renderedSourceRevision_, this.tempExtent = ne(), this.tempTileRange_ = new oh(0, 0, 0, 0), this.tempTileCoord_ = Oo(0, 0, 0);
    const n = e.cacheSize !== void 0 ? e.cacheSize : 512;
    this.tileCache_ = new r1(n), this.sourceTileCache_ = null, this.maxStaleKeys = n * 0.5;
  }
  /**
   * @return {LRUCache} Tile cache.
   */
  getTileCache() {
    return this.tileCache_;
  }
  /**
   * @return {LRUCache} Tile cache.
   */
  getSourceTileCache() {
    return this.sourceTileCache_ || (this.sourceTileCache_ = new r1(512)), this.sourceTileCache_;
  }
  /**
   * Get a tile from the cache or create one if needed.
   *
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getOrCreateTile(t, e, n, r) {
    const s = this.tileCache_, a = this.getLayer().getSource(), l = eo(a, a.getKey(), t, e, n);
    let h;
    if (s.containsKey(l))
      h = s.get(l);
    else {
      const c = r.viewState.projection, d = a.getProjection();
      if (h = a.getTile(
        t,
        e,
        n,
        r.pixelRatio,
        c,
        !d || Qt(d, c) ? void 0 : this.getSourceTileCache()
      ), !h)
        return null;
      s.set(l, h);
    }
    return h;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getTile(t, e, n, r) {
    const s = this.getOrCreateTile(t, e, n, r);
    return s || null;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   * @override
   */
  getData(t) {
    const e = this.frameState;
    if (!e)
      return null;
    const n = this.getLayer(), r = Tt(
      e.pixelToCoordinateTransform,
      t.slice()
    ), s = n.getExtent();
    if (s && !Rn(s, r))
      return null;
    const o = e.viewState, a = n.getRenderSource(), l = a.getTileGridForProjection(o.projection), h = a.getTilePixelRatio(e.pixelRatio);
    for (let c = l.getZForResolution(o.resolution); c >= l.getMinZoom(); --c) {
      const d = l.getTileCoordForCoordAndZ(r, c), u = this.getTile(c, d[1], d[2], e);
      if (!u || u.getState() !== F.LOADED)
        continue;
      const f = l.getOrigin(c), g = Zt(l.getTileSize(c)), p = l.getResolution(c);
      let m;
      if (u instanceof s3 || u instanceof h3)
        m = u.getImage();
      else if (u instanceof e1) {
        if (m = Wa(u.getData()), !m)
          continue;
      } else
        continue;
      const _ = Math.floor(
        h * ((r[0] - f[0]) / p - d[1] * g[0])
      ), y = Math.floor(
        h * ((f[1] - r[1]) / p - d[2] * g[1])
      ), x = Math.round(
        h * a.getGutterForProjection(o.projection)
      );
      return this.getImageData(m, _ + x, y + x);
    }
    return null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(t) {
    this.renderedProjection ? t.viewState.projection !== this.renderedProjection && (this.tileCache_.clear(), this.renderedProjection = t.viewState.projection) : this.renderedProjection = t.viewState.projection;
    const e = this.getLayer().getSource();
    if (!e)
      return !1;
    const n = e.getRevision();
    return this.renderedSourceRevision_ ? this.renderedSourceRevision_ !== n && (this.renderedSourceRevision_ = n, this.renderedSourceKey_ === e.getKey() && (this.tileCache_.clear(), this.sourceTileCache_?.clear())) : this.renderedSourceRevision_ = n, !0;
  }
  /**
   * Determine whether tiles for next extent should be enqueued for rendering.
   * @return {boolean} Rendering tiles for next extent is supported.
   * @protected
   */
  enqueueTilesForNextExtent() {
    return !0;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent The extent to be rendered.
   * @param {number} initialZ The zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @param {number} preload Number of additional levels to load.
   */
  enqueueTiles(t, e, n, r, s) {
    const o = t.viewState, a = this.getLayer(), l = a.getRenderSource(), h = l.getTileGridForProjection(o.projection), c = Y(l);
    c in t.wantedTiles || (t.wantedTiles[c] = {});
    const d = t.wantedTiles[c], u = a.getMapInternal(), f = Math.max(
      n - s,
      h.getMinZoom(),
      h.getZForResolution(
        Math.min(
          a.getMaxResolution(),
          u ? u.getView().getResolutionForZoom(Math.max(a.getMinZoom(), 0)) : h.getResolution(0)
        ),
        l.zDirection
      )
    ), g = o.rotation, p = g ? R1(
      o.center,
      o.resolution,
      g,
      t.size
    ) : void 0;
    for (let m = n; m >= f; --m) {
      const _ = h.getTileRangeForExtentAndZ(
        e,
        m,
        this.tempTileRange_
      ), y = h.getResolution(m);
      for (let x = _.minX; x <= _.maxX; ++x)
        for (let v = _.minY; v <= _.maxY; ++v) {
          if (g && !h.tileCoordIntersectsViewport([m, x, v], p))
            continue;
          const C = this.getTile(m, x, v, t);
          if (!C || !na(r, C, m))
            continue;
          const w = C.getKey();
          if (d[w] = !0, C.getState() === F.IDLE && !t.tileQueue.isKeyQueued(w)) {
            const E = Oo(m, x, v, this.tempTileCoord_);
            t.tileQueue.enqueue([
              C,
              c,
              h.getTileCoordCenter(E),
              y
            ]);
          }
        }
    }
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findStaleTile_(t, e) {
    const n = this.tileCache_, r = t[0], s = t[1], o = t[2], a = this.getStaleKeys();
    for (let l = 0; l < a.length; ++l) {
      const h = eo(
        this.getLayer().getSource(),
        a[l],
        r,
        s,
        o
      );
      if (n.containsKey(h)) {
        const c = n.peek(h);
        if (c.getState() === F.LOADED)
          return c.endTransition(Y(this)), na(e, c, r), !0;
      }
    }
    return !1;
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {number} altZ The alternate zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findAltTiles_(t, e, n, r) {
    const s = t.getTileRangeForTileCoordAndZ(
      e,
      n,
      this.tempTileRange_
    );
    if (!s)
      return !1;
    let o = !0;
    const a = this.tileCache_, l = this.getLayer().getRenderSource(), h = l.getKey();
    for (let c = s.minX; c <= s.maxX; ++c)
      for (let d = s.minY; d <= s.maxY; ++d) {
        const u = eo(l, h, n, c, d);
        let f = !1;
        if (a.containsKey(u)) {
          const g = a.peek(u);
          g.getState() === F.LOADED && (na(r, g, n), f = !0);
        }
        f || (o = !1);
      }
    return o;
  }
  /**
   * Render the layer.
   *
   * The frame rendering logic has three parts:
   *
   *  1. Enqueue tiles
   *  2. Find alt tiles for those that are not yet loaded
   *  3. Render loaded tiles
   *
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(t, e) {
    this.renderComplete = !0;
    const n = t.layerStatesArray[t.layerIndex], r = t.viewState, s = r.projection, o = r.resolution, a = r.center, l = t.pixelRatio, h = this.getLayer(), c = h.getSource(), d = c.getTileGridForProjection(s), u = d.getZForResolution(o, c.zDirection), f = d.getResolution(u), g = c.getKey();
    this.renderedSourceKey_ ? this.renderedSourceKey_ !== g && (this.prependStaleKey(this.renderedSourceKey_), this.renderedSourceKey_ = g) : this.renderedSourceKey_ = g;
    let p = t.extent;
    const m = c.getTilePixelRatio(l);
    this.prepareContainer(t, e);
    const _ = this.context.canvas.width, y = this.context.canvas.height, x = n.extent && Te(n.extent);
    x && (p = Ve(
      p,
      Te(n.extent)
    ));
    const v = f * _ / 2 / m, C = f * y / 2 / m, b = [
      a[0] - v,
      a[1] - C,
      a[0] + v,
      a[1] + C
    ], w = {};
    this.renderedTiles.length = 0;
    const E = h.getPreload();
    if (t.nextExtent && this.enqueueTilesForNextExtent()) {
      const j = d.getZForResolution(
        r.nextResolution,
        c.zDirection
      ), q = s1(t, t.nextExtent);
      this.enqueueTiles(t, q, j, w, E);
    }
    const S = s1(t, p);
    if (this.enqueueTiles(t, S, u, w, 0), E > 0 && setTimeout(() => {
      this.enqueueTiles(
        t,
        S,
        u - 1,
        w,
        E - 1
      );
    }, 0), !(u in w))
      return this.container;
    const R = Y(this), I = t.time;
    for (const j of w[u]) {
      const q = j.getState();
      if (q === F.EMPTY)
        continue;
      const et = j.tileCoord;
      if (q === F.LOADED && j.getAlpha(R, I) === 1) {
        j.endTransition(R);
        continue;
      }
      if (q !== F.ERROR && (this.renderComplete = !1), this.findStaleTile_(et, w)) {
        Dv(w, j, u), t.animate = !0;
        continue;
      }
      if (this.findAltTiles_(
        d,
        et,
        u + 1,
        w
      ))
        continue;
      const Ut = d.getMinZoom();
      for (let qt = u - 1; qt >= Ut && !this.findAltTiles_(
        d,
        et,
        qt,
        w
      ); --qt)
        ;
    }
    const L = f / o * l / m, A = this.getRenderContext(t);
    ri(
      this.tempTransform,
      _ / 2,
      y / 2,
      L,
      L,
      0,
      -_ / 2,
      -y / 2
    ), n.extent && this.clipUnrotated(A, t, x), c.getInterpolate() || (A.imageSmoothingEnabled = !1), this.preRender(A, t);
    const N = Object.keys(w).map(Number);
    N.sort(ei);
    let K;
    const G = [], H = [];
    for (let j = N.length - 1; j >= 0; --j) {
      const q = N[j], et = c.getTilePixelSize(
        q,
        l,
        s
      ), P = d.getResolution(q) / f, Ut = et[0] * P * L, qt = et[1] * P * L, wt = d.getTileCoordForCoordAndZ(
        Xe(b),
        q
      ), fe = d.getTileCoordExtent(wt), Bt = Tt(this.tempTransform, [
        m * (fe[0] - b[0]) / f,
        m * (b[3] - fe[3]) / f
      ]), He = m * c.getGutterForProjection(s);
      for (const ze of w[q]) {
        if (ze.getState() !== F.LOADED)
          continue;
        const ge = ze.tileCoord, x0 = wt[1] - ge[1], f2 = Math.round(Bt[0] - (x0 - 1) * Ut), Zr = wt[2] - ge[2], sn = Math.round(Bt[1] - (Zr - 1) * qt), xe = Math.round(Bt[0] - x0 * Ut), Ke = Math.round(Bt[1] - Zr * qt), Vn = f2 - xe, $n = sn - Ke, Hr = N.length === 1;
        let on = !1;
        K = [xe, Ke, xe + Vn, Ke, xe + Vn, Ke + $n, xe, Ke + $n];
        for (let Wn = 0, Yn = G.length; Wn < Yn; ++Wn)
          if (!Hr && q < H[Wn]) {
            const Ft = G[Wn];
            bt(
              [xe, Ke, xe + Vn, Ke + $n],
              [Ft[0], Ft[3], Ft[4], Ft[7]]
            ) && (on || (A.save(), on = !0), A.beginPath(), A.moveTo(K[0], K[1]), A.lineTo(K[2], K[3]), A.lineTo(K[4], K[5]), A.lineTo(K[6], K[7]), A.moveTo(Ft[6], Ft[7]), A.lineTo(Ft[4], Ft[5]), A.lineTo(Ft[2], Ft[3]), A.lineTo(Ft[0], Ft[1]), A.clip());
          }
        G.push(K), H.push(q), this.drawTile(ze, t, xe, Ke, Vn, $n, He, Hr), on && A.restore(), this.renderedTiles.unshift(ze), this.updateUsedTiles(t.usedTiles, c, ze);
      }
    }
    if (this.renderedResolution = f, this.extentChanged = !this.renderedExtent_ || !Hi(this.renderedExtent_, b), this.renderedExtent_ = b, this.renderedPixelRatio = l, this.postRender(this.context, t), n.extent && A.restore(), A.imageSmoothingEnabled = !0, this.renderComplete) {
      const j = (q, et) => {
        const ut = Y(c), P = et.wantedTiles[ut], Ut = P ? Object.keys(P).length : 0;
        this.updateCacheSize(Ut), this.tileCache_.expireCache(), this.sourceTileCache_?.expireCache();
      };
      t.postRenderFunctions.push(j);
    }
    return this.container;
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   */
  updateCacheSize(t) {
    this.tileCache_.highWaterMark = Math.max(
      this.tileCache_.highWaterMark,
      t * 2
    );
  }
  /**
   * @param {import("../../Tile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   * @protected
   */
  drawTile(t, e, n, r, s, o, a, l) {
    let h;
    if (t instanceof e1) {
      if (h = Wa(t.getData()), !h)
        throw new Error("Rendering array data is not yet supported");
    } else
      h = this.getTileImage(
        /** @type {import("../../ImageTile.js").default} */
        t
      );
    if (!h)
      return;
    const c = this.getRenderContext(e), d = Y(this), u = e.layerStatesArray[e.layerIndex], f = u.opacity * (l ? t.getAlpha(d, e.time) : 1), g = f !== c.globalAlpha;
    g && (c.save(), c.globalAlpha = f), c.drawImage(
      h,
      a,
      a,
      h.width - 2 * a,
      h.height - 2 * a,
      n,
      r,
      s,
      o
    ), g && c.restore(), f !== u.opacity ? e.animate = !0 : l && t.endTransition(d);
  }
  /**
   * @return {HTMLCanvasElement|OffscreenCanvas} Image
   */
  getImage() {
    const t = this.context;
    return t ? t.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|OffscreenCanvas|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(t) {
    return t.getImage();
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(t, e, n) {
    const r = Y(e);
    r in t || (t[r] = {}), t[r][n.getKey()] = !0;
  }
}
const $i = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class zv extends l0 {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(t) {
    t = t || {};
    const e = Object.assign({}, t), n = t.cacheSize;
    delete t.cacheSize, delete e.preload, delete e.useInterimTilesOnError, super(e), this.on, this.once, this.un, this.cacheSize_ = n, this.setPreload(t.preload !== void 0 ? t.preload : 0), this.setUseInterimTilesOnError(
      t.useInterimTilesOnError !== void 0 ? t.useInterimTilesOnError : !0
    );
  }
  /**
   * @return {number|undefined} The suggested cache size
   * @protected
   */
  getCacheSize() {
    return this.cacheSize_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get($i.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(t) {
    this.set($i.PRELOAD, t);
  }
  /**
   * Deprecated.  Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get($i.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Deprecated.  Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(t) {
    this.set($i.USE_INTERIM_TILES_ON_ERROR, t);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   * @override
   */
  getData(t) {
    return super.getData(t);
  }
}
class jv extends zv {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(t) {
    super(t);
  }
  /**
   * @override
   */
  createRenderer() {
    return new d3(this, {
      cacheSize: this.getCacheSize()
    });
  }
}
const Uv = {
  image: ["Polygon", "Circle", "LineString", "Image", "Text"],
  hybrid: ["Polygon", "LineString"],
  vector: []
}, o1 = {
  hybrid: ["Image", "Text", "Default"],
  vector: ["Polygon", "Circle", "LineString", "Image", "Text", "Default"]
};
class Bv extends d3 {
  /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   * @param {import("./TileLayer.js").Options} options Options.
   */
  constructor(t, e) {
    super(t, e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.renderedLayerRevision_, this.renderedPixelToCoordinateTransform_ = null, this.renderedRotation_, this.renderedOpacity_ = 1, this.tmpTransform_ = Le(), this.tileClipContexts_ = null;
  }
  /**
   * Determine whether tiles for next extent should be enqueued for rendering.
   * @return {boolean} Rendering tiles for next extent is supported.
   * @override
   */
  enqueueTilesForNextExtent() {
    return this.getLayer().getRenderMode() !== "vector";
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   * @override
   */
  drawTile(t, e, n, r, s, o, a, l) {
    this.updateExecutorGroup_(
      t,
      e.pixelRatio,
      e.viewState.projection
    ), this.tileImageNeedsRender_(t) && this.renderTileImage_(t, e), super.drawTile(t, e, n, r, s, o, a, l);
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @override
   */
  getTile(t, e, n, r) {
    const s = (
      /** @type {import("../../VectorRenderTile.js").default} */
      this.getOrCreateTile(t, e, n, r)
    );
    if (!s)
      return null;
    const o = r.viewState, a = o.resolution, l = r.viewHints, h = this.getLayer().getSource(), c = h.getTileGridForProjection(o.projection), d = !(l[mt.ANIMATING] || l[mt.INTERACTING]), u = c.getZForResolution(a, h.zDirection) === t;
    return d && u ? s.wantedResolution = a : s.wantedResolution || (s.wantedResolution = c.getResolution(t)), s;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(t) {
    const e = this.getLayer().getRevision();
    return this.renderedLayerRevision_ !== e && (this.renderedLayerRevision_ = e, this.renderedTiles.length = 0), super.prepareFrame(t);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */
  updateExecutorGroup_(t, e, n) {
    const r = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), s = r.getRevision(), o = r.getRenderOrder() || null, a = t.wantedResolution, l = t.getReplayState(r);
    if (!l.dirty && l.renderedResolution === a && l.renderedRevision == s && l.renderedRenderOrder == o)
      return;
    const h = r.getSource(), c = !!r.getDeclutter(), d = h.getTileGrid(), f = h.getTileGridForProjection(n).getTileCoordExtent(t.wrappedTileCoord), g = h.getSourceTiles(e, n, t), p = Y(r);
    delete t.hitDetectionImageData[p], t.executorGroups[p] = [], l.dirty = !1;
    for (let m = 0, _ = g.length; m < _; ++m) {
      const y = g[m];
      if (y.getState() != F.LOADED)
        continue;
      const x = h.getProjection(), v = y.tileCoord;
      let C = d.getTileCoordExtent(v);
      n && x && !Qt(n, x) && (C = Cs(
        C,
        x,
        n,
        32
      ));
      const b = Ve(f, C), w = Ie(
        b,
        r.getRenderBuffer() * a,
        this.tempExtent
      ), E = Hi(C, b) ? null : w, S = new Bd(
        0,
        b,
        a,
        e
      ), R = Pa(
        a,
        e
      ), I = function(G, H) {
        let j;
        const q = G.getStyleFunction() || r.getStyleFunction();
        if (q && (j = q(G, a)), j) {
          const et = this.renderFeature(
            G,
            R,
            j,
            S,
            c,
            H
          );
          l.dirty = l.dirty || et;
        }
      }, L = y.getFeatures();
      o && o !== l.renderedRenderOrder && L.sort(o);
      for (let G = 0, H = L.length; G < H; ++G) {
        let j = L[G];
        n && y.projection && !Qt(n, y.projection) && (j = j.clone(), j.getGeometry().applyTransform(In(y.projection, n))), (!E || bt(E, j.getGeometry().getExtent())) && I.call(this, j, G);
      }
      const A = S.finish(), N = r.getRenderMode() !== "vector" && c && g.length === 1 ? null : b, K = new Vd(
        N,
        a,
        e,
        h.getOverlaps(),
        A,
        r.getRenderBuffer(),
        !0
      );
      t.executorGroups[p].push(K);
    }
    l.renderedRevision = s, l.renderedRenderOrder = o, l.renderedResolution = a;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   * @override
   */
  forEachFeatureAtCoordinate(t, e, n, r, s) {
    const o = e.viewState.resolution, a = e.viewState.rotation;
    n = n ?? 0;
    const l = this.getLayer(), c = l.getSource().getTileGridForProjection(
      e.viewState.projection
    ), d = Gt([t]);
    Ie(d, o * n, d);
    const u = {}, f = function(x, v, C) {
      let b = x.getId();
      b === void 0 && (b = Y(x));
      const w = u[b];
      if (w) {
        if (w !== !0 && C < w.distanceSq) {
          if (C === 0)
            return u[b] = !0, s.splice(s.lastIndexOf(w), 1), r(x, l, v);
          w.geometry = v, w.distanceSq = C;
        }
      } else {
        if (C === 0)
          return u[b] = !0, r(x, l, v);
        s.push(
          u[b] = {
            feature: x,
            layer: l,
            geometry: v,
            distanceSq: C,
            callback: r
          }
        );
      }
    }, g = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    ), p = Y(l), m = l.getDeclutter(), _ = m ? e.declutter?.[m]?.all().map((x) => x.value) : null;
    let y;
    t: for (let x = 0, v = g.length; x < v; ++x) {
      const C = g[x], b = c.getTileCoordExtent(C.wrappedTileCoord);
      if (!bt(b, d))
        continue;
      const w = C.executorGroups[p];
      for (let E = 0, S = w.length; E < S; ++E)
        if (y = w[E].forEachFeatureAtCoordinate(
          t,
          o,
          a,
          n,
          f,
          _
        ), y)
          break t;
    }
    return y;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature.js").FeatureLike>>} Promise that resolves with an array of features.
   * @override
   */
  getFeatures(t) {
    return this.renderedTiles.length === 0 ? Promise.resolve([]) : new Promise((e, n) => {
      const r = this.getLayer(), s = r.getSource(), o = this.renderedProjection, a = o.getExtent(), l = this.renderedResolution, h = s.getTileGridForProjection(o), c = Tt(
        this.renderedPixelToCoordinateTransform_,
        t.slice()
      ), d = h.getTileCoordForCoordAndResolution(c, l).toString(), u = (
        /** @type {Array<import("../../VectorRenderTile.js").default>} */
        this.renderedTiles.find(
          (x) => x.tileCoord.toString() === d && x.getState() === F.LOADED
        )
      );
      if (!u || u.loadingSourceTiles > 0) {
        e([]);
        return;
      }
      s.getWrapX() && o.canWrapX() && !Be(
        a,
        h.getTileCoordExtent(u.tileCoord)
      ) && Bo(c, o);
      const f = Y(r), g = h.getTileCoordExtent(u.wrappedTileCoord), p = Xe(g), m = [
        (c[0] - p[0]) / l,
        (p[1] - c[1]) / l
      ], _ = u.getSourceTiles().reduce(
        (x, v) => x.concat(v.getFeatures()),
        /** @type {Array<import("../../Feature.js").FeatureLike>} */
        []
      );
      let y = u.hitDetectionImageData[f];
      if (!y) {
        const x = Zt(
          h.getTileSize(
            h.getZForResolution(l, s.zDirection)
          )
        ), v = this.renderedRotation_, C = [
          this.getRenderTransform(
            h.getTileCoordCenter(u.wrappedTileCoord),
            l,
            0,
            _e,
            x[0] * _e,
            x[1] * _e,
            0
          )
        ];
        y = $d(
          x,
          C,
          _,
          r.getStyleFunction(),
          h.getTileCoordExtent(u.wrappedTileCoord),
          u.getReplayState(r).renderedResolution,
          v
        ), u.hitDetectionImageData[f] = y;
      }
      e(Wd(m, _, y));
    });
  }
  /**
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {Array<import('../../Feature.js').FeatureLike>} Features.
   */
  getFeaturesInExtent(t) {
    const e = [], n = this.getTileCache();
    if (n.getCount() === 0)
      return e;
    const s = this.getLayer().getSource().getTileGridForProjection(
      this.frameState.viewState.projection
    ), o = s.getZForResolution(this.renderedResolution), a = {};
    return n.forEach((l) => {
      if (l.tileCoord[0] !== o || l.getState() !== F.LOADED)
        return;
      const h = l.getSourceTiles();
      for (let c = 0, d = h.length; c < d; ++c) {
        const u = h[c], f = u.getKey();
        if (f in a)
          continue;
        a[f] = !0;
        const g = u.tileCoord;
        if (bt(t, s.getTileCoordExtent(g))) {
          const p = u.getFeatures();
          if (p)
            for (let m = 0, _ = p.length; m < _; ++m) {
              const y = p[m], x = y.getGeometry();
              bt(t, x.getExtent()) && e.push(y);
            }
        }
      }
    }), e;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @override
   */
  handleFontsChanged() {
    const t = this.getLayer();
    t.getVisible() && this.renderedLayerRevision_ !== void 0 && t.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(t) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(t, e) {
    const n = this.context, r = n.globalAlpha;
    n.globalAlpha = e.opacity;
    const s = t.viewHints, o = !(s[mt.ANIMATING] || s[mt.INTERACTING]), a = [
      this.context.canvas.width,
      this.context.canvas.height
    ], l = this.getLayer().getDeclutter(), h = l ? t.declutter?.[l] : void 0, c = Y(this.getLayer()), d = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    for (let u = 0, f = d.length; u < f; ++u) {
      const g = d[u], p = g.executorGroups[c];
      if (p)
        for (let m = p.length - 1; m >= 0; --m)
          p[m].execute(
            this.context,
            a,
            this.getTileRenderTransform(g, t),
            t.viewState.rotation,
            o,
            wo,
            h
          );
    }
    n.globalAlpha = r;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferredInternal(t) {
    const e = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    ), n = Y(this.getLayer()), r = e.reduce(
      (l, h, c) => (h.executorGroups[n].forEach(
        (d) => l.push({
          executorGroup: d,
          index: c
        })
      ), l),
      /** @type {Array<{executorGroup: CanvasExecutorGroup, index: number}>} */
      []
    ), s = r.map(
      ({ executorGroup: l }) => l.getDeferredZIndexContexts()
    ), o = {};
    for (let l = 0, h = r.length; l < h; ++l) {
      const c = r[l].executorGroup.getDeferredZIndexContexts();
      for (const d in c)
        o[d] = !0;
    }
    Object.keys(o).map(Number).sort(ei).forEach((l) => {
      s.forEach((h, c) => {
        h[l] && (h[l].forEach((d) => {
          const { executorGroup: u, index: f } = r[c], g = u.getRenderedContext(), p = g.globalAlpha;
          g.globalAlpha = this.renderedOpacity_;
          const m = this.tileClipContexts_[f];
          m && m.draw(g), d.draw(g), m && g.restore(), g.globalAlpha = p, d.clear();
        }), h[l].length = 0);
      });
    });
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile The tile
   * @param {import('../../Map.js').FrameState} frameState Current frame state
   * @return {import('../../transform.js').Transform} Transform to use to render this tile
   */
  getTileRenderTransform(t, e) {
    const n = e.pixelRatio, r = e.viewState, s = r.center, o = r.resolution, a = r.rotation, l = e.size, h = Math.round(l[0] * n), c = Math.round(l[1] * n), u = this.getLayer().getSource().getTileGridForProjection(
      e.viewState.projection
    ), f = t.tileCoord, g = u.getTileCoordExtent(t.wrappedTileCoord), p = u.getTileCoordExtent(f, this.tempExtent)[0] - g[0];
    return ul(
      b2(this.inversePixelTransform.slice(), 1 / n, 1 / n),
      this.getRenderTransform(
        s,
        o,
        a,
        n,
        h,
        c,
        p
      )
    );
  }
  /**
   * Render the vectors for this layer.
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Target context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  postRender(t, e) {
    const n = e.viewHints, r = !(n[mt.ANIMATING] || n[mt.INTERACTING]);
    this.renderedPixelToCoordinateTransform_ = e.pixelToCoordinateTransform.slice(), this.renderedRotation_ = e.viewState.rotation, this.renderedOpacity_ = e.layerStatesArray[e.layerIndex].opacity;
    const s = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), o = s.getRenderMode(), a = t.globalAlpha;
    t.globalAlpha = this.renderedOpacity_;
    const l = s.getDeclutter(), h = l ? o1[o].filter((C) => !wo.includes(C)) : o1[o], c = e.viewState, d = c.rotation, u = s.getSource(), g = u.getTileGridForProjection(c.projection).getZForResolution(
      c.resolution,
      u.zDirection
    ), p = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    ), m = [], _ = [], y = [], x = Y(s);
    let v = !0;
    for (let C = p.length - 1; C >= 0; --C) {
      const b = p[C];
      v = v && !b.getReplayState(s).dirty;
      const w = b.executorGroups[x].filter(
        (N) => N.hasExecutors(h)
      );
      if (w.length === 0)
        continue;
      const E = this.getTileRenderTransform(b, e), S = b.tileCoord[0];
      let R = !1;
      const I = w[0].getClipCoords(E);
      let L = t, A;
      if (I) {
        A = new zl(), L = A.getContext();
        for (let N = 0, K = m.length; N < K; ++N)
          if (g !== S && S < _[N]) {
            const G = m[N];
            bt(
              [
                I[0],
                I[3],
                I[4],
                I[7]
              ],
              [G[0], G[3], G[4], G[7]]
            ) && (R || (L.save(), R = !0), L.beginPath(), L.moveTo(I[0], I[1]), L.lineTo(I[2], I[3]), L.lineTo(I[4], I[5]), L.lineTo(I[6], I[7]), L.moveTo(G[6], G[7]), L.lineTo(G[4], G[5]), L.lineTo(G[2], G[3]), L.lineTo(G[0], G[1]), L.clip());
          }
        m.push(I), _.push(S);
      }
      for (let N = 0, K = w.length; N < K; ++N)
        w[N].execute(
          t,
          [t.canvas.width, t.canvas.height],
          E,
          d,
          r,
          h,
          e.declutter?.[l]
        );
      R && (L === t ? L.restore() : y[C] = A);
    }
    t.globalAlpha = a, this.ready = v, this.tileClipContexts_ = y, e.declutter || this.renderDeferredInternal(e), super.postRender(t, e);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(t, e, n, r, s, o) {
    if (!n)
      return !1;
    let a = !1;
    if (Array.isArray(n))
      for (let l = 0, h = n.length; l < h; ++l)
        a = Eo(
          r,
          t,
          n[l],
          e,
          this.boundHandleStyleImageChange_,
          void 0,
          s,
          o
        ) || a;
    else
      a = Eo(
        r,
        t,
        n,
        e,
        this.boundHandleStyleImageChange_,
        void 0,
        s,
        o
      );
    return a;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} A new tile image was rendered.
   * @private
   */
  tileImageNeedsRender_(t) {
    const e = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    );
    if (e.getRenderMode() === "vector")
      return !1;
    const n = t.getReplayState(e), r = e.getRevision(), s = t.wantedResolution;
    return n.renderedTileResolution !== s || n.renderedTileRevision !== r;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  renderTileImage_(t, e) {
    const n = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), r = t.getReplayState(n), s = n.getRevision(), o = t.executorGroups[Y(n)];
    r.renderedTileRevision = s;
    const a = t.wrappedTileCoord, l = a[0], h = n.getSource();
    let c = e.pixelRatio;
    const u = e.viewState.projection, f = h.getTileGridForProjection(u), g = f.getResolution(t.tileCoord[0]), p = e.pixelRatio / t.wantedResolution * g, m = f.getResolution(l), _ = t.getContext();
    c = Math.round(
      Math.max(c, p / c)
    );
    const y = h.getTilePixelSize(l, c, u);
    _.canvas.width = y[0], _.canvas.height = y[1];
    const x = c / p;
    if (x !== 1) {
      const w = jh(this.tmpTransform_);
      b2(w, x, x), _.setTransform.apply(_, w);
    }
    const v = f.getTileCoordExtent(a, this.tempExtent), C = p / m, b = jh(this.tmpTransform_);
    b2(b, C, -C), dg(b, -v[0], -v[3]);
    for (let w = 0, E = o.length; w < E; ++w)
      o[w].execute(
        _,
        [
          _.canvas.width * x,
          _.canvas.height * x
        ],
        b,
        0,
        !0,
        Uv[n.getRenderMode()],
        null
      );
    r.renderedTileResolution = t.wantedResolution;
  }
}
class io extends Nl {
  /**
   * @param {Options<VectorTileSourceType, FeatureType>} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const e = Object.assign({}, t);
    delete e.preload;
    const n = t.cacheSize === void 0 ? 0 : t.cacheSize;
    delete t.cacheSize, delete e.useInterimTilesOnError, super(e), this.on, this.once, this.un, this.cacheSize_ = n;
    const r = t.renderMode || "hybrid";
    at(
      r == "hybrid" || r == "vector",
      "`renderMode` must be `'hybrid'` or `'vector'`"
    ), this.renderMode_ = r, this.setPreload(t.preload ? t.preload : 0), this.setUseInterimTilesOnError(
      t.useInterimTilesOnError !== void 0 ? t.useInterimTilesOnError : !0
    ), this.getBackground, this.setBackground;
  }
  /**
   * @override
   */
  createRenderer() {
    return new Bv(this, {
      cacheSize: this.cacheSize_
    });
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   * @override
   */
  getFeatures(t) {
    return super.getFeatures(t);
  }
  /**
   * Get features whose bounding box intersects the provided extent. Only features for cached
   * tiles for the last rendered zoom level are available in the source. So this method is only
   * suitable for requesting tiles for extents that are currently rendered.
   *
   * Features are returned in random tile order and as they are included in the tiles. This means
   * they can be clipped, duplicated across tiles, and simplified to the render resolution.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(t) {
    return (
      /** @type {Array<FeatureType>} */
      /** @type {*} */
      this.getRenderer().getFeaturesInExtent(t)
    );
  }
  /**
   * @return {VectorTileRenderType} The render mode.
   */
  getRenderMode() {
    return this.renderMode_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get($i.PRELOAD)
    );
  }
  /**
   * Deprecated.  Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get($i.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(t) {
    this.set($i.PRELOAD, t);
  }
  /**
   * Deprecated.  Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(t) {
    this.set($i.USE_INTERIM_TILES_ON_ERROR, t);
  }
}
function Ya(i) {
  return Array.isArray(i) ? Math.min(...i) : i;
}
class Vv extends wd {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */
  constructor(t, e, n, r, s, o, a) {
    let l = t.getExtent();
    l && t.canWrapX() && (l = l.slice(), l[0] = -1 / 0, l[2] = 1 / 0);
    let h = e.getExtent();
    h && e.canWrapX() && (h = h.slice(), h[0] = -1 / 0, h[2] = 1 / 0);
    const c = h ? Ve(n, h) : n, d = ni(c), u = Js(
      t,
      e,
      d,
      r
    ), f = l3, g = new a3(
      t,
      e,
      c,
      l,
      u * f,
      r
    ), p = g.calculateSourceExtent(), m = Qi(p) ? null : o(p, u, s), _ = m ? z.IDLE : z.EMPTY, y = m ? m.getPixelRatio() : 1;
    super(n, r, y, _), this.targetProj_ = e, this.maxSourceExtent_ = l, this.triangulation_ = g, this.targetResolution_ = r, this.targetExtent_ = n, this.sourceImage_ = m, this.sourcePixelRatio_ = y, this.interpolate_ = a, this.canvas_ = null, this.sourceListenerKey_ = null;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.state == z.LOADING && this.unlistenSource_(), super.disposeInternal();
  }
  /**
   * @return {HTMLCanvasElement|OffscreenCanvas} Image.
   * @override
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @return {import("../proj/Projection.js").default} Projection.
   */
  getProjection() {
    return this.targetProj_;
  }
  /**
   * @private
   */
  reproject_() {
    const t = this.sourceImage_.getState();
    if (t == z.LOADED) {
      const e = it(this.targetExtent_) / this.targetResolution_, n = Rt(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = o3(
        e,
        n,
        this.sourcePixelRatio_,
        Ya(this.sourceImage_.getResolution()),
        this.maxSourceExtent_,
        this.targetResolution_,
        this.targetExtent_,
        this.triangulation_,
        [
          {
            extent: this.sourceImage_.getExtent(),
            image: this.sourceImage_.getImage()
          }
        ],
        0,
        void 0,
        this.interpolate_,
        !0
      );
    }
    this.state = t, this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state == z.IDLE) {
      this.state = z.LOADING, this.changed();
      const t = this.sourceImage_.getState();
      t == z.LOADED || t == z.ERROR ? this.reproject_() : (this.sourceListenerKey_ = Q(
        this.sourceImage_,
        V.CHANGE,
        (e) => {
          const n = this.sourceImage_.getState();
          (n == z.LOADED || n == z.ERROR) && (this.unlistenSource_(), this.reproject_());
        }
      ), this.sourceImage_.load());
    }
  }
  /**
   * @private
   */
  unlistenSource_() {
    dt(
      /** @type {!import("../events.js").EventsKey} */
      this.sourceListenerKey_
    ), this.sourceListenerKey_ = null;
  }
}
const Wi = 4, ra = {
  /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: "imageloadstart",
  /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: "imageloadend",
  /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: "imageloaderror"
};
class $v extends ve {
  /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */
  constructor(t, e) {
    super(t), this.image = e;
  }
}
class Wv extends Ul {
  /**
   * @param {Options} options Single image source options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      projection: t.projection,
      state: t.state,
      interpolate: t.interpolate !== void 0 ? t.interpolate : !0
    }), this.on, this.once, this.un, this.loader = t.loader || null, this.resolutions_ = t.resolutions !== void 0 ? t.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0, this.image = null, this.wantedExtent_, this.wantedResolution_, this.static_ = t.loader ? t.loader.length === 0 : !1, this.wantedProjection_ = null;
  }
  /**
   * @return {Array<number>|null} Resolutions.
   * @override
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {Array<number>|null} resolutions Resolutions.
   */
  setResolutions(t) {
    this.resolutions_ = t;
  }
  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */
  findNearestResolution(t) {
    const e = this.getResolutions();
    if (e) {
      const n = Uo(e, t, 0);
      t = e[n];
    }
    return t;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImage(t, e, n, r) {
    const s = this.getProjection();
    if (!s || !r || Qt(s, r))
      return s && (r = s), this.getImageInternal(t, e, n, r);
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && Qt(this.reprojectedImage_.getProjection(), r) && this.reprojectedImage_.getResolution() == e && Hi(this.reprojectedImage_.getExtent(), t))
        return this.reprojectedImage_;
      this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
    }
    return this.reprojectedImage_ = new Vv(
      s,
      r,
      t,
      e,
      n,
      (o, a, l) => this.getImageInternal(o, a, l, s),
      this.getInterpolate()
    ), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   * @protected
   */
  getImageInternal(t, e, n, r) {
    if (this.loader) {
      const s = u3(t, e, n, 1), o = this.findNearestResolution(e);
      if (this.image && (this.static_ || this.wantedProjection_ === r && (this.wantedExtent_ && Be(this.wantedExtent_, s) || Be(this.image.getExtent(), s)) && (this.wantedResolution_ && Ya(this.wantedResolution_) === o || Ya(this.image.getResolution()) === o)))
        return this.image;
      this.wantedProjection_ = r, this.wantedExtent_ = s, this.wantedResolution_ = o, this.image = new wd(
        s,
        o,
        n,
        this.loader
      ), this.image.addEventListener(
        V.CHANGE,
        this.handleImageChange.bind(this)
      );
    }
    return this.image;
  }
  /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleImageChange(t) {
    const e = (
      /** @type {import("../Image.js").default} */
      t.target
    );
    let n;
    switch (e.getState()) {
      case z.LOADING:
        this.loading = !0, n = ra.IMAGELOADSTART;
        break;
      case z.LOADED:
        this.loading = !1, n = ra.IMAGELOADEND;
        break;
      case z.ERROR:
        this.loading = !1, n = ra.IMAGELOADERROR;
        break;
      default:
        return;
    }
    this.hasListener(n) && this.dispatchEvent(new $v(n, e));
  }
}
function Yv(i, t) {
  i.getImage().src = t;
}
function u3(i, t, e, n) {
  const r = t / e, s = ni(i), o = Gi(it(i) / r, Wi), a = Gi(Rt(i) / r, Wi), l = Gi((n - 1) * o / 2, Wi), h = o + 2 * l, c = Gi((n - 1) * a / 2, Wi), d = a + 2 * c;
  return zs(s, r, 0, [
    h,
    d
  ]);
}
function Qs(i, t) {
  const e = [];
  Object.keys(t).forEach(function(r) {
    t[r] !== null && t[r] !== void 0 && e.push(r + "=" + encodeURIComponent(t[r]));
  });
  const n = e.join("&");
  return i = i.replace(/[?&]$/, ""), i += i.includes("?") ? "&" : "?", i + n;
}
const Xv = /\{z\}/g, Zv = /\{x\}/g, Hv = /\{y\}/g, Kv = /\{-y\}/g;
function qv(i, t, e, n, r) {
  return i.replace(Xv, t.toString()).replace(Zv, e.toString()).replace(Hv, n.toString()).replace(Kv, function() {
    if (r === void 0)
      throw new Error(
        "If the URL template has a {-y} placeholder, the grid extent must be known"
      );
    return (r - n).toString();
  });
}
function f3(i) {
  const t = [];
  let e = /\{([a-z])-([a-z])\}/.exec(i);
  if (e) {
    const n = e[1].charCodeAt(0), r = e[2].charCodeAt(0);
    let s;
    for (s = n; s <= r; ++s)
      t.push(i.replace(e[0], String.fromCharCode(s)));
    return t;
  }
  if (e = /\{(\d+)-(\d+)\}/.exec(i), e) {
    const n = parseInt(e[2], 10);
    for (let r = parseInt(e[1], 10); r <= n; r++)
      t.push(i.replace(e[0], r.toString()));
    return t;
  }
  return t.push(i), t;
}
const Go = "1.3.0", a1 = [101, 101];
function g3(i, t, e, n, r) {
  r.WIDTH = e[0], r.HEIGHT = e[1];
  const s = n.getAxisOrientation(), o = sl(r.VERSION, "1.3") >= 0;
  r[o ? "CRS" : "SRS"] = n.getCode();
  const a = o && s.startsWith("ne") ? [t[1], t[0], t[3], t[2]] : t;
  return r.BBOX = a.join(","), Qs(i, r);
}
function m3(i, t, e, n, r, s, o) {
  s = Object.assign({ REQUEST: "GetMap" }, s);
  const a = t / e, l = [
    Ih(it(i) / a, Wi),
    Ih(Rt(i) / a, Wi)
  ];
  if (e != 1)
    switch (o) {
      case "geoserver":
        const c = 90 * e + 0.5 | 0;
        "FORMAT_OPTIONS" in s ? s.FORMAT_OPTIONS += ";dpi:" + c : s.FORMAT_OPTIONS = "dpi:" + c;
        break;
      case "mapserver":
        s.MAP_RESOLUTION = 90 * e;
        break;
      case "carmentaserver":
      case "qgis":
        s.DPI = 90 * e;
        break;
      default:
        throw new Error("Unknown `serverType` configured");
    }
  return g3(r, i, l, n, s);
}
function No(i, t) {
  return Object.assign(
    {
      REQUEST: t,
      SERVICE: "WMS",
      VERSION: Go,
      FORMAT: "image/png",
      STYLES: "",
      TRANSPARENT: "TRUE"
    },
    i
  );
}
function Jv(i) {
  const t = i.hidpi === void 0 ? !0 : i.hidpi, e = tt(i.projection || "EPSG:3857"), n = i.ratio || 1.5, r = i.load || Sd, s = i.crossOrigin ?? null;
  return (o, a, l) => {
    o = u3(o, a, l, n), l != 1 && (!t || i.serverType === void 0) && (l = 1);
    const h = m3(
      o,
      a,
      l,
      e,
      i.url,
      No(i.params, "GetMap"),
      i.serverType
    ), c = new Image();
    return c.crossOrigin = s, r(c, h).then((d) => ({ image: d, extent: o, pixelRatio: l }));
  };
}
function Qv(i, t, e) {
  if (i.url === void 0)
    return;
  const n = tt(i.projection || "EPSG:3857"), r = zs(
    t,
    e,
    0,
    a1
  ), s = {
    QUERY_LAYERS: i.params.LAYERS,
    INFO_FORMAT: "application/json"
  };
  Object.assign(
    s,
    No(i.params, "GetFeatureInfo"),
    i.params
  );
  const o = ar((t[0] - r[0]) / e, Wi), a = ar((r[3] - t[1]) / e, Wi), l = sl(s.VERSION, "1.3") >= 0;
  return s[l ? "I" : "X"] = o, s[l ? "J" : "Y"] = a, g3(
    i.url,
    r,
    a1,
    n,
    s
  );
}
function tx(i, t) {
  if (i.url === void 0)
    return;
  const e = {
    SERVICE: "WMS",
    VERSION: Go,
    REQUEST: "GetLegendGraphic",
    FORMAT: "image/png"
  };
  if (t !== void 0) {
    const n = tt(i.projection || "EPSG:3857").getMetersPerUnit() || 1, r = 28e-5;
    e.SCALE = t * n / r;
  }
  if (Object.assign(e, i.params), i.params !== void 0 && e.LAYER === void 0) {
    const n = e.LAYERS;
    if (!(!Array.isArray(n) || n.length !== 1))
      return;
    e.LAYER = n;
  }
  return Qs(i.url, e);
}
class p3 extends Wv {
  /**
   * @param {Options} [options] ImageWMS options.
   */
  constructor(t) {
    t = t || {}, super({
      attributions: t.attributions,
      interpolate: t.interpolate,
      projection: t.projection,
      resolutions: t.resolutions
    }), this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null, this.url_ = t.url, this.imageLoadFunction_ = t.imageLoadFunction !== void 0 ? t.imageLoadFunction : Yv, this.params_ = Object.assign({}, t.params), this.serverType_ = t.serverType, this.hidpi_ = t.hidpi !== void 0 ? t.hidpi : !0, this.renderedRevision_ = 0, this.ratio_ = t.ratio !== void 0 ? t.ratio : 1.5, this.loaderProjection_ = null;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(t, e, n, r) {
    const s = tt(n), o = this.getProjection();
    o && o !== s && (e = Js(
      o,
      s,
      t,
      e
    ), t = tn(t, s, o));
    const a = {
      url: this.url_,
      params: {
        ...this.params_,
        ...r
      },
      projection: o || s
    };
    return Qv(a, t, e);
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(t, e) {
    return tx(
      {
        url: this.url_,
        params: {
          ...this.params_,
          ...e
        }
      },
      t
    );
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   * @override
   */
  getImageInternal(t, e, n, r) {
    return this.url_ === void 0 ? null : ((!this.loader || this.loaderProjection_ !== r) && (this.loaderProjection_ = r, this.loader = Jv({
      crossOrigin: this.crossOrigin_,
      params: this.params_,
      projection: r,
      serverType: this.serverType_,
      hidpi: this.hidpi_,
      url: this.url_,
      ratio: this.ratio_,
      load: (s, o) => (this.image.setImage(s), this.imageLoadFunction_(this.image, o), Sd(s))
    })), super.getImageInternal(t, e, n, r));
  }
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  /**
   * Return the URL used for this WMS source.
   * @return {string|undefined} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  setImageLoadFunction(t) {
    this.imageLoadFunction_ = t, this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  setUrl(t) {
    t != this.url_ && (this.url_ = t, this.loader = null, this.changed());
  }
  /**
   * Set the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  setParams(t) {
    this.params_ = Object.assign({}, t), this.changed();
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(t) {
    Object.assign(this.params_, t), this.changed();
  }
  /**
   * @override
   */
  changed() {
    this.image = null, super.changed();
  }
}
const tr = [0, 0, 0], Li = 5;
class c2 {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(t) {
    this.minZoom = t.minZoom !== void 0 ? t.minZoom : 0, this.resolutions_ = t.resolutions, at(
      af(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (r, s) => s - r
      ),
      "`resolutions` must be sorted in descending order"
    );
    let e;
    if (!t.origins) {
      for (let r = 0, s = this.resolutions_.length - 1; r < s; ++r)
        if (!e)
          e = this.resolutions_[r] / this.resolutions_[r + 1];
        else if (this.resolutions_[r] / this.resolutions_[r + 1] !== e) {
          e = void 0;
          break;
        }
    }
    this.zoomFactor_ = e, this.maxZoom = this.resolutions_.length - 1, this.origin_ = t.origin !== void 0 ? t.origin : null, this.origins_ = null, t.origins !== void 0 && (this.origins_ = t.origins, at(
      this.origins_.length == this.resolutions_.length,
      "Number of `origins` and `resolutions` must be equal"
    ));
    const n = t.extent;
    n !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = Xe(n)), at(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    ), this.tileSizes_ = null, t.tileSizes !== void 0 && (this.tileSizes_ = t.tileSizes, at(
      this.tileSizes_.length == this.resolutions_.length,
      "Number of `tileSizes` and `resolutions` must be equal"
    )), this.tileSize_ = t.tileSize !== void 0 ? t.tileSize : this.tileSizes_ ? null : Tl, at(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    ), this.extent_ = n !== void 0 ? n : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], t.sizes !== void 0 ? this.fullTileRanges_ = t.sizes.map((r, s) => {
      const o = new oh(
        Math.min(0, r[0]),
        Math.max(r[0] - 1, -1),
        Math.min(0, r[1]),
        Math.max(r[1] - 1, -1)
      );
      if (n) {
        const a = this.getTileRangeForExtentAndZ(n, s);
        o.minX = Math.max(a.minX, o.minX), o.maxX = Math.min(a.maxX, o.maxX), o.minY = Math.max(a.minY, o.minY), o.maxY = Math.min(a.maxY, o.maxY);
      }
      return o;
    }) : n && this.calculateTileRanges_(n);
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(t, e, n) {
    const r = this.getTileRangeForExtentAndZ(t, e);
    for (let s = r.minX, o = r.maxX; s <= o; ++s)
      for (let a = r.minY, l = r.maxY; a <= l; ++a)
        n([e, s, a]);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(t, e, n, r) {
    let s, o, a, l = null, h = t[0] - 1;
    for (this.zoomFactor_ === 2 ? (o = t[1], a = t[2]) : l = this.getTileCoordExtent(t, r); h >= this.minZoom; ) {
      if (o !== void 0 && a !== void 0 ? (o = Math.floor(o / 2), a = Math.floor(a / 2), s = Qn(o, o, a, a, n)) : s = this.getTileRangeForExtentAndZ(
        l,
        h,
        n
      ), e(h, s))
        return !0;
      --h;
    }
    return !1;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(t) {
    return this.origin_ ? this.origin_ : this.origins_[t];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(t) {
    return this.resolutions_[t];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(t, e, n) {
    if (t[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const s = t[1] * 2, o = t[2] * 2;
        return Qn(
          s,
          s + 1,
          o,
          o + 1,
          e
        );
      }
      const r = this.getTileCoordExtent(
        t,
        n || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        r,
        t[0] + 1,
        e
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(t, e, n) {
    if (e > this.maxZoom || e < this.minZoom)
      return null;
    const r = t[0], s = t[1], o = t[2];
    if (e === r)
      return Qn(
        s,
        o,
        s,
        o,
        n
      );
    if (this.zoomFactor_) {
      const l = Math.pow(this.zoomFactor_, e - r), h = Math.floor(s * l), c = Math.floor(o * l);
      if (e < r)
        return Qn(h, h, c, c, n);
      const d = Math.floor(l * (s + 1)) - 1, u = Math.floor(l * (o + 1)) - 1;
      return Qn(h, d, c, u, n);
    }
    const a = this.getTileCoordExtent(t, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(a, e, n);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(t, e, n) {
    this.getTileCoordForXYAndZ_(t[0], t[3], e, !1, tr);
    const r = tr[1], s = tr[2];
    this.getTileCoordForXYAndZ_(t[2], t[1], e, !0, tr);
    const o = tr[1], a = tr[2];
    return Qn(r, o, s, a, n);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(t) {
    const e = this.getOrigin(t[0]), n = this.getResolution(t[0]), r = Zt(this.getTileSize(t[0]), this.tmpSize_);
    return [
      e[0] + (t[1] + 0.5) * r[0] * n,
      e[1] - (t[2] + 0.5) * r[1] * n
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(t, e) {
    const n = this.getOrigin(t[0]), r = this.getResolution(t[0]), s = Zt(this.getTileSize(t[0]), this.tmpSize_), o = n[0] + t[1] * s[0] * r, a = n[1] - (t[2] + 1) * s[1] * r, l = o + s[0] * r, h = a + s[1] * r;
    return ii(o, a, l, h, e);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(t, e, n) {
    return this.getTileCoordForXYAndResolution_(
      t[0],
      t[1],
      e,
      !1,
      n
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(t, e, n, r, s) {
    const o = this.getZForResolution(n), a = n / this.getResolution(o), l = this.getOrigin(o), h = Zt(this.getTileSize(o), this.tmpSize_);
    let c = a * (t - l[0]) / n / h[0], d = a * (l[1] - e) / n / h[1];
    return r ? (c = Gi(c, Li) - 1, d = Gi(d, Li) - 1) : (c = ar(c, Li), d = ar(d, Li)), Oo(o, c, d, s);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(t, e, n, r, s) {
    const o = this.getOrigin(n), a = this.getResolution(n), l = Zt(this.getTileSize(n), this.tmpSize_);
    let h = (t - o[0]) / a / l[0], c = (o[1] - e) / a / l[1];
    return r ? (h = Gi(h, Li) - 1, c = Gi(c, Li) - 1) : (h = ar(h, Li), c = ar(c, Li)), Oo(n, h, c, s);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(t, e, n) {
    return this.getTileCoordForXYAndZ_(
      t[0],
      t[1],
      e,
      !1,
      n
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(t) {
    return this.resolutions_[t[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(t) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(t) {
    return this.fullTileRanges_ ? this.fullTileRanges_[t] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, t) : null;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(t, e) {
    const n = Uo(
      this.resolutions_,
      t,
      e || 0
    );
    return ft(n, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(t, e) {
    return td(
      e,
      0,
      e.length,
      2,
      this.getTileCoordExtent(t)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(t) {
    const e = this.resolutions_.length, n = new Array(e);
    for (let r = this.minZoom; r < e; ++r)
      n[r] = this.getTileRangeForExtentAndZ(t, r);
    this.fullTileRanges_ = n;
  }
}
class ex extends c2 {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(t) {
    super({
      extent: t.extent,
      origin: t.origin,
      origins: t.origins,
      resolutions: t.resolutions,
      tileSize: t.tileSize,
      tileSizes: t.tileSizes,
      sizes: t.sizes
    }), this.matrixIds_ = t.matrixIds;
  }
  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */
  getMatrixId(t) {
    return this.matrixIds_[t];
  }
  /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */
  getMatrixIds() {
    return this.matrixIds_;
  }
}
function ah(i) {
  let t = i.getDefaultTileGrid();
  return t || (t = rx(i), i.setDefaultTileGrid(t)), t;
}
function ix(i, t, e) {
  const n = t[0], r = i.getTileCoordCenter(t), s = d2(e);
  if (!Rn(s, r)) {
    const o = it(s), a = Math.ceil(
      (s[0] - r[0]) / o
    );
    return r[0] += o * a, i.getTileCoordForCoordAndZ(r, n);
  }
  return t;
}
function nx(i, t, e, n) {
  n = n !== void 0 ? n : "top-left";
  const r = _3(i, t, e);
  return new c2({
    extent: i,
    origin: wf(i, n),
    resolutions: r,
    tileSize: e
  });
}
function lh(i) {
  const t = i || {}, e = t.extent || tt("EPSG:3857").getExtent(), n = {
    extent: e,
    minZoom: t.minZoom,
    tileSize: t.tileSize,
    resolutions: _3(
      e,
      t.maxZoom,
      t.tileSize,
      t.maxResolution
    )
  };
  return new c2(n);
}
function _3(i, t, e, n) {
  t = t !== void 0 ? t : rd, e = Zt(e !== void 0 ? e : Tl);
  const r = Rt(i), s = it(i);
  n = n > 0 ? n : Math.max(s / e[0], r / e[1]);
  const o = t + 1, a = new Array(o);
  for (let l = 0; l < o; ++l)
    a[l] = n / Math.pow(2, l);
  return a;
}
function rx(i, t, e, n) {
  const r = d2(i);
  return nx(r, t, e, n);
}
function d2(i) {
  i = tt(i);
  let t = i.getExtent();
  if (!t) {
    const e = 180 * Ir.degrees / i.getMetersPerUnit();
    t = ii(-e, -e, e, e);
  }
  return t;
}
function sx(i, t) {
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    (function(e, n, r) {
      if (!e)
        return;
      let s;
      const o = e[0];
      if (t) {
        const a = t.getFullTileRange(o);
        a && (s = a.getHeight() - 1);
      }
      return qv(i, o, e[1], e[2], s);
    })
  );
}
function ox(i, t) {
  const e = i.length, n = new Array(e);
  for (let r = 0; r < e; ++r)
    n[r] = sx(i[r], t);
  return Xa(n);
}
function Xa(i) {
  return i.length === 1 ? i[0] : (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    (function(t, e, n) {
      if (!t)
        return;
      const r = c3(t), s = wn(r, i.length);
      return i[s](t, e, n);
    })
  );
}
class y3 extends Ul {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      projection: t.projection,
      state: t.state,
      wrapX: t.wrapX,
      interpolate: t.interpolate
    }), this.on, this.once, this.un, this.tilePixelRatio_ = t.tilePixelRatio !== void 0 ? t.tilePixelRatio : 1, this.tileGrid = t.tileGrid !== void 0 ? t.tileGrid : null;
    const e = [256, 256];
    this.tileGrid && Zt(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), e), this.tmpSize = [0, 0], this.key_ = t.key || Y(this), this.tileOptions = {
      transition: t.transition,
      interpolate: t.interpolate
    }, this.zDirection = t.zDirection ? t.zDirection : 0;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(t) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(t) {
    this.key_ !== t && (this.key_ = t, this.changed());
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   * @override
   */
  getResolutions(t) {
    const e = t ? this.getTileGridForProjection(t) : this.tileGrid;
    return e ? e.getResolutions() : null;
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {import("../structs/LRUCache.js").default<import("../Tile.js").default>} [tileCache] Tile cache.
   * @return {TileType|null} Tile.
   */
  getTile(t, e, n, r, s, o) {
    return X();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(t) {
    return this.tileGrid ? this.tileGrid : ah(t);
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(t) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(t, e, n) {
    const r = this.getTileGridForProjection(n), s = this.getTilePixelRatio(e), o = Zt(r.getTileSize(t), this.tmpSize);
    return s == 1 ? o : Em(o, s, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(t, e) {
    const n = e !== void 0 ? e : this.getProjection(), r = e !== void 0 ? this.getTileGridForProjection(n) : this.tileGrid || this.getTileGridForProjection(n);
    return this.getWrapX() && n.isGlobal() && (t = ix(r, t, n)), Nv(t, r) ? t : null;
  }
  /**
   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
   * @api
   */
  clear() {
  }
  /**
   * @override
   */
  refresh() {
    this.clear(), super.refresh();
  }
}
class ax extends ve {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(t, e) {
    super(t), this.tile = e;
  }
}
const sa = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};
class u2 extends y3 {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      cacheSize: t.cacheSize,
      projection: t.projection,
      state: t.state,
      tileGrid: t.tileGrid,
      tilePixelRatio: t.tilePixelRatio,
      wrapX: t.wrapX,
      transition: t.transition,
      interpolate: t.interpolate,
      key: t.key,
      attributionsCollapsible: t.attributionsCollapsible,
      zDirection: t.zDirection
    }), this.generateTileUrlFunction_ = this.tileUrlFunction === u2.prototype.tileUrlFunction, this.tileLoadFunction = t.tileLoadFunction, t.tileUrlFunction && (this.tileUrlFunction = t.tileUrlFunction), this.urls = null, t.urls ? this.setUrls(t.urls) : t.url && this.setUrl(t.url), this.tileLoadingKeys_ = {};
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(t) {
    const e = (
      /** @type {import("../Tile.js").default} */
      t.target
    ), n = Y(e), r = e.getState();
    let s;
    r == F.LOADING ? (this.tileLoadingKeys_[n] = !0, s = sa.TILELOADSTART) : n in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[n], s = r == F.ERROR ? sa.TILELOADERROR : r == F.LOADED ? sa.TILELOADEND : void 0), s != null && this.dispatchEvent(new ax(s, e));
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(t) {
    this.tileLoadFunction = t, this.changed();
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(t, e) {
    this.tileUrlFunction = t, typeof e < "u" ? this.setKey(e) : this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(t) {
    const e = f3(t);
    this.urls = e, this.setUrls(e);
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(t) {
    this.urls = t;
    const e = t.join(`
`);
    this.generateTileUrlFunction_ ? this.setTileUrlFunction(ox(t, this.tileGrid), e) : this.setKey(e);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(t, e, n) {
  }
}
class hh extends u2 {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      cacheSize: t.cacheSize,
      projection: t.projection,
      state: t.state,
      tileGrid: t.tileGrid,
      tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : v3,
      tilePixelRatio: t.tilePixelRatio,
      tileUrlFunction: t.tileUrlFunction,
      url: t.url,
      urls: t.urls,
      wrapX: t.wrapX,
      transition: t.transition,
      interpolate: t.interpolate !== void 0 ? t.interpolate : !0,
      key: t.key,
      attributionsCollapsible: t.attributionsCollapsible,
      zDirection: t.zDirection
    }), this.crossOrigin = t.crossOrigin !== void 0 ? t.crossOrigin : null, this.tileClass = t.tileClass !== void 0 ? t.tileClass : s3, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = t.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   * @override
   */
  getGutterForProjection(t) {
    return this.getProjection() && t && !Qt(this.getProjection(), t) ? 0 : this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @override
   */
  getKey() {
    let t = super.getKey();
    return this.getInterpolate() || (t += ":disable-interpolation"), t;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   * @override
   */
  getTileGridForProjection(t) {
    const e = this.getProjection();
    if (this.tileGrid && (!e || Qt(e, t)))
      return this.tileGrid;
    const n = Y(t);
    return n in this.tileGridForProjection || (this.tileGridForProjection[n] = ah(t)), this.tileGridForProjection[n];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(t, e, n, r, s, o) {
    const a = [t, e, n], l = this.getTileCoordForTileUrlFunction(
      a,
      s
    ), h = l ? this.tileUrlFunction(l, r, s) : void 0, c = new this.tileClass(
      a,
      h !== void 0 ? F.IDLE : F.EMPTY,
      h !== void 0 ? h : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    return c.key = o, c.addEventListener(V.CHANGE, this.handleTileChange.bind(this)), c;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {import("../structs/LRUCache.js").default<import("../Tile.js").default>} [tileCache] Tile cache.
   * @return {!(ImageTile|ReprojTile)} Tile.
   * @override
   */
  getTile(t, e, n, r, s, o) {
    const a = this.getProjection();
    if (!a || !s || Qt(a, s))
      return this.getTileInternal(
        t,
        e,
        n,
        r,
        a || s
      );
    const l = [t, e, n], h = this.getKey(), c = this.getTileGridForProjection(a), d = this.getTileGridForProjection(s), u = this.getTileCoordForTileUrlFunction(
      l,
      s
    ), f = new h3(
      a,
      c,
      s,
      d,
      l,
      u,
      this.getTilePixelRatio(r),
      this.getGutter(),
      (g, p, m, _) => this.getTileInternal(g, p, m, _, a, o),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    return f.key = h, f;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @param {import("../structs/LRUCache.js").default<import("../Tile.js").default>} [tileCache] Tile cache.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(t, e, n, r, s, o) {
    const a = this.getKey(), l = eo(this, a, t, e, n);
    if (o && o.containsKey(l))
      return (
        /** @type {!ImageTile} */
        o.get(l)
      );
    const h = this.createTile_(t, e, n, r, s, a);
    return o?.set(l, h), h;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(t) {
    this.renderReprojectionEdges_ != t && (this.renderReprojectionEdges_ = t, this.changed());
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(t, e) {
    const n = tt(t);
    if (n) {
      const r = Y(n);
      r in this.tileGridForProjection || (this.tileGridForProjection[r] = e);
    }
  }
}
function v3(i, t) {
  if (ye) {
    const e = i.getCrossOrigin();
    let n = "same-origin", r = "same-origin";
    e === "anonymous" || e === "" ? (n = "cors", r = "omit") : e === "use-credentials" && (n = "cors", r = "include"), fetch(t, {
      mode: n,
      credentials: r
    }).then((s) => {
      if (!s.ok)
        throw new Error(`HTTP ${s.status}`);
      return s.blob();
    }).then((s) => createImageBitmap(s)).then((s) => {
      const o = i.getImage();
      o.width = s.width, o.height = s.height, /** @type {OffscreenCanvas} */
      o.getContext("2d").drawImage(s, 0, 0), s.close?.(), o.dispatchEvent(new Event("load"));
    }).catch(() => {
      i.getImage().dispatchEvent(new Event("error"));
    });
    return;
  }
  i.getImage().src = t;
}
class x3 extends hh {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(t) {
    t = t || {};
    const e = t.projection !== void 0 ? t.projection : "EPSG:3857", n = t.tileGrid !== void 0 ? t.tileGrid : lh({
      extent: d2(e),
      maxResolution: t.maxResolution,
      maxZoom: t.maxZoom,
      minZoom: t.minZoom,
      tileSize: t.tileSize
    });
    super({
      attributions: t.attributions,
      cacheSize: t.cacheSize,
      crossOrigin: t.crossOrigin,
      interpolate: t.interpolate,
      projection: e,
      reprojectionErrorThreshold: t.reprojectionErrorThreshold,
      tileGrid: n,
      tileLoadFunction: t.tileLoadFunction,
      tilePixelRatio: t.tilePixelRatio,
      tileUrlFunction: t.tileUrlFunction,
      url: t.url,
      urls: t.urls,
      wrapX: t.wrapX !== void 0 ? t.wrapX : !0,
      transition: t.transition,
      attributionsCollapsible: t.attributionsCollapsible,
      zDirection: t.zDirection
    }), this.gutter_ = t.gutter !== void 0 ? t.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   * @override
   */
  getGutter() {
    return this.gutter_;
  }
}
const lx = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
class hx extends x3 {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(t) {
    t = t || {};
    let e;
    t.attributions !== void 0 ? e = t.attributions : e = [lx];
    const n = t.crossOrigin !== void 0 ? t.crossOrigin : "anonymous", r = t.url !== void 0 ? t.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
    super({
      attributions: e,
      attributionsCollapsible: !1,
      cacheSize: t.cacheSize,
      crossOrigin: n,
      interpolate: t.interpolate,
      maxZoom: t.maxZoom !== void 0 ? t.maxZoom : 19,
      reprojectionErrorThreshold: t.reprojectionErrorThreshold,
      tileLoadFunction: (
        /**
         * @param {import("../ImageTile.js").default} tile Image tile
         * @param {string} src Image src
         */
        (s, o) => {
          const a = s.getImage();
          !ye && a instanceof HTMLImageElement && (a.referrerPolicy = "origin-when-cross-origin"), (t.tileLoadFunction || v3)(s, o);
        }
      ),
      transition: t.transition,
      url: r,
      wrapX: t.wrapX,
      zDirection: t.zDirection
    });
  }
}
class C3 extends hh {
  /**
   * @param {Options} [options] Tile WMS options.
   */
  constructor(t) {
    t = t || /** @type {Options} */
    {};
    const e = Object.assign({}, t.params);
    super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      cacheSize: t.cacheSize,
      crossOrigin: t.crossOrigin,
      interpolate: t.interpolate,
      projection: t.projection,
      reprojectionErrorThreshold: t.reprojectionErrorThreshold,
      tileClass: t.tileClass,
      tileGrid: t.tileGrid,
      tileLoadFunction: t.tileLoadFunction,
      url: t.url,
      urls: t.urls,
      wrapX: t.wrapX !== void 0 ? t.wrapX : !0,
      transition: t.transition,
      zDirection: t.zDirection
    }), this.gutter_ = t.gutter !== void 0 ? t.gutter : 0, this.params_ = e, this.v13_ = !0, this.serverType_ = t.serverType, this.hidpi_ = t.hidpi !== void 0 ? t.hidpi : !0, this.tmpExtent_ = ne(), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(t, e, n, r) {
    const s = tt(n), o = this.getProjection() || s;
    let a = this.getTileGrid();
    a || (a = this.getTileGridForProjection(o));
    const l = tn(
      t,
      s,
      o
    ), h = Js(
      o,
      s,
      t,
      e
    ), c = a.getZForResolution(h, this.zDirection), d = a.getResolution(c), u = a.getTileCoordForCoordAndZ(l, c);
    if (a.getResolutions().length <= u[0])
      return;
    let f = a.getTileCoordExtent(u, this.tmpExtent_);
    const g = this.gutter_;
    g !== 0 && (f = Ie(f, d * g, f));
    const p = {
      QUERY_LAYERS: this.params_.LAYERS
    };
    Object.assign(
      p,
      No(this.params_, "GetFeatureInfo"),
      r
    );
    const m = Math.floor((l[0] - f[0]) / d), _ = Math.floor((f[3] - l[1]) / d);
    return p[this.v13_ ? "I" : "X"] = m, p[this.v13_ ? "J" : "Y"] = _, this.getRequestUrl_(
      u,
      f,
      1,
      o || s,
      p
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(t, e) {
    if (this.urls[0] === void 0)
      return;
    const n = {
      SERVICE: "WMS",
      VERSION: Go,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (e === void 0 || e.LAYER === void 0) {
      const r = this.params_.LAYERS;
      if (!(!Array.isArray(r) || r.length === 1))
        return;
      n.LAYER = r;
    }
    if (t !== void 0) {
      const r = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, s = 28e-5;
      n.SCALE = t * r / s;
    }
    return Object.assign(n, e), Qs(
      /** @type {string} */
      this.urls[0],
      n
    );
  }
  /**
   * @return {number} Gutter.
   * @override
   */
  getGutter() {
    return this.gutter_;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(t, e, n, r, s) {
    const o = this.urls;
    if (!o)
      return;
    let a;
    if (o.length == 1)
      a = o[0];
    else {
      const l = wn(c3(t), o.length);
      a = o[l];
    }
    return m3(
      e,
      (this.tileGrid || this.getTileGridForProjection(r)).getResolution(t[0]),
      n,
      r,
      a,
      s,
      this.serverType_
    );
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   * @override
   */
  getTilePixelRatio(t) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : t;
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let t = 0;
    const e = [];
    for (const n in this.params_)
      e[t++] = n + "-" + this.params_[n];
    return e.join("/");
  }
  /**
   * @param {Object} params New URL paremeters.
   * @private
   */
  setParams_(t) {
    this.params_ = t, this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * Set the URL parameters passed to the WMS source.
   * @param {Object} params New URL paremeters.
   * @api
   */
  setParams(t) {
    this.setParams_(Object.assign({}, t));
  }
  /**
   * Update the URL parameters. This method can be used to update a subset of the WMS
   * parameters. Call `setParams` to set all of the parameters.
   * @param {Object} params Updated URL parameters.
   * @api
   */
  updateParams(t) {
    this.setParams_(Object.assign(this.params_, t));
  }
  /**
   * @private
   */
  updateV13_() {
    const t = this.params_.VERSION || Go;
    this.v13_ = sl(t, "1.3") >= 0;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(t, e, n) {
    let r = this.getTileGrid();
    if (r || (r = this.getTileGridForProjection(n)), r.getResolutions().length <= t[0])
      return;
    e != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (e = 1);
    const s = r.getResolution(t[0]);
    let o = r.getTileCoordExtent(t, this.tmpExtent_);
    const a = this.gutter_;
    a !== 0 && (o = Ie(o, s * a, o));
    const l = Object.assign(
      {},
      No(this.params_, "GetMap")
    );
    return this.getRequestUrl_(
      t,
      o,
      e,
      n,
      l
    );
  }
}
const l1 = [];
class cx extends v0 {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
   * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function.
   * @param {function(VectorRenderTile):void} removeSourceTiles Function.
   */
  constructor(t, e, n, r, s) {
    super(t, e, { transition: 0 }), this.context_ = null, this.executorGroups = {}, this.loadingSourceTiles = 0, this.hitDetectionImageData = {}, this.replayState_ = {}, this.sourceTiles = [], this.errorTileKeys = {}, this.wantedResolution, this.getSourceTiles = r.bind(void 0, this), this.removeSourceTiles_ = s, this.wrappedTileCoord = n;
  }
  /**
   * @return {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} The rendering context.
   */
  getContext() {
    return this.context_ || (this.context_ = Pt(1, 1, l1)), this.context_;
  }
  /**
   * @return {boolean} Tile has a rendering context.
   */
  hasContext() {
    return !!this.context_;
  }
  /**
   * Get the Canvas for this tile.
   * @return {HTMLCanvasElement|OffscreenCanvas} Canvas.
   */
  getImage() {
    return this.hasContext() ? this.getContext().canvas : null;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {ReplayState} The replay state.
   */
  getReplayState(t) {
    const e = Y(t);
    return e in this.replayState_ || (this.replayState_[e] = {
      dirty: !1,
      renderedRenderOrder: null,
      renderedResolution: NaN,
      renderedRevision: -1,
      renderedTileResolution: NaN,
      renderedTileRevision: -1,
      renderedTileZ: -1
    }), this.replayState_[e];
  }
  /**
   * Load the tile.
   * @override
   */
  load() {
    this.getSourceTiles();
  }
  /**
   * Remove from the cache due to expiry
   * @override
   */
  release() {
    this.context_ && (a0(this.context_), l1.push(this.context_.canvas), this.context_ = null), this.removeSourceTiles_(this), this.sourceTiles.length = 0, super.release();
  }
}
let dx = class extends v0 {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Data source url.
   * @param {import("./format/Feature.js").default<FeatureType>} format Feature format.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(t, e, n, r, s, o) {
    super(t, e, o), this.extent = null, this.format_ = r, this.features_ = null, this.loader_, this.projection = null, this.resolution, this.tileLoadFunction_ = s, this.url_ = n, this.key = n;
  }
  /**
   * @return {string} Tile url.
   */
  getTileUrl() {
    return this.url_;
  }
  /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default<FeatureType>} Feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Get the features for this tile. Geometries will be in the view projection.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    this.state == F.IDLE && (this.setState(F.LOADING), this.tileLoadFunction_(this, this.url_), this.loader_ && this.loader_(this.extent, this.resolution, this.projection));
  }
  /**
   * Handler for successful tile load.
   * @param {Array<FeatureType>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data projection.
   */
  onLoad(t, e) {
    this.setFeatures(t);
  }
  /**
   * Handler for tile load errors.
   */
  onError() {
    this.setState(F.ERROR);
  }
  /**
   * Function for use in a {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the features for the tile.
   * @param {Array<FeatureType>} features Features.
   * @api
   */
  setFeatures(t) {
    this.features_ = t, this.setState(F.LOADED);
  }
  /**
   * Set the feature loader for reading this tile's features.
   * @param {import("./featureloader.js").FeatureLoader<FeatureType>} loader Feature loader.
   * @api
   */
  setLoader(t) {
    this.loader_ = t;
  }
};
class ux extends u2 {
  /**
   * @param {!Options<FeatureType>} options Vector tile options.
   */
  constructor(t) {
    const e = t.projection || "EPSG:3857", n = t.extent || d2(e), r = t.tileGrid || lh({
      extent: n,
      maxResolution: t.maxResolution,
      maxZoom: t.maxZoom !== void 0 ? t.maxZoom : 22,
      minZoom: t.minZoom,
      tileSize: t.tileSize || 512
    });
    super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      cacheSize: t.cacheSize,
      interpolate: !0,
      projection: e,
      state: t.state,
      tileGrid: r,
      tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : fx,
      tileUrlFunction: t.tileUrlFunction,
      url: t.url,
      urls: t.urls,
      wrapX: t.wrapX === void 0 ? !0 : t.wrapX,
      transition: t.transition,
      zDirection: t.zDirection === void 0 ? 1 : t.zDirection
    }), this.format_ = t.format ? t.format : null, this.tileKeysBySourceTileUrl_ = {}, this.sourceTiles_ = {}, this.overlaps_ = t.overlaps == null ? !0 : t.overlaps, this.tileClass = t.tileClass ? t.tileClass : dx, this.tileGrids_ = {};
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection").default} projection Projection.
   * @param {VectorRenderTile} tile Vector render tile.
   * @return {Array<import("../VectorTile").default>} Tile keys.
   */
  getSourceTiles(t, e, n) {
    if (n.getState() === F.IDLE) {
      n.setState(F.LOADING);
      const r = n.wrappedTileCoord, s = this.getTileGridForProjection(e);
      let o = s.getTileCoordExtent(r);
      const a = r[0], l = s.getResolution(a);
      Ie(o, -l, o);
      const h = this.projection;
      e && this.projection && !Qt(e, h) && (o = Cs(o, e, h));
      const c = this.tileGrid, d = c.getExtent();
      d && Ve(o, d, o);
      let u = l;
      e && h && !Qt(e, h) && (u = l / h.getMetersPerUnit() / e.getMetersPerUnit());
      const f = c.getZForResolution(
        u,
        this.zDirection
      );
      c.forEachTileCoord(o, f, (g) => {
        const p = this.tileUrlFunction(
          g,
          t,
          e
        );
        this.sourceTiles_[p] || (this.sourceTiles_[p] = new this.tileClass(
          g,
          p ? F.IDLE : F.EMPTY,
          p,
          this.format_,
          this.tileLoadFunction
        ));
        const m = this.sourceTiles_[p];
        n.sourceTiles.push(m), this.tileKeysBySourceTileUrl_[p] || (this.tileKeysBySourceTileUrl_[p] = []), this.tileKeysBySourceTileUrl_[p].push(n.getKey());
        const _ = m.getState();
        if (_ < F.LOADED) {
          const y = (x) => {
            this.handleTileChange(x);
            const v = m.getState();
            if (v === F.LOADED || v === F.ERROR) {
              const C = m.getKey();
              C in n.errorTileKeys ? m.getState() === F.LOADED && delete n.errorTileKeys[C] : n.loadingSourceTiles--, v === F.ERROR ? n.errorTileKeys[C] = !0 : m.removeEventListener(V.CHANGE, y), n.loadingSourceTiles === 0 && n.setState(
                Zi(n.errorTileKeys) ? F.LOADED : F.ERROR
              );
            }
          };
          m.addEventListener(V.CHANGE, y), n.loadingSourceTiles++;
        }
        _ === F.IDLE && (m.extent = c.getTileCoordExtent(g), m.projection = this.projection, m.resolution = c.getResolution(
          g[0]
        ), m.load());
      }), n.loadingSourceTiles || n.setState(
        n.sourceTiles.some(
          (g) => g.getState() === F.ERROR
        ) ? F.ERROR : F.LOADED
      );
    }
    return n.sourceTiles;
  }
  /**
   * @param {VectorRenderTile} tile Vector render tile.
   */
  removeSourceTiles(t) {
    const e = t.getKey(), n = t.sourceTiles;
    for (let r = 0, s = n.length; r < s; ++r) {
      const o = n[r].getTileUrl();
      if (!this.tileKeysBySourceTileUrl_[o])
        return;
      const a = this.tileKeysBySourceTileUrl_[o].indexOf(e);
      a !== -1 && (this.tileKeysBySourceTileUrl_[o].splice(a, 1), this.tileKeysBySourceTileUrl_[o].length === 0 && (delete this.tileKeysBySourceTileUrl_[o], delete this.sourceTiles_[o]));
    }
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!VectorRenderTile} Tile.
   * @override
   */
  getTile(t, e, n, r, s) {
    const o = [t, e, n];
    let a = this.getTileCoordForTileUrlFunction(
      o,
      s
    );
    const l = this.getTileGrid().getExtent(), h = this.projection, c = this.getTileGridForProjection(s);
    if (a && l) {
      const f = c.getTileCoordExtent(a);
      Ie(f, -c.getResolution(t), f), bt(
        l,
        !s || !h || Qt(s, h) ? f : Cs(f, s, h)
      ) || (a = null);
    }
    let d = !0;
    if (a !== null) {
      const f = this.tileGrid, g = c.getResolution(t);
      let p = g;
      s && h && !Qt(s, h) && (p = g / h.getMetersPerUnit() / s.getMetersPerUnit());
      const m = f.getZForResolution(p, 1), _ = c.getTileCoordExtent(a);
      Ie(_, -g, _), f.forEachTileCoord(
        !s || !h || Qt(s, h) ? _ : Cs(_, s, h),
        m,
        (y) => {
          d = d && !this.tileUrlFunction(
            y,
            r,
            h
          );
        }
      );
    }
    const u = new cx(
      o,
      d ? F.EMPTY : F.IDLE,
      a,
      this.getSourceTiles.bind(this, r, s),
      this.removeSourceTiles.bind(this)
    );
    return u.key = this.getKey(), u;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   * @override
   */
  getTileGridForProjection(t) {
    const e = t.getCode();
    let n = this.tileGrids_[e];
    if (!n) {
      const r = this.projection;
      if (r !== null && !Qt(r, t))
        return ah(t);
      const s = this.tileGrid, o = s.getResolutions().slice(), a = o.map(function(c, d) {
        return s.getOrigin(d);
      }), l = o.map(function(c, d) {
        return s.getTileSize(d);
      }), h = rd + 1;
      for (let c = o.length; c < h; ++c)
        o.push(o[c - 1] / 2), a.push(a[c - 1]), l.push(l[c - 1]);
      n = new c2({
        extent: s.getExtent(),
        origins: a,
        resolutions: o,
        tileSizes: l
      }), this.tileGrids_[e] = n;
    }
    return n;
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   * @override
   */
  getTilePixelRatio(t) {
    return t;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   * @override
   */
  getTilePixelSize(t, e, n) {
    const r = this.getTileGridForProjection(n), s = Zt(r.getTileSize(t), this.tmpSize);
    return [
      Math.round(s[0] * e),
      Math.round(s[1] * e)
    ];
  }
  /**
   * @param {boolean} overlaps The source has overlapping geometries.
   */
  setOverlaps(t) {
    this.overlaps_ = t, this.changed();
  }
}
function fx(i, t) {
  i.setLoader(
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    function(e, n, r) {
      Hd(
        t,
        i.getFormat(),
        e,
        n,
        r,
        i.onLoad.bind(i),
        i.onError.bind(i)
      );
    }
  );
}
class gx extends hh {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(t) {
    const e = t.requestEncoding !== void 0 ? t.requestEncoding : "KVP", n = t.tileGrid;
    let r = t.urls;
    r === void 0 && t.url !== void 0 && (r = f3(t.url)), super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      cacheSize: t.cacheSize,
      crossOrigin: t.crossOrigin,
      interpolate: t.interpolate,
      projection: t.projection,
      reprojectionErrorThreshold: t.reprojectionErrorThreshold,
      tileClass: t.tileClass,
      tileGrid: n,
      tileLoadFunction: t.tileLoadFunction,
      tilePixelRatio: t.tilePixelRatio,
      urls: r,
      wrapX: t.wrapX !== void 0 ? t.wrapX : !1,
      transition: t.transition,
      zDirection: t.zDirection
    }), this.version_ = t.version !== void 0 ? t.version : "1.0.0", this.format_ = t.format !== void 0 ? t.format : "image/jpeg", this.dimensions_ = t.dimensions !== void 0 ? t.dimensions : {}, this.layer_ = t.layer, this.matrixSet_ = t.matrixSet, this.style_ = t.style, this.requestEncoding_ = e, this.setKey(this.getKeyForDimensions_()), r && r.length > 0 && (this.tileUrlFunction = Xa(
      r.map(this.createFromWMTSTemplate.bind(this))
    ));
  }
  /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   * @override
   */
  setUrls(t) {
    this.urls = t;
    const e = t.join(`
`);
    this.setTileUrlFunction(
      Xa(
        t.map(this.createFromWMTSTemplate.bind(this))
      ),
      e
    );
  }
  /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */
  getDimensions() {
    return this.dimensions_;
  }
  /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */
  getMatrixSet() {
    return this.matrixSet_;
  }
  /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {RequestEncoding} Request encoding.
   * @api
   */
  getRequestEncoding() {
    return this.requestEncoding_;
  }
  /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */
  getVersion() {
    return this.version_;
  }
  /**
   * @private
   * @return {string} The key for the current dimensions.
   */
  getKeyForDimensions_() {
    const t = this.urls ? this.urls.slice(0) : [];
    for (const e in this.dimensions_)
      t.push(e + "-" + this.dimensions_[e]);
    return t.join("/");
  }
  /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */
  updateDimensions(t) {
    Object.assign(this.dimensions_, t), this.setKey(this.getKeyForDimensions_());
  }
  /**
   * @param {string} template Template.
   * @return {import("../Tile.js").UrlFunction} Tile URL function.
   */
  createFromWMTSTemplate(t) {
    const e = this.requestEncoding_, n = {
      layer: this.layer_,
      style: this.style_,
      tilematrixset: this.matrixSet_
    };
    e == "KVP" && Object.assign(n, {
      Service: "WMTS",
      Request: "GetTile",
      Version: this.version_,
      Format: this.format_
    }), t = e == "KVP" ? Qs(t, n) : t.replace(/\{(\w+?)\}/g, function(o, a) {
      return a.toLowerCase() in n ? n[a.toLowerCase()] : o;
    });
    const r = (
      /** @type {import("../tilegrid/WMTS.js").default} */
      this.tileGrid
    ), s = this.dimensions_;
    return (
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      (function(o, a, l) {
        if (!o)
          return;
        const h = {
          TileMatrix: r.getMatrixId(o[0]),
          TileCol: o[1],
          TileRow: o[2]
        };
        Object.assign(h, s);
        let c = t;
        return e == "KVP" ? c = Qs(c, h) : c = c.replace(/\{(\w+?)\}/g, function(d, u) {
          return encodeURIComponent(h[u]);
        }), c;
      })
    );
  }
}
const mx = {
  GeoJSON: i2,
  MVT: xv
}, px = {
  Group: vi,
  Image: Rv,
  Tile: jv,
  Vector: yi,
  VectorTile: io
}, _x = {
  ImageWMS: p3,
  OSM: hx,
  Tile: y3,
  TileWMS: C3,
  Vector: e2,
  VectorTile: ux,
  WMTS: gx,
  XYZ: x3
};
function Dr(i, t, e = !0) {
  t = JSON.parse(JSON.stringify(t));
  const r = {
    ...window.eoxMapAdvancedOlLayers,
    ...px
  }[t.type];
  if (!r)
    throw new Error(`Layer type ${t.type} not supported!`);
  const s = new r({
    ...t,
    ...t.type !== "MapboxStyle" && t.source && {
      source: b3(t.source)
    },
    ...t.type === "Group" && { layers: [] },
    // Initialize an empty layer collection for group layers
    ...t.properties,
    style: void 0
    // Reset the style; it will be applied later if specified
  });
  if (s.set("_jsonDefinition", t, !0), t.type === "Group") {
    const o = t.layers.reverse().map((a) => Dr(i, a));
    o.forEach((a) => a.set("_group", s, !0)), s.setLayers(
      new Dt(o)
    );
  }
  if ("style" in t && s.setStyle(
    /** @type {import("../layers").EOxLayerType<"Vector","Vector">} **/
    t.style
  ), e && t.interactions?.length)
    for (let o = 0; o < t.interactions.length; o++) {
      const a = t.interactions[o];
      w3(
        i,
        /** @type {SelectLayer} **/
        s,
        a
      );
    }
  return S3(s, t), s;
}
function b3(i) {
  const e = {
    ...window.eoxMapAdvancedOlSources,
    ..._x
  }[i.type];
  if (i && !e)
    throw new Error(`Source type ${i.type} not supported!`);
  const n = {
    ...window.eoxMapAdvancedOlFormats,
    ...mx
  }, r = Mx(i);
  return new e({
    ...i,
    ..."format" in i && i.type !== "WMTS" && {
      // Set the format (e.g., GeoJSON, MVT) for the source
      format: new n[typeof i.format == "object" ? i.format.type : i.format]({
        ...typeof i.format == "object" && {
          ...i.format
        }
      })
    },
    // cluster layers can have their own (sub) source
    ..."source" in i && {
      source: b3(
        /** @type {import("../layers").EoxSource<any>} */
        i.source
      )
    },
    // Set the format (e.g., GeoJSON, MVT) for the source
    ..."tileGrid" in i && { tileGrid: r },
    // Set the projection, converting it using OpenLayers' `getProjection` method
    ..."projection" in i && {
      projection: tt(i.projection)
    }
  });
}
function w3(i, t, e) {
  e.type === "draw" ? ev(
    i,
    /** @type {import("ol/layer/Vector").default} **/
    t,
    /** @type {DrawOptions} **/
    e.options
  ) : e.type === "select" ? xx(
    i,
    t,
    /** @type {SelectOptions} **/
    e.options
  ) : e.type === "clusterExplode" && Sx(
    i,
    /** @type {import("ol/layer/Vector").default<import("ol/source/Cluster").default>} */
    t,
    /** @type {import("../types").ClusterExplodeOptions} */
    e.options
  );
}
function E3(i, t, e) {
  const n = (
    /** @type {EoxLayer} **/
    e.get("_jsonDefinition")
  );
  if (t.type !== n.type || t.type !== "MapboxStyle" && t.source?.type !== n.source?.type)
    throw new Error("Layers are not compatible to be updated");
  const r = Dr(i, t, !1);
  if (t.type !== "MapboxStyle" && JSON.stringify(t.source) !== JSON.stringify(n.source) && /** @type {any} **/
  e.setSource(
    /** @type {import("ol/layer").Vector<import("ol/source").Vector>} **/
    /** @type {any} **/
    r.getSource()
  ), t.type === "MapboxStyle" && JSON.stringify(t.properties.mapboxStyle) !== JSON.stringify(n.properties.mapboxStyle) && (e.getLayers().clear(), e.applyMapboxStyle(
    t.properties.mapboxStyle,
    t.properties.applyOptions
  )), ["Vector", "VectorTile"].includes(t.type) && JSON.stringify(
    /** @type {import("../layers.ts").EOxLayerType<"Vector"|"VectorTile",any>} */
    t.style
  ) !== JSON.stringify(n.style) && e.setStyle(r.getStyle()), JSON.stringify(t.properties) !== JSON.stringify(n.properties) && e.setProperties(t.properties), t.visible !== n.visible && e.setVisible(t.visible), t.opacity && t.opacity !== n.opacity && e.setOpacity(t.opacity), JSON.stringify(t.interactions) !== JSON.stringify(n.interactions) && (n.interactions?.forEach(
    /** @param {EOxInteraction} interactionDefinition **/
    (s) => {
      const o = t.interactions.find(
        (a) => a.type === s.type && a.options?.id === s.options?.id
      );
      o ? o.type === "draw" ? (i.interactions[o.options.id].setActive(
        o.options.active
      ), i.interactions[`${o.options.id}_modify`].setActive(
        o.options.modify
      )) : (i.selectInteractions[o.options.id] || i.interactions[o.options.id]).setActive(o.options.active) : s.type === "select" ? i.removeSelect(s.options.id) : i.removeInteraction(s.options.id);
    }
  ), t.interactions?.forEach((s) => {
    n.interactions.find(
      /** @param {EOxInteraction} i **/
      (a) => a.type === s.type && a.options?.id === s.options?.id
    ) || w3(
      i,
      /** @type {SelectLayer} **/
      /** @type {any} **/
      e,
      s
    );
  })), t.type === "Group") {
    const s = t.layers.map((h) => h.properties?.id), o = e.getLayers();
    o.getArray().slice().forEach((h) => {
      s.includes(h.get("id")) || o.remove(h);
    }), t.layers.forEach((h) => {
      const c = h.properties.id;
      if (o.getArray().map(
        (d) => d.get("id")
      ).includes(c))
        E3(
          i,
          h,
          i.getLayerById(c)
        );
      else {
        const d = Dr(i, h);
        o.push(d);
      }
    });
    const l = s.toReversed();
    o.getArray().sort(
      (h, c) => l.indexOf(h.get("id")) - l.indexOf(c.get("id"))
    ), o.changed();
  }
  return S3(e, t), e.set("_jsonDefinition", t, !0), e;
}
const yx = (i, t) => t ? [...t].reverse().map((e) => Dr(i, e)) : [];
function S3(i, t) {
  i.on("change:opacity", () => {
    t.opacity = i.getOpacity();
  }), i.on("change:visible", () => {
    t.visible = i.getVisible();
  }), i.on("change:zIndex", () => {
    t.zIndex = i.getZIndex();
  }), i.on("propertychange", (e) => {
    e.key !== "map" && (t.properties[e.key] = e.target.get(e.key));
  });
}
class vx {
  /**
   * @param {EOxMap} eoxMap - Instance of the EOxMap class.
   * @param {import("../types").SelectLayer} anyLayer - Layer for selection.
   * @param {SelectOptions} options - Options for the selection interaction.
   */
  constructor(t, e, n) {
    this.eoxMap = t, this.selectLayer = e, this.options = n, this.active = n.active || e.getVisible(), this.panIn = n.panIn || !1, this.tooltip = n.tooltip !== !1;
    const r = this.eoxMap.map.getOverlayById("eox-map-tooltip");
    let s;
    this.tooltip && (r ? (this.tooltipElement = r.getElement(), s = r) : (this.tooltipElement = this.eoxMap.querySelector("eox-map-tooltip") || this.eoxMap.querySelector("[is=eox-map-tooltip]") || n.overlay?.element, this.tooltipElement && (s = new r3({
      // @ts-expect-error - Type 'Element' is missing the following properties from type 'HTMLElement'
      element: this.tooltipElement,
      position: void 0,
      offset: [0, 0],
      positioning: "top-left",
      className: "eox-map-tooltip",
      id: "eox-map-tooltip",
      ...n.overlay
    }), this.eoxMap.map.addOverlay(s))));
    const o = () => {
      s && n.condition === "pointermove" && s.setPosition(void 0);
    };
    t.map.on("change:target", (h) => {
      h.oldValue?.removeEventListener("pointerleave", o), h.target.getTargetElement()?.addEventListener("pointerleave", o);
    }), t.map.getTargetElement()?.addEventListener("pointerleave", o);
    const a = (h) => {
      n?.projection && (En.defs(n.projection?.name) || (En.defs(
        n.projection?.name,
        n?.projection?.proj4_string
      ), h2(En)));
      const c = tt(
        n?.projection?.name || "EPSG:4326"
      ), d = t.map.getView().getProjection().getCode(), u = tn(
        h.coordinate,
        d,
        c
      );
      return {
        lon: u[0].toFixed(n?.precision || 2),
        lat: u[1].toFixed(n?.precision || 2)
      };
    }, l = (h) => Object.values(h).every((c) => c === 0);
    if (this.selectLayer instanceof yi || this.selectLayer instanceof io) {
      this.selectedFids = [];
      let h;
      if (this.options.layer)
        h = this.options.layer;
      else {
        const u = this.selectLayer.get("_jsonDefinition");
        h = {
          ...u,
          style: n.style,
          properties: {
            id: this.selectLayer.get("id") + "_select"
          },
          source: {
            type: u.type
          }
        };
      }
      h.renderMode = "vector", delete h.interactions, this.selectStyleLayer = /** @type {VectorLayer<import("ol/source").Vector>|VectorTile<import("ol/source").VectorTile>} */
      Dr(t, h), this.selectStyleLayer.setSource(this.selectLayer.getSource()), this.selectStyleLayer.setMap(this.eoxMap.map);
      const c = this.selectStyleLayer.getStyleFunction();
      this.selectStyleLayer.setStyle(
        /**
         * @param {import("ol/Feature").FeatureLike} feature
         * @param {number} resolution
         * **/
        (u, f) => this.selectedFids.length && this.selectedFids.includes(this.getId(u)) ? c(u, f) : null
      ), this.listener = (u) => {
        if (!this.active || u.dragging)
          return;
        const f = this.eoxMap.map.getView().getZoom();
        if (f < this.selectLayer.getMinZoom() || f > this.selectLayer.getMaxZoom())
          return;
        const g = this.eoxMap.map.forEachFeatureAtPixel(
          u.pixel,
          (y) => y,
          { layerFilter: (y) => y === this.selectLayer }
        ), p = g ? [this.getId(g)] : [], m = this.selectedFids[0] !== p[0];
        if (this.selectedFids = p, m && (this.selectStyleLayer.changed(), g && this.panIn && this.panIntoFeature(g)), s) {
          const y = u.pixel[0] > this.eoxMap.offsetWidth / 2 ? "right" : "left", x = u.pixel[1] > this.eoxMap.offsetHeight / 2 ? "bottom" : "top";
          s.setPositioning(`${x}-${y}`), s.setPosition(g ? u.coordinate : null), g && this.tooltipElement && (this.tooltipElement.feature = g);
        }
        const _ = new CustomEvent("select", {
          detail: {
            id: n.id,
            originalEvent: u,
            feature: g
          }
        });
        this.eoxMap.dispatchEvent(_);
      }, this.eoxMap.map.on(n.condition || "click", this.listener), this.selectLayer.on("change:opacity", () => {
        this.selectStyleLayer.setOpacity(this.selectLayer.getOpacity());
      }), this.selectLayer.on("change:visible", () => {
        const u = this.selectLayer.getVisible();
        this.selectStyleLayer.setVisible(u), this.setActive(u);
      }), this.changeSourceListener = () => {
        this.selectStyleLayer.setSource(this.selectLayer.getSource());
      }, this.selectLayer.on("change:source", this.changeSourceListener);
      const d = () => {
        t.getLayerById(e.get("id")) ? (this.selectStyleLayer?.setMap(this.eoxMap.map), s?.setMap(this.eoxMap.map)) : (this.selectStyleLayer?.setMap(null), s?.setMap(null));
      };
      t.map.getLayerGroup().on("change", d), this.pointerMoveListener = (u) => {
        u.dragging || (t.map.getTargetElement().style.cursor = t.map.hasFeatureAtPixel(u.pixel, {
          layerFilter: (f) => f.get("_jsonDefinition")?.interactions?.find(
            (g) => g.type == "select" && g.options?.condition === "click"
          ),
          ...n.atPixelOptions
        }) ? n.cursor || "pointer" : this.eoxMap.interactions.drawInteraction?.getActive() ? "crosshair" : "auto");
      }, t.map.on("pointermove", this.pointerMoveListener);
    }
    (this.selectLayer.getSource() instanceof p3 || this.selectLayer.getSource() instanceof C3) && (this.listener = (h) => {
      if (!this.active || h.dragging)
        return;
      const c = t.map.getView().getResolution(), d = (
        /** @type {ImageWMS | TileWMS} */
        this.selectLayer.getSource().getFeatureInfoUrl(
          h.coordinate,
          c,
          t.map.getView().getProjection(),
          { INFO_FORMAT: "application/json" }
        )
      );
      d && fetch(d).then((u) => u.text()).then((u) => {
        if (s) {
          const f = h.pixel[0] > this.eoxMap.offsetWidth / 2 ? "right" : "left", g = h.pixel[1] > this.eoxMap.offsetHeight / 2 ? "bottom" : "top";
          s.setPositioning(`${g}-${f}`);
        }
        if (u && this.tooltipElement) {
          const f = JSON.parse(u);
          let g;
          f.type === "FeatureCollection" && f.features.length > 0 ? g = f.features[0] : f.type === "Feature" ? (g = f, this.tooltipElement.innerHTML = `<pre>${JSON.stringify(g.properties, null, 2)}</pre>`) : s?.setPosition(null), n?.coordinates && g && Object.assign(g?.properties, a(h));
          const p = new Lt({
            ...g?.properties
          });
          this.tooltipElement.feature = p, s.setPosition(g ? h.coordinate : null);
        }
      });
    }, n.condition == "click" && this.eoxMap.map.on(n.condition, this.listener)), this.selectLayer.getProperties()?.type === "WebGLTile" && (this.listener = (h) => {
      if (!this.active || h.dragging)
        return;
      const c = this.selectLayer.getData(h.pixel);
      if (c) {
        if (s) {
          const d = h.pixel[0] > this.eoxMap.offsetWidth / 2 ? "right" : "left", u = h.pixel[1] > this.eoxMap.offsetHeight / 2 ? "bottom" : "top";
          s.setPositioning(`${u}-${d}`), s.setPosition(h.coordinate);
          let f = {};
          for (const [g, p] of c.entries()) {
            const m = (g + 1).toString();
            f[`band${m}`] = p;
          }
          if (l(f))
            s?.setPosition(null);
          else if (this.tooltipElement) {
            n?.coordinates && Object.assign(f, a(h));
            const g = new Lt({
              ...f
            });
            this.tooltipElement.feature = g, s.setPosition(
              Object.keys(f).length > 0 ? h.coordinate : null
            );
          }
        }
      } else
        s?.setPosition(null);
    }, this.eoxMap.map.on(n.condition || "click", this.listener));
  }
  /**
   * Sets the active state of the interaction.
   * @param {boolean} active - Whether the interaction should be active.
   */
  setActive(t) {
    this.active = t;
  }
  /**
   * Pans the map to the specified feature or extent.
   * @param {Feature | RenderFeature | import("ol/extent").Extent} featureOrExtent - The feature or extent to pan to.
   * @param {Object} [options] - Additional options for the panning animation.
   */
  panIntoFeature = (t, e) => {
    const n = t instanceof Lt || t instanceof Xt ? t.getGeometry().getExtent() : t;
    this.eoxMap.map.getView().fit(n, e || { duration: 750 });
  };
  /**
   * Highlights features by their IDs and optionally pans into their extent.
   * @param {Array<string | number>} ids - Array of feature IDs to highlight.
   * @param {Object} [fitOptions] - Options for panning into the highlighted features.
   */
  highlightById(t, e) {
    if (this.selectedFids = t, t.length && e) {
      const n = ne();
      if (this.selectLayer instanceof yi)
        for (let r = 0; r < this.selectedFids.length; r++) {
          const s = this.selectedFids[r], o = (
            /** @type {Feature} */
            this.selectLayer.getSource().getFeatureById(s)
          );
          o && o.getGeometry() && Ds(n, o.getGeometry().getExtent());
        }
      else if (this.selectLayer instanceof io) {
        const r = this.eoxMap.map, s = this.selectLayer.getFeaturesInExtent(
          r.getView().calculateExtent(r.getSize())
        );
        for (let o = 0; o < s.length; o++) {
          const a = s[o];
          this.selectedFids.includes(this.getId(a)) && Ds(n, a.getGeometry().getExtent());
        }
      }
      Qi(n) || this.panIntoFeature(n, e);
    }
    this.selectStyleLayer.changed();
  }
  /**
   * Removes the selection interaction and associated layers from the map.
   */
  remove() {
    this.eoxMap.map.un(this.options.condition || "click", this.listener), (this.selectLayer instanceof yi || this.selectLayer instanceof io) && (this.selectStyleLayer.setMap(null), delete this.eoxMap.selectInteractions[this.options.id], this.selectLayer.un("change:source", this.changeSourceListener), this.eoxMap.map.un("pointermove", this.pointerMoveListener));
  }
  /**
   * Retrieves the ID of the given feature.
   * @param {Feature | RenderFeature} feature - The feature whose ID is to be retrieved.
   * @returns {string | number} - The ID of the feature.
   * @throws Will throw an error if no valid ID is found.
   */
  getId(t) {
    if (this.options.idProperty)
      return t.get(this.options.idProperty);
    if (t.getId() !== void 0)
      return t.getId();
    if (t.get("id") !== void 0)
      return t.get("id");
    if (Y(t) !== void 0)
      return Y(t);
    throw Error(
      "No feature id found. Please provide which feature property should be taken instead using idProperty."
    );
  }
}
function xx(i, t, e) {
  if (i.interactions[e.id])
    throw Error(`Interaction with id: ${e.id} already exists.`);
  return i.selectInteractions[e.id] = new vx(
    i,
    t,
    // @ts-expect-error - Argument of type 'DrawOptions | SelectOptions' is not assignable to parameter of type 'SelectOptions'
    e
  ), i.selectInteractions[e.id];
}
const Cx = 1, bx = 28, wx = Math.PI / 2;
class Ex extends $r {
  /**
   * @param {EOxMap} eoxMap - Instance of the EOxMap class.
   * @param {import("ol/layer/Vector").default<import("ol/source/Cluster").default>} clusterLayer - Vector Layer with Cluster Source for the interaction.
   * @param {ClusterExplodeOptions} options - Options for the selection interaction.
   */
  constructor(t, e, n) {
    super(n), this.clusterLayer = e, this.eoxMap = t;
    const r = {
      maxZoom: 20,
      atPixelOptions: {},
      fitOptions: {
        duration: 500,
        padding: [40, 40, 40, 40]
      }
    }, s = structuredClone(n);
    s.fitOptions && (r.fitOptions = {
      ...r.fitOptions,
      ...s.fitOptions
    }, delete s.fitOptions), this.#t = { ...r, ...s }, this.active = n.active || e.getVisible();
    const o = new yi();
    o.setStyle(n.style), this.#n = o.getStyleFunction();
  }
  #t = null;
  #n = null;
  #e = null;
  #s(t, e) {
    const n = new CustomEvent("clusterSelect", {
      detail: {
        originalEvent: t,
        feature: e
      }
    });
    this.eoxMap.dispatchEvent(n);
  }
  #i() {
    this.#e && (this.#e.setStyle(void 0), this.#e = null);
  }
  handleEvent(t) {
    if (!this.getActive())
      return !0;
    if (t.type === "pointermove") {
      const e = this.eoxMap.map.hasFeatureAtPixel(t.pixel, {
        layerFilter: (n) => n === this.clusterLayer,
        ...this.#t.atPixelOptions
      });
      return this.eoxMap.map.getTargetElement().style.cursor = e ? "pointer" : "default", !e;
    }
    if (t.type === "click") {
      const e = this.eoxMap.map.getFeaturesAtPixel(t.pixel, {
        layerFilter: (o) => o === this.clusterLayer,
        ...this.#t.atPixelOptions
      });
      if (e.length === 0)
        return this.#i(), !0;
      const n = e[0], r = n.get("features");
      if (r.length === 1)
        return this.#s(t, r[0]), this.#i(), !0;
      if (this.#e && this.#e === n) {
        const o = this.#l(
          /** @type {import("ol/Feature").default<import("ol/geom/Point").default>} */
          n,
          t.coordinate
        );
        this.#s(t, o.feature);
      }
      if (this.eoxMap.map.getView().getZoom() > this.#t.maxZoom - 1)
        return this.#r(n), !1;
      const s = ne();
      return r.forEach((o) => {
        Ds(s, o.getGeometry().getExtent());
      }), oo(s) < 100 ? (this.#r(n), !1) : (this.#a(s).then((o) => {
        o || this.#r(n);
      }), !1);
    }
    return !0;
  }
  /**
   * Sets the active state of the interaction.
   * @param {boolean} active - Whether the interaction should be active.
   */
  setActive(t) {
    t || (this.#i(), this.eoxMap.map.getTargetElement().style.cursor = "default"), super.setActive(t);
  }
  setMap(t) {
    t || (this.#i(), this.eoxMap.map.getTargetElement().style.cursor = "default"), super.setMap(t);
  }
  /**
   * Pans the map to the specified extent.
   * @param {import("ol/extent").Extent} extent - The feature or extent to pan to.
   * @returns {Promise<boolean>} Resolves to true if the map was zoomed, false otherwise.
   */
  #a = (t) => new Promise((e) => {
    const n = this.eoxMap.map.getView().getZoom(), r = { ...this.#t.fitOptions };
    r.callback = (s) => {
      e(this.eoxMap.map.getView().getZoom() !== n), this.#t.fitOptions.callback?.(s);
    }, this.eoxMap.map.getView().fit(t, r);
  });
  #r(t) {
    this.#e && this.#i();
    const e = t.getGeometry().getCoordinates(), n = t.get("features"), r = this.#o(
      n.length,
      e,
      this.eoxMap.map.getView().getResolution()
    ).reduce(
      /**
       * @param {Array<import("ol/style/Style").default>} styles
       * @param {Array<number>} coordinates
       * @param {number} i
       * @returns {Array<import("ol/style/Style").default>} styles
       */
      (s, o, a) => {
        const l = new de(o), h = new Kt([e, o]);
        s.unshift(
          new At({
            geometry: h,
            stroke: new Ae({
              color: "rgba(50, 50, 50, 0.5)",
              width: 2.5
            })
          })
        );
        const c = new Lt({
          ...n[a].getProperties()
        }), d = this.#n(
          c,
          this.eoxMap.map.getView().getResolution()
        );
        return d?.length && d.forEach((u) => {
          const f = u.clone();
          f.setGeometry(l), s.unshift(f);
        }), s;
      },
      []
    );
    t.setStyle(r), this.#e = t;
  }
  /**
   * get the cluster member of an (open) cluster feature by calculating the points circle
   * @param {Feature<Point>} openClusterFeature cluster feature
   * @param {Array} coordinate coordinate
   * @returns {*} Object with feature and calculated coords
   */
  #l(t, e) {
    const n = t.get("features"), r = this.#o(
      n.length,
      t.getGeometry().getCoordinates(),
      this.eoxMap.map.getView().getResolution()
    );
    let s = 1 / 0, o;
    for (let a = 0, l = r.length; a < l; ++a) {
      const h = (e[0] - r[a][0]) ** 2 + (e[1] - r[a][1]) ** 2;
      h < s && (o = a, s = h);
    }
    return { feature: n[o], coords: r[o] };
  }
  /**
   * From
   * https://github.com/Leaflet/Leaflet.markercluster/blob/31360f2/src/MarkerCluster.Spiderfier.js#L55-L72
   * Arranges points in a circle around the cluster center, with a line pointing from the center to
   * each point.
   * @param {number} count Number of cluster members.
   * @param {Array<number>} clusterCenter Center coordinate of the cluster.
   * @param {number} resolution Current view resolution.
   * @return {Array<Array<number>>} An array of coordinates representing the cluster members.
   */
  #o(t, e, n) {
    let s = Cx * bx * (2 + t) / (Math.PI * 2);
    const o = Math.PI * 2 / t, a = [];
    let l;
    s = Math.max(s, 35) * n;
    for (let h = 0; h < t; ++h)
      l = wx + h * o, a.push([
        e[0] + s * Math.cos(l),
        e[1] + s * Math.sin(l)
      ]);
    return a;
  }
  /**
   * Removes the cluster interaction from the map.
   */
  remove() {
    this.setMap(null);
  }
}
function Sx(i, t, e) {
  if (i.interactions[e.id])
    throw Error(`Interaction with id: ${e.id} already exists.`);
  const n = new Ex(
    i,
    t,
    e
  );
  i.interactions[e.id] = n, i.map.addInteraction(n);
}
function Mx(i) {
  let t;
  if (!(!i || !("tileGrid" in i))) {
    if (i.type === "WMTS") {
      const n = tt("EPSG:3857").getExtent(), r = it(n) / 128, s = new Array(19), o = new Array(19);
      for (let a = 0; a < 19; ++a)
        s[a] = r / Math.pow(2, a), o[a] = a;
      t = new ex({
        resolutions: s,
        origin: Xe(n),
        // @ts-expect-error - 'projection' not specified inside WMTS.d.ts types
        projection: i.tileGrid.projection || "EPSG:3857",
        matrixIds: o,
        // @ts-expect-error source.tilegrid needs to be defined and spreadable
        ...i.tileGrid
      });
    } else
      t = lh({
        // @ts-expect-error source.tilegrid needs to be defined and spreadable
        ...i.tileGrid
      });
    return t;
  }
}
function ch(i, t) {
  return M3(i.map.getLayers().getArray()).find((n) => n.get("id") === t);
}
function M3(i) {
  const t = [];
  t.push(...i);
  let e = t.filter((n) => n instanceof vi);
  for (; e.length; ) {
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const s = (
        /** @type {import("ol/layer").Group} */
        /**@type {unknown}*/
        e[r].getLayers().getArray()
      );
      t.push(...s), n.push(
        ...s.filter((o) => o instanceof vi)
      );
    }
    e = n;
  }
  return t;
}
function Za(i) {
  const t = Object.assign({}, i.animationOptions), e = i.map.getView();
  if (ru(e), !t || !Object.keys(t).length) {
    e.setCenter(i.center), e.setZoom(i.zoom);
    return;
  }
  t.center = n3(i.center), t.zoom = i.zoom, e.animate(t);
}
const oa = "units", Tx = [1, 2, 5], as = 25.4 / 0.28;
class Rx extends Ze {
  /**
   * @param {Options} [options] Scale line options.
   */
  constructor(t) {
    t = t || {};
    const e = document.createElement("div");
    e.style.pointerEvents = "none", super({
      element: e,
      render: t.render,
      target: t.target
    }), this.on, this.once, this.un;
    const n = t.className !== void 0 ? t.className : t.bar ? "ol-scale-bar" : "ol-scale-line";
    this.innerElement_ = document.createElement("div"), this.innerElement_.className = n + "-inner", this.element.className = n + " " + si, this.element.appendChild(this.innerElement_), this.viewState_ = null, this.minWidth_ = t.minWidth !== void 0 ? t.minWidth : 64, this.maxWidth_ = t.maxWidth, this.renderedVisible_ = !1, this.renderedWidth_ = void 0, this.renderedHTML_ = "", this.addChangeListener(oa, this.handleUnitsChanged_), this.setUnits(t.units || "metric"), this.scaleBar_ = t.bar || !1, this.scaleBarSteps_ = t.steps || 4, this.scaleBarText_ = t.text || !1, this.dpi_ = t.dpi || void 0;
  }
  /**
   * Return the units to use in the scale line.
   * @return {Units} The units
   * to use in the scale line.
   * @observable
   * @api
   */
  getUnits() {
    return this.get(oa);
  }
  /**
   * @private
   */
  handleUnitsChanged_() {
    this.updateElement_();
  }
  /**
   * Set the units to use in the scale line.
   * @param {Units} units The units to use in the scale line.
   * @observable
   * @api
   */
  setUnits(t) {
    this.set(oa, t);
  }
  /**
   * Specify the dpi of output device such as printer.
   * @param {number|undefined} dpi The dpi of output device.
   * @api
   */
  setDpi(t) {
    this.dpi_ = t;
  }
  /**
   * @private
   */
  updateElement_() {
    const t = this.viewState_;
    if (!t) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const e = t.center, n = t.projection, r = this.getUnits(), s = r == "degrees" ? "degrees" : "m";
    let o = Lr(
      n,
      t.resolution,
      e,
      s
    );
    const a = this.minWidth_ * (this.dpi_ || as) / as, l = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || as) / as : void 0;
    let h = a * o, c = "";
    if (r == "degrees") {
      const x = Ir.degrees;
      h *= x, h < x / 60 ? (c = "", o *= 3600) : h < x ? (c = "", o *= 60) : c = "";
    } else if (r == "imperial")
      h < 0.9144 ? (c = "in", o /= 0.0254) : h < 1609.344 ? (c = "ft", o /= 0.3048) : (c = "mi", o /= 1609.344);
    else if (r == "nautical")
      o /= 1852, c = "NM";
    else if (r == "metric")
      h < 1e-6 ? (c = "nm", o *= 1e9) : h < 1e-3 ? (c = "m", o *= 1e6) : h < 1 ? (c = "mm", o *= 1e3) : h < 1e3 ? c = "m" : (c = "km", o /= 1e3);
    else if (r == "us")
      h < 0.9144 ? (c = "in", o *= 39.37) : h < 1609.344 ? (c = "ft", o /= 0.30480061) : (c = "mi", o /= 1609.3472);
    else
      throw new Error("Invalid units");
    let d = 3 * Math.floor(Math.log(a * o) / Math.log(10)), u, f, g, p = 0, m, _;
    for (; ; ) {
      g = Math.floor(d / 3);
      const x = Math.pow(10, g);
      if (u = Tx[(d % 3 + 3) % 3] * x, f = Math.round(u / o), isNaN(f)) {
        this.element.style.display = "none", this.renderedVisible_ = !1;
        return;
      }
      if (l !== void 0 && f >= l) {
        u = p, f = m, g = _;
        break;
      } else if (f >= a)
        break;
      p = u, m = f, _ = g, ++d;
    }
    const y = this.scaleBar_ ? this.createScaleBar(f, u, c) : u.toFixed(g < 0 ? -g : 0) + " " + c;
    this.renderedHTML_ != y && (this.innerElement_.innerHTML = y, this.renderedHTML_ = y), this.renderedWidth_ != f && (this.innerElement_.style.width = f + "px", this.renderedWidth_ = f), this.renderedVisible_ || (this.element.style.display = "", this.renderedVisible_ = !0);
  }
  /**
   * @private
   * @param {number} width The current width of the scalebar.
   * @param {number} scale The current scale.
   * @param {string} suffix The suffix to append to the scale text.
   * @return {string} The stringified HTML of the scalebar.
   */
  createScaleBar(t, e, n) {
    const r = this.getScaleForResolution(), s = r < 1 ? Math.round(1 / r).toLocaleString() + " : 1" : "1 : " + Math.round(r).toLocaleString(), o = this.scaleBarSteps_, a = t / o, l = [this.createMarker("absolute")];
    for (let c = 0; c < o; ++c) {
      const d = c % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
      l.push(
        `<div><div class="ol-scale-singlebar ${d}" style="width: ${a}px;"></div>` + this.createMarker("relative") + // render text every second step, except when only 2 steps
        (c % 2 === 0 || o === 2 ? this.createStepText(c, t, !1, e, n) : "") + "</div>"
      );
    }
    return l.push(this.createStepText(o, t, !0, e, n)), (this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${t}px;">` + s + "</div>" : "") + l.join("");
  }
  /**
   * Creates a marker at given position
   * @param {'absolute'|'relative'} position The position, absolute or relative
   * @return {string} The stringified div containing the marker
   */
  createMarker(t) {
    return `<div class="ol-scale-step-marker" style="position: ${t}; top: ${t === "absolute" ? 3 : -10}px;"></div>`;
  }
  /**
   * Creates the label for a marker marker at given position
   * @param {number} i The iterator
   * @param {number} width The width the scalebar will currently use
   * @param {boolean} isLast Flag indicating if we add the last step text
   * @param {number} scale The current scale for the whole scalebar
   * @param {string} suffix The suffix for the scale
   * @return {string} The stringified div containing the step text
   */
  createStepText(t, e, n, r, s) {
    const a = (t === 0 ? 0 : Math.round(r / this.scaleBarSteps_ * t * 100) / 100) + (t === 0 ? "" : " " + s), l = t === 0 ? -3 : e / this.scaleBarSteps_ * -1, h = t === 0 ? 0 : e / this.scaleBarSteps_ * 2;
    return `<div class="ol-scale-step-text" style="margin-left: ${l}px;text-align: ${t === 0 ? "left" : "center"};min-width: ${h}px;left: ${n ? e + "px" : "unset"};">` + a + "</div>";
  }
  /**
   * Returns the appropriate scale for the given resolution and units.
   * @return {number} The appropriate scale.
   */
  getScaleForResolution() {
    const t = Lr(
      this.viewState_.projection,
      this.viewState_.resolution,
      this.viewState_.center,
      "m"
    ), e = this.dpi_ || as, n = 1e3 / 25.4;
    return t * n * e;
  }
  /**
   * Update the scale line element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(t) {
    const e = t.frameState;
    e ? this.viewState_ = e.viewState : this.viewState_ = null, this.updateElement_();
  }
}
const h1 = ["fullscreenchange", "webkitfullscreenchange"], c1 = {
  /**
   * Triggered after the map entered fullscreen.
   * @event FullScreenEventType#enterfullscreen
   * @api
   */
  ENTERFULLSCREEN: "enterfullscreen",
  /**
   * Triggered after the map leave fullscreen.
   * @event FullScreenEventType#leavefullscreen
   * @api
   */
  LEAVEFULLSCREEN: "leavefullscreen"
};
class Px extends Ze {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super({
      element: document.createElement("div"),
      target: t.target
    }), this.on, this.once, this.un, this.keys_ = t.keys !== void 0 ? t.keys : !1, this.source_ = t.source, this.isInFullscreen_ = !1, this.boundHandleMapTargetChange_ = this.handleMapTargetChange_.bind(this), this.cssClassName_ = t.className !== void 0 ? t.className : "ol-full-screen", this.documentListeners_ = [], this.activeClassName_ = t.activeClassName !== void 0 ? t.activeClassName.split(" ") : [this.cssClassName_ + "-true"], this.inactiveClassName_ = t.inactiveClassName !== void 0 ? t.inactiveClassName.split(" ") : [this.cssClassName_ + "-false"];
    const e = t.label !== void 0 ? t.label : "";
    this.labelNode_ = typeof e == "string" ? document.createTextNode(e) : e;
    const n = t.labelActive !== void 0 ? t.labelActive : "";
    this.labelActiveNode_ = typeof n == "string" ? document.createTextNode(n) : n;
    const r = t.tipLabel ? t.tipLabel : "Toggle full-screen";
    this.button_ = document.createElement("button"), this.button_.title = r, this.button_.setAttribute("type", "button"), this.button_.appendChild(this.labelNode_), this.button_.addEventListener(
      V.CLICK,
      this.handleClick_.bind(this),
      !1
    ), this.setClassName_(this.button_, this.isInFullscreen_), this.element.className = `${this.cssClassName_} ${si} ${zn}`, this.element.appendChild(this.button_);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(t) {
    t.preventDefault(), this.handleFullScreen_();
  }
  /**
   * @private
   */
  handleFullScreen_() {
    const t = this.getMap();
    if (!t)
      return;
    const e = t.getOwnerDocument();
    if (d1(e))
      if (u1(e))
        kx(e);
      else {
        let n;
        this.source_ ? n = typeof this.source_ == "string" ? e.getElementById(this.source_) : this.source_ : n = t.getTargetElement(), this.keys_ ? Ix(n) : T3(n);
      }
  }
  /**
   * @private
   */
  handleFullScreenChange_() {
    const t = this.getMap();
    if (!t)
      return;
    const e = this.isInFullscreen_;
    this.isInFullscreen_ = u1(t.getOwnerDocument()), e !== this.isInFullscreen_ && (this.setClassName_(this.button_, this.isInFullscreen_), this.isInFullscreen_ ? (Ar(this.labelActiveNode_, this.labelNode_), this.dispatchEvent(c1.ENTERFULLSCREEN)) : (Ar(this.labelNode_, this.labelActiveNode_), this.dispatchEvent(c1.LEAVEFULLSCREEN)), t.updateSize());
  }
  /**
   * @param {HTMLElement} element Target element
   * @param {boolean} fullscreen True if fullscreen class name should be active
   * @private
   */
  setClassName_(t, e) {
    e ? (t.classList.remove(...this.inactiveClassName_), t.classList.add(...this.activeClassName_)) : (t.classList.remove(...this.activeClassName_), t.classList.add(...this.inactiveClassName_));
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   * @override
   */
  setMap(t) {
    const e = this.getMap();
    e && e.removeChangeListener(
      Et.TARGET,
      this.boundHandleMapTargetChange_
    ), super.setMap(t), this.handleMapTargetChange_(), t && t.addChangeListener(
      Et.TARGET,
      this.boundHandleMapTargetChange_
    );
  }
  /**
   * @private
   */
  handleMapTargetChange_() {
    const t = this.documentListeners_;
    for (let n = 0, r = t.length; n < r; ++n)
      dt(t[n]);
    t.length = 0;
    const e = this.getMap();
    if (e) {
      const n = e.getOwnerDocument();
      d1(n) ? this.element.classList.remove(Wh) : this.element.classList.add(Wh);
      for (let r = 0, s = h1.length; r < s; ++r)
        t.push(
          Q(n, h1[r], this.handleFullScreenChange_, this)
        );
      this.handleFullScreenChange_();
    }
  }
}
function d1(i) {
  const t = i.body;
  return !!(t.webkitRequestFullscreen || t.requestFullscreen && i.fullscreenEnabled);
}
function u1(i) {
  return !!(i.webkitIsFullScreen || i.fullscreenElement);
}
function T3(i) {
  i.requestFullscreen ? i.requestFullscreen() : i.webkitRequestFullscreen && i.webkitRequestFullscreen();
}
function Ix(i) {
  i.webkitRequestFullscreen ? i.webkitRequestFullscreen() : T3(i);
}
function kx(i) {
  i.exitFullscreen ? i.exitFullscreen() : i.webkitExitFullscreen && i.webkitExitFullscreen();
}
const ls = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
class Lx extends Ze {
  /**
   * @param {Options} [options] Zoom slider options.
   */
  constructor(t) {
    t = t || {}, super({
      target: t.target,
      element: document.createElement("div"),
      render: t.render
    }), this.dragListenerKeys_ = [], this.currentResolution_ = void 0, this.direction_ = ls.VERTICAL, this.dragging_, this.heightLimit_ = 0, this.widthLimit_ = 0, this.startX_, this.startY_, this.thumbSize_ = null, this.sliderInitialized_ = !1, this.duration_ = t.duration !== void 0 ? t.duration : 200;
    const e = t.className !== void 0 ? t.className : "ol-zoomslider", n = document.createElement("button");
    n.setAttribute("type", "button"), n.className = e + "-thumb " + si;
    const r = this.element;
    r.className = e + " " + si + " " + zn, r.appendChild(n), r.addEventListener(
      Qe.POINTERDOWN,
      this.handleDraggerStart_.bind(this),
      !1
    ), r.addEventListener(
      Qe.POINTERMOVE,
      this.handleDraggerDrag_.bind(this),
      !1
    ), r.addEventListener(
      Qe.POINTERUP,
      this.handleDraggerEnd_.bind(this),
      !1
    ), r.addEventListener(
      V.CLICK,
      this.handleContainerClick_.bind(this),
      !1
    ), n.addEventListener(V.CLICK, lf, !1);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   * @override
   */
  setMap(t) {
    super.setMap(t), t && t.render();
  }
  /**
   * Initializes the slider element. This will determine and set this controls
   * direction_ and also constrain the dragging of the thumb to always be within
   * the bounds of the container.
   *
   * @return {boolean} Initialization successful
   * @private
   */
  initSlider_() {
    const t = this.element;
    let e = t.offsetWidth, n = t.offsetHeight;
    if (e === 0 && n === 0)
      return this.sliderInitialized_ = !1;
    const r = getComputedStyle(t);
    e -= parseFloat(r.paddingRight) + parseFloat(r.paddingLeft), n -= parseFloat(r.paddingTop) + parseFloat(r.paddingBottom);
    const s = (
      /** @type {HTMLElement} */
      t.firstElementChild
    ), o = getComputedStyle(s), a = s.offsetWidth + parseFloat(o.marginRight) + parseFloat(o.marginLeft), l = s.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);
    return this.thumbSize_ = [a, l], e > n ? (this.direction_ = ls.HORIZONTAL, this.widthLimit_ = e - a) : (this.direction_ = ls.VERTICAL, this.heightLimit_ = n - l), this.sliderInitialized_ = !0;
  }
  /**
   * @param {PointerEvent} event The browser event to handle.
   * @private
   */
  handleContainerClick_(t) {
    const e = this.getMap().getView(), n = this.getRelativePosition_(
      t.offsetX - this.thumbSize_[0] / 2,
      t.offsetY - this.thumbSize_[1] / 2
    ), r = this.getResolutionForPosition_(n), s = e.getConstrainedZoom(e.getZoomForResolution(r));
    e.animateInternal({
      zoom: s,
      duration: this.duration_,
      easing: Nn
    });
  }
  /**
   * Handle dragger start events.
   * @param {PointerEvent} event The drag event.
   * @private
   */
  handleDraggerStart_(t) {
    if (!this.dragging_ && t.target === this.element.firstElementChild) {
      const e = (
        /** @type {HTMLElement} */
        this.element.firstElementChild
      );
      if (this.getMap().getView().beginInteraction(), this.startX_ = t.clientX - parseFloat(e.style.left), this.startY_ = t.clientY - parseFloat(e.style.top), this.dragging_ = !0, this.dragListenerKeys_.length === 0) {
        const n = this.handleDraggerDrag_, r = this.handleDraggerEnd_, s = this.getMap().getOwnerDocument();
        this.dragListenerKeys_.push(
          Q(s, Qe.POINTERMOVE, n, this),
          Q(s, Qe.POINTERUP, r, this)
        );
      }
    }
  }
  /**
   * Handle dragger drag events.
   *
   * @param {PointerEvent} event The drag event.
   * @private
   */
  handleDraggerDrag_(t) {
    if (this.dragging_) {
      const e = t.clientX - this.startX_, n = t.clientY - this.startY_, r = this.getRelativePosition_(e, n);
      this.currentResolution_ = this.getResolutionForPosition_(r), this.getMap().getView().setResolution(this.currentResolution_);
    }
  }
  /**
   * Handle dragger end events.
   * @param {PointerEvent} event The drag event.
   * @private
   */
  handleDraggerEnd_(t) {
    this.dragging_ && (this.getMap().getView().endInteraction(), this.dragging_ = !1, this.startX_ = void 0, this.startY_ = void 0, this.dragListenerKeys_.forEach(dt), this.dragListenerKeys_.length = 0);
  }
  /**
   * Positions the thumb inside its container according to the given resolution.
   *
   * @param {number} res The res.
   * @private
   */
  setThumbPosition_(t) {
    const e = this.getPositionForResolution_(t), n = (
      /** @type {HTMLElement} */
      this.element.firstElementChild
    );
    this.direction_ == ls.HORIZONTAL ? n.style.left = this.widthLimit_ * e + "px" : n.style.top = this.heightLimit_ * e + "px";
  }
  /**
   * Calculates the relative position of the thumb given x and y offsets.  The
   * relative position scales from 0 to 1.  The x and y offsets are assumed to be
   * in pixel units within the dragger limits.
   *
   * @param {number} x Pixel position relative to the left of the slider.
   * @param {number} y Pixel position relative to the top of the slider.
   * @return {number} The relative position of the thumb.
   * @private
   */
  getRelativePosition_(t, e) {
    let n;
    return this.direction_ === ls.HORIZONTAL ? n = t / this.widthLimit_ : n = e / this.heightLimit_, ft(n, 0, 1);
  }
  /**
   * Calculates the corresponding resolution of the thumb given its relative
   * position (where 0 is the minimum and 1 is the maximum).
   *
   * @param {number} position The relative position of the thumb.
   * @return {number} The corresponding resolution.
   * @private
   */
  getResolutionForPosition_(t) {
    return this.getMap().getView().getResolutionForValueFunction()(1 - t);
  }
  /**
   * Determines the relative position of the slider for the given resolution.  A
   * relative position of 0 corresponds to the minimum view resolution.  A
   * relative position of 1 corresponds to the maximum view resolution.
   *
   * @param {number} res The resolution.
   * @return {number} The relative position value (between 0 and 1).
   * @private
   */
  getPositionForResolution_(t) {
    const e = this.getMap().getView().getValueForResolutionFunction();
    return ft(1 - e(t), 0, 1);
  }
  /**
   * Update the zoomslider element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(t) {
    if (!t.frameState || !this.sliderInitialized_ && !this.initSlider_())
      return;
    const e = t.frameState.viewState.resolution;
    this.currentResolution_ = e, this.setThumbPosition_(e);
  }
}
const aa = 0.75, Y0 = 0.1;
class Ax extends Ze {
  /**
   * @param {Options} [options] OverviewMap options.
   */
  constructor(t) {
    t = t || {}, super({
      element: document.createElement("div"),
      render: t.render,
      target: t.target
    }), this.boundHandleRotationChanged_ = this.handleRotationChanged_.bind(this), this.collapsed_ = t.collapsed !== void 0 ? t.collapsed : !0, this.collapsible_ = t.collapsible !== void 0 ? t.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1), this.rotateWithView_ = t.rotateWithView !== void 0 ? t.rotateWithView : !1, this.viewExtent_ = void 0;
    const e = t.className !== void 0 ? t.className : "ol-overviewmap", n = t.tipLabel !== void 0 ? t.tipLabel : "Overview map", r = t.collapseLabel !== void 0 ? t.collapseLabel : "";
    typeof r == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = r) : this.collapseLabel_ = r;
    const s = t.label !== void 0 ? t.label : "";
    typeof s == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = s) : this.label_ = s;
    const o = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_, a = document.createElement("button");
    a.setAttribute("type", "button"), a.title = n, a.appendChild(o), a.addEventListener(
      V.CLICK,
      this.handleClick_.bind(this),
      !1
    ), this.ovmapDiv_ = document.createElement("div"), this.ovmapDiv_.className = "ol-overviewmap-map", this.view_ = t.view;
    const l = new zd({
      view: t.view,
      controls: new Dt(),
      interactions: new Dt()
    });
    this.ovmap_ = l, t.layers && t.layers.forEach(function(_) {
      l.addLayer(_);
    });
    const h = document.createElement("div");
    h.className = "ol-overviewmap-box", h.style.boxSizing = "border-box", this.boxOverlay_ = new r3({
      position: [0, 0],
      positioning: "center-center",
      element: h
    }), this.ovmap_.addOverlay(this.boxOverlay_);
    const c = e + " " + si + " " + zn + (this.collapsed_ && this.collapsible_ ? " " + go : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), d = this.element;
    d.className = c, d.appendChild(this.ovmapDiv_), d.appendChild(a);
    const u = this.boxOverlay_, f = this.boxOverlay_.getElement(), g = (_) => ({
      clientX: _.clientX,
      clientY: _.clientY
    }), p = function(_) {
      const y = (
        /** @type {?} */
        g(_)
      ), x = l.getEventCoordinate(
        /** @type {MouseEvent} */
        y
      );
      u.setPosition(x);
    }, m = (_) => {
      const y = l.getEventCoordinateInternal(_), x = this.getMap();
      x.getView().setCenterInternal(y);
      const v = x.getOwnerDocument();
      v.removeEventListener("pointermove", p), v.removeEventListener("pointerup", m);
    };
    this.ovmapDiv_.addEventListener("pointerdown", (_) => {
      const y = this.getMap().getOwnerDocument();
      _.target === f && y.addEventListener("pointermove", p), y.addEventListener("pointerup", m);
    });
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   * @override
   */
  setMap(t) {
    const e = this.getMap();
    if (t !== e) {
      if (e) {
        const n = e.getView();
        n && this.unbindView_(n), this.ovmap_.setTarget(null);
      }
      if (super.setMap(t), t) {
        this.ovmap_.setTarget(this.ovmapDiv_), this.listenerKeys.push(
          Q(
            t,
            Mn.PROPERTYCHANGE,
            this.handleMapPropertyChange_,
            this
          )
        );
        const n = t.getView();
        n && this.bindView_(n), this.ovmap_.isRendered() || this.updateBoxAfterOvmapIsRendered_();
      }
    }
  }
  /**
   * Handle map property changes.  This only deals with changes to the map's view.
   * @param {import("../Object.js").ObjectEvent} event The propertychange event.
   * @private
   */
  handleMapPropertyChange_(t) {
    if (t.key === Et.VIEW) {
      const e = (
        /** @type {import("../View.js").default} */
        t.oldValue
      );
      e && this.unbindView_(e);
      const n = this.getMap().getView();
      this.bindView_(n);
    } else !this.ovmap_.isRendered() && (t.key === Et.TARGET || t.key === Et.SIZE) && this.ovmap_.updateSize();
  }
  /**
   * Register listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */
  bindView_(t) {
    if (!this.view_) {
      const e = new Se({
        projection: t.getProjection()
      });
      this.ovmap_.setView(e);
    }
    t.addChangeListener(
      me.ROTATION,
      this.boundHandleRotationChanged_
    ), this.handleRotationChanged_(), t.isDef() && (this.ovmap_.updateSize(), this.resetExtent_());
  }
  /**
   * Unregister listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */
  unbindView_(t) {
    t.removeChangeListener(
      me.ROTATION,
      this.boundHandleRotationChanged_
    );
  }
  /**
   * Handle rotation changes to the main map.
   * @private
   */
  handleRotationChanged_() {
    this.rotateWithView_ && this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
  }
  /**
   * Reset the overview map extent if the box size (width or
   * height) is less than the size of the overview map size times minRatio
   * or is greater than the size of the overview size times maxRatio.
   *
   * If the map extent was not reset, the box size can fits in the defined
   * ratio sizes. This method then checks if is contained inside the overview
   * map current extent. If not, recenter the overview map to the current
   * main map center location.
   * @private
   */
  validateExtent_() {
    const t = this.getMap(), e = this.ovmap_;
    if (!t.isRendered() || !e.isRendered())
      return;
    const n = (
      /** @type {import("../size.js").Size} */
      t.getSize()
    ), s = t.getView().calculateExtentInternal(n);
    if (this.viewExtent_ && Hi(s, this.viewExtent_))
      return;
    this.viewExtent_ = s;
    const o = (
      /** @type {import("../size.js").Size} */
      e.getSize()
    ), l = e.getView().calculateExtentInternal(o), h = e.getPixelFromCoordinateInternal(
      Xe(s)
    ), c = e.getPixelFromCoordinateInternal(
      Br(s)
    ), d = Math.abs(h[0] - c[0]), u = Math.abs(h[1] - c[1]), f = o[0], g = o[1];
    d < f * Y0 || u < g * Y0 || d > f * aa || u > g * aa ? this.resetExtent_() : Be(l, s) || this.recenter_();
  }
  /**
   * Reset the overview map extent to half calculated min and max ratio times
   * the extent of the main map.
   * @private
   */
  resetExtent_() {
    const t = this.getMap(), e = this.ovmap_, n = (
      /** @type {import("../size.js").Size} */
      t.getSize()
    ), s = t.getView().calculateExtentInternal(n), o = e.getView(), a = Math.log(aa / Y0) / Math.LN2, l = 1 / (Math.pow(2, a / 2) * Y0);
    Sf(s, l), o.fitInternal(fo(s));
  }
  /**
   * Set the center of the overview map to the map center without changing its
   * resolution.
   * @private
   */
  recenter_() {
    const t = this.getMap(), e = this.ovmap_, n = t.getView();
    e.getView().setCenterInternal(n.getCenterInternal());
  }
  /**
   * Update the box using the main map extent
   * @private
   */
  updateBox_() {
    const t = this.getMap(), e = this.ovmap_;
    if (!t.isRendered() || !e.isRendered())
      return;
    const n = (
      /** @type {import("../size.js").Size} */
      t.getSize()
    ), r = t.getView(), s = e.getView(), o = this.rotateWithView_ ? 0 : -r.getRotation(), a = this.boxOverlay_, l = this.boxOverlay_.getElement(), h = r.getCenter(), c = r.getResolution(), d = s.getResolution(), u = n[0] * c / d, f = n[1] * c / d;
    if (a.setPosition(h), l) {
      l.style.width = u + "px", l.style.height = f + "px";
      const g = "rotate(" + o + "rad)";
      l.style.transform = g;
    }
  }
  /**
   * @private
   */
  updateBoxAfterOvmapIsRendered_() {
    this.ovmapPostrenderKey_ || (this.ovmapPostrenderKey_ = Ns(
      this.ovmap_,
      Je.POSTRENDER,
      (t) => {
        delete this.ovmapPostrenderKey_, this.updateBox_();
      }
    ));
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(t) {
    t.preventDefault(), this.handleToggle_();
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(go), this.collapsed_ ? Ar(this.collapseLabel_, this.label_) : Ar(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_;
    const t = this.ovmap_;
    if (!this.collapsed_) {
      if (t.isRendered()) {
        this.viewExtent_ = void 0, t.render();
        return;
      }
      t.updateSize(), this.resetExtent_(), this.updateBoxAfterOvmapIsRendered_();
    }
  }
  /**
   * Return `true` if the overview map is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the overview map should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(t) {
    this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), !t && this.collapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the overview map according to the passed parameter. Will
   * not do anything if the overview map isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(t) {
    !this.collapsible_ || this.collapsed_ === t || this.handleToggle_();
  }
  /**
   * Determine if the overview map is collapsed.
   * @return {boolean} The overview map is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Return `true` if the overview map view can rotate, `false` otherwise.
   * @return {boolean} True if the control view can rotate.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Set whether the overview map view should rotate with the main map view.
   * @param {boolean} rotateWithView True if the control view should rotate.
   * @api
   */
  setRotateWithView(t) {
    this.rotateWithView_ !== t && (this.rotateWithView_ = t, this.getMap().getView().getRotation() !== 0 && (this.rotateWithView_ ? this.handleRotationChanged_() : this.ovmap_.getView().setRotation(0), this.viewExtent_ = void 0, this.validateExtent_(), this.updateBox_()));
  }
  /**
   * Return the overview map.
   * @return {import("../Map.js").default} Overview map.
   * @api
   */
  getOverviewMap() {
    return this.ovmap_;
  }
  /**
   * Update the overview map element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(t) {
    this.validateExtent_(), this.updateBox_();
  }
}
class Fx extends Ze {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super({
      element: document.createElement("div"),
      target: t.target
    }), this.extent = t.extent ? t.extent : null, this.fitOptions = t.fitOptions || {};
    const e = t.className !== void 0 ? t.className : "ol-zoom-extent", n = t.label !== void 0 ? t.label : "E", r = t.tipLabel !== void 0 ? t.tipLabel : "Fit to extent", s = document.createElement("button");
    s.setAttribute("type", "button"), s.title = r, s.appendChild(
      typeof n == "string" ? document.createTextNode(n) : n
    ), s.addEventListener(
      V.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const o = e + " " + si + " " + zn, a = this.element;
    a.className = o, a.appendChild(s);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(t) {
    t.preventDefault(), this.handleZoomToExtent();
  }
  /**
   * @protected
   */
  handleZoomToExtent() {
    const e = this.getMap().getView(), n = this.extent ? Te(this.extent, e.getProjection()) : e.getProjection().getExtent();
    e.fitInternal(fo(n), this.fitOptions);
  }
}
const la = "projection", f1 = "coordinateFormat";
class Ox extends Ze {
  /**
   * @param {Options} [options] Mouse position options.
   */
  constructor(t) {
    t = t || {};
    const e = document.createElement("div");
    e.className = t.className !== void 0 ? t.className : "ol-mouse-position", super({
      element: e,
      render: t.render,
      target: t.target
    }), this.on, this.once, this.un, this.addChangeListener(la, this.handleProjectionChanged_), t.coordinateFormat && this.setCoordinateFormat(t.coordinateFormat), t.projection && this.setProjection(t.projection), this.renderOnMouseOut_ = t.placeholder !== void 0, this.placeholder_ = this.renderOnMouseOut_ ? t.placeholder : "&#160;", this.renderedHTML_ = e.innerHTML, this.mapProjection_ = null, this.transform_ = null, this.wrapX_ = t.wrapX !== !1;
  }
  /**
   * @private
   */
  handleProjectionChanged_() {
    this.transform_ = null;
  }
  /**
   * Return the coordinate format type used to render the current position or
   * undefined.
   * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
   *     position in.
   * @observable
   * @api
   */
  getCoordinateFormat() {
    return (
      /** @type {import("../coordinate.js").CoordinateFormat|undefined} */
      this.get(f1)
    );
  }
  /**
   * Return the projection that is used to report the mouse position.
   * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  getProjection() {
    return (
      /** @type {import("../proj/Projection.js").default|undefined} */
      this.get(la)
    );
  }
  /**
   * @param {MouseEvent} event Browser event.
   * @protected
   */
  handleMouseMove(t) {
    const e = this.getMap();
    this.updateHTML_(e.getEventPixel(t));
  }
  /**
   * @param {Event} event Browser event.
   * @protected
   */
  handleMouseOut(t) {
    this.updateHTML_(null);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   * @override
   */
  setMap(t) {
    if (super.setMap(t), t) {
      const e = t.getViewport();
      this.listenerKeys.push(
        Q(e, Qe.POINTERMOVE, this.handleMouseMove, this)
      ), this.renderOnMouseOut_ && this.listenerKeys.push(
        Q(e, Qe.POINTEROUT, this.handleMouseOut, this)
      ), this.updateHTML_(null);
    }
  }
  /**
   * Set the coordinate format type used to render the current position.
   * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
   *     position in.
   * @observable
   * @api
   */
  setCoordinateFormat(t) {
    this.set(f1, t);
  }
  /**
   * Set the projection that is used to report the mouse position.
   * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  setProjection(t) {
    this.set(la, tt(t));
  }
  /**
   * @param {?import("../pixel.js").Pixel} pixel Pixel.
   * @private
   */
  updateHTML_(t) {
    let e = this.placeholder_;
    if (t && this.mapProjection_) {
      if (!this.transform_) {
        const s = this.getProjection();
        s ? this.transform_ = Vr(
          this.mapProjection_,
          s
        ) : this.transform_ = B1;
      }
      const r = this.getMap().getCoordinateFromPixelInternal(t);
      if (r) {
        if (this.transform_(r, r), this.wrapX_) {
          const o = this.getProjection() || this.mapProjection_;
          Bo(r, o);
        }
        const s = this.getCoordinateFormat();
        s ? e = s(r) : e = r.toString();
      }
    }
    (!this.renderedHTML_ || e !== this.renderedHTML_) && (this.element.innerHTML = e, this.renderedHTML_ = e);
  }
  /**
   * Update the projection. Rendering of the coordinates is done in
   * `handleMouseMove` and `handleMouseUp`.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(t) {
    const e = t.frameState;
    e ? this.mapProjection_ != e.viewState.projection && (this.mapProjection_ = e.viewState.projection, this.transform_ = null) : this.mapProjection_ = null;
  }
}
const _t = {
  ACCURACY: "accuracy",
  ACCURACY_GEOMETRY: "accuracyGeometry",
  ALTITUDE: "altitude",
  ALTITUDE_ACCURACY: "altitudeAccuracy",
  HEADING: "heading",
  POSITION: "position",
  PROJECTION: "projection",
  SPEED: "speed",
  TRACKING: "tracking",
  TRACKING_OPTIONS: "trackingOptions"
}, Gx = {
  /**
   * Triggered when a `GeolocationPositionError` occurs.
   * @event module:ol/Geolocation.GeolocationError#error
   * @api
   */
  ERROR: "error"
};
class Nx extends ve {
  /**
   * @param {GeolocationPositionError} error error object.
   */
  constructor(t) {
    super(Gx.ERROR), this.code = t.code, this.message = t.message;
  }
}
class Dx extends De {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = t || {}, this.position_ = null, this.transform_ = B1, this.watchId_ = void 0, this.addChangeListener(_t.PROJECTION, this.handleProjectionChanged_), this.addChangeListener(_t.TRACKING, this.handleTrackingChanged_), t.projection !== void 0 && this.setProjection(t.projection), t.trackingOptions !== void 0 && this.setTrackingOptions(t.trackingOptions), this.setTracking(t.tracking !== void 0 ? t.tracking : !1);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.setTracking(!1), super.disposeInternal();
  }
  /**
   * @private
   */
  handleProjectionChanged_() {
    const t = this.getProjection();
    t && (this.transform_ = Vr(
      tt("EPSG:4326"),
      t
    ), this.position_ && this.set(_t.POSITION, this.transform_(this.position_)));
  }
  /**
   * @private
   */
  handleTrackingChanged_() {
    if ("geolocation" in navigator) {
      const t = this.getTracking();
      t && this.watchId_ === void 0 ? this.watchId_ = navigator.geolocation.watchPosition(
        this.positionChange_.bind(this),
        this.positionError_.bind(this),
        this.getTrackingOptions()
      ) : !t && this.watchId_ !== void 0 && (navigator.geolocation.clearWatch(this.watchId_), this.watchId_ = void 0);
    }
  }
  /**
   * @private
   * @param {GeolocationPosition} position position event.
   */
  positionChange_(t) {
    const e = t.coords;
    this.set(_t.ACCURACY, e.accuracy), this.set(
      _t.ALTITUDE,
      e.altitude === null ? void 0 : e.altitude
    ), this.set(
      _t.ALTITUDE_ACCURACY,
      e.altitudeAccuracy === null ? void 0 : e.altitudeAccuracy
    ), this.set(
      _t.HEADING,
      e.heading === null ? void 0 : ie(e.heading)
    ), this.position_ ? (this.position_[0] = e.longitude, this.position_[1] = e.latitude) : this.position_ = [e.longitude, e.latitude];
    const n = this.transform_(this.position_);
    this.set(_t.POSITION, n.slice()), this.set(_t.SPEED, e.speed === null ? void 0 : e.speed);
    const r = Ig(this.position_, e.accuracy);
    r.applyTransform(this.transform_), this.set(_t.ACCURACY_GEOMETRY, r), this.changed();
  }
  /**
   * @private
   * @param {GeolocationPositionError} error error object.
   */
  positionError_(t) {
    this.dispatchEvent(new Nx(t));
  }
  /**
   * Get the accuracy of the position in meters.
   * @return {number|undefined} The accuracy of the position measurement in
   *     meters.
   * @observable
   * @api
   */
  getAccuracy() {
    return (
      /** @type {number|undefined} */
      this.get(_t.ACCURACY)
    );
  }
  /**
   * Get a geometry of the position accuracy.
   * @return {?import("./geom/Polygon.js").default} A geometry of the position accuracy.
   * @observable
   * @api
   */
  getAccuracyGeometry() {
    return (
      /** @type {?import("./geom/Polygon.js").default} */
      this.get(_t.ACCURACY_GEOMETRY) || null
    );
  }
  /**
   * Get the altitude associated with the position.
   * @return {number|undefined} The altitude of the position in meters above mean
   *     sea level.
   * @observable
   * @api
   */
  getAltitude() {
    return (
      /** @type {number|undefined} */
      this.get(_t.ALTITUDE)
    );
  }
  /**
   * Get the altitude accuracy of the position.
   * @return {number|undefined} The accuracy of the altitude measurement in
   *     meters.
   * @observable
   * @api
   */
  getAltitudeAccuracy() {
    return (
      /** @type {number|undefined} */
      this.get(_t.ALTITUDE_ACCURACY)
    );
  }
  /**
   * Get the heading as radians clockwise from North.
   * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`
   * is set to `true` in the tracking options.
   * @return {number|undefined} The heading of the device in radians from north.
   * @observable
   * @api
   */
  getHeading() {
    return (
      /** @type {number|undefined} */
      this.get(_t.HEADING)
    );
  }
  /**
   * Get the position of the device.
   * @return {import("./coordinate.js").Coordinate|undefined} The current position of the device reported
   *     in the current projection.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(_t.POSITION)
    );
  }
  /**
   * Get the projection associated with the position.
   * @return {import("./proj/Projection.js").default|undefined} The projection the position is
   *     reported in.
   * @observable
   * @api
   */
  getProjection() {
    return (
      /** @type {import("./proj/Projection.js").default|undefined} */
      this.get(_t.PROJECTION)
    );
  }
  /**
   * Get the speed in meters per second.
   * @return {number|undefined} The instantaneous speed of the device in meters
   *     per second.
   * @observable
   * @api
   */
  getSpeed() {
    return (
      /** @type {number|undefined} */
      this.get(_t.SPEED)
    );
  }
  /**
   * Determine if the device location is being tracked.
   * @return {boolean} The device location is being tracked.
   * @observable
   * @api
   */
  getTracking() {
    return (
      /** @type {boolean} */
      this.get(_t.TRACKING)
    );
  }
  /**
   * Get the tracking options.
   * See https://www.w3.org/TR/geolocation-API/#position-options.
   * @return {PositionOptions|undefined} PositionOptions as defined by
   *     the [HTML5 Geolocation spec
   *     ](https://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */
  getTrackingOptions() {
    return (
      /** @type {PositionOptions|undefined} */
      this.get(_t.TRACKING_OPTIONS)
    );
  }
  /**
   * Set the projection to use for transforming the coordinates.
   * @param {import("./proj.js").ProjectionLike} projection The projection the position is
   *     reported in.
   * @observable
   * @api
   */
  setProjection(t) {
    this.set(_t.PROJECTION, tt(t));
  }
  /**
   * Enable or disable tracking.
   * @param {boolean} tracking Enable tracking.
   * @observable
   * @api
   */
  setTracking(t) {
    this.set(_t.TRACKING, t);
  }
  /**
   * Set the tracking options.
   * See http://www.w3.org/TR/geolocation-API/#position-options.
   * @param {PositionOptions} options PositionOptions as defined by the
   *     [HTML5 Geolocation spec
   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */
  setTrackingOptions(t) {
    this.set(_t.TRACKING_OPTIONS, t);
  }
}
class zx extends Ze {
  /**
   * @param {GeolocationOptions} [opt_options] - Control options.
   */
  constructor(t) {
    const e = t || {}, n = document.createElement("div");
    n.className = "geolocation ol-unselectable ol-control";
    const r = document.createElement("button");
    r.title = "Show your location", r.innerHTML = e.buttonIcon ? `
      <img src="${e.buttonIcon}" alt="Geolocation" />
    ` : `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>crosshairs-gps</title><path d="M12,8A4,4 0 0,1 16,12A4,4 0 0,1 12,16A4,4 0 0,1 8,12A4,4 0 0,1 12,8M3.05,13H1V11H3.05C3.5,6.83 6.83,3.5 11,3.05V1H13V3.05C17.17,3.5 20.5,6.83 20.95,11H23V13H20.95C20.5,17.17 17.17,20.5 13,20.95V23H11V20.95C6.83,20.5 3.5,17.17 3.05,13M12,5A7,7 0 0,0 5,12A7,7 0 0,0 12,19A7,7 0 0,0 19,12A7,7 0 0,0 12,5Z" /></svg>
    `, n.appendChild(r), super({ element: n }), this._centerWhenReady = e.centerWhenReady, this._highAccuracy = e.highAccuracy, this._trackAccuracy = e.trackAccuracy, this._trackHeading = e.trackHeading, this._positionFeature = new Lt({
      geometry: new de([NaN, NaN]),
      heading: 0
    }), this._source = new e2({
      features: [this._positionFeature]
    }), this._trackAccuracy && (this._accuracyFeature = new Lt(), this._accuracyFeature.setStyle(
      new At({
        fill: new Ne({ color: "rgba(0, 0, 0, 0.2)" }),
        stroke: new Ae({ width: 2, color: "rgba(0, 0, 0, 0.7)" })
      })
    ), this._source.addFeature(this._accuracyFeature)), this._layer = new yi({ source: this._source }), e.style && this._layer.setStyle(e.style), r.addEventListener("click", this.centerOnPosition.bind(this), !1);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   *
   * @param {import("ol/Map").default|null} map - Map instance.
   * @api
   */
  setMap(t) {
    this._layer.setMap(t), super.setMap(t), t && this._centerWhenReady && this.initGeolocation();
  }
  /**
   * Initializes the geolocation control.
   * This will prompt the user for geolocation permissions in the browser.
   */
  initGeolocation() {
    return new Promise((t, e) => {
      const n = this.getMap();
      n && (this._geolocation = new Dx({
        tracking: !0,
        trackingOptions: { enableHighAccuracy: this._highAccuracy },
        projection: n.getView().getProjection()
      })), this._centerWhenReady && this._geolocation.once("change:position", (r) => {
        n.getView().setCenter(r.target.getPosition());
      }), this._geolocation.on("error", (r) => e(r)), this._geolocation.on("change:accuracyGeometry", () => {
        this._trackAccuracy && this._accuracyFeature.setGeometry(
          this._geolocation.getAccuracyGeometry()
        );
      }), this._geolocation.on("change:heading", (r) => {
        this._trackHeading && this._highAccuracy && this._positionFeature.set("heading", r.target.getHeading());
      }), this._geolocation.on("change:position", () => {
        const r = this._geolocation.getPosition();
        this._positionFeature.getGeometry().setCoordinates(r || null), t(r);
      });
    });
  }
  /**
   * Returns the geolocation control element.
   *
   * @returns {HTMLElement} - The control element.
   */
  getElement() {
    return this.element;
  }
  /**
   * Centers the map on the position of the geolocation, if possible.
   */
  async centerOnPosition() {
    try {
      await this.initGeolocation();
      const t = this._geolocation?.getPosition();
      t && this.getMap()?.getView().setCenter(t);
    } catch (t) {
      console.error(t);
    }
  }
}
class jx extends Ze {
  /**
   * Creates a loading indicator control to show when map loading events occur.
   *
   * @param {LoadingIndicatorOptions} [opt_options] - Options for configuring the loading indicator control.
   */
  constructor(t) {
    const e = t || {};
    e.opacity === void 0 && (e.opacity = 1), e.type === void 0 && (e.type = "small");
    const n = document.createElement("div");
    n.className = "LoadingIndicator ol-unselectable ol-control", n.classList.add("loading-indicator"), n.style.opacity = String(e.opacity), e.spinnerSvg ? n.innerHTML = e.spinnerSvg : n.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid" width="50" height="50" style="shape-rendering: auto; display: block; background: transparent;" xmlns:xlink="http://www.w3.org/1999/xlink"><g><circle stroke-dasharray="164.93361431346415 56.97787143782138" r="35" stroke-width="12" stroke="#1a467c" fill="none" cy="50" cx="50">
      <animateTransform keyTimes="0;1" values="0 50 50;360 50 50" dur="1.2222222222222223s" repeatCount="indefinite" type="rotate" attributeName="transform"></animateTransform>
      </circle></g></svg>`, e.type === "fullscreen" ? n.classList.add("fullscreen") : n.classList.add("small"), super({ element: n });
  }
  /**
   * Attaches the control to a map and sets up event listeners to show/hide the loading indicator based on map load events.
   *
   * @param {import("ol/Map").default|null} map - The map instance to attach the control to, or `null` to remove it.
   * @api
   */
  setMap(t) {
    super.setMap(t), t && (t.on("loadstart", () => {
      this.getElement().style.visibility = "visible";
    }), t.on("loadend", () => {
      this.getElement().style.visibility = "hidden";
    }));
  }
  /**
   * Returns the loading indicator element.
   *
   * @returns {HTMLElement} - The control element.
   */
  getElement() {
    return this.element;
  }
}
const Ux = {
  Zoom: hd,
  Rotate: ld,
  ScaleLine: Rx,
  FullScreen: Px,
  ZoomSlider: Lx,
  Attribution: ad,
  OverviewMap: Ax,
  ZoomToExtent: Fx,
  MousePosition: Ox,
  Geolocation: zx,
  LoadingIndicator: jx
};
function Bx(i, t, e, n) {
  t && t[e] ? JSON.stringify(t[e]) !== JSON.stringify(n) && (i.removeControl(e), g1(i, e, n)) : g1(i, e, n);
}
function g1(i, t, e) {
  const n = Object.assign({}, e);
  e && e.layers && (n.layers = yx(i, e.layers));
  const r = new Ux[t](n);
  i.map.addControl(r), i.mapControls[t] = r;
}
const R3 = `@import"https://eox.at/fonts/inter/inter.css";@import"https://eox.at/fonts/materialdesignicons/materialdesignicons.min.css";:root{--size: 1rem;--font: Inter, Roboto, "Helvetica Neue", "Arial Nova", "Nimbus Sans", Noto Sans, Arial, sans-serif;--font-icon: "Material Symbols Outlined";--speed1: .1s;--speed2: .2s;--speed3: .3s;--speed4: .4s;--active: rgb(128 128 128 / .192);--overlay: rgb(0 0 0 / .5);--elevate1: 0 .125rem .125rem 0 rgb(0 0 0 / .32);--elevate2: 0 .25rem .5rem 0 rgb(0 0 0 / .4);--elevate3: 0 .375rem .75rem 0 rgb(0 0 0 / .48);--top: env(safe-area-inset-top);--bottom: env(safe-area-inset-bottom);--left: env(safe-area-inset-left);--right: env(safe-area-inset-right)}:root,body.light{--primary: #6750a4;--on-primary: #ffffff;--primary-container: #e9ddff;--on-primary-container: #22005d;--secondary: #625b71;--on-secondary: #ffffff;--secondary-container: #e8def8;--on-secondary-container: #1e192b;--tertiary: #7e5260;--on-tertiary: #ffffff;--tertiary-container: #ffd9e3;--on-tertiary-container: #31101d;--error: #ba1a1a;--on-error: #ffffff;--error-container: #ffdad6;--on-error-container: #410002;--background: #fffbff;--on-background: #1c1b1e;--surface: #fdf8fd;--on-surface: #1c1b1e;--surface-variant: #e7e0eb;--on-surface-variant: #49454e;--outline: #7a757f;--outline-variant: #cac4cf;--shadow: #000000;--scrim: #000000;--inverse-surface: #313033;--inverse-on-surface: #f4eff4;--inverse-primary: #cfbcff;--surface-dim: #ddd8dd;--surface-bright: #fdf8fd;--surface-container-lowest: #ffffff;--surface-container-low: #f7f2f7;--surface-container: #f2ecf1;--surface-container-high: #ece7eb;--surface-container-highest: #e6e1e6}body.dark{--primary: #cfbcff;--on-primary: #381e72;--primary-container: #4f378a;--on-primary-container: #e9ddff;--secondary: #cbc2db;--on-secondary: #332d41;--secondary-container: #4a4458;--on-secondary-container: #e8def8;--tertiary: #efb8c8;--on-tertiary: #4a2532;--tertiary-container: #633b48;--on-tertiary-container: #ffd9e3;--error: #ffb4ab;--on-error: #690005;--error-container: #93000a;--on-error-container: #ffb4ab;--background: #1c1b1e;--on-background: #e6e1e6;--surface: #141316;--on-surface: #e6e1e6;--surface-variant: #49454e;--on-surface-variant: #cac4cf;--outline: #948f99;--outline-variant: #49454e;--shadow: #000000;--scrim: #000000;--inverse-surface: #e6e1e6;--inverse-on-surface: #313033;--inverse-primary: #6750a4;--surface-dim: #141316;--surface-bright: #3a383c;--surface-container-lowest: #0f0e11;--surface-container-low: #1c1b1e;--surface-container: #201f22;--surface-container-high: #2b292d;--surface-container-highest: #363438}@font-face{font-family:Material Symbols Outlined;font-style:normal;font-weight:400;font-display:block;src:url(/material-symbols-outlined.woff2) format("woff2"),url(https://cdn.jsdelivr.net/npm/beercss@3.12.13/dist/cdn/material-symbols-outlined.woff2) format("woff2")}@font-face{font-family:Material Symbols Rounded;font-style:normal;font-weight:400;font-display:block;src:url(/material-symbols-rounded.woff2) format("woff2"),url(https://cdn.jsdelivr.net/npm/beercss@3.12.13/dist/cdn/material-symbols-rounded.woff2) format("woff2")}@font-face{font-family:Material Symbols Sharp;font-style:normal;font-weight:400;font-display:block;src:url(/material-symbols-sharp.woff2) format("woff2"),url(https://cdn.jsdelivr.net/npm/beercss@3.12.13/dist/cdn/material-symbols-sharp.woff2) format("woff2")}@font-face{font-family:Material Symbols Subset;font-style:normal;font-weight:400;font-display:block;src:url(/material-symbols-subset.woff2) format("woff2"),url(https://cdn.jsdelivr.net/npm/beercss@3.12.13/dist/cdn/material-symbols-subset.woff2) format("woff2")}*{-webkit-tap-highlight-color:transparent;position:relative;vertical-align:middle;color:inherit;margin:0;padding:0;border-radius:inherit;box-sizing:border-box}*:after,*:before{all:unset}body{color:var(--on-surface);background-color:var(--surface);overflow-x:hidden}label{font-size:.75rem;vertical-align:baseline}a,b,i,span,strong,em,code{vertical-align:baseline}a,button,.button{cursor:pointer;text-decoration:none;display:inline-flex;align-items:center;border:none;font-family:inherit;outline:inherit;justify-content:center}a,button,.button,i,label{-webkit-user-select:none;user-select:none}@media(pointer:fine){body ::-webkit-scrollbar,body ::-webkit-scrollbar-thumb,body ::-webkit-scrollbar-button{background:none;inline-size:.4rem;block-size:.4rem}body :is(:focus,:hover)::-webkit-scrollbar-thumb,body :has(:focus,:hover)::-webkit-scrollbar-thumb{background:var(--outline);border-radius:1rem}}:not(.grid,nav,.row)>:not(progress.max)+:is(address,article,blockquote,code,.field,fieldset,form,.grid,h1,h2,h3,h4,h5,h6,nav,ol,p,pre,.row,section,aside,table,.tabs,ul):not([class*=margin],.right,.left,.top,.bottom){margin-block-start:1rem}:has(>[class*=margin]){padding:.1px}:is(a,button,.button,.chip):focus-visible{outline:.125rem solid var(--primary);outline-offset:.25rem}:is(nav,.row,li).group>:focus-visible{z-index:1}:is(button,.button,.chip)>:is(span,i,img,svg){pointer-events:none}.transparent{background-color:transparent!important;box-shadow:none!important;color:inherit!important}.primary{background-color:var(--primary)!important;color:var(--on-primary)!important}.primary-text{color:var(--primary)!important}.primary-border{border-color:var(--primary)!important}.primary-container{background-color:var(--primary-container)!important;color:var(--on-primary-container)!important}.secondary{background-color:var(--secondary)!important;color:var(--on-secondary)!important}.secondary-text{color:var(--secondary)!important}.secondary-border{border-color:var(--secondary)!important}.secondary-container{background-color:var(--secondary-container)!important;color:var(--on-secondary-container)!important}.tertiary{background-color:var(--tertiary)!important;color:var(--on-tertiary)!important}.tertiary-text{color:var(--tertiary)!important}.tertiary-border{border-color:var(--tertiary)!important}.tertiary-container{background-color:var(--tertiary-container)!important;color:var(--on-tertiary-container)!important}.error{background-color:var(--error)!important;color:var(--on-error)!important}.error-text{color:var(--error)!important}.error-border{border-color:var(--error)!important}.error-container{background-color:var(--error-container)!important;color:var(--on-error-container)!important}.background{background-color:var(--background)!important;color:var(--on-background)!important}.surface,.surface-dim,.surface-bright,.surface-container-lowest,.surface-container-low,.surface-container,.surface-container-high,.surface-container-highest{background-color:var(--surface)!important;color:var(--on-surface)!important}.surface-variant{background-color:var(--surface-variant)!important;color:var(--on-surface-variant)!important}.inverse-surface{background-color:var(--inverse-surface);color:var(--inverse-on-surface)}.inverse-primary{background-color:var(--inverse-primary);color:var(--primary)}.inverse-primary-text{color:var(--inverse-primary)!important}.inverse-primary-border{border-color:var(--inverse-primary)!important}.surface-dim{background-color:var(--surface-dim)!important}.surface-bright{background-color:var(--surface-bright)!important}.surface-container-lowest{background-color:var(--surface-container-lowest)!important}.surface-container{background-color:var(--surface-container)!important}.surface-container-high{background-color:var(--surface-container-high)!important}.surface-container-highest{background-color:var(--surface-container-highest)!important}.surface-container-low{background-color:var(--surface-container-low)!important}.black{background-color:#000!important}.black-border{border-color:#000!important}.black-text{color:#000!important}.white{background-color:#fff!important}.white-border{border-color:#fff!important}.white-text{color:#fff!important}.transparent-border{border-color:transparent!important}.transparent-text{color:transparent!important}.fill:not(i){background-color:var(--surface-variant)!important;color:var(--on-surface-variant)!important}.middle-align{display:flex;align-items:center!important}.bottom-align{display:flex;align-items:flex-end!important}.top-align{display:flex;align-items:flex-start!important}.left-align{text-align:start;justify-content:flex-start!important}.right-align{text-align:end;justify-content:flex-end!important}.center-align{text-align:center;justify-content:center!important}[class*=blur],[class*=blur].light{--_blur: 1rem;-webkit-backdrop-filter:blur(var(--_blur));backdrop-filter:blur(var(--_blur));color:var(--on-surface);background-color:#ffffff80!important}.dark [class*=blur],[class*=blur].dark{background-color:#00000080!important}.small-blur{--_blur: .5rem}.large-blur{--_blur: 1.5rem}.red,.red6{background-color:#f44336!important}.red-border{border-color:#f44336!important}.red-text{color:#f44336!important}.red1{background-color:#ffebee!important}.red2{background-color:#ffcdd2!important}.red3{background-color:#ef9a9a!important}.red4{background-color:#e57373!important}.red5{background-color:#ef5350!important}.red7{background-color:#e53935!important}.red8{background-color:#d32f2f!important}.red9{background-color:#c62828!important}.red10{background-color:#b71c1c!important}.pink,.pink6{background-color:#e91e63!important}.pink-border{border-color:#e91e63!important}.pink-text{color:#e91e63!important}.pink1{background-color:#fce4ec!important}.pink2{background-color:#f8bbd0!important}.pink3{background-color:#f48fb1!important}.pink4{background-color:#f06292!important}.pink5{background-color:#ec407a!important}.pink7{background-color:#d81b60!important}.pink8{background-color:#c2185b!important}.pink9{background-color:#ad1457!important}.pink10{background-color:#880e4f!important}.purple,.purple6{background-color:#9c27b0!important}.purple-border{border-color:#9c27b0!important}.purple-text{color:#9c27b0!important}.purple1{background-color:#f3e5f5!important}.purple2{background-color:#e1bee7!important}.purple3{background-color:#ce93d8!important}.purple4{background-color:#ba68c8!important}.purple5{background-color:#ab47bc!important}.purple7{background-color:#8e24aa!important}.purple8{background-color:#7b1fa2!important}.purple9{background-color:#6a1b9a!important}.purple10{background-color:#4a148c!important}.deep-purple,.deep-purple6{background-color:#673ab7!important}.deep-purple-border{border-color:#673ab7!important}.deep-purple-text{color:#673ab7!important}.deep-purple1{background-color:#ede7f6!important}.deep-purple2{background-color:#d1c4e9!important}.deep-purple3{background-color:#b39ddb!important}.deep-purple4{background-color:#9575cd!important}.deep-purple5{background-color:#7e57c2!important}.deep-purple7{background-color:#5e35b1!important}.deep-purple8{background-color:#512da8!important}.deep-purple9{background-color:#4527a0!important}.deep-purple10{background-color:#311b92!important}.indigo,.indigo6{background-color:#3f51b5!important}.indigo-border{border-color:#3f51b5!important}.indigo-text{color:#3f51b5!important}.indigo1{background-color:#e8eaf6!important}.indigo2{background-color:#c5cae9!important}.indigo3{background-color:#9fa8da!important}.indigo4{background-color:#7986cb!important}.indigo5{background-color:#5c6bc0!important}.indigo7{background-color:#3949ab!important}.indigo8{background-color:#303f9f!important}.indigo9{background-color:#283593!important}.indigo10{background-color:#1a237e!important}.blue,.blue6{background-color:#2196f3!important}.blue-border{border-color:#2196f3!important}.blue-text{color:#2196f3!important}.blue1{background-color:#e3f2fd!important}.blue2{background-color:#bbdefb!important}.blue3{background-color:#90caf9!important}.blue4{background-color:#64b5f6!important}.blue5{background-color:#42a5f5!important}.blue7{background-color:#1e88e5!important}.blue8{background-color:#1976d2!important}.blue9{background-color:#1565c0!important}.blue10{background-color:#0d47a1!important}.light-blue,.light-blue6{background-color:#03a9f4!important}.light-blue-border{border-color:#03a9f4!important}.light-blue-text{color:#03a9f4!important}.light-blue1{background-color:#e1f5fe!important}.light-blue2{background-color:#b3e5fc!important}.light-blue3{background-color:#81d4fa!important}.light-blue4{background-color:#4fc3f7!important}.light-blue5{background-color:#29b6f6!important}.light-blue7{background-color:#039be5!important}.light-blue8{background-color:#0288d1!important}.light-blue9{background-color:#0277bd!important}.light-blue10{background-color:#01579b!important}.cyan,.cyan6{background-color:#00bcd4!important}.cyan-border{border-color:#00bcd4!important}.cyan-text{color:#00bcd4!important}.cyan1{background-color:#e0f7fa!important}.cyan2{background-color:#b2ebf2!important}.cyan3{background-color:#80deea!important}.cyan4{background-color:#4dd0e1!important}.cyan5{background-color:#26c6da!important}.cyan7{background-color:#00acc1!important}.cyan8{background-color:#0097a7!important}.cyan9{background-color:#00838f!important}.cyan10{background-color:#006064!important}.teal,.teal6{background-color:#009688!important}.teal-border{border-color:#009688!important}.teal-text{color:#009688!important}.teal1{background-color:#e0f2f1!important}.teal2{background-color:#b2dfdb!important}.teal3{background-color:#80cbc4!important}.teal4{background-color:#4db6ac!important}.teal5{background-color:#26a69a!important}.teal7{background-color:#00897b!important}.teal8{background-color:#00796b!important}.teal9{background-color:#00695c!important}.teal10{background-color:#004d40!important}.green,.green6{background-color:#4caf50!important}.green-border{border-color:#4caf50!important}.green-text{color:#4caf50!important}.green1{background-color:#e8f5e9!important}.green2{background-color:#c8e6c9!important}.green3{background-color:#a5d6a7!important}.green4{background-color:#81c784!important}.green5{background-color:#66bb6a!important}.green7{background-color:#43a047!important}.green8{background-color:#388e3c!important}.green9{background-color:#2e7d32!important}.green10{background-color:#1b5e20!important}.light-green,.light-green6{background-color:#8bc34a!important}.light-green-border{border-color:#8bc34a!important}.light-green-text{color:#8bc34a!important}.light-green1{background-color:#f1f8e9!important}.light-green2{background-color:#dcedc8!important}.light-green3{background-color:#c5e1a5!important}.light-green4{background-color:#aed581!important}.light-green5{background-color:#9ccc65!important}.light-green7{background-color:#7cb342!important}.light-green8{background-color:#689f38!important}.light-green9{background-color:#558b2f!important}.light-green10{background-color:#33691e!important}.lime,.lime6{background-color:#cddc39!important}.lime-border{border-color:#cddc39!important}.lime-text{color:#cddc39!important}.lime1{background-color:#f9fbe7!important}.lime2{background-color:#f0f4c3!important}.lime3{background-color:#e6ee9c!important}.lime4{background-color:#dce775!important}.lime5{background-color:#d4e157!important}.lime7{background-color:#c0ca33!important}.lime8{background-color:#afb42b!important}.lime9{background-color:#9e9d24!important}.lime10{background-color:#827717!important}.yellow,.yellow6{background-color:#ffeb3b!important}.yellow-border{border-color:#ffeb3b!important}.yellow-text{color:#ffeb3b!important}.yellow1{background-color:#fffde7!important}.yellow2{background-color:#fff9c4!important}.yellow3{background-color:#fff59d!important}.yellow4{background-color:#fff176!important}.yellow5{background-color:#ffee58!important}.yellow7{background-color:#fdd835!important}.yellow8{background-color:#fbc02d!important}.yellow9{background-color:#f9a825!important}.yellow10{background-color:#f57f17!important}.amber,.amber6{background-color:#ffc107!important}.amber-border{border-color:#ffc107!important}.amber-text{color:#ffc107!important}.amber1{background-color:#fff8e1!important}.amber2{background-color:#ffecb3!important}.amber3{background-color:#ffe082!important}.amber4{background-color:#ffd54f!important}.amber5{background-color:#ffca28!important}.amber7{background-color:#ffb300!important}.amber8{background-color:#ffa000!important}.amber9{background-color:#ff8f00!important}.amber10{background-color:#ff6f00!important}.orange,.orange6{background-color:#ff9800!important}.orange-border{border-color:#ff9800!important}.orange-text{color:#ff9800!important}.orange1{background-color:#fff3e0!important}.orange2{background-color:#ffe0b2!important}.orange3{background-color:#ffcc80!important}.orange4{background-color:#ffb74d!important}.orange5{background-color:#ffa726!important}.orange7{background-color:#fb8c00!important}.orange8{background-color:#f57c00!important}.orange9{background-color:#ef6c00!important}.orange10{background-color:#e65100!important}.deep-orange,.deep-orange6{background-color:#ff5722!important}.deep-orange-border{border-color:#ff5722!important}.deep-orange-text{color:#ff5722!important}.deep-orange1{background-color:#fbe9e7!important}.deep-orange2{background-color:#ffccbc!important}.deep-orange3{background-color:#ffab91!important}.deep-orange4{background-color:#ff8a65!important}.deep-orange5{background-color:#ff7043!important}.deep-orange7{background-color:#f4511e!important}.deep-orange8{background-color:#e64a19!important}.deep-orange9{background-color:#d84315!important}.deep-orange10{background-color:#bf360c!important}.brown,.brown6{background-color:#795548!important}.brown-border{border-color:#795548!important}.brown-text{color:#795548!important}.brown1{background-color:#efebe9!important}.brown2{background-color:#d7ccc8!important}.brown3{background-color:#bcaaa4!important}.brown4{background-color:#a1887f!important}.brown5{background-color:#8d6e63!important}.brown7{background-color:#6d4c41!important}.brown8{background-color:#5d4037!important}.brown9{background-color:#4e342e!important}.brown10{background-color:#3e2723!important}.blue-grey,.blue-grey6{background-color:#607d8b!important}.blue-grey-border{border-color:#607d8b!important}.blue-grey-text{color:#607d8b!important}.blue-grey1{background-color:#eceff1!important}.blue-grey2{background-color:#cfd8dc!important}.blue-grey3{background-color:#b0bec5!important}.blue-grey4{background-color:#90a4ae!important}.blue-grey5{background-color:#78909c!important}.blue-grey7{background-color:#546e7a!important}.blue-grey8{background-color:#455a64!important}.blue-grey9{background-color:#37474f!important}.blue-grey10{background-color:#263238!important}.grey,.grey6{background-color:#9e9e9e!important}.grey-border{border-color:#9e9e9e!important}.grey-text{color:#9e9e9e!important}.grey1{background-color:#fafafa!important}.grey2{background-color:#f5f5f5!important}.grey3{background-color:#eee!important}.grey4{background-color:#e0e0e0!important}.grey5{background-color:#bdbdbd!important}.grey7{background-color:#757575!important}.grey8{background-color:#616161!important}.grey9{background-color:#424242!important}.grey10{background-color:#212121!important}.horizontal{display:inline-flex;flex-direction:row!important;gap:1rem;inline-size:auto!important;max-inline-size:none!important}.horizontal>*{margin-block:0!important}.vertical{display:flex;flex-direction:column!important}:is(a,button,.button,.chip).vertical{display:inline-flex;gap:.25rem;block-size:auto!important;max-block-size:none!important;padding-block:.5rem}.vertical>*{margin-inline:0!important}.no-elevate{box-shadow:none!important}.small-elevate,.elevate{box-shadow:var(--elevate1)!important}.medium-elevate{box-shadow:var(--elevate2)!important}.large-elevate{box-shadow:var(--elevate3)!important}.round,[class*=-round]{--_round: 2rem;border-radius:var(--_round)!important}.small-round{--_round: .5rem}.large-round{--_round: 3.5rem}.no-round,.square,.top-round,.bottom-round,.left-round,.right-round{border-radius:.5rem!important}.top-round{border-start-start-radius:var(--_round)!important;border-start-end-radius:var(--_round)!important}.bottom-round{border-end-end-radius:var(--_round)!important;border-end-start-radius:var(--_round)!important}.left-round{border-start-start-radius:var(--_round)!important;border-end-start-radius:var(--_round)!important}.right-round{border-start-end-radius:var(--_round)!important;border-end-end-radius:var(--_round)!important}.circle:not(.extend){border-radius:50%}:is(.circle,.square):is(button,.button,.chip){padding:0;block-size:var(--_size);inline-size:var(--_size)}:is(.circle,.square)>span{display:none}:is(.circle,.square).round{border-radius:1rem!important}.border:not(table,.field,.list,menu,article){box-sizing:border-box;border:.0625rem solid var(--outline);background-color:transparent;box-shadow:none}.no-border{border-color:transparent!important}.border:not(.extend,.circle,.square,.badge){box-sizing:content-box}.margin,[class*=-margin]:not(.left-margin,.right-margin,.top-margin,.bottom-margin,.horizontal-margin,.vertical-margin){margin:var(--_margin)!important}.margin,[class*=-margin]{--_margin: 1rem}.no-margin{--_margin: 0}.auto-margin{--_margin: auto}.tiny-margin{--_margin: .25rem}.small-margin{--_margin: .5rem}.large-margin{--_margin: 1.5rem}.left-margin,.horizontal-margin{margin-inline-start:var(--_margin)!important}.right-margin,.horizontal-margin{margin-inline-end:var(--_margin)!important}.top-margin,.vertical-margin{margin-block-start:var(--_margin)!important}.bottom-margin,.vertical-margin{margin-block-end:var(--_margin)!important}.no-opacity{opacity:1!important}.opacity{opacity:0!important}.small-opacity{opacity:.75!important}.medium-opacity{opacity:.5!important}.large-opacity{opacity:.25!important}.padding,[class*=-padding]:not(.left-padding,.right-padding,.top-padding,.bottom-padding,.horizontal-padding,.vertical-padding){padding:var(--_padding)!important}.padding,[class*=-padding]{--_padding: 1rem}.no-padding{--_padding: 0 !important}.tiny-padding{--_padding: .25rem !important}.small-padding{--_padding: .5rem !important}.large-padding{--_padding: 1.5rem !important}.left-padding,.horizontal-padding{padding-inline-start:var(--_padding)!important}.right-padding,.horizontal-padding{padding-inline-end:var(--_padding)!important}.top-padding,.vertical-padding{padding-block-start:var(--_padding)!important}.bottom-padding,.vertical-padding{padding-block-end:var(--_padding)!important}.front{z-index:10!important}.back{z-index:-10!important}.left{inset-inline-start:0}.right{inset-inline-end:0}.top{inset-block-start:0}.bottom{inset-block-end:0}.center{inset-inline-start:50%;transform:translate(-50%)}[dir=rtl] .center{transform:translate(50%)}.middle{inset-block-start:50%;transform:translateY(-50%)}.middle.center{transform:translate(-50%,-50%)}[dir=rtl] .middle.center{transform:translate(50%,-50%)}.ripple{--_duration: .6s}.fast-ripple{--_duration: .2s}.slow-ripple{--_duration: 1.8s}.ripple-js{position:absolute;inset:0;pointer-events:none;overflow:hidden}.ripple-js>div{position:absolute;border-radius:50%;background:currentColor;opacity:.3;transform:scale(0);animation:to-ripple var(--_duration) linear}@keyframes to-ripple{to{transform:scale(4);opacity:0}}.scroll{overflow:auto;min-inline-size:0}.no-scroll{overflow:hidden}.shadow{background-color:#00000050}:is(.left-shadow,.right-shadow,.top-shadow,.bottom-shadow){background-color:transparent!important}.left-shadow{background-image:linear-gradient(to right,black,transparent)!important}.right-shadow{background-image:linear-gradient(to left,black,transparent)!important}.bottom-shadow{background-image:linear-gradient(to top,black,transparent)!important}.top-shadow{background-image:linear-gradient(to bottom,black,transparent)!important}[class*=-width]{max-inline-size:100%}.auto-width{inline-size:auto}.small-width{inline-size:12rem!important}.medium-width{inline-size:24rem!important}.large-width{inline-size:36rem!important}.auto-height{block-size:auto}.small-height{block-size:12rem!important}.medium-height{block-size:24rem!important}.large-height{block-size:36rem!important}.wrap{display:block;white-space:normal}.no-wrap:not(menu){display:flex;white-space:nowrap}.tiny-space:not(nav,.row,.grid,table,.tooltip,.list,menu,.shape){block-size:.5rem}:is(.space,.small-space):not(nav,.row,.grid,table,.tooltip,.list,menu,.shape){block-size:1rem}.medium-space:not(nav,.row,.grid,table,.tooltip,.list,menu,.shape){block-size:2rem}.large-space:not(nav,.row,.grid,table,.tooltip,.list,menu,.shape){block-size:3rem}.extra-space:not(nav,.row,.grid,table,.tooltip,.list,menu,.shape){block-size:4rem}.responsive{inline-size:-webkit-fill-available;inline-size:-moz-available}@media only screen and (max-width:600px){:is(.m,.l):not(.s){display:none!important}}@media only screen and (min-width:601px)and (max-width:992px){:is(.s,.l):not(.m){display:none!important}}@media only screen and (min-width:993px){:is(.m,.s):not(.l){display:none!important}}html{font-size:var(--size)}body{font-family:var(--font);font-size:.875rem;line-height:1.5rem;letter-spacing:.0313rem}h1,h2,h3,h4,h5,h6{font-weight:400;display:block;align-items:center;line-height:normal}h1{font-size:3.5625rem}h2{font-size:2.8125rem}h3{font-size:2.25rem}h4{font-size:2rem}h5{font-size:1.75rem}h6{font-size:1.5rem}h1.small{font-size:3.0625rem}h2.small{font-size:2.3125rem}h3.small{font-size:1.75rem}h4.small{font-size:1.5rem}h5.small{font-size:1.25rem}h6.small{font-size:1rem}h1.large{font-size:4.0625rem}h2.large{font-size:3.3125rem}h3.large{font-size:2.75rem}h4.large{font-size:2.5rem}h5.large{font-size:2.25rem}h6.large{font-size:2rem}.link{color:var(--primary)!important}.inverse-link{color:var(--inverse-primary)!important}.truncate{overflow:hidden;white-space:nowrap!important;text-overflow:ellipsis;flex:inherit}.truncate>*{white-space:nowrap!important}.small-text{font-size:.75rem}.medium-text{font-size:.875rem}.large-text{font-size:1rem}.upper{text-transform:uppercase}.lower{text-transform:lowercase}.capitalize{text-transform:capitalize}.bold{font-weight:700}.overline{text-decoration:line-through}.underline{text-decoration:underline}.italic{font-style:italic}p{margin:.5rem 0}.no-line{line-height:normal}.tiny-line{line-height:1.25rem}.small-line{line-height:1.5rem}.medium-line{line-height:1.75rem}.large-line{line-height:2rem}.extra-line{line-height:2.25rem}pre{border-radius:0;background-color:var(--surface-container);white-space:pre-wrap;padding:1rem;border-inline-start:.25rem solid var(--primary);font-family:inherit}blockquote{border-radius:0;padding:1rem;border-inline-start:.25rem solid var(--primary);font-family:inherit}code{border-radius:0;background-color:var(--surface-container);white-space:pre-wrap;padding:.25rem}pre>code,blockquote>code{padding:0}.scroll>code{white-space:pre}pre:has(>code){direction:ltr;text-align:start}sub{vertical-align:sub}sup{vertical-align:super}:is(.wave,.chip,.button,button,nav.tabbed>a,.tabs>a,nav.toolbar>a):not(.slow-ripple,.ripple,.fast-ripple):after,nav:is(.left,.right,.bottom,.top).max>a:after,nav:is(.left,.right,.bottom,.top).max>:is(ol,ul)>li>a:after,nav:is(.left,.right,.bottom,.top):not(.max)>a>i:after,nav:is(.left,.right,.bottom,.top):not(.max)>:is(ol,ul)>li>a>i:after{content:"";position:absolute;inset:0;z-index:1;border-radius:inherit;inline-size:100%;block-size:100%;background-position:center;background-image:radial-gradient(circle,currentColor 1%,transparent 1%);opacity:0;transition:none;pointer-events:none}:is(.wave,.chip,.button,button,nav.tabbed>a,.tabs>a,nav.toolbar>a):not(.slow-ripple,.ripple,.fast-ripple):is(:focus-visible,:hover):after,nav:is(.left,.right,.bottom,.top).max>a:not(.button,.chip):is(:focus-visible,:hover):after,nav:is(.left,.right,.bottom,.top).max>:is(ol,ul)>li>a:not(.button,.chip):is(:focus-visible,:hover):after,nav:is(.left,.right,.bottom,.top):not(.max)>a:not(.button,.chip):is(:focus-visible,:hover)>i:after,nav:is(.left,.right,.bottom,.top):not(.max)>:is(ol,ul)>li>a:not(.button,.chip):is(:focus-visible,:hover)>i:after{background-size:22500%;opacity:.1;transition:background-size var(--speed2) linear}:is(.wave,.chip,.button,button,nav.tabbed>a,.tabs>a,nav.toolbar>a,nav.max>a):not(.slow-ripple,.ripple,.fast-ripple):active:after,nav:is(.left,.right,.bottom,.top).max>a:active:after,nav:is(.left,.right,.bottom,.top).max>:is(ol,ul)>li>a:active:after,nav:is(.left,.right,.bottom,.top):not(.max)>a:active>i:after,nav:is(.left,.right,.bottom,.top):not(.max)>:is(ol,ul)>li>a:active>i:after{background-size:0%;opacity:0;transition:none}.no-wave:after,.no-wave:is(:hover,:active):after{display:none}.zoom,.tiny-zoom{zoom:2}.small-zoom{zoom:3}.medium-zoom{zoom:4}.large-zoom{zoom:5}.extra-zoom{zoom:6}.badge{--_x: 0;--_y: -100%;display:inline-flex;align-items:center;justify-content:center;position:absolute;font-size:.6875rem;text-transform:none;z-index:2;padding:0 .25rem;min-block-size:1rem;min-inline-size:1rem;background-color:var(--error);color:var(--on-error);line-height:normal;border-radius:1rem;inset:50% auto auto 50%;transform:translate(var(--_x, 50%),var(--_y, -50%));font-family:var(--font)}.badge.top{--_y: -100%}.badge.bottom{--_y: 0}.badge.left{--_x: -100%}.badge.right{--_x: 0}.badge.border{border-color:var(--error);color:var(--error);background-color:var(--surface)}.badge:is(.circle,.square){text-align:center;inline-size:auto;block-size:auto;padding:0 .25rem;border-radius:1rem}.badge.square{border-radius:0}.badge.min>*{display:none}.badge.min{clip-path:circle(18.75% at 50% 50%)}nav:is(.left,.right,.top,.bottom)>a>.badge,nav:is(.left,.right,.top,.bottom)>:is(ol,ul)>li>a>.badge{inset:1rem auto auto 50%}.badge.none{inset:auto!important;transform:none;position:relative;margin:0 .125rem}header,footer{display:grid;align-content:center;border-radius:0;padding:0 1rem}:is(dialog,article)>:is(header,footer){padding-inline:0;inset:0}header{min-block-size:4rem}footer{min-block-size:5rem}:is(header,footer,menu>*).fixed{position:sticky;inset:0;z-index:11;background-color:inherit}header.fixed{inset:calc(-1 * var(--_padding)) 0 0 0;margin-block-start:calc(-1 * var(--_padding))}footer.fixed{inset:0 0 calc(-1 * var(--_padding)) 0;margin-block-end:calc(-1 * var(--_padding))}:is(header,footer).fixed.min{margin-inline:auto}dialog>:is(header,footer){background:none}dialog>:is(header,footer).fixed{background-color:inherit}:is(main,header,footer,section).responsive{max-inline-size:min(100vw,75rem);margin:0 auto}:is(main,header,footer,section).responsive.max{max-inline-size:none}:has(>main)>:is(header,footer).fixed{transform:none;box-sizing:content-box;position:sticky;inset:0;z-index:12}:has(>main)>header{padding-block-start:var(--top)}:has(>main)>footer{padding-block-end:var(--bottom)}nav.top~header,nav.bottom~footer{padding-block:0}nav.top~header.fixed{inset-block:calc(var(--top) + 4.5rem) 0}nav.bottom~footer.fixed{inset-block:0 calc(var(--bottom) + 4.5rem)}:is(nav,.row)>header{background-color:inherit}.button,button{--_padding: 1rem;--_size: 2.5rem;box-sizing:content-box;display:inline-flex;align-items:center;justify-content:center;block-size:var(--_size);font-size:.875rem;font-weight:500;color:var(--on-primary);padding:0 var(--_padding);background-color:var(--primary);margin:0 .5rem;border-radius:var(--_size);transition:transform var(--speed3),border-radius var(--speed2),padding var(--speed3);-webkit-user-select:none;user-select:none;gap:.5rem;line-height:normal}:is(button,.button).small{--_size: 2rem;--_padding: .75rem}:is(button,.button).large{--_size: 3rem;--_padding: 1.25rem}:is(.button,button):is(.extra,.extend){--_size: 3.5rem;font-size:1rem;--_padding: 1.5rem}:is(button,.button):is(.square,.circle){--_padding: 0}:is(button,.button).border{border-color:var(--outline-variant);color:var(--primary)}.extend>span{display:none}.extend:is(:hover,.active){inline-size:auto;--_padding: 1.5rem;padding:0 var(--_padding)}.extend:is(:hover,.active)>i+span{display:inherit;margin-inline-start:var(--_padding)}.extend:is(:hover,.active)>:is(img,svg)+span{display:inherit;margin-inline-start:calc(1rem + var(--_padding))}:is(.button,button)[disabled]{opacity:.5;cursor:not-allowed}.button[disabled]{pointer-events:none}:is(.button,button)[disabled]:before,:is(.button,button)[disabled]:after{display:none}:is(.button,button):not(.chip,.extend).fill{background-color:var(--secondary-container)!important;color:var(--on-secondary-container)!important}:is(.button,button):not(.chip,.extend).active{background-color:var(--primary-container);color:var(--on-primary-container)}:is(.button,button):not(.chip,.extend).fill.active{background-color:var(--secondary)!important;color:var(--on-secondary)!important}:is(.button,button):not(.chip,.extend).border.active{background-color:var(--inverse-surface)!important;color:var(--inverse-on-surface)!important;border-color:var(--inverse-surface)!important}:is(.button,button):not(.chip):active,:is(.button,button):not(.chip).active{border-radius:.5rem!important}article{--_padding: 1rem;box-shadow:var(--elevate1);background-color:var(--surface-container-low);color:var(--on-surface);padding:var(--_padding);border-radius:.75rem;display:block;transition:transform var(--speed3),border-radius var(--speed3),padding var(--speed3)}article.small{block-size:12rem}article.medium{block-size:20rem}article.large{block-size:32rem}article.border{box-shadow:none;border:.0625rem solid var(--outline-variant)}.chip{--_padding: .75rem;--_size: 2rem;box-sizing:border-box;display:inline-flex;align-items:center;justify-content:center;block-size:var(--_size);min-inline-size:var(--_size);font-size:.875rem;font-weight:500;background-color:transparent;border:.0625rem solid var(--outline-variant);color:var(--on-surface-variant);padding:0 var(--_padding);margin:0 .5rem;text-transform:none;border-radius:.5rem;transition:transform var(--speed3),border-radius var(--speed3),padding var(--speed3);-webkit-user-select:none;user-select:none;gap:.5rem;line-height:normal;letter-spacing:normal}.chip.medium{--_size: 2.5rem;--_padding: 1rem}.chip.large{--_padding: 1.25rem;--_size: 3rem}.chip.fill{border:none}dialog{--_padding: 1.5rem;--_top: calc(var(--_padding) + var(--top));--_bottom: calc(var(--_padding) + var(--bottom));display:block;visibility:hidden;border:none;opacity:0;position:fixed;box-shadow:var(--elevate2);color:var(--on-surface);background-color:var(--surface-container-high);padding:var(--_padding);z-index:100;inset:10% auto auto 50%;min-inline-size:20rem;max-inline-size:100%;max-block-size:80%;overflow-x:hidden;overflow-y:auto;transition:all var(--speed3),0s background-color;border-radius:1.75rem;transform:translate(-50%,-4rem);outline:none}dialog.small{inline-size:25%;block-size:25%}dialog.medium{inline-size:50%;block-size:50%}dialog.large{inline-size:75%;block-size:75%}dialog:is(.active,[open]){visibility:visible;opacity:1;transform:translate(-50%)}dialog:popover-open{visibility:visible;opacity:1;transform:translate(-50%)}dialog:is(.top,.right,.bottom,.left,.max){--_padding: 1rem}dialog:is(.top,.bottom){opacity:1;block-size:auto;inline-size:100%;min-inline-size:auto;max-block-size:100%}dialog.top{inset:0 auto auto 0;transform:translateY(-100%);border-radius:0 0 1rem 1rem;padding-block-start:var(--_top)}dialog.bottom{inset:auto auto 0 0;transform:translateY(100%);border-radius:1rem 1rem 0 0;padding-block-end:var(--_bottom)}dialog:is(.left,.right){opacity:1;inset:0 auto auto 0;inline-size:auto;block-size:100%;max-block-size:100%;background-color:var(--surface);padding-block:var(--_top) var(--_bottom)}[dir=rtl] dialog.right,dialog.left{inset:0 auto auto 0;border-radius:0 1rem 1rem 0;transform:translate(-100%)}[dir=rtl] dialog.left,dialog.right{inset:0 0 auto auto;border-radius:1rem 0 0 1rem;transform:translate(100%)}dialog.max{inset:0 auto auto 0;inline-size:100%;block-size:100%;max-inline-size:100%;max-block-size:100%;transform:translateY(4rem);background-color:var(--surface);border-radius:0;padding-block:var(--_top) var(--_bottom)}dialog:is(.active,[open]):is(.left,.right,.top,.bottom,.max){transform:translate(0)}dialog:popover-open:is(.left,.right,.top,.bottom,.max){transform:translate(0)}dialog.small:is(.left,.right){inline-size:20rem}dialog.medium:is(.left,.right){inline-size:32rem}dialog.large:is(.left,.right){inline-size:44rem}dialog.small:is(.top,.bottom){block-size:16rem}dialog.medium:is(.top,.bottom){block-size:24rem}dialog.large:is(.top,.bottom){block-size:32rem}@media(pointer:coarse){body:has(dialog[open],dialog.active){overflow:hidden}}hr,[class*=divider]{all:unset;inline-size:-webkit-fill-available;min-block-size:auto;block-size:.0625rem;background-color:var(--outline-variant);display:block}hr+*,[class*=divider]+*{margin:0!important}hr.medium,.medium-divider{margin:1rem 0!important}hr.large,.large-divider{margin:1.5rem 0!important}hr.small,.small-divider{margin:.5rem 0!important}li:has(>hr),li:has(>.divider){padding:0!important;align-self:normal!important;min-inline-size:auto!important;min-block-size:auto!important;inline-size:-webkit-fill-available}hr.vertical,.divider.vertical,li:has(>hr.vertical),li:has(>.divider.vertical){padding:0!important;align-self:center!important;min-inline-size:auto;min-block-size:1.5rem;inline-size:.0625rem}summary,summary:focus{list-style-type:none;cursor:pointer;outline:none}summary::-webkit-details-marker{display:none}.field{--_size: 3rem;--_start: 1.2rem;block-size:var(--_size);margin-block-end:2rem;border-radius:.25rem .25rem 0 0;max-block-size:12rem}.grid>*>.field{margin-block-end:1rem}.grid>*>.field+.field{margin-block-start:2rem}.grid.no-space>*>.field+.field{margin-block-start:1rem}.grid.medium-space>*>.field+.field{margin-block-start:2.5rem}.grid.large-space>*>.field+.field{margin-block-start:3rem}.field.small{--_size: 2.5rem;--_start: 1rem}.field.large{--_size: 3.5rem;--_start: 1.4rem}.field.extra{--_size: 4rem;--_start: 1.6rem}.field.border{border-radius:.25rem}.field.round.small{border-radius:1.25rem}.field.round{border-radius:1.5rem}.field.round.large{border-radius:1.75rem}.field.round.extra{border-radius:2rem}.field>:is(i,img,svg,progress,a:not(.helper,.error)){position:absolute;inset:50% auto auto;transform:translateY(-50%);cursor:pointer;z-index:0;inline-size:1.5rem;block-size:1.5rem}.field>:is(i,img,svg,progress,a:not(.helper,.error)),[dir=rtl] .field>:is(i,img,svg,progress,a:not(.helper,.error)):first-child{inset:50% 1rem auto auto}.field>:is(i,img,svg,progress,a:not(.helper,.error)):first-child,[dir=rtl] .field>:is(i,img,svg,progress,a:not(.helper,.error)){inset:50% auto auto 1rem}.field.invalid>i{color:var(--error)}.field>progress.circle{inset-block-start:calc(50% - .75rem)!important;border-width:.1875rem}.field>a:not(.helper,.error){z-index:10}.field>a>:is(i,img,svg,progress,a:not(.helper,.error)){inline-size:1.5rem;block-size:1.5rem}.field>:is(input,textarea,select){all:unset;position:relative;display:flex;align-items:center;box-sizing:border-box;border-radius:inherit;border:.0625rem solid transparent;padding:0 .9375rem;font-family:inherit;font-size:1rem;inline-size:100%;block-size:100%;outline:none;z-index:1;background:none;resize:none;text-align:start;cursor:text}input::-webkit-date-and-time-value{text-align:start}:is(input,select,textarea):is(:-webkit-autofill,:autofill){-webkit-background-clip:text;-webkit-text-fill-color:var(--on-surface)}.field>:is(input,textarea,select):focus{border:.125rem solid transparent;padding:0 .875rem}.field.min>textarea{overflow:hidden auto;position:absolute;inset:0}input[type=file],input[type=color],:not(.field)>input[type^=date],:not(.field)>input[type^=time],input::-webkit-calendar-picker-indicator{opacity:0;position:absolute;inset:0;inline-size:100%;block-size:100%;margin:0;padding:0;border:0;outline:0;z-index:2!important}input::-webkit-search-decoration,input::-webkit-search-cancel-button,input::-webkit-search-results-button,input::-webkit-search-results-decoration,input::-webkit-inner-spin-button,input::-webkit-outer-spin-button{display:none}input[type=number]{-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield}.field.border>:is(input,textarea,select){border-color:var(--outline)}.field.border>:is(input,textarea,select):focus{border-color:var(--primary)}.field.round>:is(input,textarea,select){padding-inline:1.4376rem}.field.round>:is(input,textarea,select):focus{padding-inline:1.375rem}.field.prefix>:is(input,textarea,select){padding-inline-start:2.9375rem}.field.prefix>.slider{margin-inline-start:3.5rem}.field.prefix>:is(input,textarea,select):focus{padding-inline-start:2.875rem}.field.suffix>:is(input,textarea,select){padding-inline-end:2.9375rem}.field.suffix>.slider{margin-inline-end:3.5rem}.field.suffix>:is(input,textarea,select):focus{padding-inline-end:2.875rem}.field:not(.border,.round)>:is(input,textarea,select){border-block-end-color:var(--outline)}.field:not(.border,.round)>:is(input,textarea,select):focus{border-block-end-color:var(--primary)}.field.round:not(.border,.fill)>:is(input,textarea,select),.field.round:not(.border)>:is(input,textarea,select):focus{box-shadow:var(--elevate1)}.field.round:not(.border,.fill)>:is(input,textarea,select):focus{box-shadow:var(--elevate2)}.field.invalid:not(.border,.round)>:is(input,textarea,select),.field.invalid:not(.border,.round)>:is(input,textarea,select):focus{border-block-end-color:var(--error)}.field.invalid.border>:is(input,textarea,select),.field.invalid.border>:is(input,textarea,select):focus{border-color:var(--error)}.field:has(>:disabled){opacity:.5;cursor:not-allowed}.field>:disabled{cursor:not-allowed}.field.textarea.small:not(.min){--_size: 5rem}.field.textarea:not(.min){--_size: 5.5rem}.field.textarea.large:not(.min){--_size: 6rem}.field.textarea.extra:not(.min){--_size: 6.5rem}.field>select{-webkit-user-select:none;user-select:none}@-moz-document url-prefix(){.field>select:focus{background-color:var(--surface)}.field.fill>select:focus{background-color:var(--surface-variant)}.field>select:focus+label{z-index:1}}.field>select>option{background-color:var(--surface)}.field.label>:is(input,select){padding-block-start:1rem}.field.label.border:not(.fill)>:is(input,select){padding-block-start:0}.field>textarea{padding-block-start:var(--_start);white-space:pre-wrap;overflow-wrap:break-word}.field>textarea:focus{padding-block-start:calc(var(--_start) - .06rem)}.field:not(.label)>textarea,.field.border.label:not(.fill)>textarea{padding-block-start:calc(var(--_start) - .5rem)}.field:not(.label)>textarea:focus,.field.border.label:not(.fill)>textarea:focus{padding-block-start:calc(var(--_start) - .56rem)}.field.label>label{--_start: 1rem;position:absolute;inset:-.5rem 1rem 0 var(--_start);display:flex;block-size:calc(var(--_size) + 1rem);line-height:calc(var(--_size) + 1rem);font-size:1rem;transition:all .2s;gap:.25rem;white-space:nowrap}.field.label.round>label{inset:-.5rem 1.75rem 0 var(--_start)}.field.label.textarea:not(.min)>label{block-size:calc(var(--_size) - 1.5rem);line-height:calc(var(--_size) - 1.5rem)}.field.label.border.prefix:not(.fill)>:is(label.active,:focus+label,[placeholder]:not(:placeholder-shown)+label,select+label){--_start: 1rem}.field.label.round>label,.field.label.border.prefix.round:not(.fill)>:is(label.active,:focus+label,[placeholder]:not(:placeholder-shown)+label,select+label){--_start: 1.5rem}.field.label.prefix>label{--_start: 3rem}.field.label>:is(label.active,:focus+label,[placeholder]:not(:placeholder-shown)+label,select+label){block-size:2.5rem;line-height:2.5rem;font-size:.75rem}.field.label.border:not(.fill)>:is(label.active,:focus+label,[placeholder]:not(:placeholder-shown)+label,select+label){block-size:1rem;line-height:1rem}.field.label.border:not(.fill)>label:after{content:"";display:block;margin:.5rem 0 0;border-block-start:.0625rem solid var(--outline);block-size:1rem;transition:none;flex:auto}.field.label.border:not(.fill)>:focus+label:after{border-block-start:.125rem solid var(--primary)}.field.label.border:not(.fill)>:is(input,textarea):is(:focus,[placeholder]:not(:placeholder-shown),.active),.field.label.border:not(.fill)>select{clip-path:polygon(-2% -2%,.75rem -2%,.75rem .5rem,calc(100% - 1rem) .5rem,calc(100% - 1rem) -2%,102% -2%,102% 102%,-2% 102%)}[dir=rtl] .field.label.border:not(.fill)>:is(input,textarea):is(:focus,[placeholder]:not(:placeholder-shown),.active),[dir=rtl] .field.label.border:not(.fill)>select{clip-path:polygon(-2% -2%,1rem -2%,1rem .5rem,calc(100% - .75rem) .5rem,calc(100% - .75rem) -2%,102% -2%,102% 102%,-2% 102%)}.field.label.border.round:not(.fill)>:is(input,textarea):is(:focus,[placeholder]:not(:placeholder-shown),.active),.field.label.border.round:not(.fill)>select{clip-path:polygon(-2% -2%,1.25rem -2%,1.25rem .5rem,calc(100% - 1.75rem) .5rem,calc(100% - 1.75rem) -2%,102% -2%,102% 102%,-2% 102%)}[dir=rtl] .field.label.border.round:not(.fill)>:is(input,textarea):is(:focus,[placeholder]:not(:placeholder-shown),.active),[dir=rtl] .field.label.border.round:not(.fill)>select{clip-path:polygon(-2% -2%,1.75rem -2%,1.75rem .5rem,calc(100% - 1.25rem) .5rem,calc(100% - 1.25rem) -2%,102% -2%,102% 102%,-2% 102%)}.field.label>:focus+label{color:var(--primary)}.field.label.invalid>label,.field.label.invalid>label:after{color:var(--error)!important;border-color:var(--error)!important}.field.label>label>a{block-size:inherit;line-height:inherit;inline-size:1rem}.field.label>label>a>:is(i,img,svg){block-size:1rem;line-height:1rem;inline-size:1rem;font-size:1rem}.field>:is(.helper,.error){position:absolute;inset:auto auto 0 1rem;transform:translateY(100%);font-size:.75rem;background:none!important;padding-block-start:.125rem}[dir=rtl] .field>:is(.helper,.error){inset:auto 1rem 0 auto}a.helper{color:var(--primary)}.field>.error{color:var(--error)!important}.field.round>:is(.helper,.error){inset-inline-start:1.5rem}.field.invalid>.helper{display:none}table td>.field{margin:0}fieldset{border-radius:.25rem;padding:1rem;border:.0625rem solid var(--outline-variant)}fieldset>legend{margin:0 -.25rem;padding:0 .25rem}fieldset>legend+*{margin-block-start:0!important}.grid{--_gap: 1rem;display:grid;grid-template-columns:repeat(12,1fr);gap:var(--_gap);block-size:auto}.grid.no-space{--_gap: 0rem}.grid.medium-space{--_gap: 1.5rem}.grid.large-space{--_gap: 2rem}.grid>*{margin:0}.s1{grid-area:auto/span 1}.s2{grid-area:auto/span 2}.s3{grid-area:auto/span 3}.s4{grid-area:auto/span 4}.s5{grid-area:auto/span 5}.s6{grid-area:auto/span 6}.s7{grid-area:auto/span 7}.s8{grid-area:auto/span 8}.s9{grid-area:auto/span 9}.s10{grid-area:auto/span 10}.s11{grid-area:auto/span 11}.s12{grid-area:auto/span 12}@media only screen and (min-width:601px){.m1{grid-area:auto/span 1}.m2{grid-area:auto/span 2}.m3{grid-area:auto/span 3}.m4{grid-area:auto/span 4}.m5{grid-area:auto/span 5}.m6{grid-area:auto/span 6}.m7{grid-area:auto/span 7}.m8{grid-area:auto/span 8}.m9{grid-area:auto/span 9}.m10{grid-area:auto/span 10}.m11{grid-area:auto/span 11}.m12{grid-area:auto/span 12}}@media only screen and (min-width:993px){.l1{grid-area:auto/span 1}.l2{grid-area:auto/span 2}.l3{grid-area:auto/span 3}.l4{grid-area:auto/span 4}.l5{grid-area:auto/span 5}.l6{grid-area:auto/span 6}.l7{grid-area:auto/span 7}.l8{grid-area:auto/span 8}.l9{grid-area:auto/span 9}.l10{grid-area:auto/span 10}.l11{grid-area:auto/span 11}.l12{grid-area:auto/span 12}}i,:is(.checkbox,.radio,.switch)>span:before,:is(.checkbox,.radio,.switch)>span>i{--_size: 1.5rem;font-family:var(--font-icon);font-weight:400;font-style:normal;font-size:var(--_size);letter-spacing:normal;text-transform:none;display:inline-flex;align-items:center;justify-content:center;white-space:nowrap;word-wrap:normal;direction:ltr;font-feature-settings:"liga";-webkit-font-smoothing:antialiased;vertical-align:middle;text-align:center;overflow:hidden;inline-size:var(--_size);min-inline-size:var(--_size);block-size:var(--_size);min-block-size:var(--_size);box-sizing:content-box;line-height:normal;border-radius:0}i:has(.badge){overflow:unset}i.tiny{--_size: 1rem}.chip>i,i.small{--_size: 1.25rem}i.medium{--_size: 1.5rem}i.large{--_size: 1.75rem}i.extra{--_size: 2rem}i.fill,a.active>i,button.active>i{font-variation-settings:"FILL" 1}i>:is(img,svg){inline-size:100%;block-size:100%;background-size:100%;border-radius:inherit;position:absolute;inset:0 auto auto 0;padding:inherit}i[class*=fa-]{font-size:calc(var(--_size) * .85);line-height:normal;block-size:auto;min-block-size:auto}.absolute{position:absolute}.fixed{position:fixed}:is(.absolute,.fixed).left.right{inline-size:auto}:is(.absolute,.fixed).left.right.small{block-size:20rem}:is(.absolute,.fixed).left.right.medium{block-size:28rem}:is(.absolute,.fixed).left.right.large{block-size:44rem}:is(.absolute,.fixed).top.bottom.small{inline-size:20rem}:is(.absolute,.fixed).top.bottom.medium{inline-size:28rem}:is(.absolute,.fixed).top.bottom.large{inline-size:44rem}.list{display:flex;flex-direction:column;padding:0;margin:0;flex:1}.list>li,.list>li>details>summary,.list>li>a:only-child{all:unset;box-sizing:border-box;position:relative;display:flex;align-items:center;align-self:normal;text-align:start;justify-content:flex-start;white-space:nowrap;gap:1rem;min-block-size:3.5rem;padding:.5rem 1rem;cursor:pointer;flex:1}.list>li:has(ul,ol,details[open],a:only-child){padding:0}.list>li>.list{padding:0 0 0 1rem}.list>li>*,.list>li>a:only-child>*,.list>li>details>summary>*{margin:0}.list>li>:is(details,.max),.list>li>a:only-child>.max,.list>li>details>summary>.max{flex:1}.list.border>li:not(:last-child):before,.list.border>li>details[open]>summary:before{content:"";position:absolute;background-color:var(--outline-variant);inset:auto 0 0;block-size:.0625rem;inline-size:auto}.list.no-space>li,.list.no-space>li>details>summary{min-block-size:2.5rem}.list.medium-space>li,.list.medium-space>li>details>summary{min-block-size:4.5rem}.list.large-space>li,.list.large-space>li>details>summary{min-block-size:5.5rem}:has(>main){display:grid;grid-template-columns:auto 1fr auto;grid-template-rows:auto auto 1fr auto auto;grid-template-areas:"left top right" "left header right" "left main right" "left footer right" "left bottom right";min-block-size:100dvh;box-sizing:border-box;background-color:var(--surface)}nav.left{grid-area:left}nav.right{grid-area:right}nav.top{grid-area:top}nav.bottom{grid-area:bottom}header{grid-area:header}footer{grid-area:footer}main{--_padding: .5rem;grid-area:main;padding:var(--_padding);overflow:hidden}aside{z-index:1}aside:not(.fixed,.absolute).right{float:right}aside:not(.fixed,.absolute).left{float:left}svg{fill:currentcolor}:is(img,svg,video):is(.small,.medium,.large,.tiny,.extra,.round,.circle,.square,.responsive){--_size: 3rem;object-fit:cover;object-position:center;transition:transform var(--speed3),border-radius var(--speed3),padding var(--speed3);block-size:var(--_size);inline-size:var(--_size)}:is(img,svg,video).round{--_round: .5rem}:is(img,svg,video).tiny{--_size: 2rem}:is(img,svg,video).small{--_size: 2.5rem}:is(img,svg,video).large{--_size: 3.5rem}:is(img,svg,video).extra{--_size: 4rem}:is(img,svg,video).responsive{--_size: 100%;margin:0 auto}:is(img,svg,video).responsive.tiny{inline-size:100%;block-size:4rem}:is(img,svg,video).responsive.small{inline-size:100%;block-size:8rem}:is(img,svg,video).responsive.medium{inline-size:100%;block-size:12rem}:is(img,svg,video).responsive.large{inline-size:100%;block-size:16rem}:is(img,svg,video).responsive.extra{inline-size:100%;block-size:20rem}:is(img,svg,video).responsive.round{--_round: 2rem}:is(img,svg,video).empty-state{max-inline-size:100%;inline-size:24rem}:is(button,.button,.chip):not(.transparent)>.responsive{border:.25rem solid transparent}:is(button,.button,.chip,.field)>:is(img,svg):not(.responsive),.tabs :is(img,svg):not(.responsive){min-inline-size:1.5rem;max-inline-size:1.5rem;min-block-size:1.5rem;max-block-size:1.5rem}:is(button,.button,.chip):not(.extend)>.responsive:first-child{margin-inline-start:calc(-1 * var(--_padding))}:is(button,.button,.chip):not(.extend)>.responsive:not(:first-child){margin-inline-end:calc(-1 * var(--_padding))}:is(button,.button,.chip,.circle,.square,.extend)>.responsive{--_size: inherit;margin:0 auto}.extend>:is(.responsive,i){margin:0;position:absolute;inset-inline:1rem;z-index:1}.extend>.responsive{inset-inline:0;inline-size:3.5rem}.extend.border>.responsive{inline-size:3.375rem}menu{opacity:0;visibility:hidden;position:absolute;box-shadow:var(--elevate2);background-color:var(--surface-container);z-index:11;inset:auto auto 0 0;inline-size:100%;max-block-size:50vh;max-inline-size:none!important;overflow-x:hidden;overflow-y:auto;font-size:.875rem;font-weight:400;text-transform:none;color:var(--on-surface);line-height:normal;text-align:start;border-radius:.25rem;transform:scale(.8) translateY(120%);transition:all var(--speed2),0s background-color;justify-content:flex-start;padding:.5rem 0}[dir=rtl] menu{inset:auto 0 0 auto}menu.no-wrap{inline-size:max-content;white-space:nowrap!important}menu.active,:not(menu,[data-ui]):focus-within>menu,menu>li:hover>menu,menu>li>menu:hover{opacity:1;visibility:visible;transform:scale(1) translateY(100%)}menu.active.top,:not(menu,[data-ui]):focus-within>menu.top,menu>li:hover>menu.top,menu>li>menu.top:hover{transform:scale(1) translateY(-100%)}menu *{white-space:inherit!important}menu>li,menu>li>a:only-child{all:unset;box-sizing:border-box;position:relative;display:flex;align-items:center;align-self:normal;text-align:start;justify-content:inherit;white-space:nowrap;gap:1rem;padding:.5rem 1rem;min-block-size:3rem;flex:1;margin:0!important;cursor:pointer}menu>li:is(:hover,:focus,.active){background-color:var(--active)}menu>li>:is(.max,.field),menu>li>a:only-child>.max,menu>li:has(.field,a:only-child){flex:1;padding:0;margin:0}menu.min{inset:0 0 auto;transform:none!important;background-color:var(--surface-variant)!important;color:var(--on-surface-variant)!important;padding:0}[dir=rtl] menu.min.right,menu.min.left,menu.top.left{inset:0 0 auto auto}[dir=rtl] menu.min.left,menu.min.right,menu.top,menu.top.right{inset:0 auto auto 0}menu.max{position:fixed;inset:0;block-size:100%;max-block-size:none;min-block-size:auto;z-index:100;transform:none!important;background-color:var(--surface-variant)!important;color:var(--on-surface-variant)!important;border-radius:0}menu.no-wrap:is(.min,.max){min-inline-size:16rem}[dir=rtl] menu.right,[dir=rtl] menu.top.min.right,menu.left,menu.top.min.left{inset:auto 0 0 auto}[dir=rtl] menu.left,[dir=rtl] menu.top.min.left,menu.right,menu.top.min{inset:auto auto 0 0}menu.top{transform:scale(.8) translateY(-120%)}menu:has(menu){--_child: 1;--_type: 0;overflow:unset;white-space:nowrap;inline-size:auto;min-inline-size:12rem;max-block-size:none}menu>li>:is(menu,menu.right),[dir=rtl] menu>li>menu.left{inset:auto auto calc(3rem * (var(--_child) - var(--_type))) 100%}[dir=rtl] menu>li>:is(menu,menu.right),menu>li>menu.left{inset:auto 100% calc(3rem * (var(--_child) - var(--_type))) auto}menu>li>:is(menu.top,menu.top.right),[dir=rtl] menu>li>menu.top.left{inset:calc(3rem * (var(--_child) - var(--_type))) auto auto 100%}[dir=rtl] menu>li>:is(menu.top,menu.top.right),menu>li>menu.top.left{inset:calc(3rem * (var(--_child) - var(--_type))) 100% auto auto}menu.no-space>li{min-block-size:2.5rem}menu.medium-space>li{min-block-size:3.5rem}menu.large-space>li{min-block-size:4rem}menu.border>li:not(:last-child):before{content:"";position:absolute;background-color:var(--outline-variant);inset:auto 0 0;block-size:.0625rem;inline-size:auto}menu.transparent{margin:0 -1rem!important;padding:.5rem}menu.transparent>li{background-color:inherit;box-shadow:none;padding:0}menu>li:nth-last-child(2){--_child: 2}menu>li:nth-last-child(3){--_child: 3}menu>li:nth-last-child(4){--_child: 4}menu>li:nth-last-child(5){--_child: 5}menu>li:nth-last-child(6){--_child: 6}menu>li:nth-last-child(7){--_child: 7}menu>li:nth-last-child(8){--_child: 8}menu>li:nth-last-child(9){--_child: 9}menu>li:nth-last-child(10){--_child: 10}menu>li:nth-last-child(11){--_child: 11}menu>li:nth-last-of-type(2){--_type: 1}menu>li:nth-last-of-type(3){--_type: 2}menu>li:nth-last-of-type(4){--_type: 3}menu>li:nth-last-of-type(5){--_type: 4}menu>li:nth-last-of-type(6){--_type: 5}menu>li:nth-last-of-type(7){--_type: 6}menu>li:nth-last-of-type(8){--_type: 7}menu>li:nth-last-of-type(9){--_type: 8}menu>li:nth-last-of-type(10){--_type: 9}menu>li:nth-last-of-type(11){--_type: 10}@media(pointer:coarse){:not(menu,[data-ui]):hover>menu{opacity:1;visibility:visible;transform:scale(1) translateY(100%)}:not(menu,[data-ui]):hover>menu.top{transform:scale(1) translateY(-100%)}}nav>:is(ol,ul),nav>:is(ol,ul)>li{all:unset}nav,.row,a.row{display:flex;align-items:center;align-self:normal;text-align:start;justify-content:flex-start;white-space:nowrap;gap:1rem;border-radius:0;min-inline-size:0}a.row,nav.row{min-block-size:3rem;margin:0}:is(nav,.row,.max)>:only-child,nav>:is(ol,ul)>li>:only-child{margin:0}:is(nav,.row)>:not(ul,ol,header,footer){margin:0;white-space:normal;flex:none}:is(nav,.row).min{display:inline-flex}:is(nav,.row,li).no-space{gap:0}:is(nav,.row,li).tiny-space{gap:.5rem}:is(nav,.row,li).medium-space{gap:1.5rem}:is(nav,.row,li).large-space{gap:2rem}:is(nav,.row)>.max,:is(nav,.row)>:is(ol,ul)>.max{flex:1}:is(nav,.row).wrap{display:flex;flex-wrap:wrap}:is(header,footer)>:is(nav,.row){min-block-size:inherit}nav:is(.left,.right,.top,.bottom){--_padding: .5rem;--_top: calc(var(--_padding) + var(--top));--_bottom: calc(var(--_padding) + var(--bottom));position:sticky;inset:0;border:0;color:var(--on-surface);transform:none;z-index:100;text-align:center;padding:var(--_padding);margin:0}nav:is(.left,.right){justify-content:flex-start;flex-direction:column;background-color:var(--surface);block-size:100dvh;min-inline-size:6rem;padding-block:var(--_top) var(--_bottom)}nav:is(.top,.bottom){position:sticky;inset:0;padding:.5rem;justify-content:center;flex-direction:row;background-color:var(--surface-container);block-size:auto;min-block-size:4.5rem}nav.top{block-size:calc(var(--top) + 4.5rem);padding-block-start:var(--_top)}nav.bottom{block-size:calc(var(--bottom) + 4.5rem);padding-block-end:var(--_bottom)}nav>header{min-block-size:auto;padding:0;margin:0 0 1rem;align-items:flex-start;gap:1rem;background:none!important}nav:is(.top,.bottom)>header{flex-direction:row;align-items:center;margin:0 1rem 0 0}nav>header>*{margin:0}nav>header>.extend:hover{--_padding: 0;inline-size:var(--_size)}nav>header>.extend:hover>span{display:none}nav>:is(ol,ul){all:inherit;min-inline-size:auto;margin:0;padding:0;flex:auto}nav.max:is(.left,.right,.top,.bottom){gap:0;inline-size:auto;align-items:flex-start;min-inline-size:12.75rem;padding:var(--_top) 1.25rem var(--_bottom) 1.25rem}nav.max>:is(ol,ul){padding:0}nav.max>header{margin:0 0 1.25rem}nav.max:is(.top,.bottom)>header{margin:0 1.25rem 0 0}nav.max>header>.extend{--_padding: 1.5rem;inline-size:auto;padding:0 var(--_padding)}nav.max>header>.extend>span{display:block;margin-inline-start:var(--_padding)}nav.max>header>.extend>:is(img,svg)+span{margin-inline-start:calc(1rem + var(--_padding))}nav.max:is(.top,.bottom){padding:0 .5rem;align-items:center;min-inline-size:auto;max-inline-size:none}nav:is(.left,.right,.top,.bottom)>a:not(.button,.chip),nav:is(.left,.right,.top,.bottom)>:is(ol,ul)>li>a:not(.button,.chip){display:flex;flex-direction:column;gap:.25rem;line-height:normal;inline-size:3.5rem;font-size:.8rem}nav:not(.max):is(.left,.right,.top,.bottom)>a:not(.button,.chip)>i,nav:not(.max):is(.left,.right,.top,.bottom)>:is(ol,ul)>li>a:not(.button,.chip)>i{padding:.25rem 1rem;border-radius:2rem;transition:padding var(--speed1) linear;margin:0 auto}nav.max:is(.left,.right,.top,.bottom)>a:not(.button,.chip),nav.max:is(.left,.right,.top,.bottom)>:is(ol,ul)>li>a:not(.button,.chip){flex-direction:row;gap:.5rem;inline-size:auto;block-size:3.5rem;padding:0 1rem;border-radius:2rem;font-size:inherit}nav.max:is(.top,.bottom)>a:not(.button,.chip),nav.max:is(.top,.bottom)>:is(ol,ul)>li>a:not(.button,.chip){gap:.25rem;block-size:2.5rem;font-size:.8rem}nav.max:is(.left,.right,.top,.bottom)>a.active:not(.button,.chip),nav.max:is(.left,.right,.top,.bottom)>:is(ol,ul)>li>a.active:not(.button,.chip),nav:is(.left,.right,.top,.bottom):not(.max)>a.active:not(.button,.chip)>i,nav:is(.left,.right,.top,.bottom):not(.max)>:is(ol,ul)>li>a.active:not(.button,.chip)>i{background-color:var(--secondary-container);color:var(--on-secondary-container)}:is(nav,.row):is(.left-align,.top-align,.vertical){justify-content:flex-start}:is(nav,.row):is(.right-align,.bottom-align){justify-content:flex-end}:is(nav,.row):is(.center-align,.middle-align){justify-content:center}:is(nav,.row):is(.left-align,.top-align,.vertical).vertical{align-items:flex-start}:is(nav,.row):is(.right-align,.bottom-align).vertical{align-items:flex-end}:is(nav,.row):is(.center-align,.middle-align).vertical{align-items:center}nav:not(.left,.right)>.space{inline-size:.5rem}nav:not(.left,.right)>.medium-space{inline-size:1rem}nav:not(.left,.right)>.large-space{inline-size:1.5rem}nav.tabbed{background-color:var(--surface-container);border-radius:4rem!important;gap:0rem;block-size:4rem}nav.tabbed.small{block-size:3rem}nav.tabbed.large{block-size:5rem}nav.tabbed>a{border-radius:inherit;block-size:inherit;display:inline-flex;align-items:center;padding-inline:1rem;gap:.5rem;font-size:1rem;flex:1}nav.tabbed>a.active{background-color:var(--primary-container)}nav.toolbar{display:inline-flex;justify-content:space-around;border-radius:2rem;background-color:var(--surface-container);color:var(--on-surface);padding:0 1rem;gap:.5rem;min-block-size:4rem;min-inline-size:4rem}nav.toolbar>a{display:inline-flex;gap:.5rem;min-inline-size:2.5rem;min-block-size:2.5rem;border-radius:1.75rem}nav.toolbar>a:has(>:not(i)){padding:0 1rem}nav.toolbar>a.active{background-color:var(--secondary-container);color:var(--on-secondary-container)}nav.toolbar.fill{background-color:var(--primary-container)!important;color:var(--on-primary-container)!important}nav.toolbar.fill>a.active{background-color:var(--surface-container)!important;color:var(--on-surface)!important}nav.toolbar.vertical{flex-direction:column!important;min-inline-size:4rem;padding:1rem 0;align-self:center;align-items:center!important}nav.toolbar.vertical>a{inline-size:2.5rem;block-size:2.5rem}nav.toolbar.vertical>a>:is(div,span):not(.badge,.tooltip){display:none}nav.toolbar.max{border-radius:0;display:flex}nav.group{background:none!important}nav.group:is(.connected,.split){gap:.125rem}nav.group:not(.split)>:is(.button,button):not(.border){background-color:var(--surface-container);color:var(--on-surface-container)}nav.group:not(.split)>:is(.button,button).active{background-color:var(--primary);color:var(--on-primary)}nav.group.connected>:is(.button,button):not(.border){background-color:var(--surface-container);color:var(--on-surface-container)}nav.group.connected>:is(.button,button).active{background-color:var(--secondary-container);color:var(--on-secondary-container)}nav.group:is(.connected,.split)>:is(.button,button).active,nav.split>:is(.button,button):active{border-radius:2rem!important}:not(nav)>:is(ul,ol){all:revert}:is(.scroll,.no-scroll,.no-space,.tabs,.tabbed)>:focus-visible{outline:.125rem solid var(--primary);outline-offset:-.125rem}nav.split>:is(.button,button):not(.chip,.fill,.border){background-color:var(--primary);color:var(--on-primary)}nav.group.primary-container>button,nav:is(.max,.toolbar,.tabbed,.group).primary>:is(button,a).active,nav:not(.max,.toolbar,.tabbed,.group).primary>a.active:not(.button,.chip)>i{background-color:var(--primary-container)!important;color:var(--on-primary-container)!important}nav.group.primary>button,nav:is(.max,.toolbar,.tabbed,.group).primary-container>:is(button,a).active,nav:not(.max,.toolbar,.tabbed,.group).primary-container>a.active:not(.button,.chip)>i{background-color:var(--primary)!important;color:var(--on-primary)!important}nav.group.secondary-container>button,nav:is(.max,.toolbar,.tabbed,.group).secondary>:is(button,a).active,nav:not(.max,.toolbar,.tabbed,.group).secondary>a.active:not(.button,.chip)>i{background-color:var(--secondary-container)!important;color:var(--on-secondary-container)!important}nav.group.secondary>button,nav:is(.max,.toolbar,.tabbed,.group).secondary-container>:is(button,a).active,nav:not(.max,.toolbar,.tabbed,.group).secondary-container>a.active:not(.button,.chip)>i{background-color:var(--secondary)!important;color:var(--on-secondary)!important}nav.group.tertiary-container>button,nav:is(.max,.toolbar,.tabbed,.group).tertiary>:is(button,a).active,nav:not(.max,.toolbar,.tabbed,.group).tertiary>a.active:not(.button,.chip)>i{background-color:var(--tertiary-container)!important;color:var(--on-tertiary-container)!important}nav.group.tertiary>button,nav:is(.max,.toolbar,.tabbed,.group).tertiary-container>:is(button,a).active,nav:not(.max,.toolbar,.tabbed,.group).tertiary-container>a.active:not(.button,.chip)>i{background-color:var(--tertiary)!important;color:var(--on-tertiary)!important}@media only screen and (max-width:600px){nav.top,nav.bottom{justify-content:space-around}}.overlay,dialog::backdrop{display:block!important;opacity:0;visibility:hidden;position:fixed;inset:0;color:var(--on-surface);background-color:var(--overlay);z-index:100;transition:all var(--speed3),0s background-color;border-radius:0}.overlay.active{opacity:1;visibility:visible}dialog:popover-open::backdrop{opacity:1;visibility:visible}.overlay+dialog::backdrop,.snackbar::backdrop{display:none}[popover]{border:0}.page{--_transform: translate(0, 0);opacity:0;position:absolute;display:none}.page.active{opacity:1;position:inherit;display:inherit;animation:var(--speed4) to-page ease}.page.active.top{--_transform: translate(0, -4rem)}.page.active.bottom{--_transform: translate(0, 4rem)}.page.active.left{--_transform: translate(-4rem, 0)}.page.active.right{--_transform: translate(4rem, 0)}@keyframes to-page{0%{opacity:0;transform:var(--_transform)}to{opacity:1;transform:translate(0)}}progress{--_light: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWJiYGAQBgAAAP//ZyYa+wAAAAZJREFUAwAAIgAWeX9MsQAAAABJRU5ErkJggg==);--_dark: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR4AWL6//+/FAAAAP//qSv5QwAAAAZJREFUAwAJIAMaJWjIvQAAAABJRU5ErkJggg==);--_size: .25rem;position:relative;inline-size:100%;block-size:var(--_size);color:var(--primary);background:var(--_light);border-radius:1rem;flex:none;border:none;overflow:hidden;writing-mode:horizontal-tb;direction:ltr;-webkit-appearance:none}.dark progress{background:var(--_dark)}progress.small{--_size: .25rem}progress.medium{--_size: .35rem}progress.large{--_size: .45rem}progress:not(.circle,[value]):after{content:"";position:absolute;inset:0;inline-size:100%;block-size:100%;clip-path:none;background:currentcolor;animation:3.2s to-linear ease infinite}progress:not(.circle,[value])::-moz-progress-bar{animation:3.2s to-linear ease infinite}progress:not(.circle,[value])::-webkit-progress-value{animation:3.2s to-linear ease infinite}progress::-webkit-progress-bar{background:none}progress::-webkit-progress-value{background:currentColor}progress::-moz-progress-bar{background:currentColor}progress.wavy{block-size:calc(var(--_size) * 2);background:none;background-image:var(--_light);background-repeat:repeat-x;background-position:0 50%;background-size:auto calc(var(--_size) / 2)}.dark progress.wavy{background-image:var(--_dark)}progress.wavy::-webkit-progress-value,progress.wavy:not(.circle,[value]):after{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='610%201101%201220%2075'%3e%3cpath%20fill='%23D0BCFF'%20d='M1870.425,1173.746c-29.448,0-58.665-7.477-84.493-21.622c-0.03-0.016-0.061-0.032-0.09-0.049%20c-43.555-23.82-95.546-23.809-139.091,0.039c-0.037,0.021-0.075,0.042-0.113,0.062c-25.803,14.109-54.984,21.567-84.394,21.568%20c-29.449,0-58.667-7.478-84.495-21.623c-43.554-23.852-95.539-23.865-139.089-0.052c-0.03,0.018-0.062,0.034-0.092,0.051%20c-25.83,14.146-55.048,21.623-84.497,21.623c-29.423,0-58.613-7.463-84.425-21.584c-0.025-0.014-0.052-0.028-0.077-0.042%20c-43.572-23.863-95.596-23.862-139.164-0.001c-0.028,0.016-0.057,0.031-0.085,0.046c-25.809,14.117-55.001,21.581-84.418,21.581%20c-0.002,0,0,0-0.001,0c-29.45-0.001-58.669-7.479-84.498-21.625c-43.534-23.845-95.513-23.863-139.063-0.058%20c-0.036,0.021-0.072,0.04-0.108,0.06c-25.829,14.146-55.047,21.623-84.496,21.623c-29.398,0-58.566-7.451-84.362-21.551%20c-0.048-0.024-0.095-0.05-0.142-0.075c-43.568-23.863-95.593-23.863-139.163,0c-0.027,0.015-0.054,0.028-0.081,0.043%20c-25.811,14.12-55.001,21.583-84.421,21.583c-29.45,0-58.668-7.478-84.497-21.624c-7.521-4.118-10.278-13.554-6.159-21.074%20s13.554-10.277,21.074-6.158c43.57,23.862,95.593,23.864,139.163,0c0.033-0.018,0.065-0.035,0.098-0.053%20c25.807-14.114,54.991-21.573,84.406-21.573c29.398,0,58.567,7.451,84.364,21.55c0.047,0.025,0.093,0.051,0.14,0.076%20c43.534,23.843,95.508,23.864,139.056,0.059c0.038-0.021,0.075-0.042,0.113-0.063c25.828-14.145,55.049-21.622,84.496-21.622%20c0.002,0,0,0,0.002,0c29.449,0,58.668,7.478,84.497,21.625c43.57,23.863,95.595,23.862,139.165,0.001%20c0.021-0.013,0.043-0.024,0.065-0.036c25.813-14.124,55.011-21.591,84.438-21.591c29.42,0,58.61,7.463,84.421,21.582%20c0.027,0.015,0.055,0.03,0.082,0.045c43.539,23.847,95.521,23.862,139.074,0.049c0.032-0.018,0.064-0.035,0.096-0.053%20c25.829-14.146,55.047-21.623,84.496-21.623s58.667,7.477,84.496,21.623c43.58,23.867,95.604,23.866,139.172,0.005%20c0.039-0.021,0.079-0.043,0.118-0.064c25.803-14.108,54.98-21.564,84.389-21.564c29.448-0.001,58.666,7.476,84.494,21.62%20c0.038,0.021,0.076,0.042,0.114,0.063c43.549,23.807,95.528,23.791,139.063-0.051c7.52-4.121,16.955-1.361,21.073,6.159%20c4.119,7.521,1.361,16.955-6.159,21.073C1929.089,1166.27,1899.872,1173.746,1870.425,1173.746z'%3e%3canimateTransform%20attributeName='transform'%20type='translate'%20from='0%200'%20to='312.5%200'%20dur='1s'%20calcMode='linear'%20repeatCount='indefinite'%20/%3e%3c/path%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='610%201101%201220%2075'%3e%3cpath%20fill='%23D0BCFF'%20d='M1870.425,1173.746c-29.448,0-58.665-7.477-84.493-21.622c-0.03-0.016-0.061-0.032-0.09-0.049%20c-43.555-23.82-95.546-23.809-139.091,0.039c-0.037,0.021-0.075,0.042-0.113,0.062c-25.803,14.109-54.984,21.567-84.394,21.568%20c-29.449,0-58.667-7.478-84.495-21.623c-43.554-23.852-95.539-23.865-139.089-0.052c-0.03,0.018-0.062,0.034-0.092,0.051%20c-25.83,14.146-55.048,21.623-84.497,21.623c-29.423,0-58.613-7.463-84.425-21.584c-0.025-0.014-0.052-0.028-0.077-0.042%20c-43.572-23.863-95.596-23.862-139.164-0.001c-0.028,0.016-0.057,0.031-0.085,0.046c-25.809,14.117-55.001,21.581-84.418,21.581%20c-0.002,0,0,0-0.001,0c-29.45-0.001-58.669-7.479-84.498-21.625c-43.534-23.845-95.513-23.863-139.063-0.058%20c-0.036,0.021-0.072,0.04-0.108,0.06c-25.829,14.146-55.047,21.623-84.496,21.623c-29.398,0-58.566-7.451-84.362-21.551%20c-0.048-0.024-0.095-0.05-0.142-0.075c-43.568-23.863-95.593-23.863-139.163,0c-0.027,0.015-0.054,0.028-0.081,0.043%20c-25.811,14.12-55.001,21.583-84.421,21.583c-29.45,0-58.668-7.478-84.497-21.624c-7.521-4.118-10.278-13.554-6.159-21.074%20s13.554-10.277,21.074-6.158c43.57,23.862,95.593,23.864,139.163,0c0.033-0.018,0.065-0.035,0.098-0.053%20c25.807-14.114,54.991-21.573,84.406-21.573c29.398,0,58.567,7.451,84.364,21.55c0.047,0.025,0.093,0.051,0.14,0.076%20c43.534,23.843,95.508,23.864,139.056,0.059c0.038-0.021,0.075-0.042,0.113-0.063c25.828-14.145,55.049-21.622,84.496-21.622%20c0.002,0,0,0,0.002,0c29.449,0,58.668,7.478,84.497,21.625c43.57,23.863,95.595,23.862,139.165,0.001%20c0.021-0.013,0.043-0.024,0.065-0.036c25.813-14.124,55.011-21.591,84.438-21.591c29.42,0,58.61,7.463,84.421,21.582%20c0.027,0.015,0.055,0.03,0.082,0.045c43.539,23.847,95.521,23.862,139.074,0.049c0.032-0.018,0.064-0.035,0.096-0.053%20c25.829-14.146,55.047-21.623,84.496-21.623s58.667,7.477,84.496,21.623c43.58,23.867,95.604,23.866,139.172,0.005%20c0.039-0.021,0.079-0.043,0.118-0.064c25.803-14.108,54.98-21.564,84.389-21.564c29.448-0.001,58.666,7.476,84.494,21.62%20c0.038,0.021,0.076,0.042,0.114,0.063c43.549,23.807,95.528,23.791,139.063-0.051c7.52-4.121,16.955-1.361,21.073,6.159%20c4.119,7.521,1.361,16.955-6.159,21.073C1929.089,1166.27,1899.872,1173.746,1870.425,1173.746z'%3e%3canimateTransform%20attributeName='transform'%20type='translate'%20from='0%200'%20to='312.5%200'%20dur='1s'%20calcMode='linear'%20repeatCount='indefinite'%20/%3e%3c/path%3e%3c/svg%3e");-webkit-mask-position:0 50%;mask-position:0 50%;-webkit-mask-repeat:repeat-x;mask-repeat:repeat-x;-webkit-mask-size:auto 100%;mask-size:auto 100%}progress.wavy::-moz-progress-bar{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='610%201101%201220%2075'%3e%3cpath%20fill='%23D0BCFF'%20d='M1870.425,1173.746c-29.448,0-58.665-7.477-84.493-21.622c-0.03-0.016-0.061-0.032-0.09-0.049%20c-43.555-23.82-95.546-23.809-139.091,0.039c-0.037,0.021-0.075,0.042-0.113,0.062c-25.803,14.109-54.984,21.567-84.394,21.568%20c-29.449,0-58.667-7.478-84.495-21.623c-43.554-23.852-95.539-23.865-139.089-0.052c-0.03,0.018-0.062,0.034-0.092,0.051%20c-25.83,14.146-55.048,21.623-84.497,21.623c-29.423,0-58.613-7.463-84.425-21.584c-0.025-0.014-0.052-0.028-0.077-0.042%20c-43.572-23.863-95.596-23.862-139.164-0.001c-0.028,0.016-0.057,0.031-0.085,0.046c-25.809,14.117-55.001,21.581-84.418,21.581%20c-0.002,0,0,0-0.001,0c-29.45-0.001-58.669-7.479-84.498-21.625c-43.534-23.845-95.513-23.863-139.063-0.058%20c-0.036,0.021-0.072,0.04-0.108,0.06c-25.829,14.146-55.047,21.623-84.496,21.623c-29.398,0-58.566-7.451-84.362-21.551%20c-0.048-0.024-0.095-0.05-0.142-0.075c-43.568-23.863-95.593-23.863-139.163,0c-0.027,0.015-0.054,0.028-0.081,0.043%20c-25.811,14.12-55.001,21.583-84.421,21.583c-29.45,0-58.668-7.478-84.497-21.624c-7.521-4.118-10.278-13.554-6.159-21.074%20s13.554-10.277,21.074-6.158c43.57,23.862,95.593,23.864,139.163,0c0.033-0.018,0.065-0.035,0.098-0.053%20c25.807-14.114,54.991-21.573,84.406-21.573c29.398,0,58.567,7.451,84.364,21.55c0.047,0.025,0.093,0.051,0.14,0.076%20c43.534,23.843,95.508,23.864,139.056,0.059c0.038-0.021,0.075-0.042,0.113-0.063c25.828-14.145,55.049-21.622,84.496-21.622%20c0.002,0,0,0,0.002,0c29.449,0,58.668,7.478,84.497,21.625c43.57,23.863,95.595,23.862,139.165,0.001%20c0.021-0.013,0.043-0.024,0.065-0.036c25.813-14.124,55.011-21.591,84.438-21.591c29.42,0,58.61,7.463,84.421,21.582%20c0.027,0.015,0.055,0.03,0.082,0.045c43.539,23.847,95.521,23.862,139.074,0.049c0.032-0.018,0.064-0.035,0.096-0.053%20c25.829-14.146,55.047-21.623,84.496-21.623s58.667,7.477,84.496,21.623c43.58,23.867,95.604,23.866,139.172,0.005%20c0.039-0.021,0.079-0.043,0.118-0.064c25.803-14.108,54.98-21.564,84.389-21.564c29.448-0.001,58.666,7.476,84.494,21.62%20c0.038,0.021,0.076,0.042,0.114,0.063c43.549,23.807,95.528,23.791,139.063-0.051c7.52-4.121,16.955-1.361,21.073,6.159%20c4.119,7.521,1.361,16.955-6.159,21.073C1929.089,1166.27,1899.872,1173.746,1870.425,1173.746z'%3e%3canimateTransform%20attributeName='transform'%20type='translate'%20from='0%200'%20to='312.5%200'%20dur='1s'%20calcMode='linear'%20repeatCount='indefinite'%20/%3e%3c/path%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='610%201101%201220%2075'%3e%3cpath%20fill='%23D0BCFF'%20d='M1870.425,1173.746c-29.448,0-58.665-7.477-84.493-21.622c-0.03-0.016-0.061-0.032-0.09-0.049%20c-43.555-23.82-95.546-23.809-139.091,0.039c-0.037,0.021-0.075,0.042-0.113,0.062c-25.803,14.109-54.984,21.567-84.394,21.568%20c-29.449,0-58.667-7.478-84.495-21.623c-43.554-23.852-95.539-23.865-139.089-0.052c-0.03,0.018-0.062,0.034-0.092,0.051%20c-25.83,14.146-55.048,21.623-84.497,21.623c-29.423,0-58.613-7.463-84.425-21.584c-0.025-0.014-0.052-0.028-0.077-0.042%20c-43.572-23.863-95.596-23.862-139.164-0.001c-0.028,0.016-0.057,0.031-0.085,0.046c-25.809,14.117-55.001,21.581-84.418,21.581%20c-0.002,0,0,0-0.001,0c-29.45-0.001-58.669-7.479-84.498-21.625c-43.534-23.845-95.513-23.863-139.063-0.058%20c-0.036,0.021-0.072,0.04-0.108,0.06c-25.829,14.146-55.047,21.623-84.496,21.623c-29.398,0-58.566-7.451-84.362-21.551%20c-0.048-0.024-0.095-0.05-0.142-0.075c-43.568-23.863-95.593-23.863-139.163,0c-0.027,0.015-0.054,0.028-0.081,0.043%20c-25.811,14.12-55.001,21.583-84.421,21.583c-29.45,0-58.668-7.478-84.497-21.624c-7.521-4.118-10.278-13.554-6.159-21.074%20s13.554-10.277,21.074-6.158c43.57,23.862,95.593,23.864,139.163,0c0.033-0.018,0.065-0.035,0.098-0.053%20c25.807-14.114,54.991-21.573,84.406-21.573c29.398,0,58.567,7.451,84.364,21.55c0.047,0.025,0.093,0.051,0.14,0.076%20c43.534,23.843,95.508,23.864,139.056,0.059c0.038-0.021,0.075-0.042,0.113-0.063c25.828-14.145,55.049-21.622,84.496-21.622%20c0.002,0,0,0,0.002,0c29.449,0,58.668,7.478,84.497,21.625c43.57,23.863,95.595,23.862,139.165,0.001%20c0.021-0.013,0.043-0.024,0.065-0.036c25.813-14.124,55.011-21.591,84.438-21.591c29.42,0,58.61,7.463,84.421,21.582%20c0.027,0.015,0.055,0.03,0.082,0.045c43.539,23.847,95.521,23.862,139.074,0.049c0.032-0.018,0.064-0.035,0.096-0.053%20c25.829-14.146,55.047-21.623,84.496-21.623s58.667,7.477,84.496,21.623c43.58,23.867,95.604,23.866,139.172,0.005%20c0.039-0.021,0.079-0.043,0.118-0.064c25.803-14.108,54.98-21.564,84.389-21.564c29.448-0.001,58.666,7.476,84.494,21.62%20c0.038,0.021,0.076,0.042,0.114,0.063c43.549,23.807,95.528,23.791,139.063-0.051c7.52-4.121,16.955-1.361,21.073,6.159%20c4.119,7.521,1.361,16.955-6.159,21.073C1929.089,1166.27,1899.872,1173.746,1870.425,1173.746z'%3e%3canimateTransform%20attributeName='transform'%20type='translate'%20from='0%200'%20to='312.5%200'%20dur='1s'%20calcMode='linear'%20repeatCount='indefinite'%20/%3e%3c/path%3e%3c/svg%3e");-webkit-mask-position:0 50%;mask-position:0 50%;-webkit-mask-repeat:repeat-x;mask-repeat:repeat-x;-webkit-mask-size:auto 100%;mask-size:auto 100%}progress.circle{display:inline-block;inline-size:2.5rem;block-size:2.5rem;border-radius:50%;border-width:.3rem;border-style:solid;border-color:currentcolor;animation:1.6s to-circular linear infinite;background:none;flex:none}progress.circle::-moz-progress-bar{background:none}progress.circle.small{inline-size:1.5rem;block-size:1.5rem;border-width:.2rem}progress.circle.large{inline-size:3.5rem;block-size:3.5rem;border-width:.4rem}:is(nav,.row,.field)>progress:not(.circle,.small,.medium,.large){flex:auto}progress.max{display:unset;position:absolute;inline-size:100%!important;block-size:100%!important;color:currentColor;background:none;inset:0;border-radius:inherit;animation:none;writing-mode:horizontal-tb;opacity:.33}progress.max[class*=-text]{opacity:1}progress:is(.horizontal,.vertical,.max){display:unset;inline-size:100%!important}progress.vertical{writing-mode:vertical-lr}progress.max.vertical{transform:rotate(-180deg)}progress.max+*{margin-block-start:0}:is(.button,button,.chip)>progress.circle{color:inherit}@supports (-moz-appearance:none){progress.max.vertical{transform:none}}@keyframes to-linear{0%{margin-inline-start:-100%}50%{margin-inline-start:0%}to{margin-inline-start:100%}}@keyframes to-circular{0%{transform:rotate(0);clip-path:polygon(50% 50%,0% 0%,50% 0%,50% 0%,50% 0%,50% 0%,50% 0%,50% 0%,50% 0%)}20%{clip-path:polygon(50% 50%,0% 0%,50% 0%,100% 0%,100% 0%,100% 0%,100% 0%,100% 0%,100% 0%)}30%{clip-path:polygon(50% 50%,0% 0%,50% 0%,100% 0%,100% 50%,100% 50%,100% 50%,100% 50%,100% 50%)}40%{clip-path:polygon(50% 50%,0% 0%,50% 0%,100% 0%,100% 50%,100% 100%,100% 100%,100% 100%,100% 100%)}50%{clip-path:polygon(50% 50%,50% 0%,50% 0%,100% 0%,100% 50%,100% 100%,50% 100%,50% 100%,50% 100%)}60%{clip-path:polygon(50% 50%,100% 50%,100% 50%,100% 50%,100% 50%,100% 100%,50% 100%,0% 100%,0% 100%)}70%{clip-path:polygon(50% 50%,50% 100%,50% 100%,50% 100%,50% 100%,50% 100%,50% 100%,0% 100%,0% 50%)}80%{clip-path:polygon(50% 50%,0% 100%,0% 100%,0% 100%,0% 100%,0% 100%,0% 100%,0% 100%,0% 50%)}90%{transform:rotate(360deg);clip-path:polygon(50% 50%,0% 50%,0% 50%,0% 50%,0% 50%,0% 50%,0% 50%,0% 50%,0% 50%)}to{clip-path:polygon(50% 50%,0% 50%,0% 50%,0% 50%,0% 50%,0% 50%,0% 50%,0% 50%,0% 50%)}}.shape{display:flex;align-items:center;justify-content:center;color:var(--on-primary);background-color:var(--primary);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-position:center;mask-position:center;-webkit-mask-size:contain;mask-size:contain;border-radius:0;block-size:3.5rem;inline-size:3.5rem;margin:0!important;padding:0!important;border:0!important}.transparent>.shape>i{filter:invert(1)}.shape.tiny-space{-webkit-mask-size:90%;mask-size:90%}.shape.space,.shape.small-space{-webkit-mask-size:80%;mask-size:80%}.shape.medium-space{-webkit-mask-size:70%;mask-size:70%}.shape.large-space{-webkit-mask-size:60%;mask-size:60%}.shape.extra-space{-webkit-mask-size:50%;mask-size:50%}.shape.tiny{block-size:2.5rem;inline-size:2.5rem}.shape.medium{block-size:4.5rem;inline-size:4.5rem}.shape.large{block-size:5.5rem;inline-size:5.5rem}.shape.extra{block-size:6.5rem;inline-size:6.5rem}.shape.max,.shape>.responsive,.shape>.responsive>.responsive{position:absolute;inset:0;block-size:100%;inline-size:100%;margin:0!important;padding:0!important;border:0!important}.shape>.responsive{background:inherit;color:inherit}.shape.rotate{animation:linear to-shape-rotate infinite 12s}.shape.rotate>*{animation:linear to-shape-rotate infinite 12s reverse}.shape.fast-rotate{animation:linear to-shape-rotate infinite 6s}.shape.fast-rotate>*{animation:linear to-shape-rotate infinite 6s reverse}.shape.slow-rotate{animation:linear to-shape-rotate infinite 24s}.shape.slow-rotate>*{animation:linear to-shape-rotate infinite 24s reverse}:is(button,.button,.chip):has(>.shape)>.responsive{border:none}.shape.arch{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='304'%20height='304'%20viewBox='0%200%20304%20304'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M304%20253.72C304%20259.83%20304%20262.89%20303.69%20265.46C301.31%20285.51%20285.51%20301.31%20265.46%20303.69C262.89%20304%20259.83%20304%20253.72%20304H50.281C44.169%20304%2041.113%20304%2038.544%20303.69C18.495%20301.31%202.68799%20285.51%200.304993%20265.46C-7.33137e-06%20262.89%200%20259.83%200%20253.72V152C0%2068.05%2068.053%200%20152%200C235.95%200%20304%2068.05%20304%20152V253.72Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='304'%20height='304'%20viewBox='0%200%20304%20304'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M304%20253.72C304%20259.83%20304%20262.89%20303.69%20265.46C301.31%20285.51%20285.51%20301.31%20265.46%20303.69C262.89%20304%20259.83%20304%20253.72%20304H50.281C44.169%20304%2041.113%20304%2038.544%20303.69C18.495%20301.31%202.68799%20285.51%200.304993%20265.46C-7.33137e-06%20262.89%200%20259.83%200%20253.72V152C0%2068.05%2068.053%200%20152%200C235.95%200%20304%2068.05%20304%20152V253.72Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.arrow{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='316'%20height='278'%20viewBox='0%200%20316%20278'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M271.57%20122.2C257.552%20100.62%20243.535%2079.01%20229.517%2057.43C220.423%2043.42%20211.167%2029.2202%20198.872%2018.0902C186.576%206.94018%20170.648%20-0.939823%20154.316%200.0901773C139.976%201.01018%20126.684%208.72013%20116.191%2018.7901C105.698%2028.8601%2097.546%2041.2601%2089.528%2053.5401C67.842%2086.7201%2046.13%20119.9%2024.444%20153.1C14.139%20168.86%203.56499%20185.31%200.712987%20204.09C-2.73101%20226.78%206.55198%20249.89%2023.018%20264.98C40.237%20280.76%2068.138%20279.48%2089.098%20275.16C112.075%20270.41%20134.541%20261.48%20157.975%20261.51C178.047%20261.51%20197.446%20268.11%20216.979%20272.91C236.485%20277.68%20257.445%20280.62%20276.279%20273.52C299.659%20264.73%20316.448%20239.73%20315.991%20214.07C315.56%20190.66%20302.457%20169.75%20289.839%20150.27C283.758%20140.92%20277.678%20131.55%20271.597%20122.2H271.57Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='316'%20height='278'%20viewBox='0%200%20316%20278'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M271.57%20122.2C257.552%20100.62%20243.535%2079.01%20229.517%2057.43C220.423%2043.42%20211.167%2029.2202%20198.872%2018.0902C186.576%206.94018%20170.648%20-0.939823%20154.316%200.0901773C139.976%201.01018%20126.684%208.72013%20116.191%2018.7901C105.698%2028.8601%2097.546%2041.2601%2089.528%2053.5401C67.842%2086.7201%2046.13%20119.9%2024.444%20153.1C14.139%20168.86%203.56499%20185.31%200.712987%20204.09C-2.73101%20226.78%206.55198%20249.89%2023.018%20264.98C40.237%20280.76%2068.138%20279.48%2089.098%20275.16C112.075%20270.41%20134.541%20261.48%20157.975%20261.51C178.047%20261.51%20197.446%20268.11%20216.979%20272.91C236.485%20277.68%20257.445%20280.62%20276.279%20273.52C299.659%20264.73%20316.448%20239.73%20315.991%20214.07C315.56%20190.66%20302.457%20169.75%20289.839%20150.27C283.758%20140.92%20277.678%20131.55%20271.597%20122.2H271.57Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.boom{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M156.818%2010.1599C157.571%204.13988%20157.948%201.13006%20158.52%200.590059C159.353%20-0.199941%20160.647%20-0.199941%20161.48%200.590059C162.052%201.13006%20162.429%204.13988%20163.182%2010.1599L172.76%2086.74C173.064%2089.17%20173.216%2090.3799%20173.652%2090.8899C174.285%2091.6099%20175.32%2091.8399%20176.193%2091.4299C176.794%2091.1499%20177.425%2090.1%20178.686%2088L218.415%2021.9599C221.539%2016.7699%20223.101%2014.1699%20223.842%2013.9099C224.92%2013.5399%20226.102%2014.0699%20226.546%2015.1299C226.851%2015.8499%20225.977%2018.76%20224.229%2024.57L201.999%2098.4399C201.293%20100.79%20200.941%20101.96%20201.136%20102.59C201.42%20103.52%20202.276%20104.14%20203.238%20104.13C203.901%20104.12%20204.901%20103.42%20206.901%20102.02L269.911%2057.9399C274.867%2054.4699%20277.344%2052.74%20278.125%2052.8C279.261%2052.9%20280.127%2053.87%20280.105%2055.01C280.091%2055.8%20278.117%2058.0999%20274.17%2062.6899L223.976%20121.09C222.383%20122.94%20221.587%20123.87%20221.508%20124.53C221.393%20125.49%20221.922%20126.41%20222.807%20126.79C223.416%20127.06%20224.613%20126.82%20227.006%20126.36L302.403%20111.86C308.332%20110.72%20311.297%20110.15%20311.983%20110.53C312.981%20111.08%20313.381%20112.32%20312.898%20113.36C312.566%20114.07%20309.834%20115.36%20304.37%20117.94L234.892%20150.77C232.686%20151.81%20231.584%20152.33%20231.244%20152.9C230.751%20153.73%20230.862%20154.79%20231.516%20155.5C231.966%20155.99%20233.152%20156.27%20235.525%20156.82L310.272%20174.41C316.15%20175.79%20319.09%20176.48%20319.562%20177.11C320.249%20178.02%20320.114%20179.32%20319.253%20180.07C318.66%20180.58%20315.643%20180.65%20309.607%20180.77L232.857%20182.34C230.421%20182.39%20229.203%20182.42%20228.662%20182.8C227.875%20183.36%20227.548%20184.37%20227.859%20185.29C228.073%20185.92%20229.043%20186.66%20230.985%20188.14L292.158%20234.76C296.968%20238.43%20299.374%20240.27%20299.551%20241.03C299.809%20242.15%20299.162%20243.28%20298.071%20243.61C297.322%20243.84%20294.54%20242.66%20288.975%20240.31L218.226%20210.36C215.98%20209.41%20214.857%20208.93%20214.207%20209.06C213.263%20209.25%20212.555%20210.04%20212.468%20211C212.409%20211.66%20212.996%20212.74%20214.171%20214.88L251.192%20282.5C254.103%20287.81%20255.559%20290.47%20255.411%20291.25C255.194%20292.37%20254.148%20293.14%20253.016%20293C252.238%20292.9%20250.173%20290.69%20246.043%20286.26L193.526%20229.96C191.859%20228.18%20191.025%20227.28%20190.38%20227.14C189.441%20226.92%20188.475%20227.35%20188.006%20228.2C187.683%20228.78%20187.786%20230%20187.991%20232.44L194.458%20309.35C194.967%20315.4%20195.221%20318.42%20194.773%20319.07C194.12%20320.01%20192.854%20320.28%20191.878%20319.69C191.206%20319.28%20190.215%20316.41%20188.233%20310.68L163.029%20237.78C162.229%20235.46%20161.829%20234.31%20161.299%20233.91C160.529%20233.33%20159.471%20233.33%20158.701%20233.91C158.171%20234.31%20157.771%20235.46%20156.971%20237.78L131.767%20310.68C129.785%20316.41%20128.794%20319.28%20128.122%20319.69C127.146%20320.28%20125.88%20320.01%20125.227%20319.07C124.779%20318.42%20125.033%20315.4%20125.542%20309.35L132.009%20232.44C132.214%20230%20132.317%20228.78%20131.994%20228.2C131.525%20227.35%20130.559%20226.92%20129.621%20227.14C128.975%20227.28%20128.141%20228.18%20126.474%20229.96L73.9568%20286.26C69.8267%20290.69%2067.7616%20292.9%2066.984%20293C65.8524%20293.14%2064.8055%20292.37%2064.5894%20291.25C64.4409%20290.47%2065.8966%20287.81%2068.808%20282.5L105.829%20214.88C107.004%20212.74%20107.591%20211.66%20107.532%20211C107.445%20210.04%20106.737%20209.25%20105.793%20209.06C105.143%20208.93%20104.02%20209.41%20101.774%20210.36L31.0245%20240.31C25.4605%20242.66%2022.6785%20243.84%2021.9288%20243.61C20.838%20243.28%2020.191%20242.15%2020.4489%20241.03C20.6262%20240.27%2023.0316%20238.43%2027.8424%20234.76L89.0148%20188.14C90.957%20186.66%2091.927%20185.92%2092.141%20185.29C92.452%20184.37%2092.125%20183.36%2091.338%20182.8C90.797%20182.42%2089.5787%20182.39%2087.1425%20182.34L10.3933%20180.77C4.35749%20180.65%201.3395%20180.58%200.747495%20180.07C-0.114065%20179.32%20-0.249315%20178.02%200.438095%20177.11C0.910495%20176.48%203.84969%20175.79%209.72809%20174.41L84.475%20156.82C86.8477%20156.27%2088.034%20155.99%2088.4844%20155.5C89.1385%20154.79%2089.2491%20153.73%2088.756%20152.9C88.4164%20152.33%2087.3137%20151.81%2085.1083%20150.77L15.6304%20117.94C10.1664%20115.36%207.4344%20114.07%207.1023%20113.36C6.6191%20112.32%207.01889%20111.08%208.01699%20110.53C8.70279%20110.15%2011.6676%20110.72%2017.5971%20111.86L92.994%20126.36C95.387%20126.82%2096.584%20127.06%2097.193%20126.79C98.078%20126.41%2098.607%20125.49%2098.492%20124.53C98.414%20123.87%2097.617%20122.94%2096.024%20121.09L45.8303%2062.6899C41.8829%2058.0999%2039.9092%2055.8%2039.8946%2055.01C39.8732%2053.87%2040.739%2052.9%2041.8751%2052.8C42.6558%2052.74%2045.1335%2054.4699%2050.0889%2057.9399L113.099%20102.02C115.099%20103.42%20116.099%20104.12%20116.762%20104.13C117.724%20104.14%20118.58%20103.52%20118.864%20102.59C119.059%20101.96%20118.707%20100.79%20118.001%2098.4399L95.771%2024.57C94.023%2018.76%2093.149%2015.8499%2093.454%2015.1299C93.898%2014.0699%2095.08%2013.5399%2096.158%2013.9099C96.899%2014.1699%2098.461%2016.7699%20101.585%2021.9599L141.314%2088C142.575%2090.1%20143.206%2091.1499%20143.807%2091.4299C144.68%2091.8399%20145.715%2091.6099%20146.348%2090.8899C146.784%2090.3799%20146.936%2089.17%20147.24%2086.74L156.818%2010.1599Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M156.818%2010.1599C157.571%204.13988%20157.948%201.13006%20158.52%200.590059C159.353%20-0.199941%20160.647%20-0.199941%20161.48%200.590059C162.052%201.13006%20162.429%204.13988%20163.182%2010.1599L172.76%2086.74C173.064%2089.17%20173.216%2090.3799%20173.652%2090.8899C174.285%2091.6099%20175.32%2091.8399%20176.193%2091.4299C176.794%2091.1499%20177.425%2090.1%20178.686%2088L218.415%2021.9599C221.539%2016.7699%20223.101%2014.1699%20223.842%2013.9099C224.92%2013.5399%20226.102%2014.0699%20226.546%2015.1299C226.851%2015.8499%20225.977%2018.76%20224.229%2024.57L201.999%2098.4399C201.293%20100.79%20200.941%20101.96%20201.136%20102.59C201.42%20103.52%20202.276%20104.14%20203.238%20104.13C203.901%20104.12%20204.901%20103.42%20206.901%20102.02L269.911%2057.9399C274.867%2054.4699%20277.344%2052.74%20278.125%2052.8C279.261%2052.9%20280.127%2053.87%20280.105%2055.01C280.091%2055.8%20278.117%2058.0999%20274.17%2062.6899L223.976%20121.09C222.383%20122.94%20221.587%20123.87%20221.508%20124.53C221.393%20125.49%20221.922%20126.41%20222.807%20126.79C223.416%20127.06%20224.613%20126.82%20227.006%20126.36L302.403%20111.86C308.332%20110.72%20311.297%20110.15%20311.983%20110.53C312.981%20111.08%20313.381%20112.32%20312.898%20113.36C312.566%20114.07%20309.834%20115.36%20304.37%20117.94L234.892%20150.77C232.686%20151.81%20231.584%20152.33%20231.244%20152.9C230.751%20153.73%20230.862%20154.79%20231.516%20155.5C231.966%20155.99%20233.152%20156.27%20235.525%20156.82L310.272%20174.41C316.15%20175.79%20319.09%20176.48%20319.562%20177.11C320.249%20178.02%20320.114%20179.32%20319.253%20180.07C318.66%20180.58%20315.643%20180.65%20309.607%20180.77L232.857%20182.34C230.421%20182.39%20229.203%20182.42%20228.662%20182.8C227.875%20183.36%20227.548%20184.37%20227.859%20185.29C228.073%20185.92%20229.043%20186.66%20230.985%20188.14L292.158%20234.76C296.968%20238.43%20299.374%20240.27%20299.551%20241.03C299.809%20242.15%20299.162%20243.28%20298.071%20243.61C297.322%20243.84%20294.54%20242.66%20288.975%20240.31L218.226%20210.36C215.98%20209.41%20214.857%20208.93%20214.207%20209.06C213.263%20209.25%20212.555%20210.04%20212.468%20211C212.409%20211.66%20212.996%20212.74%20214.171%20214.88L251.192%20282.5C254.103%20287.81%20255.559%20290.47%20255.411%20291.25C255.194%20292.37%20254.148%20293.14%20253.016%20293C252.238%20292.9%20250.173%20290.69%20246.043%20286.26L193.526%20229.96C191.859%20228.18%20191.025%20227.28%20190.38%20227.14C189.441%20226.92%20188.475%20227.35%20188.006%20228.2C187.683%20228.78%20187.786%20230%20187.991%20232.44L194.458%20309.35C194.967%20315.4%20195.221%20318.42%20194.773%20319.07C194.12%20320.01%20192.854%20320.28%20191.878%20319.69C191.206%20319.28%20190.215%20316.41%20188.233%20310.68L163.029%20237.78C162.229%20235.46%20161.829%20234.31%20161.299%20233.91C160.529%20233.33%20159.471%20233.33%20158.701%20233.91C158.171%20234.31%20157.771%20235.46%20156.971%20237.78L131.767%20310.68C129.785%20316.41%20128.794%20319.28%20128.122%20319.69C127.146%20320.28%20125.88%20320.01%20125.227%20319.07C124.779%20318.42%20125.033%20315.4%20125.542%20309.35L132.009%20232.44C132.214%20230%20132.317%20228.78%20131.994%20228.2C131.525%20227.35%20130.559%20226.92%20129.621%20227.14C128.975%20227.28%20128.141%20228.18%20126.474%20229.96L73.9568%20286.26C69.8267%20290.69%2067.7616%20292.9%2066.984%20293C65.8524%20293.14%2064.8055%20292.37%2064.5894%20291.25C64.4409%20290.47%2065.8966%20287.81%2068.808%20282.5L105.829%20214.88C107.004%20212.74%20107.591%20211.66%20107.532%20211C107.445%20210.04%20106.737%20209.25%20105.793%20209.06C105.143%20208.93%20104.02%20209.41%20101.774%20210.36L31.0245%20240.31C25.4605%20242.66%2022.6785%20243.84%2021.9288%20243.61C20.838%20243.28%2020.191%20242.15%2020.4489%20241.03C20.6262%20240.27%2023.0316%20238.43%2027.8424%20234.76L89.0148%20188.14C90.957%20186.66%2091.927%20185.92%2092.141%20185.29C92.452%20184.37%2092.125%20183.36%2091.338%20182.8C90.797%20182.42%2089.5787%20182.39%2087.1425%20182.34L10.3933%20180.77C4.35749%20180.65%201.3395%20180.58%200.747495%20180.07C-0.114065%20179.32%20-0.249315%20178.02%200.438095%20177.11C0.910495%20176.48%203.84969%20175.79%209.72809%20174.41L84.475%20156.82C86.8477%20156.27%2088.034%20155.99%2088.4844%20155.5C89.1385%20154.79%2089.2491%20153.73%2088.756%20152.9C88.4164%20152.33%2087.3137%20151.81%2085.1083%20150.77L15.6304%20117.94C10.1664%20115.36%207.4344%20114.07%207.1023%20113.36C6.6191%20112.32%207.01889%20111.08%208.01699%20110.53C8.70279%20110.15%2011.6676%20110.72%2017.5971%20111.86L92.994%20126.36C95.387%20126.82%2096.584%20127.06%2097.193%20126.79C98.078%20126.41%2098.607%20125.49%2098.492%20124.53C98.414%20123.87%2097.617%20122.94%2096.024%20121.09L45.8303%2062.6899C41.8829%2058.0999%2039.9092%2055.8%2039.8946%2055.01C39.8732%2053.87%2040.739%2052.9%2041.8751%2052.8C42.6558%2052.74%2045.1335%2054.4699%2050.0889%2057.9399L113.099%20102.02C115.099%20103.42%20116.099%20104.12%20116.762%20104.13C117.724%20104.14%20118.58%20103.52%20118.864%20102.59C119.059%20101.96%20118.707%20100.79%20118.001%2098.4399L95.771%2024.57C94.023%2018.76%2093.149%2015.8499%2093.454%2015.1299C93.898%2014.0699%2095.08%2013.5399%2096.158%2013.9099C96.899%2014.1699%2098.461%2016.7699%20101.585%2021.9599L141.314%2088C142.575%2090.1%20143.206%2091.1499%20143.807%2091.4299C144.68%2091.8399%20145.715%2091.6099%20146.348%2090.8899C146.784%2090.3799%20146.936%2089.17%20147.24%2086.74L156.818%2010.1599Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.bun{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='310'%20height='320'%20viewBox='0%200%20310%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%2081.36C0%2036.42%2036.42%200%2081.36%200H228.64C273.58%200%20310%2036.42%20310%2081.36C310%20118.41%20285.23%20149.68%20251.34%20159.5C251.12%20159.57%20250.97%20159.77%20250.97%20160C250.97%20160.23%20251.12%20160.43%20251.34%20160.5C285.23%20170.32%20310%20201.59%20310%20238.64C310%20283.58%20273.58%20320%20228.64%20320H81.36C36.42%20320%200%20283.58%200%20238.64C0%20201.83%2024.45%20170.73%2058%20160.69C58.3%20160.6%2058.51%20160.32%2058.51%20160C58.51%20159.68%2058.3%20159.4%2058%20159.31C24.45%20149.27%200%20118.17%200%2081.36Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='310'%20height='320'%20viewBox='0%200%20310%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%2081.36C0%2036.42%2036.42%200%2081.36%200H228.64C273.58%200%20310%2036.42%20310%2081.36C310%20118.41%20285.23%20149.68%20251.34%20159.5C251.12%20159.57%20250.97%20159.77%20250.97%20160C250.97%20160.23%20251.12%20160.43%20251.34%20160.5C285.23%20170.32%20310%20201.59%20310%20238.64C310%20283.58%20273.58%20320%20228.64%20320H81.36C36.42%20320%200%20283.58%200%20238.64C0%20201.83%2024.45%20170.73%2058%20160.69C58.3%20160.6%2058.51%20160.32%2058.51%20160C58.51%20159.68%2058.3%20159.4%2058%20159.31C24.45%20149.27%200%20118.17%200%2081.36Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.burst{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M157.39%202.55C158.13%201.23%20158.49%200.58%20158.94%200.3C159.59%20-0.1%20160.41%20-0.1%20161.06%200.3C161.51%200.58%20161.87%201.23%20162.61%202.55L187.87%2047.6999C188.32%2048.5099%20188.55%2048.92%20188.86%2049.16C189.3%2049.52%20189.87%2049.6699%20190.43%2049.5799C190.82%2049.5199%20191.22%2049.29%20192.01%2048.81L236.47%2022.3399C237.76%2021.5699%20238.41%2021.18%20238.93%2021.17C239.7%2021.14%20240.4%2021.5499%20240.77%2022.2199C241.02%2022.6899%20241.01%2023.4399%20240.99%2024.9499L240.29%2076.68C240.27%2077.61%20240.27%2078.0699%20240.41%2078.4399C240.61%2078.9699%20241.03%2079.3899%20241.56%2079.5899C241.93%2079.7299%20242.39%2079.7299%20243.32%2079.7099L295.05%2079.01C296.56%2078.99%20297.31%2078.9799%20297.78%2079.2299C298.45%2079.5999%20298.86%2080.2999%20298.83%2081.0699C298.82%2081.5899%20298.43%2082.24%20297.66%2083.53L271.19%20127.99C270.71%20128.78%20270.48%20129.18%20270.42%20129.57C270.33%20130.13%20270.48%20130.7%20270.84%20131.14C271.08%20131.45%20271.49%20131.68%20272.3%20132.13L317.45%20157.39C318.77%20158.13%20319.42%20158.49%20319.7%20158.94C320.1%20159.59%20320.1%20160.41%20319.7%20161.06C319.42%20161.51%20318.77%20161.87%20317.45%20162.61L272.3%20187.87C271.49%20188.32%20271.08%20188.55%20270.84%20188.86C270.48%20189.3%20270.33%20189.87%20270.42%20190.43C270.48%20190.82%20270.71%20191.22%20271.19%20192.01L297.66%20236.47C298.43%20237.76%20298.82%20238.41%20298.83%20238.93C298.86%20239.7%20298.45%20240.4%20297.78%20240.77C297.31%20241.02%20296.56%20241.01%20295.05%20240.99L243.32%20240.29C242.39%20240.27%20241.93%20240.27%20241.56%20240.41C241.03%20240.61%20240.61%20241.03%20240.41%20241.56C240.27%20241.93%20240.27%20242.39%20240.29%20243.32L240.99%20295.05C241.01%20296.56%20241.02%20297.31%20240.77%20297.78C240.4%20298.45%20239.7%20298.86%20238.93%20298.83C238.41%20298.82%20237.76%20298.43%20236.47%20297.66L192.01%20271.19C191.22%20270.71%20190.82%20270.48%20190.43%20270.42C189.87%20270.33%20189.3%20270.48%20188.86%20270.84C188.55%20271.08%20188.32%20271.49%20187.87%20272.3L162.61%20317.45C161.87%20318.77%20161.51%20319.42%20161.06%20319.7C160.41%20320.1%20159.59%20320.1%20158.94%20319.7C158.49%20319.42%20158.13%20318.77%20157.39%20317.45L132.13%20272.3C131.68%20271.49%20131.45%20271.08%20131.14%20270.84C130.7%20270.48%20130.13%20270.33%20129.57%20270.42C129.18%20270.48%20128.78%20270.71%20127.99%20271.19L83.53%20297.66C82.24%20298.43%2081.5899%20298.82%2081.0699%20298.83C80.2999%20298.86%2079.5999%20298.45%2079.2299%20297.78C78.9799%20297.31%2078.99%20296.56%2079.01%20295.05L79.7099%20243.32C79.7299%20242.39%2079.7299%20241.93%2079.5899%20241.56C79.3899%20241.03%2078.9699%20240.61%2078.4399%20240.41C78.0699%20240.27%2077.61%20240.27%2076.68%20240.29L24.9499%20240.99C23.4399%20241.01%2022.6899%20241.02%2022.2199%20240.77C21.5499%20240.4%2021.14%20239.7%2021.17%20238.93C21.18%20238.41%2021.5699%20237.76%2022.3399%20236.47L48.81%20192.01C49.29%20191.22%2049.5199%20190.82%2049.5799%20190.43C49.6699%20189.87%2049.52%20189.3%2049.16%20188.86C48.92%20188.55%2048.5099%20188.32%2047.6999%20187.87L2.55%20162.61C1.23%20161.87%200.58%20161.51%200.3%20161.06C-0.1%20160.41%20-0.1%20159.59%200.3%20158.94C0.58%20158.49%201.23%20158.13%202.55%20157.39L47.6999%20132.13C48.5099%20131.68%2048.92%20131.45%2049.16%20131.14C49.52%20130.7%2049.6699%20130.13%2049.5799%20129.57C49.5199%20129.18%2049.29%20128.78%2048.81%20127.99L22.3399%2083.53C21.5699%2082.24%2021.18%2081.5899%2021.17%2081.0699C21.14%2080.2999%2021.5499%2079.5999%2022.2199%2079.2299C22.6899%2078.9799%2023.4399%2078.99%2024.9499%2079.01L76.68%2079.7099C77.61%2079.7299%2078.0699%2079.7299%2078.4399%2079.5899C78.9699%2079.3899%2079.3899%2078.9699%2079.5899%2078.4399C79.7299%2078.0699%2079.7299%2077.61%2079.7099%2076.68L79.01%2024.9499C78.99%2023.4399%2078.9799%2022.6899%2079.2299%2022.2199C79.5999%2021.5499%2080.2999%2021.14%2081.0699%2021.17C81.5899%2021.18%2082.24%2021.5699%2083.53%2022.3399L127.99%2048.81C128.78%2049.29%20129.18%2049.5199%20129.57%2049.5799C130.13%2049.6699%20130.7%2049.52%20131.14%2049.16C131.45%2048.92%20131.68%2048.5099%20132.13%2047.6999L157.39%202.55Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M157.39%202.55C158.13%201.23%20158.49%200.58%20158.94%200.3C159.59%20-0.1%20160.41%20-0.1%20161.06%200.3C161.51%200.58%20161.87%201.23%20162.61%202.55L187.87%2047.6999C188.32%2048.5099%20188.55%2048.92%20188.86%2049.16C189.3%2049.52%20189.87%2049.6699%20190.43%2049.5799C190.82%2049.5199%20191.22%2049.29%20192.01%2048.81L236.47%2022.3399C237.76%2021.5699%20238.41%2021.18%20238.93%2021.17C239.7%2021.14%20240.4%2021.5499%20240.77%2022.2199C241.02%2022.6899%20241.01%2023.4399%20240.99%2024.9499L240.29%2076.68C240.27%2077.61%20240.27%2078.0699%20240.41%2078.4399C240.61%2078.9699%20241.03%2079.3899%20241.56%2079.5899C241.93%2079.7299%20242.39%2079.7299%20243.32%2079.7099L295.05%2079.01C296.56%2078.99%20297.31%2078.9799%20297.78%2079.2299C298.45%2079.5999%20298.86%2080.2999%20298.83%2081.0699C298.82%2081.5899%20298.43%2082.24%20297.66%2083.53L271.19%20127.99C270.71%20128.78%20270.48%20129.18%20270.42%20129.57C270.33%20130.13%20270.48%20130.7%20270.84%20131.14C271.08%20131.45%20271.49%20131.68%20272.3%20132.13L317.45%20157.39C318.77%20158.13%20319.42%20158.49%20319.7%20158.94C320.1%20159.59%20320.1%20160.41%20319.7%20161.06C319.42%20161.51%20318.77%20161.87%20317.45%20162.61L272.3%20187.87C271.49%20188.32%20271.08%20188.55%20270.84%20188.86C270.48%20189.3%20270.33%20189.87%20270.42%20190.43C270.48%20190.82%20270.71%20191.22%20271.19%20192.01L297.66%20236.47C298.43%20237.76%20298.82%20238.41%20298.83%20238.93C298.86%20239.7%20298.45%20240.4%20297.78%20240.77C297.31%20241.02%20296.56%20241.01%20295.05%20240.99L243.32%20240.29C242.39%20240.27%20241.93%20240.27%20241.56%20240.41C241.03%20240.61%20240.61%20241.03%20240.41%20241.56C240.27%20241.93%20240.27%20242.39%20240.29%20243.32L240.99%20295.05C241.01%20296.56%20241.02%20297.31%20240.77%20297.78C240.4%20298.45%20239.7%20298.86%20238.93%20298.83C238.41%20298.82%20237.76%20298.43%20236.47%20297.66L192.01%20271.19C191.22%20270.71%20190.82%20270.48%20190.43%20270.42C189.87%20270.33%20189.3%20270.48%20188.86%20270.84C188.55%20271.08%20188.32%20271.49%20187.87%20272.3L162.61%20317.45C161.87%20318.77%20161.51%20319.42%20161.06%20319.7C160.41%20320.1%20159.59%20320.1%20158.94%20319.7C158.49%20319.42%20158.13%20318.77%20157.39%20317.45L132.13%20272.3C131.68%20271.49%20131.45%20271.08%20131.14%20270.84C130.7%20270.48%20130.13%20270.33%20129.57%20270.42C129.18%20270.48%20128.78%20270.71%20127.99%20271.19L83.53%20297.66C82.24%20298.43%2081.5899%20298.82%2081.0699%20298.83C80.2999%20298.86%2079.5999%20298.45%2079.2299%20297.78C78.9799%20297.31%2078.99%20296.56%2079.01%20295.05L79.7099%20243.32C79.7299%20242.39%2079.7299%20241.93%2079.5899%20241.56C79.3899%20241.03%2078.9699%20240.61%2078.4399%20240.41C78.0699%20240.27%2077.61%20240.27%2076.68%20240.29L24.9499%20240.99C23.4399%20241.01%2022.6899%20241.02%2022.2199%20240.77C21.5499%20240.4%2021.14%20239.7%2021.17%20238.93C21.18%20238.41%2021.5699%20237.76%2022.3399%20236.47L48.81%20192.01C49.29%20191.22%2049.5199%20190.82%2049.5799%20190.43C49.6699%20189.87%2049.52%20189.3%2049.16%20188.86C48.92%20188.55%2048.5099%20188.32%2047.6999%20187.87L2.55%20162.61C1.23%20161.87%200.58%20161.51%200.3%20161.06C-0.1%20160.41%20-0.1%20159.59%200.3%20158.94C0.58%20158.49%201.23%20158.13%202.55%20157.39L47.6999%20132.13C48.5099%20131.68%2048.92%20131.45%2049.16%20131.14C49.52%20130.7%2049.6699%20130.13%2049.5799%20129.57C49.5199%20129.18%2049.29%20128.78%2048.81%20127.99L22.3399%2083.53C21.5699%2082.24%2021.18%2081.5899%2021.17%2081.0699C21.14%2080.2999%2021.5499%2079.5999%2022.2199%2079.2299C22.6899%2078.9799%2023.4399%2078.99%2024.9499%2079.01L76.68%2079.7099C77.61%2079.7299%2078.0699%2079.7299%2078.4399%2079.5899C78.9699%2079.3899%2079.3899%2078.9699%2079.5899%2078.4399C79.7299%2078.0699%2079.7299%2077.61%2079.7099%2076.68L79.01%2024.9499C78.99%2023.4399%2078.9799%2022.6899%2079.2299%2022.2199C79.5999%2021.5499%2080.2999%2021.14%2081.0699%2021.17C81.5899%2021.18%2082.24%2021.5699%2083.53%2022.3399L127.99%2048.81C128.78%2049.29%20129.18%2049.5199%20129.57%2049.5799C130.13%2049.6699%20130.7%2049.52%20131.14%2049.16C131.45%2048.92%20131.68%2048.5099%20132.13%2047.6999L157.39%202.55Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.circle{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M320%20160C320%20248.366%20248.366%20320%20160%20320C71.6344%20320%20-1e-05%20248.366%200%20160C0%2071.6344%2071.6345%20-7.72516e-06%20160%200C248.366%207.72516e-06%20320%2071.6345%20320%20160Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M320%20160C320%20248.366%20248.366%20320%20160%20320C71.6344%20320%20-1e-05%20248.366%200%20160C0%2071.6344%2071.6345%20-7.72516e-06%20160%200C248.366%207.72516e-06%20320%2071.6345%20320%20160Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.clamshell{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='254'%20viewBox='0%200%20320%20254'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M306.405%2084.081C313.114%2097.591%20316.468%20104.346%20318.162%20111.403C320.613%20121.606%20320.613%20132.394%20318.162%20142.597C316.468%20149.654%20313.114%20156.409%20306.405%20169.919L285.967%20211.079C279.258%20224.589%20275.904%20231.344%20271.495%20236.58C265.12%20244.148%20257.084%20249.543%20248.259%20252.177C242.155%20254%20235.446%20254%20222.028%20254H97.972C84.554%20254%2077.845%20254%2071.741%20252.178C62.916%20249.543%2054.88%20244.149%2048.505%20236.58C44.096%20231.345%2040.742%20224.589%2034.033%20211.079L13.595%20169.919C6.88599%20156.409%203.53201%20149.654%201.83801%20142.597C-0.612994%20132.394%20-0.612994%20121.606%201.83801%20111.403C3.53201%20104.346%206.88599%2097.591%2013.595%2084.081L34.033%2042.921C40.742%2029.411%2044.096%2022.655%2048.505%2017.42C54.88%209.85098%2062.916%204.45699%2071.741%201.82199C77.845%20-9.05991e-06%2084.554%200%2097.972%200H222.028C235.446%200%20242.155%20-9.05991e-06%20248.259%201.82199C257.084%204.45699%20265.12%209.85098%20271.495%2017.42C275.904%2022.655%20279.258%2029.41%20285.967%2042.921L306.405%2084.081Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='254'%20viewBox='0%200%20320%20254'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M306.405%2084.081C313.114%2097.591%20316.468%20104.346%20318.162%20111.403C320.613%20121.606%20320.613%20132.394%20318.162%20142.597C316.468%20149.654%20313.114%20156.409%20306.405%20169.919L285.967%20211.079C279.258%20224.589%20275.904%20231.344%20271.495%20236.58C265.12%20244.148%20257.084%20249.543%20248.259%20252.177C242.155%20254%20235.446%20254%20222.028%20254H97.972C84.554%20254%2077.845%20254%2071.741%20252.178C62.916%20249.543%2054.88%20244.149%2048.505%20236.58C44.096%20231.345%2040.742%20224.589%2034.033%20211.079L13.595%20169.919C6.88599%20156.409%203.53201%20149.654%201.83801%20142.597C-0.612994%20132.394%20-0.612994%20121.606%201.83801%20111.403C3.53201%20104.346%206.88599%2097.591%2013.595%2084.081L34.033%2042.921C40.742%2029.411%2044.096%2022.655%2048.505%2017.42C54.88%209.85098%2062.916%204.45699%2071.741%201.82199C77.845%20-9.05991e-06%2084.554%200%2097.972%200H222.028C235.446%200%20242.155%20-9.05991e-06%20248.259%201.82199C257.084%204.45699%20265.12%209.85098%20271.495%2017.42C275.904%2022.655%20279.258%2029.41%20285.967%2042.921L306.405%2084.081Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.diamond{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='268'%20height='320'%20viewBox='0%200%20268%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M191.442%20276.481C174.606%20298.514%20166.188%20309.53%20156.466%20314.548C142.383%20321.817%20125.617%20321.817%20111.534%20314.548C101.812%20309.53%2093.394%20298.514%2076.558%20276.481L20.646%20203.308C10.406%20189.906%205.286%20183.206%202.751%20176.032C-0.917%20165.654%20-0.917%20154.346%202.751%20143.968C5.286%20136.794%2010.406%20130.094%2020.646%20116.692L76.558%2043.5194C93.394%2021.4863%20101.812%2010.4697%20111.534%205.45181C125.617%20-1.81727%20142.383%20-1.81727%20156.466%205.4518C166.188%2010.4697%20174.606%2021.4863%20191.442%2043.5195L247.354%20116.692C257.594%20130.094%20262.714%20136.794%20265.249%20143.968C268.917%20154.346%20268.917%20165.654%20265.249%20176.032C262.714%20183.206%20257.594%20189.906%20247.354%20203.308L191.442%20276.481Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='268'%20height='320'%20viewBox='0%200%20268%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M191.442%20276.481C174.606%20298.514%20166.188%20309.53%20156.466%20314.548C142.383%20321.817%20125.617%20321.817%20111.534%20314.548C101.812%20309.53%2093.394%20298.514%2076.558%20276.481L20.646%20203.308C10.406%20189.906%205.286%20183.206%202.751%20176.032C-0.917%20165.654%20-0.917%20154.346%202.751%20143.968C5.286%20136.794%2010.406%20130.094%2020.646%20116.692L76.558%2043.5194C93.394%2021.4863%20101.812%2010.4697%20111.534%205.45181C125.617%20-1.81727%20142.383%20-1.81727%20156.466%205.4518C166.188%2010.4697%20174.606%2021.4863%20191.442%2043.5195L247.354%20116.692C257.594%20130.094%20262.714%20136.794%20265.249%20143.968C268.917%20154.346%20268.917%20165.654%20265.249%20176.032C262.714%20183.206%20257.594%20189.906%20247.354%20203.308L191.442%20276.481Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.fan{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='280'%20height='280'%20viewBox='0%200%20280%20280'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%2044.2105C0%2042.6506%201.95317e-05%2041.8706%200.0200195%2041.2111C0.71702%2018.7571%2018.757%200.7174%2041.211%200.0205002C41.871%201.82539e-07%2042.651%200%2044.211%200C52.53%200%2056.69%20-4.76837e-07%2060.208%200.1092C179.96%203.8259%20276.17%20100.038%20279.89%20219.792C280%20223.31%20280%20227.47%20280%20235.789C280%20237.349%20280%20238.129%20279.98%20238.789C279.28%20261.243%20261.24%20279.283%20238.79%20279.98C238.13%20280%20237.35%20280%20235.79%20280H62.945C43.927%20280%2034.417%20280%2026.874%20277.013C15.955%20272.69%207.31%20264.045%202.987%20253.126C-4.76837e-07%20245.583%200%20236.073%200%20217.055V44.2105Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='280'%20height='280'%20viewBox='0%200%20280%20280'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%2044.2105C0%2042.6506%201.95317e-05%2041.8706%200.0200195%2041.2111C0.71702%2018.7571%2018.757%200.7174%2041.211%200.0205002C41.871%201.82539e-07%2042.651%200%2044.211%200C52.53%200%2056.69%20-4.76837e-07%2060.208%200.1092C179.96%203.8259%20276.17%20100.038%20279.89%20219.792C280%20223.31%20280%20227.47%20280%20235.789C280%20237.349%20280%20238.129%20279.98%20238.789C279.28%20261.243%20261.24%20279.283%20238.79%20279.98C238.13%20280%20237.35%20280%20235.79%20280H62.945C43.927%20280%2034.417%20280%2026.874%20277.013C15.955%20272.69%207.31%20264.045%202.987%20253.126C-4.76837e-07%20245.583%200%20236.073%200%20217.055V44.2105Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.flower{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M273.13%2046.8625C261.25%2034.988%20234.19%2040.8597%20201.55%2059.6813C191.77%2023.2855%20176.79%202.9362e-06%20160%200C143.2%20-2.9362e-06%20128.22%2023.2841%20118.45%2059.6779C85.7999%2040.8581%2058.75%2034.9874%2046.87%2046.8614C35%2058.7367%2040.8699%2085.7963%2059.6899%20118.446C23.2899%20128.222%200%20143.204%200%20160C0%20176.793%2023.2801%20191.773%2059.6801%20201.549C40.8501%20234.2%2034.98%20261.261%2046.85%20273.137C58.73%20285.013%2085.7899%20279.138%20118.44%20260.31C128.22%20296.711%20143.2%20320%20160%20320C176.79%20320%20191.77%20296.709%20201.55%20260.307C234.21%20279.136%20261.27%20285.012%20273.15%20273.136C285.02%20261.26%20279.15%20234.2%20260.32%20201.549C296.72%20191.773%20320%20176.793%20320%20160C320%20143.204%20296.71%20128.222%20260.3%20118.446C279.13%2085.7966%20285%2058.7376%20273.13%2046.8625Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M273.13%2046.8625C261.25%2034.988%20234.19%2040.8597%20201.55%2059.6813C191.77%2023.2855%20176.79%202.9362e-06%20160%200C143.2%20-2.9362e-06%20128.22%2023.2841%20118.45%2059.6779C85.7999%2040.8581%2058.75%2034.9874%2046.87%2046.8614C35%2058.7367%2040.8699%2085.7963%2059.6899%20118.446C23.2899%20128.222%200%20143.204%200%20160C0%20176.793%2023.2801%20191.773%2059.6801%20201.549C40.8501%20234.2%2034.98%20261.261%2046.85%20273.137C58.73%20285.013%2085.7899%20279.138%20118.44%20260.31C128.22%20296.711%20143.2%20320%20160%20320C176.79%20320%20191.77%20296.709%20201.55%20260.307C234.21%20279.136%20261.27%20285.012%20273.15%20273.136C285.02%20261.26%20279.15%20234.2%20260.32%20201.549C296.72%20191.773%20320%20176.793%20320%20160C320%20143.204%20296.71%20128.222%20260.3%20118.446C279.13%2085.7966%20285%2058.7376%20273.13%2046.8625Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.gem{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='302'%20height='312'%20viewBox='0%200%20302%20312'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M92.48%2026.6316C110.64%2013.4359%20119.73%206.838%20129.41%203.55802C143.41%20-1.18601%20158.59%20-1.18601%20172.59%203.55802C182.27%206.838%20191.36%2013.4359%20209.52%2026.6317L250.37%2056.3046C261.16%2064.1409%20266.56%2068.059%20270.95%2072.7627C277.31%2079.5606%20282.18%2087.6027%20285.27%2096.381C287.41%20102.454%20288.38%20109.048%20290.34%20122.236L297.9%20173.237C301.33%20196.373%20303.05%20207.941%20301.32%20218.367C298.81%20233.448%20291.24%20247.227%20279.86%20257.431C271.99%20264.486%20261.3%20269.245%20239.93%20278.763L191.52%20300.326C178.62%20306.07%20172.17%20308.941%20165.55%20310.409C155.96%20312.53%20146.04%20312.53%20136.45%20310.409C129.83%20308.941%20123.38%20306.07%20110.48%20300.326L62.07%20278.763C40.7%20269.245%2030.01%20264.486%2022.14%20257.431C10.76%20247.227%203.19008%20233.448%200.68008%20218.367C-1.04992%20207.941%200.670002%20196.373%204.1%20173.237L11.6601%20122.236C13.6201%20109.048%2014.59%20102.454%2016.73%2096.381C19.82%2087.6027%2024.6901%2079.5606%2031.0501%2072.7627C35.4401%2068.059%2040.84%2064.1409%2051.63%2056.3046L92.48%2026.6316Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='302'%20height='312'%20viewBox='0%200%20302%20312'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M92.48%2026.6316C110.64%2013.4359%20119.73%206.838%20129.41%203.55802C143.41%20-1.18601%20158.59%20-1.18601%20172.59%203.55802C182.27%206.838%20191.36%2013.4359%20209.52%2026.6317L250.37%2056.3046C261.16%2064.1409%20266.56%2068.059%20270.95%2072.7627C277.31%2079.5606%20282.18%2087.6027%20285.27%2096.381C287.41%20102.454%20288.38%20109.048%20290.34%20122.236L297.9%20173.237C301.33%20196.373%20303.05%20207.941%20301.32%20218.367C298.81%20233.448%20291.24%20247.227%20279.86%20257.431C271.99%20264.486%20261.3%20269.245%20239.93%20278.763L191.52%20300.326C178.62%20306.07%20172.17%20308.941%20165.55%20310.409C155.96%20312.53%20146.04%20312.53%20136.45%20310.409C129.83%20308.941%20123.38%20306.07%20110.48%20300.326L62.07%20278.763C40.7%20269.245%2030.01%20264.486%2022.14%20257.431C10.76%20247.227%203.19008%20233.448%200.68008%20218.367C-1.04992%20207.941%200.670002%20196.373%204.1%20173.237L11.6601%20122.236C13.6201%20109.048%2014.59%20102.454%2016.73%2096.381C19.82%2087.6027%2024.6901%2079.5606%2031.0501%2072.7627C35.4401%2068.059%2040.84%2064.1409%2051.63%2056.3046L92.48%2026.6316Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.ghost-ish{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='304'%20height='304'%20viewBox='0%200%20304%20304'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%20144.762C0%2064.812%2068.0527%200%20152%200C235.947%200%20304%2064.812%20304%20144.762V246.095C304%20278.075%20276.779%20304%20243.2%20304C233.247%20304%20223.853%20301.722%20215.56%20297.685C211.335%20295.627%20207.119%20293.372%20202.885%20291.107C187.986%20283.136%20172.866%20275.048%20156.327%20275.048H147.673C131.134%20275.048%20116.014%20283.136%20101.115%20291.107C96.881%20293.372%2092.665%20295.627%2088.44%20297.685C80.1472%20301.722%2070.7529%20304%2060.8%20304C27.2211%20304%200%20278.075%200%20246.095V144.762Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='304'%20height='304'%20viewBox='0%200%20304%20304'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%20144.762C0%2064.812%2068.0527%200%20152%200C235.947%200%20304%2064.812%20304%20144.762V246.095C304%20278.075%20276.779%20304%20243.2%20304C233.247%20304%20223.853%20301.722%20215.56%20297.685C211.335%20295.627%20207.119%20293.372%20202.885%20291.107C187.986%20283.136%20172.866%20275.048%20156.327%20275.048H147.673C131.134%20275.048%20116.014%20283.136%20101.115%20291.107C96.881%20293.372%2092.665%20295.627%2088.44%20297.685C80.1472%20301.722%2070.7529%20304%2060.8%20304C27.2211%20304%200%20278.075%200%20246.095V144.762Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.heart{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='286'%20viewBox='0%200%20320%20286'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M251.1%200.130005C229.439%200.130005%20210.113%2010.3%20197.481%2026.2L160%2067.51V67.38L122.519%2026.0601C109.887%2010.1701%2090.561%200%2068.9%200C30.848%200%200%2031.3701%200%2070.0601C0%20104.06%2028.375%20129.47%2048.919%20153.88C69.389%20178.21%2089.856%20202.52%20110.323%20226.84L156.272%20281.44C157.516%20282.91%20158.756%20284.39%20160%20285.87V286C161.244%20284.52%20162.484%20283.05%20163.728%20281.57C179.043%20263.37%20194.358%20245.18%20209.677%20226.98C230.144%20202.66%20250.614%20178.34%20271.081%20154.02C291.625%20129.61%20320%20104.2%20320%2070.1899C320%2031.4999%20289.152%200.130005%20251.1%200.130005Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='286'%20viewBox='0%200%20320%20286'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M251.1%200.130005C229.439%200.130005%20210.113%2010.3%20197.481%2026.2L160%2067.51V67.38L122.519%2026.0601C109.887%2010.1701%2090.561%200%2068.9%200C30.848%200%200%2031.3701%200%2070.0601C0%20104.06%2028.375%20129.47%2048.919%20153.88C69.389%20178.21%2089.856%20202.52%20110.323%20226.84L156.272%20281.44C157.516%20282.91%20158.756%20284.39%20160%20285.87V286C161.244%20284.52%20162.484%20283.05%20163.728%20281.57C179.043%20263.37%20194.358%20245.18%20209.677%20226.98C230.144%20202.66%20250.614%20178.34%20271.081%20154.02C291.625%20129.61%20320%20104.2%20320%2070.1899C320%2031.4999%20289.152%200.130005%20251.1%200.130005Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.leaf-clover4{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='296'%20height='296'%20viewBox='0%200%20296%20296'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M21%20148C7.9%20132.34%200%20112.13%200%2090.0601C0%2040.3201%2040.11%200%2089.6%200C111.99%200%20132.47%208.25991%20148.17%2021.9099C163.84%208.25991%20184.27%200%20206.61%200C255.98%200%20296%2040.3201%20296%2090.0601C296%20112.13%20288.12%20132.34%20275.05%20148C288.12%20163.66%20296%20183.87%20296%20205.94C296%20255.68%20255.98%20296%20206.61%20296C184.27%20296%20163.84%20287.74%20148.17%20274.09C132.47%20287.74%20111.99%20296%2089.6%20296C40.11%20296%200%20255.68%200%20205.94C0%20183.87%207.9%20163.66%2021%20148Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='296'%20height='296'%20viewBox='0%200%20296%20296'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M21%20148C7.9%20132.34%200%20112.13%200%2090.0601C0%2040.3201%2040.11%200%2089.6%200C111.99%200%20132.47%208.25991%20148.17%2021.9099C163.84%208.25991%20184.27%200%20206.61%200C255.98%200%20296%2040.3201%20296%2090.0601C296%20112.13%20288.12%20132.34%20275.05%20148C288.12%20163.66%20296%20183.87%20296%20205.94C296%20255.68%20255.98%20296%20206.61%20296C184.27%20296%20163.84%20287.74%20148.17%20274.09C132.47%20287.74%20111.99%20296%2089.6%20296C40.11%20296%200%20255.68%200%20205.94C0%20183.87%207.9%20163.66%2021%20148Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.leaft-clover8{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M308.58%20160C334.43%20208.16%20314.9%20251.77%20265.07%20265.06C251.77%20314.9%20208.16%20334.42%20160%20308.58C111.83%20334.43%2068.2201%20314.9%2054.9301%20265.07C5.10006%20251.77%20-14.4299%20208.16%2011.4201%20160C-14.4299%20111.83%205.10006%2068.2198%2054.9301%2054.9298C68.2201%205.09982%20111.83%20-14.4302%20160%2011.4198C208.16%20-14.4302%20251.77%205.09982%20265.06%2054.9298C314.9%2068.2198%20334.42%20111.83%20308.58%20160Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M308.58%20160C334.43%20208.16%20314.9%20251.77%20265.07%20265.06C251.77%20314.9%20208.16%20334.42%20160%20308.58C111.83%20334.43%2068.2201%20314.9%2054.9301%20265.07C5.10006%20251.77%20-14.4299%20208.16%2011.4201%20160C-14.4299%20111.83%205.10006%2068.2198%2054.9301%2054.9298C68.2201%205.09982%20111.83%20-14.4302%20160%2011.4198C208.16%20-14.4302%20251.77%205.09982%20265.06%2054.9298C314.9%2068.2198%20334.42%20111.83%20308.58%20160Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.loading-indicator{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20viewBox='4%204%2040%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill='%23D0BCFF'%3e%3canimate%20attributeName='d'%20dur='5s'%20repeatCount='indefinite'%20calcMode='spline'%20keySplines='0.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8'%20keyTimes='0;%200.14;%200.14;%200.29;%200.29;%200.43;%200.43;%200.57;%200.57;%200.71;%200.71;%200.86;%200.86;%201'%20values='M20.9%2010.4%2021.4%209.5%2021.9%208.7%2022.5%207.8%2023.2%207.2%2024.2%207%2025.1%207.4%2025.7%208.1%2026.2%209%2026.8%209.8%2027.3%2010.6%2028.1%2011.2%2029%2011.3%2030%2011%2030.9%2010.6%2031.8%2010.3%2032.8%209.9%2033.7%2010%2034.5%2010.6%2034.9%2011.5%2034.8%2012.5%2034.8%2013.5%2034.7%2014.5%2034.7%2015.5%2035.2%2016.3%2036%2016.8%2037%2017.1%2037.9%2017.3%2038.9%2017.5%2039.8%2017.9%2040.4%2018.7%2040.5%2019.7%2040%2020.5%2039.4%2021.3%2038.7%2022%2038.1%2022.8%2037.6%2023.7%2037.7%2024.6%2038.3%2025.5%2038.9%2026.2%2039.6%2027%2040.2%2027.7%2040.5%2028.7%2040.3%2029.6%2039.5%2030.3%2038.6%2030.6%2037.6%2030.8%2036.7%2031%2035.7%2031.3%2035%2031.9%2034.6%2032.8%2034.7%2033.8%2034.8%2034.8%2034.9%2035.8%2034.8%2036.8%2034.3%2037.6%2033.4%2038.1%2032.4%2038%2031.5%2037.6%2030.6%2037.2%2029.7%2036.9%2028.7%2036.6%2027.8%2036.9%2027.1%2037.6%2026.6%2038.5%2026.1%2039.3%2025.5%2040.2%2024.8%2040.8%2023.8%2041%2022.9%2040.6%2022.3%2039.9%2021.8%2039%2021.2%2038.2%2020.7%2037.4%2019.9%2036.8%2019%2036.7%2018%2037%2017.1%2037.4%2016.2%2037.7%2015.2%2038.1%2014.3%2038%2013.5%2037.4%2013.1%2036.5%2013.2%2035.5%2013.2%2034.5%2013.3%2033.5%2013.3%2032.5%2012.8%2031.7%2012%2031.2%2011%2031%2010.1%2030.7%209.1%2030.5%208.2%2030.1%207.6%2029.3%207.5%2028.3%208%2027.5%208.7%2026.7%209.3%2026%209.9%2025.2%2010.4%2024.3%2010.3%2023.4%209.7%2022.5%209.1%2021.8%208.4%2021%207.8%2020.3%207.5%2019.3%207.7%2018.4%208.5%2017.7%209.4%2017.4%2010.4%2017.2%2011.3%2017%2012.3%2016.7%2013%2016.1%2013.4%2015.2%2013.3%2014.2%2013.2%2013.2%2013.1%2012.2%2013.2%2011.2%2013.7%2010.4%2014.6%209.9%2015.6%2010%2016.5%2010.4%2017.4%2010.8%2018.3%2011.1%2019.3%2011.4%2020.2%2011.1Z;%20M20.3%208.6%2021.1%208%2022%207.6%2023%207.3%2023%207.3%2024%207.2%2025%207.3%2025.9%207.5%2026.8%208%2027.6%208.6%2028.4%209.1%2028.4%209.1%2029.3%209.6%2030.3%209.8%2031.3%209.9%2032.3%2010%2033.3%2010.2%2034.2%2010.6%2034.2%2010.6%2035%2011.2%2035.7%2011.9%2036.3%2012.7%2036.7%2013.6%2036.9%2014.6%2037.2%2015.5%2037.2%2015.5%2037.6%2016.5%2038.2%2017.3%2038.9%2018%2039.6%2018.7%2040.2%2019.5%2040.6%2020.4%2040.6%2020.4%2040.9%2021.3%2041%2022.3%2040.9%2023.3%2040.6%2024.3%2040.2%2025.2%2039.8%2026.1%2039.8%2026.1%2039.5%2027%2039.4%2028%2039.5%2029%2039.6%2030%2039.5%2031%2039.3%2032%2039.3%2032%2038.9%2032.9%2038.3%2033.7%2037.6%2034.4%2036.8%2035%2035.9%2035.4%2035%2035.8%2035%2035.8%2034.1%2036.3%2033.4%2037%2032.9%2037.9%2032.3%2038.7%2031.6%2039.4%2030.8%2040%2030.8%2040%2029.9%2040.4%2028.9%2040.7%2027.9%2040.8%2027%2040.7%2026%2040.4%2025%2040.1%2025%2040.1%2024%2040%2023%2040.1%2022.1%2040.4%2021.1%2040.7%2020.1%2040.8%2019.1%2040.7%2019.1%2040.7%2018.2%2040.5%2017.3%2040%2016.4%2039.5%2015.7%2038.8%2015.2%2037.9%2014.6%2037.1%2014.6%2037.1%2013.9%2036.4%2013.1%2035.8%2012.2%2035.4%2011.3%2035%2010.5%2034.4%209.7%2033.8%209.7%2033.8%209.1%2032.9%208.7%2032%208.5%2031.1%208.4%2030.1%208.5%2029.1%208.6%2028.1%208.6%2028.1%208.5%2027.1%208.3%2026.1%207.8%2025.2%207.4%2024.3%207.1%2023.4%207%2022.4%207%2022.4%207.1%2021.4%207.3%2020.4%207.8%2019.5%208.3%2018.7%209.1%2018%209.8%2017.3%209.8%2017.3%2010.4%2016.5%2010.8%2015.6%2011%2014.6%2011.3%2013.7%2011.7%2012.8%2012.2%2011.9%2012.2%2011.9%2012.9%2011.2%2013.8%2010.7%2014.7%2010.2%2015.6%2010%2016.6%209.9%2017.6%209.8%2017.6%209.8%2018.6%209.6%2019.5%209.2Z;%20M18.6%209.6%2019.5%209.2%2020.3%208.6%2021.1%208%2022%207.6%2023%207.3%2024%207.2%2025%207.3%2025.9%207.5%2026.8%208%2027.6%208.6%2028.4%209.1%2029.3%209.6%2030.3%209.8%2031.3%209.9%2032.3%2010%2033.3%2010.2%2034.2%2010.6%2035%2011.2%2035.7%2011.9%2036.3%2012.7%2036.7%2013.6%2036.9%2014.6%2037.2%2015.5%2037.6%2016.4%2038.2%2017.3%2038.9%2018%2039.6%2018.7%2040.2%2019.5%2040.6%2020.4%2040.9%2021.3%2041%2022.3%2040.9%2023.3%2040.6%2024.3%2040.2%2025.2%2039.8%2026.1%2039.5%2027%2039.4%2028%2039.5%2029%2039.6%2030%2039.5%2031%2039.3%2032%2038.9%2032.9%2038.3%2033.7%2037.6%2034.4%2036.8%2035%2035.9%2035.4%2035%2035.8%2034.1%2036.3%2033.4%2037%2032.9%2037.9%2032.3%2038.7%2031.6%2039.4%2030.8%2040%2029.9%2040.4%2028.9%2040.7%2027.9%2040.8%2027%2040.7%2026%2040.4%2025%2040.1%2024%2040%2023%2040.1%2022.1%2040.4%2021.1%2040.7%2020.1%2040.8%2019.1%2040.7%2018.2%2040.5%2017.3%2040%2016.4%2039.5%2015.7%2038.8%2015.2%2037.9%2014.6%2037.1%2013.9%2036.4%2013.1%2035.8%2012.2%2035.4%2011.3%2035%2010.5%2034.4%209.7%2033.8%209.1%2032.9%208.7%2032%208.5%2031.1%208.4%2030.1%208.5%2029.1%208.6%2028.1%208.5%2027.1%208.3%2026.1%207.8%2025.2%207.4%2024.3%207.1%2023.4%207%2022.4%207.1%2021.4%207.3%2020.4%207.8%2019.5%208.3%2018.7%209.1%2018%209.8%2017.3%2010.4%2016.5%2010.8%2015.6%2011%2014.6%2011.3%2013.7%2011.7%2012.8%2012.2%2011.9%2012.9%2011.2%2013.8%2010.7%2014.7%2010.2%2015.6%2010%2016.6%209.9%2017.6%209.8Z;%20M18.6%209.9%2019.5%209.4%2020.3%208.8%2021.1%208.2%2022%207.8%2023%207.6%2023.9%207.5%2024.9%207.6%2025.9%207.8%2026.8%208.2%2027.6%208.7%2028.5%209.3%2029.3%209.9%2030.1%2010.5%2030.9%2011%2031.7%2011.6%2032.5%2012.2%2033.3%2012.8%2033.7%2013.1%2034.1%2013.3%2034.9%2013.9%2035.7%2014.5%2036.6%2015%2037.4%2015.6%2038.2%2016.2%2039%2016.8%2039.7%2017.5%2040.2%2018.3%2040.7%2019.2%2040.9%2020.1%2041%2021.1%2040.9%2022.1%2040.7%2023.1%2040.3%2024%2040%2024.9%2039.7%2025.9%2039.4%2026.8%2039%2027.8%2038.7%2028.7%2038.4%2029.6%2038.1%2030.6%2037.8%2031.5%2037.5%2032.5%2037.2%2033.4%2036.9%2034.4%2036.6%2035.3%2036.2%2036.2%2035.7%2037.1%2035%2037.8%2034.3%2038.4%2033.4%2038.9%2032.5%2039.3%2031.5%2039.5%2030.5%2039.5%2030%2039.5%2029.5%2039.5%2028.5%2039.5%2027.5%2039.5%2026.5%2039.5%2025.5%2039.4%2024.5%2039.4%2023.6%2039.4%2022.6%2039.4%2021.6%2039.5%2020.6%2039.5%2019.6%2039.5%2018.6%2039.5%2017.6%2039.5%2016.6%2039.5%2015.6%2039.3%2014.7%2039%2013.8%2038.5%2013.1%2037.9%2012.4%2037.2%2011.9%2036.3%2011.5%2035.4%2011.2%2034.5%2010.9%2033.5%2010.6%2032.6%2010.3%2031.6%2010%2030.7%209.7%2029.7%209.3%2028.8%209%2027.9%208.7%2026.9%208.4%2026%208%2025%207.7%2024.1%207.4%2023.2%207.1%2022.2%207.1%2021.7%207%2021.2%207.1%2020.2%207.3%2019.3%207.7%2018.4%208.3%2017.5%208.9%2016.8%209.7%2016.2%2010.5%2015.6%2011.4%2015.1%2012.2%2014.5%2013%2014%2013.8%2013.4%2014.6%2012.8%2015.4%2012.3%2016.2%2011.7%2017%2011.1%2017.8%2010.5Z;%20M15.4%2012.3%2016.2%2011.7%2017%2011.1%2017.8%2010.5%2018.6%209.9%2019.5%209.4%2020.3%208.8%2021.1%208.3%2022%207.8%2023%207.6%2023.9%207.5%2024.9%207.6%2025.9%207.8%2026.8%208.2%2027.6%208.7%2028.5%209.3%2029.3%209.9%2030.1%2010.5%2030.9%2011%2031.7%2011.6%2032.5%2012.2%2033.3%2012.8%2034.1%2013.3%2034.9%2013.9%2035.7%2014.5%2036.6%2015%2037.4%2015.6%2038.2%2016.2%2039%2016.8%2039.7%2017.5%2040.2%2018.3%2040.7%2019.2%2040.9%2020.1%2041%2021.1%2040.9%2022.1%2040.7%2023.1%2040.3%2024%2040%2024.9%2039.7%2025.9%2039.4%2026.8%2039%2027.8%2038.7%2028.7%2038.4%2029.6%2038.1%2030.6%2037.8%2031.5%2037.5%2032.5%2037.2%2033.4%2036.9%2034.4%2036.6%2035.3%2036.2%2036.2%2035.7%2037.1%2035%2037.8%2034.3%2038.4%2033.4%2038.9%2032.5%2039.3%2031.5%2039.4%2030.5%2039.5%2029.5%2039.5%2028.5%2039.5%2027.5%2039.5%2026.5%2039.5%2025.5%2039.4%2024.5%2039.4%2023.6%2039.4%2022.6%2039.4%2021.6%2039.5%2020.6%2039.5%2019.6%2039.5%2018.6%2039.5%2017.6%2039.5%2016.6%2039.5%2015.6%2039.3%2014.7%2039%2013.8%2038.5%2013.1%2037.9%2012.4%2037.2%2011.9%2036.3%2011.5%2035.4%2011.2%2034.5%2010.9%2033.5%2010.6%2032.6%2010.3%2031.6%2010%2030.7%209.7%2029.7%209.3%2028.8%209%2027.9%208.7%2026.9%208.4%2026%208%2025%207.7%2024.1%207.4%2023.2%207.1%2022.2%207%2021.2%207.1%2020.2%207.3%2019.3%207.7%2018.4%208.3%2017.5%208.9%2016.8%209.7%2016.2%2010.5%2015.6%2011.4%2015.1%2012.2%2014.5%2013%2014%2013.8%2013.4%2014.6%2012.8Z;%20M17%2012.8%2017.7%2012.1%2018.5%2011.5%2019.3%2010.9%2020.1%2010.5%2020.2%2010.4%2021.1%2010%2022%209.7%2023%209.4%2024%209.2%2025%209%2026%209%2027%209%2027.6%209.1%2028%209.1%2028.9%209.3%2029.9%209.6%2030.9%209.9%2031.8%2010.3%2032.6%2010.8%2033.5%2011.3%2034.3%2011.9%2034.6%2012.2%2035%2012.6%2035.7%2013.3%2036.4%2014.1%2036.9%2014.9%2037.4%2015.8%2037.9%2016.6%2038.3%2017.6%2038.6%2018.5%2038.6%2018.7%2038.8%2019.5%2038.9%2020.5%2039%2021.5%2039%2022.5%2038.9%2023.5%2038.7%2024.5%2038.5%2025.4%2038.2%2026.3%2038.2%2026.4%2037.8%2027.3%2037.4%2028.2%2036.8%2029.1%2036.2%2029.9%2035.6%2030.6%2034.9%2031.3%2034.2%2032%2033.8%2032.5%2033.5%2032.8%2032.8%2033.5%2032.1%2034.2%2031.4%2034.9%2030.7%2035.6%2029.9%2036.2%2029.1%2036.8%2028.2%2037.3%2027.9%2037.5%2027.4%2037.8%2026.4%2038.2%2025.5%2038.5%2024.5%2038.7%2023.5%2038.9%2022.5%2039%2021.5%2039%2020.5%2038.9%2020.4%2038.9%2019.5%2038.8%2018.6%2038.6%2017.6%2038.3%2016.7%2037.9%2015.8%2037.5%2014.9%2037%2014.1%2036.4%2013.4%2035.8%2013.3%2035.8%2012.6%2035.1%2012%2034.3%2011.3%2033.5%2010.8%2032.7%2010.3%2031.8%209.9%2030.9%209.6%2030%209.4%2029.3%209.3%2029%209.1%2028%209%2027%209%2026%209%2025%209.2%2024%209.4%2023%209.6%2022.1%209.8%2021.7%2010%2021.1%2010.4%2020.2%2010.9%2019.4%2011.4%2018.5%2012.1%2017.8%2012.7%2017%2013.4%2016.3%2014.2%2015.6%2014.2%2015.5%2014.9%2014.9%2015.6%2014.2%2016.3%2013.5Z;%20M33.5%2011.3%2034.3%2011.9%2035%2012.6%2035.3%2012.8%2035.7%2013.3%2036.4%2014.1%2036.9%2014.9%2037.4%2015.8%2037.9%2016.6%2038.3%2017.6%2038.3%2017.7%2038.6%2018.5%2038.8%2019.5%2038.9%2020.5%2039%2021.5%2039%2022.5%2038.9%2023.5%2038.9%2023.5%2038.7%2024.5%2038.5%2025.4%2038.2%2026.4%2037.8%2027.3%2037.4%2028.2%2036.9%2028.9%2036.8%2029.1%2036.2%2029.9%2035.6%2030.6%2034.9%2031.3%2034.2%2032%2033.5%2032.8%2033.1%2033.2%2032.8%2033.5%2032.1%2034.2%2031.4%2034.9%2030.7%2035.6%2029.9%2036.2%2029.1%2036.8%2028.7%2037%2028.2%2037.3%2027.4%2037.8%2026.4%2038.2%2025.5%2038.5%2024.5%2038.7%2023.5%2038.9%2023.3%2038.9%2022.5%2039%2021.5%2039%2020.5%2038.9%2019.5%2038.8%2018.6%2038.6%2017.6%2038.3%2017.6%2038.3%2016.7%2037.9%2015.8%2037.5%2014.9%2037%2014.1%2036.4%2013.3%2035.8%2012.7%2035.2%2012.6%2035.1%2012%2034.3%2011.3%2033.5%2010.8%2032.7%2010.3%2031.8%209.9%2030.9%209.7%2030.3%209.6%2029.9%209.3%2029%209.1%2028%209%2027%209%2026%209%2025%209.1%2024.5%209.2%2024%209.4%2023%209.6%2022.1%2010%2021.1%2010.4%2020.2%2010.9%2019.4%2011.1%2019.1%2011.5%2018.5%2012.1%2017.7%2012.7%2017%2013.5%2016.3%2014.2%2015.6%2014.9%2014.9%2014.9%2014.8%2015.6%2014.2%2016.3%2013.5%2017%2012.8%2017.7%2012.1%2018.5%2011.5%2019.3%2011%2019.3%2010.9%2020.2%2010.4%2021.1%2010%2022%209.7%2023%209.4%2024%209.2%2024.7%209.1%2025%209%2026%209%2027%209%2028%209.1%2028.9%209.3%2029.9%209.6%2030.4%209.7%2030.9%209.9%2031.8%2010.3%2032.6%2010.8Z;%20M33.2%2011.1%2034.2%2011.2%2035.1%2011.4%2036%2011.9%2036.6%2012.7%2036.8%2013.7%2036.9%2014.7%2036.9%2015.7%2037%2016.7%2037.1%2017.7%2037.3%2018.6%2037.9%2019.4%2038.5%2020.2%2039.2%2020.9%2039.8%2021.7%2040.5%2022.4%2040.9%2023.3%2041%2024.3%2040.7%2025.2%2040.1%2026%2039.4%2026.8%2038.8%2027.5%2038.1%2028.3%2037.5%2029.1%2037.1%2030%2037%2031%2037%2031.9%2036.9%2032.9%2036.8%2033.9%2036.7%2034.9%2036.2%2035.8%2035.5%2036.4%2034.5%2036.8%2033.6%2036.8%2032.6%2036.9%2031.6%2037%2030.6%2037.1%2029.6%2037.2%2028.8%2037.7%2028%2038.4%2027.3%2039%2026.5%2039.7%2025.8%2040.3%2024.9%2040.8%2023.9%2041%2023%2040.8%2022.1%2040.2%2021.4%2039.6%2020.6%2038.9%2019.9%2038.3%2019.1%2037.6%2018.3%2037.2%2017.3%2037%2016.3%2037%2015.3%2036.9%2014.3%2036.8%2013.3%2036.7%2012.4%2036.4%2011.7%2035.7%2011.3%2034.8%2011.2%2033.8%2011.1%2032.8%2011%2031.8%2011%2030.8%2010.9%2029.9%2010.4%2029%209.8%2028.2%209.1%2027.5%208.5%2026.7%207.8%2026%207.3%2025.1%207%2024.2%207.1%2023.2%207.6%2022.3%208.2%2021.6%208.9%2020.8%209.5%2020.1%2010.2%2019.3%2010.7%2018.5%2010.9%2017.5%2011%2016.6%2011.1%2015.6%2011.1%2014.6%2011.2%2013.6%2011.5%2012.6%2012.1%2011.9%2013%2011.4%2013.9%2011.2%2014.9%2011.1%2015.9%2011%2016.9%2011%2017.9%2010.9%2018.8%2010.6%2019.6%2010%2020.4%209.3%2021.1%208.6%2021.9%208%2022.6%207.4%2023.6%207%2024.6%207.1%2025.5%207.5%2026.2%208.1%2027%208.7%2027.7%209.4%2028.5%2010%2029.3%2010.6%2030.2%2010.9%2031.2%2011%2032.2%2011.1Z;%20M27.7%209.4%2028.5%2010%2029.3%2010.6%2030.2%2010.9%2031.2%2011%2032.2%2011.1%2033.2%2011.1%2034.2%2011.2%2035.1%2011.4%2036%2011.9%2036.6%2012.7%2036.8%2013.7%2036.9%2014.7%2036.9%2015.7%2037%2016.7%2037.1%2017.7%2037.3%2018.6%2037.9%2019.4%2038.5%2020.2%2039.2%2020.9%2039.8%2021.7%2040.5%2022.4%2040.9%2023.3%2041%2024.3%2040.7%2025.2%2040.1%2026%2039.4%2026.8%2038.8%2027.5%2038.1%2028.3%2037.5%2029.1%2037.1%2030%2037%2031%2037%2031.9%2036.9%2032.9%2036.8%2033.9%2036.7%2034.9%2036.2%2035.8%2035.5%2036.4%2034.5%2036.8%2033.6%2036.9%2032.6%2036.9%2031.6%2037%2030.6%2037.1%2029.6%2037.2%2028.8%2037.7%2028%2038.4%2027.3%2039%2026.5%2039.7%2025.8%2040.3%2024.9%2040.8%2023.9%2041%2023%2040.8%2022.1%2040.2%2021.4%2039.6%2020.6%2038.9%2019.9%2038.3%2019.1%2037.6%2018.3%2037.2%2017.3%2037%2016.3%2037%2015.3%2036.9%2014.3%2036.8%2013.3%2036.7%2012.4%2036.4%2011.7%2035.7%2011.3%2034.8%2011.2%2033.8%2011.1%2032.8%2011%2031.8%2011%2030.8%2010.9%2029.9%2010.4%2029%209.8%2028.2%209.1%2027.5%208.5%2026.7%207.8%2026%207.3%2025.1%207%2024.2%207.1%2023.2%207.6%2022.3%208.2%2021.6%208.9%2020.8%209.5%2020.1%2010.2%2019.3%2010.7%2018.5%2010.9%2017.5%2011%2016.5%2011.1%2015.6%2011.1%2014.6%2011.2%2013.6%2011.5%2012.6%2012.1%2011.9%2013%2011.4%2013.9%2011.2%2014.9%2011.1%2015.9%2011%2016.9%2011%2017.9%2010.9%2018.8%2010.6%2019.6%2010%2020.4%209.3%2021.1%208.6%2021.9%208%2022.6%207.4%2023.6%207%2024.6%207.1%2025.5%207.5%2026.2%208.1%2027%208.7Z;%20M27.9%2010.6%2028.8%2010.3%2029.8%2010.1%2030.8%2010%2031.8%2010.1%2032.7%2010.3%2033.7%2010.6%2034.6%2011.1%2034.8%2011.3%2035.4%2011.7%2036.1%2012.4%2036.7%2013.1%2037.2%2014%2037.6%2014.9%2037.9%2015.9%2038%2016.9%2038%2017.9%2037.8%2018.8%2037.5%2019.8%2037.1%2020.7%2036.8%2021.6%2036.5%2022.6%2036.4%2023.6%2036.4%2024.4%2036.4%2024.6%2036.5%2025.5%2036.8%2026.5%2037.2%2027.4%2037.6%2028.3%2037.8%2029.3%2038%2030.3%2038%2031.3%2037.8%2032.3%2037.6%2033.2%2037.2%2034.1%2036.6%2035%2036%2035.7%2035.3%2036.4%2034.4%2037%2034.1%2037.2%2033.6%2037.4%2032.6%2037.8%2031.6%2037.9%2030.6%2038%2029.7%2037.9%2028.7%2037.7%2027.8%2037.3%2026.8%2036.9%2025.9%2036.6%2024.9%2036.4%2023.9%2036.4%2022.9%2036.4%2022%2036.6%2021%2037%2020.1%2037.4%2020.1%2037.4%2019.2%2037.7%2018.2%2037.9%2017.2%2038%2016.2%2037.9%2015.3%2037.7%2014.3%2037.4%2013.4%2036.9%2012.6%2036.3%2011.9%2035.6%2011.3%2034.9%2010.8%2034%2010.4%2033.1%2010.1%2032.1%2010%2031.1%2010%2030.6%2010%2030.1%2010.2%2029.2%2010.5%2028.2%2010.9%2027.3%2011.2%2026.4%2011.5%2025.4%2011.6%2024.4%2011.6%2023.4%2011.5%2022.5%2011.2%2021.5%2010.8%2020.6%2010.4%2019.7%2010.2%2018.7%2010%2017.7%2010%2016.7%2010%2016.6%2010.2%2015.7%2010.4%2014.8%2010.8%2013.9%2011.4%2013%2012%2012.3%2012.7%2011.6%2013.6%2011%2014.4%2010.6%2015.4%2010.2%2016.4%2010.1%2017.4%2010%2018.3%2010.1%2019.3%2010.3%2020.2%2010.7%2020.9%2011%2021.2%2011.1%2022.1%2011.4%2023.1%2011.6%2024.1%2011.6%2025.1%2011.6%2026%2011.4%2027%2011Z;%20M36%2035.7%2035.3%2036.4%2034.4%2037%2033.6%2037.4%2032.6%2037.8%2031.6%2037.9%2030.6%2038%2029.7%2037.9%2028.7%2037.7%2027.8%2037.3%2026.8%2036.9%2025.9%2036.6%2024.9%2036.4%2023.9%2036.4%2022.9%2036.4%2022%2036.6%2021%2037%2020.1%2037.4%2019.2%2037.7%2018.2%2037.9%2017.2%2038%2016.2%2037.9%2015.3%2037.7%2014.3%2037.4%2013.4%2036.9%2012.6%2036.3%2011.9%2035.6%2011.3%2034.9%2010.8%2034%2010.4%2033.1%2010.1%2032.1%2010%2031.1%2010%2030.2%2010.2%2029.2%2010.5%2028.2%2010.9%2027.3%2011.2%2026.4%2011.5%2025.4%2011.6%2024.4%2011.6%2023.4%2011.5%2022.5%2011.2%2021.5%2010.8%2020.6%2010.4%2019.7%2010.2%2018.7%2010%2017.7%2010%2016.7%2010.2%2015.7%2010.4%2014.8%2010.8%2013.9%2011.4%2013%2012%2012.3%2012.7%2011.6%2013.6%2011%2014.4%2010.6%2015.4%2010.2%2016.4%2010.1%2017.4%2010%2018.3%2010.1%2019.3%2010.3%2020.2%2010.7%2021.2%2011.1%2022.1%2011.4%2023.1%2011.6%2024.1%2011.6%2025.1%2011.6%2026%2011.4%2027%2011%2027.9%2010.6%2028.8%2010.3%2029.8%2010.1%2030.8%2010%2031.8%2010.1%2032.7%2010.3%2033.7%2010.6%2034.6%2011.1%2035.4%2011.7%2036.1%2012.4%2036.7%2013.1%2037.2%2014%2037.6%2014.9%2037.9%2015.9%2038%2016.9%2038%2017.8%2037.8%2018.8%2037.5%2019.8%2037.1%2020.7%2036.8%2021.6%2036.5%2022.6%2036.4%2023.6%2036.4%2024.6%2036.5%2025.5%2036.8%2026.5%2037.2%2027.4%2037.6%2028.3%2037.8%2029.3%2038%2030.3%2038%2031.3%2037.8%2032.3%2037.6%2033.2%2037.2%2034.1%2036.6%2035Z;%20M32.1%2032.1%2031.4%2032.8%2030.7%2033.5%2029.9%2034.1%2029.1%2034.7%2028.3%2035.3%2027.6%2035.8%2027.5%2035.8%2026.6%2036.4%2025.8%2036.8%2024.9%2037.3%2024%2037.7%2023.1%2038%2022.1%2038.3%2021.2%2038.6%2020.2%2038.8%2019.2%2038.9%2018.2%2039%2017.2%2039%2016.6%2038.9%2016.3%2038.9%2015.3%2038.7%2014.3%2038.4%2013.4%2038%2012.5%2037.5%2011.7%2036.9%2011.1%2036.3%2010.5%2035.5%2010%2034.6%209.6%2033.7%209.3%2032.7%209.1%2031.7%209.1%2031.4%209%2030.8%209%2029.8%209.1%2028.8%209.2%2027.8%209.4%2026.8%209.7%2025.9%2010%2024.9%2010.3%2024%2010.7%2023.1%2011.2%2022.2%2011.6%2021.4%2012.2%2020.5%2012.2%2020.4%2012.7%2019.7%2013.3%2018.9%2013.9%2018.1%2014.5%2017.3%2015.2%2016.6%2015.9%2015.9%2016.6%2015.2%2017.3%2014.5%2018.1%2013.9%2018.9%2013.3%2019.7%2012.7%2020.4%2012.2%2020.5%2012.2%2021.4%2011.6%2022.2%2011.2%2023.1%2010.7%2024%2010.3%2024.9%2010%2025.9%209.7%2026.8%209.4%2027.8%209.2%2028.8%209.1%2029.8%209%2030.8%209%2031.4%209.1%2031.7%209.1%2032.7%209.3%2033.7%209.6%2034.6%2010%2035.5%2010.5%2036.3%2011.1%2036.9%2011.7%2037.5%2012.5%2038%2013.4%2038.4%2014.3%2038.7%2015.3%2038.9%2016.3%2038.9%2016.6%2039%2017.2%2039%2018.2%2038.9%2019.2%2038.8%2020.2%2038.6%2021.2%2038.3%2022.1%2038%2023.1%2037.7%2024%2037.3%2024.9%2036.8%2025.8%2036.4%2026.6%2035.8%2027.5%2035.8%2027.6%2035.3%2028.3%2034.7%2029.1%2034.1%2029.9%2033.5%2030.7%2032.8%2031.4Z;%20M24.3%2010.2%2024.9%2010%2025.9%209.7%2026.8%209.4%2027.1%209.4%2027.8%209.2%2028.8%209.1%2029.8%209%2029.9%209%2030.8%209%2031.7%209.1%2032.7%209.3%2032.8%209.3%2033.7%209.6%2034.6%2010%2035.5%2010.5%2035.5%2010.5%2036.3%2011.1%2036.9%2011.7%2037.5%2012.5%2037.5%2012.5%2038%2013.4%2038.4%2014.3%2038.7%2015.2%2038.7%2015.3%2038.9%2016.3%2039%2017.2%2039%2018.1%2039%2018.2%2038.9%2019.2%2038.8%2020.2%2038.6%2020.9%2038.6%2021.2%2038.3%2022.1%2038%2023.1%2037.8%2023.7%2037.7%2024%2037.3%2024.9%2036.8%2025.8%2036.5%2026.4%2036.4%2026.6%2035.8%2027.5%2035.3%2028.3%2035%2028.8%2034.7%2029.1%2034.1%2029.9%2033.5%2030.7%2033.1%2031.1%2032.8%2031.4%2032.1%2032.1%2031.4%2032.8%2031.1%2033.1%2030.7%2033.5%2029.9%2034.1%2029.1%2034.7%2028.8%2035%2028.3%2035.3%2027.5%2035.8%2026.6%2036.4%2026.4%2036.5%2025.8%2036.8%2024.9%2037.3%2024%2037.7%2023.7%2037.8%2023.1%2038%2022.1%2038.3%2021.2%2038.6%2020.9%2038.6%2020.2%2038.8%2019.2%2038.9%2018.2%2039%2018.1%2039%2017.2%2039%2016.3%2038.9%2015.3%2038.7%2015.2%2038.7%2014.3%2038.4%2013.4%2038%2012.5%2037.5%2012.5%2037.5%2011.7%2036.9%2011.1%2036.3%2010.5%2035.5%2010.5%2035.5%2010%2034.6%209.6%2033.7%209.3%2032.8%209.3%2032.7%209.1%2031.7%209%2030.8%209%2029.9%209%2029.8%209.1%2028.8%209.2%2027.8%209.4%2027.1%209.4%2026.8%209.7%2025.9%2010%2024.9%2010.2%2024.3%2010.3%2024%2010.7%2023.1%2011.2%2022.2%2011.5%2021.6%2011.6%2021.4%2012.2%2020.5%2012.7%2019.7%2013%2019.2%2013.3%2018.9%2013.9%2018.1%2014.5%2017.3%2014.9%2016.9%2015.2%2016.6%2015.9%2015.9%2016.6%2015.2%2016.9%2014.9%2017.3%2014.5%2018.1%2013.9%2018.9%2013.3%2019.2%2013%2019.7%2012.7%2020.5%2012.2%2021.4%2011.6%2021.6%2011.5%2022.2%2011.2%2023.1%2010.7%2024%2010.3Z;%20M22.5%207.8%2023.2%207.2%2024.2%207%2025.1%207.4%2025.7%208.1%2026.2%209%2026.8%209.8%2027.3%2010.6%2028.1%2011.2%2029%2011.3%2030%2011%2030.9%2010.6%2031.8%2010.3%2032.8%209.9%2033.7%2010%2034.5%2010.6%2034.9%2011.5%2034.8%2012.5%2034.8%2013.5%2034.7%2014.5%2034.7%2015.5%2035.2%2016.3%2036%2016.8%2037%2017%2037.9%2017.3%2038.9%2017.5%2039.8%2017.9%2040.4%2018.7%2040.5%2019.7%2040%2020.5%2039.3%2021.3%2038.7%2022%2038.1%2022.8%2037.6%2023.7%2037.7%2024.6%2038.3%2025.4%2038.9%2026.2%2039.6%2027%2040.2%2027.7%2040.5%2028.6%2040.3%2029.6%2039.5%2030.3%2038.6%2030.6%2037.6%2030.8%2036.7%2031%2035.7%2031.3%2035%2031.9%2034.6%2032.8%2034.7%2033.8%2034.8%2034.8%2034.8%2035.8%2034.8%2036.8%2034.3%2037.6%2033.4%2038.1%2032.4%2038%2031.5%2037.6%2030.6%2037.2%2029.7%2036.9%2028.7%2036.6%2027.8%2036.9%2027.1%2037.6%2026.6%2038.5%2026.1%2039.3%2025.5%2040.2%2024.8%2040.8%2023.8%2041%2022.9%2040.6%2022.3%2039.9%2021.8%2039%2021.2%2038.2%2020.7%2037.4%2019.9%2036.8%2019%2036.7%2018%2037%2017.1%2037.4%2016.2%2037.7%2015.2%2038.1%2014.3%2038%2013.5%2037.4%2013.1%2036.5%2013.2%2035.5%2013.2%2034.5%2013.3%2033.5%2013.3%2032.5%2012.8%2031.7%2012%2031.2%2011%2031%2010.1%2030.7%209.1%2030.5%208.2%2030.1%207.6%2029.3%207.5%2028.3%208%2027.5%208.7%2026.7%209.3%2026%209.9%2025.2%2010.4%2024.3%2010.3%2023.4%209.7%2022.6%209.1%2021.8%208.4%2021%207.8%2020.3%207.5%2019.4%207.7%2018.4%208.5%2017.7%209.4%2017.4%2010.4%2017.2%2011.3%2017%2012.3%2016.7%2013%2016.1%2013.4%2015.2%2013.3%2014.2%2013.2%2013.2%2013.2%2012.2%2013.2%2011.2%2013.7%2010.4%2014.6%209.9%2015.6%2010%2016.5%2010.4%2017.4%2010.8%2018.3%2011.1%2019.3%2011.4%2020.2%2011.1%2020.9%2010.4%2021.4%209.5%2021.9%208.7Z'%3e%3c/animate%3e%3canimateTransform%20attributeName='transform'%20attributeType='XML'%20type='rotate'%20dur='5s'%20repeatCount='indefinite'%20calcMode='spline'%20keySplines='0.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8'%20keyTimes='0;%200.14;%200.29;%200.43;%200.57;%200.71;%200.86;%201'%20values='0%2024%2024;%20154%2024%2024;%20309%2024%2024;%20463%2024%2024;%20617%2024%2024;%20771%2024%2024;%20926%2024%2024;%201080%2024%2024'%3e%3c/animateTransform%3e%3c/path%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20viewBox='4%204%2040%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill='%23D0BCFF'%3e%3canimate%20attributeName='d'%20dur='5s'%20repeatCount='indefinite'%20calcMode='spline'%20keySplines='0.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8'%20keyTimes='0;%200.14;%200.14;%200.29;%200.29;%200.43;%200.43;%200.57;%200.57;%200.71;%200.71;%200.86;%200.86;%201'%20values='M20.9%2010.4%2021.4%209.5%2021.9%208.7%2022.5%207.8%2023.2%207.2%2024.2%207%2025.1%207.4%2025.7%208.1%2026.2%209%2026.8%209.8%2027.3%2010.6%2028.1%2011.2%2029%2011.3%2030%2011%2030.9%2010.6%2031.8%2010.3%2032.8%209.9%2033.7%2010%2034.5%2010.6%2034.9%2011.5%2034.8%2012.5%2034.8%2013.5%2034.7%2014.5%2034.7%2015.5%2035.2%2016.3%2036%2016.8%2037%2017.1%2037.9%2017.3%2038.9%2017.5%2039.8%2017.9%2040.4%2018.7%2040.5%2019.7%2040%2020.5%2039.4%2021.3%2038.7%2022%2038.1%2022.8%2037.6%2023.7%2037.7%2024.6%2038.3%2025.5%2038.9%2026.2%2039.6%2027%2040.2%2027.7%2040.5%2028.7%2040.3%2029.6%2039.5%2030.3%2038.6%2030.6%2037.6%2030.8%2036.7%2031%2035.7%2031.3%2035%2031.9%2034.6%2032.8%2034.7%2033.8%2034.8%2034.8%2034.9%2035.8%2034.8%2036.8%2034.3%2037.6%2033.4%2038.1%2032.4%2038%2031.5%2037.6%2030.6%2037.2%2029.7%2036.9%2028.7%2036.6%2027.8%2036.9%2027.1%2037.6%2026.6%2038.5%2026.1%2039.3%2025.5%2040.2%2024.8%2040.8%2023.8%2041%2022.9%2040.6%2022.3%2039.9%2021.8%2039%2021.2%2038.2%2020.7%2037.4%2019.9%2036.8%2019%2036.7%2018%2037%2017.1%2037.4%2016.2%2037.7%2015.2%2038.1%2014.3%2038%2013.5%2037.4%2013.1%2036.5%2013.2%2035.5%2013.2%2034.5%2013.3%2033.5%2013.3%2032.5%2012.8%2031.7%2012%2031.2%2011%2031%2010.1%2030.7%209.1%2030.5%208.2%2030.1%207.6%2029.3%207.5%2028.3%208%2027.5%208.7%2026.7%209.3%2026%209.9%2025.2%2010.4%2024.3%2010.3%2023.4%209.7%2022.5%209.1%2021.8%208.4%2021%207.8%2020.3%207.5%2019.3%207.7%2018.4%208.5%2017.7%209.4%2017.4%2010.4%2017.2%2011.3%2017%2012.3%2016.7%2013%2016.1%2013.4%2015.2%2013.3%2014.2%2013.2%2013.2%2013.1%2012.2%2013.2%2011.2%2013.7%2010.4%2014.6%209.9%2015.6%2010%2016.5%2010.4%2017.4%2010.8%2018.3%2011.1%2019.3%2011.4%2020.2%2011.1Z;%20M20.3%208.6%2021.1%208%2022%207.6%2023%207.3%2023%207.3%2024%207.2%2025%207.3%2025.9%207.5%2026.8%208%2027.6%208.6%2028.4%209.1%2028.4%209.1%2029.3%209.6%2030.3%209.8%2031.3%209.9%2032.3%2010%2033.3%2010.2%2034.2%2010.6%2034.2%2010.6%2035%2011.2%2035.7%2011.9%2036.3%2012.7%2036.7%2013.6%2036.9%2014.6%2037.2%2015.5%2037.2%2015.5%2037.6%2016.5%2038.2%2017.3%2038.9%2018%2039.6%2018.7%2040.2%2019.5%2040.6%2020.4%2040.6%2020.4%2040.9%2021.3%2041%2022.3%2040.9%2023.3%2040.6%2024.3%2040.2%2025.2%2039.8%2026.1%2039.8%2026.1%2039.5%2027%2039.4%2028%2039.5%2029%2039.6%2030%2039.5%2031%2039.3%2032%2039.3%2032%2038.9%2032.9%2038.3%2033.7%2037.6%2034.4%2036.8%2035%2035.9%2035.4%2035%2035.8%2035%2035.8%2034.1%2036.3%2033.4%2037%2032.9%2037.9%2032.3%2038.7%2031.6%2039.4%2030.8%2040%2030.8%2040%2029.9%2040.4%2028.9%2040.7%2027.9%2040.8%2027%2040.7%2026%2040.4%2025%2040.1%2025%2040.1%2024%2040%2023%2040.1%2022.1%2040.4%2021.1%2040.7%2020.1%2040.8%2019.1%2040.7%2019.1%2040.7%2018.2%2040.5%2017.3%2040%2016.4%2039.5%2015.7%2038.8%2015.2%2037.9%2014.6%2037.1%2014.6%2037.1%2013.9%2036.4%2013.1%2035.8%2012.2%2035.4%2011.3%2035%2010.5%2034.4%209.7%2033.8%209.7%2033.8%209.1%2032.9%208.7%2032%208.5%2031.1%208.4%2030.1%208.5%2029.1%208.6%2028.1%208.6%2028.1%208.5%2027.1%208.3%2026.1%207.8%2025.2%207.4%2024.3%207.1%2023.4%207%2022.4%207%2022.4%207.1%2021.4%207.3%2020.4%207.8%2019.5%208.3%2018.7%209.1%2018%209.8%2017.3%209.8%2017.3%2010.4%2016.5%2010.8%2015.6%2011%2014.6%2011.3%2013.7%2011.7%2012.8%2012.2%2011.9%2012.2%2011.9%2012.9%2011.2%2013.8%2010.7%2014.7%2010.2%2015.6%2010%2016.6%209.9%2017.6%209.8%2017.6%209.8%2018.6%209.6%2019.5%209.2Z;%20M18.6%209.6%2019.5%209.2%2020.3%208.6%2021.1%208%2022%207.6%2023%207.3%2024%207.2%2025%207.3%2025.9%207.5%2026.8%208%2027.6%208.6%2028.4%209.1%2029.3%209.6%2030.3%209.8%2031.3%209.9%2032.3%2010%2033.3%2010.2%2034.2%2010.6%2035%2011.2%2035.7%2011.9%2036.3%2012.7%2036.7%2013.6%2036.9%2014.6%2037.2%2015.5%2037.6%2016.4%2038.2%2017.3%2038.9%2018%2039.6%2018.7%2040.2%2019.5%2040.6%2020.4%2040.9%2021.3%2041%2022.3%2040.9%2023.3%2040.6%2024.3%2040.2%2025.2%2039.8%2026.1%2039.5%2027%2039.4%2028%2039.5%2029%2039.6%2030%2039.5%2031%2039.3%2032%2038.9%2032.9%2038.3%2033.7%2037.6%2034.4%2036.8%2035%2035.9%2035.4%2035%2035.8%2034.1%2036.3%2033.4%2037%2032.9%2037.9%2032.3%2038.7%2031.6%2039.4%2030.8%2040%2029.9%2040.4%2028.9%2040.7%2027.9%2040.8%2027%2040.7%2026%2040.4%2025%2040.1%2024%2040%2023%2040.1%2022.1%2040.4%2021.1%2040.7%2020.1%2040.8%2019.1%2040.7%2018.2%2040.5%2017.3%2040%2016.4%2039.5%2015.7%2038.8%2015.2%2037.9%2014.6%2037.1%2013.9%2036.4%2013.1%2035.8%2012.2%2035.4%2011.3%2035%2010.5%2034.4%209.7%2033.8%209.1%2032.9%208.7%2032%208.5%2031.1%208.4%2030.1%208.5%2029.1%208.6%2028.1%208.5%2027.1%208.3%2026.1%207.8%2025.2%207.4%2024.3%207.1%2023.4%207%2022.4%207.1%2021.4%207.3%2020.4%207.8%2019.5%208.3%2018.7%209.1%2018%209.8%2017.3%2010.4%2016.5%2010.8%2015.6%2011%2014.6%2011.3%2013.7%2011.7%2012.8%2012.2%2011.9%2012.9%2011.2%2013.8%2010.7%2014.7%2010.2%2015.6%2010%2016.6%209.9%2017.6%209.8Z;%20M18.6%209.9%2019.5%209.4%2020.3%208.8%2021.1%208.2%2022%207.8%2023%207.6%2023.9%207.5%2024.9%207.6%2025.9%207.8%2026.8%208.2%2027.6%208.7%2028.5%209.3%2029.3%209.9%2030.1%2010.5%2030.9%2011%2031.7%2011.6%2032.5%2012.2%2033.3%2012.8%2033.7%2013.1%2034.1%2013.3%2034.9%2013.9%2035.7%2014.5%2036.6%2015%2037.4%2015.6%2038.2%2016.2%2039%2016.8%2039.7%2017.5%2040.2%2018.3%2040.7%2019.2%2040.9%2020.1%2041%2021.1%2040.9%2022.1%2040.7%2023.1%2040.3%2024%2040%2024.9%2039.7%2025.9%2039.4%2026.8%2039%2027.8%2038.7%2028.7%2038.4%2029.6%2038.1%2030.6%2037.8%2031.5%2037.5%2032.5%2037.2%2033.4%2036.9%2034.4%2036.6%2035.3%2036.2%2036.2%2035.7%2037.1%2035%2037.8%2034.3%2038.4%2033.4%2038.9%2032.5%2039.3%2031.5%2039.5%2030.5%2039.5%2030%2039.5%2029.5%2039.5%2028.5%2039.5%2027.5%2039.5%2026.5%2039.5%2025.5%2039.4%2024.5%2039.4%2023.6%2039.4%2022.6%2039.4%2021.6%2039.5%2020.6%2039.5%2019.6%2039.5%2018.6%2039.5%2017.6%2039.5%2016.6%2039.5%2015.6%2039.3%2014.7%2039%2013.8%2038.5%2013.1%2037.9%2012.4%2037.2%2011.9%2036.3%2011.5%2035.4%2011.2%2034.5%2010.9%2033.5%2010.6%2032.6%2010.3%2031.6%2010%2030.7%209.7%2029.7%209.3%2028.8%209%2027.9%208.7%2026.9%208.4%2026%208%2025%207.7%2024.1%207.4%2023.2%207.1%2022.2%207.1%2021.7%207%2021.2%207.1%2020.2%207.3%2019.3%207.7%2018.4%208.3%2017.5%208.9%2016.8%209.7%2016.2%2010.5%2015.6%2011.4%2015.1%2012.2%2014.5%2013%2014%2013.8%2013.4%2014.6%2012.8%2015.4%2012.3%2016.2%2011.7%2017%2011.1%2017.8%2010.5Z;%20M15.4%2012.3%2016.2%2011.7%2017%2011.1%2017.8%2010.5%2018.6%209.9%2019.5%209.4%2020.3%208.8%2021.1%208.3%2022%207.8%2023%207.6%2023.9%207.5%2024.9%207.6%2025.9%207.8%2026.8%208.2%2027.6%208.7%2028.5%209.3%2029.3%209.9%2030.1%2010.5%2030.9%2011%2031.7%2011.6%2032.5%2012.2%2033.3%2012.8%2034.1%2013.3%2034.9%2013.9%2035.7%2014.5%2036.6%2015%2037.4%2015.6%2038.2%2016.2%2039%2016.8%2039.7%2017.5%2040.2%2018.3%2040.7%2019.2%2040.9%2020.1%2041%2021.1%2040.9%2022.1%2040.7%2023.1%2040.3%2024%2040%2024.9%2039.7%2025.9%2039.4%2026.8%2039%2027.8%2038.7%2028.7%2038.4%2029.6%2038.1%2030.6%2037.8%2031.5%2037.5%2032.5%2037.2%2033.4%2036.9%2034.4%2036.6%2035.3%2036.2%2036.2%2035.7%2037.1%2035%2037.8%2034.3%2038.4%2033.4%2038.9%2032.5%2039.3%2031.5%2039.4%2030.5%2039.5%2029.5%2039.5%2028.5%2039.5%2027.5%2039.5%2026.5%2039.5%2025.5%2039.4%2024.5%2039.4%2023.6%2039.4%2022.6%2039.4%2021.6%2039.5%2020.6%2039.5%2019.6%2039.5%2018.6%2039.5%2017.6%2039.5%2016.6%2039.5%2015.6%2039.3%2014.7%2039%2013.8%2038.5%2013.1%2037.9%2012.4%2037.2%2011.9%2036.3%2011.5%2035.4%2011.2%2034.5%2010.9%2033.5%2010.6%2032.6%2010.3%2031.6%2010%2030.7%209.7%2029.7%209.3%2028.8%209%2027.9%208.7%2026.9%208.4%2026%208%2025%207.7%2024.1%207.4%2023.2%207.1%2022.2%207%2021.2%207.1%2020.2%207.3%2019.3%207.7%2018.4%208.3%2017.5%208.9%2016.8%209.7%2016.2%2010.5%2015.6%2011.4%2015.1%2012.2%2014.5%2013%2014%2013.8%2013.4%2014.6%2012.8Z;%20M17%2012.8%2017.7%2012.1%2018.5%2011.5%2019.3%2010.9%2020.1%2010.5%2020.2%2010.4%2021.1%2010%2022%209.7%2023%209.4%2024%209.2%2025%209%2026%209%2027%209%2027.6%209.1%2028%209.1%2028.9%209.3%2029.9%209.6%2030.9%209.9%2031.8%2010.3%2032.6%2010.8%2033.5%2011.3%2034.3%2011.9%2034.6%2012.2%2035%2012.6%2035.7%2013.3%2036.4%2014.1%2036.9%2014.9%2037.4%2015.8%2037.9%2016.6%2038.3%2017.6%2038.6%2018.5%2038.6%2018.7%2038.8%2019.5%2038.9%2020.5%2039%2021.5%2039%2022.5%2038.9%2023.5%2038.7%2024.5%2038.5%2025.4%2038.2%2026.3%2038.2%2026.4%2037.8%2027.3%2037.4%2028.2%2036.8%2029.1%2036.2%2029.9%2035.6%2030.6%2034.9%2031.3%2034.2%2032%2033.8%2032.5%2033.5%2032.8%2032.8%2033.5%2032.1%2034.2%2031.4%2034.9%2030.7%2035.6%2029.9%2036.2%2029.1%2036.8%2028.2%2037.3%2027.9%2037.5%2027.4%2037.8%2026.4%2038.2%2025.5%2038.5%2024.5%2038.7%2023.5%2038.9%2022.5%2039%2021.5%2039%2020.5%2038.9%2020.4%2038.9%2019.5%2038.8%2018.6%2038.6%2017.6%2038.3%2016.7%2037.9%2015.8%2037.5%2014.9%2037%2014.1%2036.4%2013.4%2035.8%2013.3%2035.8%2012.6%2035.1%2012%2034.3%2011.3%2033.5%2010.8%2032.7%2010.3%2031.8%209.9%2030.9%209.6%2030%209.4%2029.3%209.3%2029%209.1%2028%209%2027%209%2026%209%2025%209.2%2024%209.4%2023%209.6%2022.1%209.8%2021.7%2010%2021.1%2010.4%2020.2%2010.9%2019.4%2011.4%2018.5%2012.1%2017.8%2012.7%2017%2013.4%2016.3%2014.2%2015.6%2014.2%2015.5%2014.9%2014.9%2015.6%2014.2%2016.3%2013.5Z;%20M33.5%2011.3%2034.3%2011.9%2035%2012.6%2035.3%2012.8%2035.7%2013.3%2036.4%2014.1%2036.9%2014.9%2037.4%2015.8%2037.9%2016.6%2038.3%2017.6%2038.3%2017.7%2038.6%2018.5%2038.8%2019.5%2038.9%2020.5%2039%2021.5%2039%2022.5%2038.9%2023.5%2038.9%2023.5%2038.7%2024.5%2038.5%2025.4%2038.2%2026.4%2037.8%2027.3%2037.4%2028.2%2036.9%2028.9%2036.8%2029.1%2036.2%2029.9%2035.6%2030.6%2034.9%2031.3%2034.2%2032%2033.5%2032.8%2033.1%2033.2%2032.8%2033.5%2032.1%2034.2%2031.4%2034.9%2030.7%2035.6%2029.9%2036.2%2029.1%2036.8%2028.7%2037%2028.2%2037.3%2027.4%2037.8%2026.4%2038.2%2025.5%2038.5%2024.5%2038.7%2023.5%2038.9%2023.3%2038.9%2022.5%2039%2021.5%2039%2020.5%2038.9%2019.5%2038.8%2018.6%2038.6%2017.6%2038.3%2017.6%2038.3%2016.7%2037.9%2015.8%2037.5%2014.9%2037%2014.1%2036.4%2013.3%2035.8%2012.7%2035.2%2012.6%2035.1%2012%2034.3%2011.3%2033.5%2010.8%2032.7%2010.3%2031.8%209.9%2030.9%209.7%2030.3%209.6%2029.9%209.3%2029%209.1%2028%209%2027%209%2026%209%2025%209.1%2024.5%209.2%2024%209.4%2023%209.6%2022.1%2010%2021.1%2010.4%2020.2%2010.9%2019.4%2011.1%2019.1%2011.5%2018.5%2012.1%2017.7%2012.7%2017%2013.5%2016.3%2014.2%2015.6%2014.9%2014.9%2014.9%2014.8%2015.6%2014.2%2016.3%2013.5%2017%2012.8%2017.7%2012.1%2018.5%2011.5%2019.3%2011%2019.3%2010.9%2020.2%2010.4%2021.1%2010%2022%209.7%2023%209.4%2024%209.2%2024.7%209.1%2025%209%2026%209%2027%209%2028%209.1%2028.9%209.3%2029.9%209.6%2030.4%209.7%2030.9%209.9%2031.8%2010.3%2032.6%2010.8Z;%20M33.2%2011.1%2034.2%2011.2%2035.1%2011.4%2036%2011.9%2036.6%2012.7%2036.8%2013.7%2036.9%2014.7%2036.9%2015.7%2037%2016.7%2037.1%2017.7%2037.3%2018.6%2037.9%2019.4%2038.5%2020.2%2039.2%2020.9%2039.8%2021.7%2040.5%2022.4%2040.9%2023.3%2041%2024.3%2040.7%2025.2%2040.1%2026%2039.4%2026.8%2038.8%2027.5%2038.1%2028.3%2037.5%2029.1%2037.1%2030%2037%2031%2037%2031.9%2036.9%2032.9%2036.8%2033.9%2036.7%2034.9%2036.2%2035.8%2035.5%2036.4%2034.5%2036.8%2033.6%2036.8%2032.6%2036.9%2031.6%2037%2030.6%2037.1%2029.6%2037.2%2028.8%2037.7%2028%2038.4%2027.3%2039%2026.5%2039.7%2025.8%2040.3%2024.9%2040.8%2023.9%2041%2023%2040.8%2022.1%2040.2%2021.4%2039.6%2020.6%2038.9%2019.9%2038.3%2019.1%2037.6%2018.3%2037.2%2017.3%2037%2016.3%2037%2015.3%2036.9%2014.3%2036.8%2013.3%2036.7%2012.4%2036.4%2011.7%2035.7%2011.3%2034.8%2011.2%2033.8%2011.1%2032.8%2011%2031.8%2011%2030.8%2010.9%2029.9%2010.4%2029%209.8%2028.2%209.1%2027.5%208.5%2026.7%207.8%2026%207.3%2025.1%207%2024.2%207.1%2023.2%207.6%2022.3%208.2%2021.6%208.9%2020.8%209.5%2020.1%2010.2%2019.3%2010.7%2018.5%2010.9%2017.5%2011%2016.6%2011.1%2015.6%2011.1%2014.6%2011.2%2013.6%2011.5%2012.6%2012.1%2011.9%2013%2011.4%2013.9%2011.2%2014.9%2011.1%2015.9%2011%2016.9%2011%2017.9%2010.9%2018.8%2010.6%2019.6%2010%2020.4%209.3%2021.1%208.6%2021.9%208%2022.6%207.4%2023.6%207%2024.6%207.1%2025.5%207.5%2026.2%208.1%2027%208.7%2027.7%209.4%2028.5%2010%2029.3%2010.6%2030.2%2010.9%2031.2%2011%2032.2%2011.1Z;%20M27.7%209.4%2028.5%2010%2029.3%2010.6%2030.2%2010.9%2031.2%2011%2032.2%2011.1%2033.2%2011.1%2034.2%2011.2%2035.1%2011.4%2036%2011.9%2036.6%2012.7%2036.8%2013.7%2036.9%2014.7%2036.9%2015.7%2037%2016.7%2037.1%2017.7%2037.3%2018.6%2037.9%2019.4%2038.5%2020.2%2039.2%2020.9%2039.8%2021.7%2040.5%2022.4%2040.9%2023.3%2041%2024.3%2040.7%2025.2%2040.1%2026%2039.4%2026.8%2038.8%2027.5%2038.1%2028.3%2037.5%2029.1%2037.1%2030%2037%2031%2037%2031.9%2036.9%2032.9%2036.8%2033.9%2036.7%2034.9%2036.2%2035.8%2035.5%2036.4%2034.5%2036.8%2033.6%2036.9%2032.6%2036.9%2031.6%2037%2030.6%2037.1%2029.6%2037.2%2028.8%2037.7%2028%2038.4%2027.3%2039%2026.5%2039.7%2025.8%2040.3%2024.9%2040.8%2023.9%2041%2023%2040.8%2022.1%2040.2%2021.4%2039.6%2020.6%2038.9%2019.9%2038.3%2019.1%2037.6%2018.3%2037.2%2017.3%2037%2016.3%2037%2015.3%2036.9%2014.3%2036.8%2013.3%2036.7%2012.4%2036.4%2011.7%2035.7%2011.3%2034.8%2011.2%2033.8%2011.1%2032.8%2011%2031.8%2011%2030.8%2010.9%2029.9%2010.4%2029%209.8%2028.2%209.1%2027.5%208.5%2026.7%207.8%2026%207.3%2025.1%207%2024.2%207.1%2023.2%207.6%2022.3%208.2%2021.6%208.9%2020.8%209.5%2020.1%2010.2%2019.3%2010.7%2018.5%2010.9%2017.5%2011%2016.5%2011.1%2015.6%2011.1%2014.6%2011.2%2013.6%2011.5%2012.6%2012.1%2011.9%2013%2011.4%2013.9%2011.2%2014.9%2011.1%2015.9%2011%2016.9%2011%2017.9%2010.9%2018.8%2010.6%2019.6%2010%2020.4%209.3%2021.1%208.6%2021.9%208%2022.6%207.4%2023.6%207%2024.6%207.1%2025.5%207.5%2026.2%208.1%2027%208.7Z;%20M27.9%2010.6%2028.8%2010.3%2029.8%2010.1%2030.8%2010%2031.8%2010.1%2032.7%2010.3%2033.7%2010.6%2034.6%2011.1%2034.8%2011.3%2035.4%2011.7%2036.1%2012.4%2036.7%2013.1%2037.2%2014%2037.6%2014.9%2037.9%2015.9%2038%2016.9%2038%2017.9%2037.8%2018.8%2037.5%2019.8%2037.1%2020.7%2036.8%2021.6%2036.5%2022.6%2036.4%2023.6%2036.4%2024.4%2036.4%2024.6%2036.5%2025.5%2036.8%2026.5%2037.2%2027.4%2037.6%2028.3%2037.8%2029.3%2038%2030.3%2038%2031.3%2037.8%2032.3%2037.6%2033.2%2037.2%2034.1%2036.6%2035%2036%2035.7%2035.3%2036.4%2034.4%2037%2034.1%2037.2%2033.6%2037.4%2032.6%2037.8%2031.6%2037.9%2030.6%2038%2029.7%2037.9%2028.7%2037.7%2027.8%2037.3%2026.8%2036.9%2025.9%2036.6%2024.9%2036.4%2023.9%2036.4%2022.9%2036.4%2022%2036.6%2021%2037%2020.1%2037.4%2020.1%2037.4%2019.2%2037.7%2018.2%2037.9%2017.2%2038%2016.2%2037.9%2015.3%2037.7%2014.3%2037.4%2013.4%2036.9%2012.6%2036.3%2011.9%2035.6%2011.3%2034.9%2010.8%2034%2010.4%2033.1%2010.1%2032.1%2010%2031.1%2010%2030.6%2010%2030.1%2010.2%2029.2%2010.5%2028.2%2010.9%2027.3%2011.2%2026.4%2011.5%2025.4%2011.6%2024.4%2011.6%2023.4%2011.5%2022.5%2011.2%2021.5%2010.8%2020.6%2010.4%2019.7%2010.2%2018.7%2010%2017.7%2010%2016.7%2010%2016.6%2010.2%2015.7%2010.4%2014.8%2010.8%2013.9%2011.4%2013%2012%2012.3%2012.7%2011.6%2013.6%2011%2014.4%2010.6%2015.4%2010.2%2016.4%2010.1%2017.4%2010%2018.3%2010.1%2019.3%2010.3%2020.2%2010.7%2020.9%2011%2021.2%2011.1%2022.1%2011.4%2023.1%2011.6%2024.1%2011.6%2025.1%2011.6%2026%2011.4%2027%2011Z;%20M36%2035.7%2035.3%2036.4%2034.4%2037%2033.6%2037.4%2032.6%2037.8%2031.6%2037.9%2030.6%2038%2029.7%2037.9%2028.7%2037.7%2027.8%2037.3%2026.8%2036.9%2025.9%2036.6%2024.9%2036.4%2023.9%2036.4%2022.9%2036.4%2022%2036.6%2021%2037%2020.1%2037.4%2019.2%2037.7%2018.2%2037.9%2017.2%2038%2016.2%2037.9%2015.3%2037.7%2014.3%2037.4%2013.4%2036.9%2012.6%2036.3%2011.9%2035.6%2011.3%2034.9%2010.8%2034%2010.4%2033.1%2010.1%2032.1%2010%2031.1%2010%2030.2%2010.2%2029.2%2010.5%2028.2%2010.9%2027.3%2011.2%2026.4%2011.5%2025.4%2011.6%2024.4%2011.6%2023.4%2011.5%2022.5%2011.2%2021.5%2010.8%2020.6%2010.4%2019.7%2010.2%2018.7%2010%2017.7%2010%2016.7%2010.2%2015.7%2010.4%2014.8%2010.8%2013.9%2011.4%2013%2012%2012.3%2012.7%2011.6%2013.6%2011%2014.4%2010.6%2015.4%2010.2%2016.4%2010.1%2017.4%2010%2018.3%2010.1%2019.3%2010.3%2020.2%2010.7%2021.2%2011.1%2022.1%2011.4%2023.1%2011.6%2024.1%2011.6%2025.1%2011.6%2026%2011.4%2027%2011%2027.9%2010.6%2028.8%2010.3%2029.8%2010.1%2030.8%2010%2031.8%2010.1%2032.7%2010.3%2033.7%2010.6%2034.6%2011.1%2035.4%2011.7%2036.1%2012.4%2036.7%2013.1%2037.2%2014%2037.6%2014.9%2037.9%2015.9%2038%2016.9%2038%2017.8%2037.8%2018.8%2037.5%2019.8%2037.1%2020.7%2036.8%2021.6%2036.5%2022.6%2036.4%2023.6%2036.4%2024.6%2036.5%2025.5%2036.8%2026.5%2037.2%2027.4%2037.6%2028.3%2037.8%2029.3%2038%2030.3%2038%2031.3%2037.8%2032.3%2037.6%2033.2%2037.2%2034.1%2036.6%2035Z;%20M32.1%2032.1%2031.4%2032.8%2030.7%2033.5%2029.9%2034.1%2029.1%2034.7%2028.3%2035.3%2027.6%2035.8%2027.5%2035.8%2026.6%2036.4%2025.8%2036.8%2024.9%2037.3%2024%2037.7%2023.1%2038%2022.1%2038.3%2021.2%2038.6%2020.2%2038.8%2019.2%2038.9%2018.2%2039%2017.2%2039%2016.6%2038.9%2016.3%2038.9%2015.3%2038.7%2014.3%2038.4%2013.4%2038%2012.5%2037.5%2011.7%2036.9%2011.1%2036.3%2010.5%2035.5%2010%2034.6%209.6%2033.7%209.3%2032.7%209.1%2031.7%209.1%2031.4%209%2030.8%209%2029.8%209.1%2028.8%209.2%2027.8%209.4%2026.8%209.7%2025.9%2010%2024.9%2010.3%2024%2010.7%2023.1%2011.2%2022.2%2011.6%2021.4%2012.2%2020.5%2012.2%2020.4%2012.7%2019.7%2013.3%2018.9%2013.9%2018.1%2014.5%2017.3%2015.2%2016.6%2015.9%2015.9%2016.6%2015.2%2017.3%2014.5%2018.1%2013.9%2018.9%2013.3%2019.7%2012.7%2020.4%2012.2%2020.5%2012.2%2021.4%2011.6%2022.2%2011.2%2023.1%2010.7%2024%2010.3%2024.9%2010%2025.9%209.7%2026.8%209.4%2027.8%209.2%2028.8%209.1%2029.8%209%2030.8%209%2031.4%209.1%2031.7%209.1%2032.7%209.3%2033.7%209.6%2034.6%2010%2035.5%2010.5%2036.3%2011.1%2036.9%2011.7%2037.5%2012.5%2038%2013.4%2038.4%2014.3%2038.7%2015.3%2038.9%2016.3%2038.9%2016.6%2039%2017.2%2039%2018.2%2038.9%2019.2%2038.8%2020.2%2038.6%2021.2%2038.3%2022.1%2038%2023.1%2037.7%2024%2037.3%2024.9%2036.8%2025.8%2036.4%2026.6%2035.8%2027.5%2035.8%2027.6%2035.3%2028.3%2034.7%2029.1%2034.1%2029.9%2033.5%2030.7%2032.8%2031.4Z;%20M24.3%2010.2%2024.9%2010%2025.9%209.7%2026.8%209.4%2027.1%209.4%2027.8%209.2%2028.8%209.1%2029.8%209%2029.9%209%2030.8%209%2031.7%209.1%2032.7%209.3%2032.8%209.3%2033.7%209.6%2034.6%2010%2035.5%2010.5%2035.5%2010.5%2036.3%2011.1%2036.9%2011.7%2037.5%2012.5%2037.5%2012.5%2038%2013.4%2038.4%2014.3%2038.7%2015.2%2038.7%2015.3%2038.9%2016.3%2039%2017.2%2039%2018.1%2039%2018.2%2038.9%2019.2%2038.8%2020.2%2038.6%2020.9%2038.6%2021.2%2038.3%2022.1%2038%2023.1%2037.8%2023.7%2037.7%2024%2037.3%2024.9%2036.8%2025.8%2036.5%2026.4%2036.4%2026.6%2035.8%2027.5%2035.3%2028.3%2035%2028.8%2034.7%2029.1%2034.1%2029.9%2033.5%2030.7%2033.1%2031.1%2032.8%2031.4%2032.1%2032.1%2031.4%2032.8%2031.1%2033.1%2030.7%2033.5%2029.9%2034.1%2029.1%2034.7%2028.8%2035%2028.3%2035.3%2027.5%2035.8%2026.6%2036.4%2026.4%2036.5%2025.8%2036.8%2024.9%2037.3%2024%2037.7%2023.7%2037.8%2023.1%2038%2022.1%2038.3%2021.2%2038.6%2020.9%2038.6%2020.2%2038.8%2019.2%2038.9%2018.2%2039%2018.1%2039%2017.2%2039%2016.3%2038.9%2015.3%2038.7%2015.2%2038.7%2014.3%2038.4%2013.4%2038%2012.5%2037.5%2012.5%2037.5%2011.7%2036.9%2011.1%2036.3%2010.5%2035.5%2010.5%2035.5%2010%2034.6%209.6%2033.7%209.3%2032.8%209.3%2032.7%209.1%2031.7%209%2030.8%209%2029.9%209%2029.8%209.1%2028.8%209.2%2027.8%209.4%2027.1%209.4%2026.8%209.7%2025.9%2010%2024.9%2010.2%2024.3%2010.3%2024%2010.7%2023.1%2011.2%2022.2%2011.5%2021.6%2011.6%2021.4%2012.2%2020.5%2012.7%2019.7%2013%2019.2%2013.3%2018.9%2013.9%2018.1%2014.5%2017.3%2014.9%2016.9%2015.2%2016.6%2015.9%2015.9%2016.6%2015.2%2016.9%2014.9%2017.3%2014.5%2018.1%2013.9%2018.9%2013.3%2019.2%2013%2019.7%2012.7%2020.5%2012.2%2021.4%2011.6%2021.6%2011.5%2022.2%2011.2%2023.1%2010.7%2024%2010.3Z;%20M22.5%207.8%2023.2%207.2%2024.2%207%2025.1%207.4%2025.7%208.1%2026.2%209%2026.8%209.8%2027.3%2010.6%2028.1%2011.2%2029%2011.3%2030%2011%2030.9%2010.6%2031.8%2010.3%2032.8%209.9%2033.7%2010%2034.5%2010.6%2034.9%2011.5%2034.8%2012.5%2034.8%2013.5%2034.7%2014.5%2034.7%2015.5%2035.2%2016.3%2036%2016.8%2037%2017%2037.9%2017.3%2038.9%2017.5%2039.8%2017.9%2040.4%2018.7%2040.5%2019.7%2040%2020.5%2039.3%2021.3%2038.7%2022%2038.1%2022.8%2037.6%2023.7%2037.7%2024.6%2038.3%2025.4%2038.9%2026.2%2039.6%2027%2040.2%2027.7%2040.5%2028.6%2040.3%2029.6%2039.5%2030.3%2038.6%2030.6%2037.6%2030.8%2036.7%2031%2035.7%2031.3%2035%2031.9%2034.6%2032.8%2034.7%2033.8%2034.8%2034.8%2034.8%2035.8%2034.8%2036.8%2034.3%2037.6%2033.4%2038.1%2032.4%2038%2031.5%2037.6%2030.6%2037.2%2029.7%2036.9%2028.7%2036.6%2027.8%2036.9%2027.1%2037.6%2026.6%2038.5%2026.1%2039.3%2025.5%2040.2%2024.8%2040.8%2023.8%2041%2022.9%2040.6%2022.3%2039.9%2021.8%2039%2021.2%2038.2%2020.7%2037.4%2019.9%2036.8%2019%2036.7%2018%2037%2017.1%2037.4%2016.2%2037.7%2015.2%2038.1%2014.3%2038%2013.5%2037.4%2013.1%2036.5%2013.2%2035.5%2013.2%2034.5%2013.3%2033.5%2013.3%2032.5%2012.8%2031.7%2012%2031.2%2011%2031%2010.1%2030.7%209.1%2030.5%208.2%2030.1%207.6%2029.3%207.5%2028.3%208%2027.5%208.7%2026.7%209.3%2026%209.9%2025.2%2010.4%2024.3%2010.3%2023.4%209.7%2022.6%209.1%2021.8%208.4%2021%207.8%2020.3%207.5%2019.4%207.7%2018.4%208.5%2017.7%209.4%2017.4%2010.4%2017.2%2011.3%2017%2012.3%2016.7%2013%2016.1%2013.4%2015.2%2013.3%2014.2%2013.2%2013.2%2013.2%2012.2%2013.2%2011.2%2013.7%2010.4%2014.6%209.9%2015.6%2010%2016.5%2010.4%2017.4%2010.8%2018.3%2011.1%2019.3%2011.4%2020.2%2011.1%2020.9%2010.4%2021.4%209.5%2021.9%208.7Z'%3e%3c/animate%3e%3canimateTransform%20attributeName='transform'%20attributeType='XML'%20type='rotate'%20dur='5s'%20repeatCount='indefinite'%20calcMode='spline'%20keySplines='0.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8;%200.5%200.2%200%200.8'%20keyTimes='0;%200.14;%200.29;%200.43;%200.57;%200.71;%200.86;%201'%20values='0%2024%2024;%20154%2024%2024;%20309%2024%2024;%20463%2024%2024;%20617%2024%2024;%20771%2024%2024;%20926%2024%2024;%201080%2024%2024'%3e%3c/animateTransform%3e%3c/path%3e%3c/svg%3e")}.shape.oval{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='300'%20height='300'%20viewBox='0%200%20300%20300'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M231.309%20231.31C161.705%20300.91%2068.8765%20320.94%2023.9707%20276.03C-20.9352%20231.12%20-0.913322%20138.29%2068.6908%2068.6899C138.295%20-0.91011%20231.123%20-20.9401%20276.029%2023.9699C320.935%2068.8799%20300.913%20161.71%20231.309%20231.31Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='300'%20height='300'%20viewBox='0%200%20300%20300'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M231.309%20231.31C161.705%20300.91%2068.8765%20320.94%2023.9707%20276.03C-20.9352%20231.12%20-0.913322%20138.29%2068.6908%2068.6899C138.295%20-0.91011%20231.123%20-20.9401%20276.029%2023.9699C320.935%2068.8799%20300.913%20161.71%20231.309%20231.31Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.pentagon{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M109.63%2024.3699C125.24%2012.2899%20133.04%206.24994%20141.38%203.24994C153.44%20-1.08006%20166.56%20-1.08006%20178.62%203.24994C186.96%206.24994%20194.76%2012.2899%20210.37%2024.3699L244.51%2050.8L278.63%2075.56C294.82%2087.31%20302.92%2093.1899%20308.33%20100.57C316.15%20111.26%20320.27%20124.39%20319.99%20137.82C319.79%20147.11%20316.58%20156.82%20310.14%20176.23L296.74%20216.66L284.38%20258.08C278.57%20277.52%20275.67%20287.24%20270.6%20294.8C263.26%20305.74%20252.59%20313.78%20240.32%20317.63C231.84%20320.3%20222.06%20320.14%20202.5%20319.83L160%20319.16L117.5%20319.83C97.94%20320.14%2088.16%20320.3%2079.68%20317.63C67.41%20313.78%2056.74%20305.74%2049.4%20294.8C44.33%20287.24%2041.43%20277.52%2035.62%20258.08L23.26%20216.66L9.85994%20176.23C3.41994%20156.82%200.209968%20147.11%200.0099682%20137.82C-0.270032%20124.39%203.85%20111.26%2011.67%20100.57C17.08%2093.1899%2025.18%2087.31%2041.37%2075.56L75.49%2050.8L109.63%2024.3699Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M109.63%2024.3699C125.24%2012.2899%20133.04%206.24994%20141.38%203.24994C153.44%20-1.08006%20166.56%20-1.08006%20178.62%203.24994C186.96%206.24994%20194.76%2012.2899%20210.37%2024.3699L244.51%2050.8L278.63%2075.56C294.82%2087.31%20302.92%2093.1899%20308.33%20100.57C316.15%20111.26%20320.27%20124.39%20319.99%20137.82C319.79%20147.11%20316.58%20156.82%20310.14%20176.23L296.74%20216.66L284.38%20258.08C278.57%20277.52%20275.67%20287.24%20270.6%20294.8C263.26%20305.74%20252.59%20313.78%20240.32%20317.63C231.84%20320.3%20222.06%20320.14%20202.5%20319.83L160%20319.16L117.5%20319.83C97.94%20320.14%2088.16%20320.3%2079.68%20317.63C67.41%20313.78%2056.74%20305.74%2049.4%20294.8C44.33%20287.24%2041.43%20277.52%2035.62%20258.08L23.26%20216.66L9.85994%20176.23C3.41994%20156.82%200.209968%20147.11%200.0099682%20137.82C-0.270032%20124.39%203.85%20111.26%2011.67%20100.57C17.08%2093.1899%2025.18%2087.31%2041.37%2075.56L75.49%2050.8L109.63%2024.3699Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.pill{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='300'%20height='300'%20viewBox='0%200%20300%20300'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M79.86%2037.77C130.22%20-12.59%20211.87%20-12.59%20262.23%2037.77C312.59%2088.13%20312.59%20169.78%20262.23%20220.14L220.14%20262.23C169.78%20312.59%2088.13%20312.59%2037.77%20262.23C-12.59%20211.87%20-12.59%20130.22%2037.77%2079.86L79.86%2037.77Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='300'%20height='300'%20viewBox='0%200%20300%20300'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M79.86%2037.77C130.22%20-12.59%20211.87%20-12.59%20262.23%2037.77C312.59%2088.13%20312.59%20169.78%20262.23%20220.14L220.14%20262.23C169.78%20312.59%2088.13%20312.59%2037.77%20262.23C-12.59%20211.87%20-12.59%20130.22%2037.77%2079.86L79.86%2037.77Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.pixel-circle{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M225.19%200H94.81V20.74H50.37V47.41H23.704V94.8101H0V225.19H23.704V272.59H50.37V299.26H94.81V320H225.19V299.26H269.63V272.59H296.3V225.19H320V94.8101H296.3V47.41H269.63V20.74H225.19V0Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M225.19%200H94.81V20.74H50.37V47.41H23.704V94.8101H0V225.19H23.704V272.59H50.37V299.26H94.81V320H225.19V299.26H269.63V272.59H296.3V225.19H320V94.8101H296.3V47.41H269.63V20.74H225.19V0Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.pixel-triangle{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='248'%20height='320'%20viewBox='0%200%20248%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M55.64%200H0V320H55.64V292.174H98.5601V265.739H143.08V235.13H179.64V210.086H216.21V179.478H248V140.522H216.21V109.912H179.64V84.869H143.08V54.261H98.5601V27.826H55.64V0Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='248'%20height='320'%20viewBox='0%200%20248%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M55.64%200H0V320H55.64V292.174H98.5601V265.739H143.08V235.13H179.64V210.086H216.21V179.478H248V140.522H216.21V109.912H179.64V84.869H143.08V54.261H98.5601V27.826H55.64V0Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.puffy{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='280'%20viewBox='0%200%20320%20280'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M319.98%20138.106C319.72%20116.574%20303.73%2099.333%20284.24%2099.621C283.17%2099.621%20282.11%2099.711%20281.06%2099.838C281.88%2099.098%20282.68%2098.341%20283.44%2097.511C297.4%2082.489%20297.69%2057.782%20284.11%2042.344C283.31%2041.443%20282.52%2040.541%20281.7%2039.675C267.74%2024.653%20245.42%2024.977%20231.82%2040.415C231.07%2041.262%20230.39%2042.146%20229.72%2043.048C229.83%2041.894%20229.9%2040.721%20229.92%2039.531C230.19%2017.998%20214.61%200.307%20195.14%200C194.57%200%20194%200%20193.43%200H192.27C177.84%200%20165.46%209.59399%20160%2023.318C154.54%209.59399%20142.15%200%20127.73%200H126.57C126%200%20125.43%200%20124.86%200C105.39%200.289%2089.8099%2017.98%2090.0699%2039.531C90.0699%2040.721%2090.15%2041.894%2090.26%2043.048C89.6%2042.146%2088.91%2041.262%2088.16%2040.415C74.58%2024.977%2052.24%2024.653%2038.28%2039.675C37.47%2040.559%2036.65%2041.443%2035.87%2042.344C22.29%2057.782%2022.58%2082.471%2036.54%2097.511C37.31%2098.341%2038.1%2099.098%2038.92%2099.838C37.88%2099.711%2036.82%2099.639%2035.74%2099.621C16.27%2099.333%200.28%20116.574%200%20138.106C0%20138.738%200%20139.369%200%20140C0%20140.631%200%20141.262%200%20141.894C0.26%20163.427%2016.26%20180.667%2035.74%20180.379C36.82%20180.379%2037.88%20180.289%2038.92%20180.162C38.1%20180.902%2037.31%20181.659%2036.54%20182.489C22.58%20197.511%2022.29%20222.218%2035.87%20237.656C36.67%20238.557%2037.47%20239.459%2038.28%20240.325C52.24%20255.347%2074.56%20255.023%2088.16%20239.585C88.91%20238.738%2089.6%20237.854%2090.26%20236.952C90.15%20238.106%2090.0799%20239.279%2090.0699%20240.469C89.8099%20262.002%20105.38%20279.711%20124.86%20280C125.43%20280%20126%20280%20126.57%20280H127.73C142.16%20280%20154.54%20270.406%20160%20256.682C165.46%20270.406%20177.85%20280%20192.27%20280H193.43C194%20280%20194.57%20280%20195.14%20280C214.61%20279.711%20230.19%20262.02%20229.93%20240.469C229.93%20239.279%20229.85%20238.106%20229.74%20236.952C230.4%20237.854%20231.09%20238.738%20231.84%20239.585C245.42%20255.023%20267.76%20255.347%20281.72%20240.325C282.53%20239.441%20283.35%20238.557%20284.13%20237.656C297.71%20222.218%20297.42%20197.529%20283.46%20182.489C282.69%20181.659%20281.9%20180.902%20281.08%20180.162C282.12%20180.289%20283.18%20180.361%20284.26%20180.379C303.73%20180.667%20319.74%20163.445%20320%20141.894C320%20141.262%20320%20140.631%20320%20140C320%20139.369%20320%20138.738%20320%20138.106H319.98Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='280'%20viewBox='0%200%20320%20280'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M319.98%20138.106C319.72%20116.574%20303.73%2099.333%20284.24%2099.621C283.17%2099.621%20282.11%2099.711%20281.06%2099.838C281.88%2099.098%20282.68%2098.341%20283.44%2097.511C297.4%2082.489%20297.69%2057.782%20284.11%2042.344C283.31%2041.443%20282.52%2040.541%20281.7%2039.675C267.74%2024.653%20245.42%2024.977%20231.82%2040.415C231.07%2041.262%20230.39%2042.146%20229.72%2043.048C229.83%2041.894%20229.9%2040.721%20229.92%2039.531C230.19%2017.998%20214.61%200.307%20195.14%200C194.57%200%20194%200%20193.43%200H192.27C177.84%200%20165.46%209.59399%20160%2023.318C154.54%209.59399%20142.15%200%20127.73%200H126.57C126%200%20125.43%200%20124.86%200C105.39%200.289%2089.8099%2017.98%2090.0699%2039.531C90.0699%2040.721%2090.15%2041.894%2090.26%2043.048C89.6%2042.146%2088.91%2041.262%2088.16%2040.415C74.58%2024.977%2052.24%2024.653%2038.28%2039.675C37.47%2040.559%2036.65%2041.443%2035.87%2042.344C22.29%2057.782%2022.58%2082.471%2036.54%2097.511C37.31%2098.341%2038.1%2099.098%2038.92%2099.838C37.88%2099.711%2036.82%2099.639%2035.74%2099.621C16.27%2099.333%200.28%20116.574%200%20138.106C0%20138.738%200%20139.369%200%20140C0%20140.631%200%20141.262%200%20141.894C0.26%20163.427%2016.26%20180.667%2035.74%20180.379C36.82%20180.379%2037.88%20180.289%2038.92%20180.162C38.1%20180.902%2037.31%20181.659%2036.54%20182.489C22.58%20197.511%2022.29%20222.218%2035.87%20237.656C36.67%20238.557%2037.47%20239.459%2038.28%20240.325C52.24%20255.347%2074.56%20255.023%2088.16%20239.585C88.91%20238.738%2089.6%20237.854%2090.26%20236.952C90.15%20238.106%2090.0799%20239.279%2090.0699%20240.469C89.8099%20262.002%20105.38%20279.711%20124.86%20280C125.43%20280%20126%20280%20126.57%20280H127.73C142.16%20280%20154.54%20270.406%20160%20256.682C165.46%20270.406%20177.85%20280%20192.27%20280H193.43C194%20280%20194.57%20280%20195.14%20280C214.61%20279.711%20230.19%20262.02%20229.93%20240.469C229.93%20239.279%20229.85%20238.106%20229.74%20236.952C230.4%20237.854%20231.09%20238.738%20231.84%20239.585C245.42%20255.023%20267.76%20255.347%20281.72%20240.325C282.53%20239.441%20283.35%20238.557%20284.13%20237.656C297.71%20222.218%20297.42%20197.529%20283.46%20182.489C282.69%20181.659%20281.9%20180.902%20281.08%20180.162C282.12%20180.289%20283.18%20180.361%20284.26%20180.379C303.73%20180.667%20319.74%20163.445%20320%20141.894C320%20141.262%20320%20140.631%20320%20140C320%20139.369%20320%20138.738%20320%20138.106H319.98Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.puffy-diamond{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M249.4%20249.754C261.48%20237.666%20265.57%20220.608%20261.66%20205.157C277.12%20209.086%20294.2%20205.001%20306.3%20192.902C324.57%20174.636%20324.57%20145.02%20306.3%20126.754C294.27%20114.727%20277.32%20110.619%20261.94%20114.43C265.37%2099.286%20261.19%2082.766%20249.4%2070.975C237.28%2058.86%20220.17%2054.78%20204.7%2058.736C208.8%2043.171%20204.75%2025.903%20192.54%2013.7C174.28%20-4.56699%20144.66%20-4.56699%20126.4%2013.7C114.27%2025.83%20110.19%2042.965%20114.17%2058.458C99%2054.986%2082.43%2059.158%2070.62%2070.975C58.83%2082.767%2054.6499%2099.289%2058.0799%20114.434C42.6899%20110.616%2025.7299%20114.723%2013.6999%20126.754C-4.57006%20145.02%20-4.57006%20174.636%2013.6999%20192.902C25.7999%20205.005%2042.89%20209.089%2058.35%20205.153C54.44%20220.605%2058.53%20237.665%2070.62%20249.754C82.38%20261.521%2098.86%20265.708%20113.98%20262.314C110.33%20277.602%20114.47%20294.371%20126.4%20306.3C144.66%20324.567%20174.28%20324.567%20192.54%20306.3C204.54%20294.301%20208.66%20277.403%20204.89%20262.043C220.32%20265.914%20237.33%20261.817%20249.4%20249.754Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M249.4%20249.754C261.48%20237.666%20265.57%20220.608%20261.66%20205.157C277.12%20209.086%20294.2%20205.001%20306.3%20192.902C324.57%20174.636%20324.57%20145.02%20306.3%20126.754C294.27%20114.727%20277.32%20110.619%20261.94%20114.43C265.37%2099.286%20261.19%2082.766%20249.4%2070.975C237.28%2058.86%20220.17%2054.78%20204.7%2058.736C208.8%2043.171%20204.75%2025.903%20192.54%2013.7C174.28%20-4.56699%20144.66%20-4.56699%20126.4%2013.7C114.27%2025.83%20110.19%2042.965%20114.17%2058.458C99%2054.986%2082.43%2059.158%2070.62%2070.975C58.83%2082.767%2054.6499%2099.289%2058.0799%20114.434C42.6899%20110.616%2025.7299%20114.723%2013.6999%20126.754C-4.57006%20145.02%20-4.57006%20174.636%2013.6999%20192.902C25.7999%20205.005%2042.89%20209.089%2058.35%20205.153C54.44%20220.605%2058.53%20237.665%2070.62%20249.754C82.38%20261.521%2098.86%20265.708%20113.98%20262.314C110.33%20277.602%20114.47%20294.371%20126.4%20306.3C144.66%20324.567%20174.28%20324.567%20192.54%20306.3C204.54%20294.301%20208.66%20277.403%20204.89%20262.043C220.32%20265.914%20237.33%20261.817%20249.4%20249.754Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.semicircle{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='200'%20viewBox='0%200%20320%20200'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M320%20166.92C320%20185.19%20305.19%20200%20286.921%20200H33.0794C14.8102%20200%200%20185.19%200%20166.92V160C-1e-05%2071.63%2071.6344%200%20160%200C248.366%200%20320%2071.63%20320%20160V166.92Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='200'%20viewBox='0%200%20320%20200'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M320%20166.92C320%20185.19%20305.19%20200%20286.921%20200H33.0794C14.8102%20200%200%20185.19%200%20166.92V160C-1e-05%2071.63%2071.6344%200%20160%200C248.366%200%20320%2071.63%20320%20160V166.92Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.sided-cookie4{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='280'%20height='280'%20viewBox='0%200%20280%20280'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M178.73%206.20997C238.87%20-19.91%20299.91%2041.13%20273.79%20101.27L269.47%20111.21C261.5%20129.58%20261.5%20150.42%20269.47%20168.79L273.79%20178.73C299.91%20238.87%20238.87%20299.91%20178.73%20273.79L168.79%20269.47C150.42%20261.5%20129.58%20261.5%20111.21%20269.47L101.27%20273.79C41.128%20299.91%20-19.9141%20238.87%206.20694%20178.73L10.526%20168.79C18.501%20150.42%2018.501%20129.58%2010.526%20111.21L6.20694%20101.27C-19.9141%2041.13%2041.128%20-19.91%20101.27%206.20997L111.21%2010.53C129.58%2018.5%20150.42%2018.5%20168.79%2010.53L178.73%206.20997Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='280'%20height='280'%20viewBox='0%200%20280%20280'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M178.73%206.20997C238.87%20-19.91%20299.91%2041.13%20273.79%20101.27L269.47%20111.21C261.5%20129.58%20261.5%20150.42%20269.47%20168.79L273.79%20178.73C299.91%20238.87%20238.87%20299.91%20178.73%20273.79L168.79%20269.47C150.42%20261.5%20129.58%20261.5%20111.21%20269.47L101.27%20273.79C41.128%20299.91%20-19.9141%20238.87%206.20694%20178.73L10.526%20168.79C18.501%20150.42%2018.501%20129.58%2010.526%20111.21L6.20694%20101.27C-19.9141%2041.13%2041.128%20-19.91%20101.27%206.20997L111.21%2010.53C129.58%2018.5%20150.42%2018.5%20168.79%2010.53L178.73%206.20997Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.sided-cookie6{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='296'%20height='316'%20viewBox='0%200%20296%20316'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M92.1859%2022.5702C123.276%20-7.51981%20172.724%20-7.51981%20203.814%2022.5702C213.328%2031.7702%20224.984%2038.4802%20237.738%2042.0902C279.419%2053.8902%20304.142%2096.5901%20293.552%20138.47C290.312%20151.29%20290.312%20164.71%20293.552%20177.53C304.142%20219.41%20279.419%20262.11%20237.738%20273.91C224.984%20277.52%20213.328%20284.23%20203.814%20293.43C172.724%20323.52%20123.276%20323.52%2092.1859%20293.43C82.6719%20284.23%2071.0159%20277.52%2058.2619%20273.91C16.5809%20262.11%20-8.14208%20219.41%202.44792%20177.53C5.68792%20164.71%205.68792%20151.29%202.44792%20138.47C-8.14208%2096.5901%2016.5809%2053.8902%2058.2619%2042.0902C71.0159%2038.4802%2082.6719%2031.7702%2092.1859%2022.5702Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='296'%20height='316'%20viewBox='0%200%20296%20316'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M92.1859%2022.5702C123.276%20-7.51981%20172.724%20-7.51981%20203.814%2022.5702C213.328%2031.7702%20224.984%2038.4802%20237.738%2042.0902C279.419%2053.8902%20304.142%2096.5901%20293.552%20138.47C290.312%20151.29%20290.312%20164.71%20293.552%20177.53C304.142%20219.41%20279.419%20262.11%20237.738%20273.91C224.984%20277.52%20213.328%20284.23%20203.814%20293.43C172.724%20323.52%20123.276%20323.52%2092.1859%20293.43C82.6719%20284.23%2071.0159%20277.52%2058.2619%20273.91C16.5809%20262.11%20-8.14208%20219.41%202.44792%20177.53C5.68792%20164.71%205.68792%20151.29%202.44792%20138.47C-8.14208%2096.5901%2016.5809%2053.8902%2058.2619%2042.0902C71.0159%2038.4802%2082.6719%2031.7702%2092.1859%2022.5702Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.sided-cookie7{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='316'%20viewBox='0%200%20320%20316'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M112.67%2019.78C116.243%2016.64%20118.029%2015.07%20119.671%2013.8C143.425%20-4.6%20176.575%20-4.6%20200.329%2013.8C201.971%2015.07%20203.757%2016.64%20207.33%2019.78C208.526%2020.84%20209.124%2021.3601%20209.724%2021.8701C218.136%2028.9201%20228.171%2033.7699%20238.92%2035.9599C239.688%2036.1199%20240.471%2036.26%20242.038%2036.54C246.719%2037.38%20249.059%2037.79%20251.075%2038.29C280.234%2045.43%20300.902%2071.4099%20301.364%20101.49C301.396%20103.57%20301.283%20105.95%20301.057%20110.71C300.982%20112.31%20300.944%20113.1%20300.925%20113.89C300.665%20124.88%20303.143%20135.76%20308.136%20145.55C308.493%20146.25%20308.872%20146.95%20309.63%20148.36C311.894%20152.55%20313.026%20154.64%20313.897%20156.53C326.503%20183.83%20319.127%20216.23%20295.949%20235.34C294.347%20236.67%20292.42%20238.06%20288.566%20240.85C287.276%20241.79%20286.63%20242.25%20286.007%20242.73C277.27%20249.38%20270.326%20258.11%20265.803%20268.12C265.48%20268.84%20265.169%20269.57%20264.547%20271.04C262.69%20275.43%20261.761%20277.62%20260.832%20279.48C247.393%20306.38%20217.526%20320.8%20188.162%20314.56C186.132%20314.12%20183.842%20313.48%20179.262%20312.2C177.728%20311.78%20176.962%20311.56%20176.203%20311.37C165.569%20308.67%20154.431%20308.67%20143.797%20311.37C143.038%20311.56%20142.272%20311.78%20140.738%20312.2C136.158%20313.48%20133.868%20314.12%20131.838%20314.56C102.474%20320.8%2072.6071%20306.38%2059.168%20279.48C58.2388%20277.62%2057.3102%20275.43%2055.453%20271.04C54.8311%20269.57%2054.5202%20268.84%2054.1975%20268.12C49.6741%20258.11%2042.7297%20249.38%2033.993%20242.73C33.3696%20242.25%2032.7244%20241.79%2031.434%20240.85C27.5801%20238.06%2025.6532%20236.67%2024.0507%20235.34C0.872993%20216.23%20-6.50347%20183.83%206.10269%20156.53C6.97419%20154.64%208.10619%20152.55%2010.3703%20148.36C11.1283%20146.95%2011.5074%20146.25%2011.8636%20145.55C16.8568%20135.76%2019.3353%20124.88%2019.0745%20113.89C19.0559%20113.1%2019.0182%20112.31%2018.9426%20110.71C18.7168%20105.95%2018.6039%20103.57%2018.6359%20101.49C19.0982%2071.4099%2039.7665%2045.43%2068.9252%2038.29C70.9411%2037.79%2073.2814%2037.38%2077.9618%2036.54C79.5289%2036.26%2080.3125%2036.1199%2081.0795%2035.9599C91.829%2033.7699%20101.864%2028.9201%20110.276%2021.8701C110.876%2021.3601%20111.474%2020.84%20112.67%2019.78Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='316'%20viewBox='0%200%20320%20316'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M112.67%2019.78C116.243%2016.64%20118.029%2015.07%20119.671%2013.8C143.425%20-4.6%20176.575%20-4.6%20200.329%2013.8C201.971%2015.07%20203.757%2016.64%20207.33%2019.78C208.526%2020.84%20209.124%2021.3601%20209.724%2021.8701C218.136%2028.9201%20228.171%2033.7699%20238.92%2035.9599C239.688%2036.1199%20240.471%2036.26%20242.038%2036.54C246.719%2037.38%20249.059%2037.79%20251.075%2038.29C280.234%2045.43%20300.902%2071.4099%20301.364%20101.49C301.396%20103.57%20301.283%20105.95%20301.057%20110.71C300.982%20112.31%20300.944%20113.1%20300.925%20113.89C300.665%20124.88%20303.143%20135.76%20308.136%20145.55C308.493%20146.25%20308.872%20146.95%20309.63%20148.36C311.894%20152.55%20313.026%20154.64%20313.897%20156.53C326.503%20183.83%20319.127%20216.23%20295.949%20235.34C294.347%20236.67%20292.42%20238.06%20288.566%20240.85C287.276%20241.79%20286.63%20242.25%20286.007%20242.73C277.27%20249.38%20270.326%20258.11%20265.803%20268.12C265.48%20268.84%20265.169%20269.57%20264.547%20271.04C262.69%20275.43%20261.761%20277.62%20260.832%20279.48C247.393%20306.38%20217.526%20320.8%20188.162%20314.56C186.132%20314.12%20183.842%20313.48%20179.262%20312.2C177.728%20311.78%20176.962%20311.56%20176.203%20311.37C165.569%20308.67%20154.431%20308.67%20143.797%20311.37C143.038%20311.56%20142.272%20311.78%20140.738%20312.2C136.158%20313.48%20133.868%20314.12%20131.838%20314.56C102.474%20320.8%2072.6071%20306.38%2059.168%20279.48C58.2388%20277.62%2057.3102%20275.43%2055.453%20271.04C54.8311%20269.57%2054.5202%20268.84%2054.1975%20268.12C49.6741%20258.11%2042.7297%20249.38%2033.993%20242.73C33.3696%20242.25%2032.7244%20241.79%2031.434%20240.85C27.5801%20238.06%2025.6532%20236.67%2024.0507%20235.34C0.872993%20216.23%20-6.50347%20183.83%206.10269%20156.53C6.97419%20154.64%208.10619%20152.55%2010.3703%20148.36C11.1283%20146.95%2011.5074%20146.25%2011.8636%20145.55C16.8568%20135.76%2019.3353%20124.88%2019.0745%20113.89C19.0559%20113.1%2019.0182%20112.31%2018.9426%20110.71C18.7168%20105.95%2018.6039%20103.57%2018.6359%20101.49C19.0982%2071.4099%2039.7665%2045.43%2068.9252%2038.29C70.9411%2037.79%2073.2814%2037.38%2077.9618%2036.54C79.5289%2036.26%2080.3125%2036.1199%2081.0795%2035.9599C91.829%2033.7699%20101.864%2028.9201%20110.276%2021.8701C110.876%2021.3601%20111.474%2020.84%20112.67%2019.78Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.sided-cookie9{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M125.26%2013.3798C126.99%2011.9498%20127.85%2011.2398%20128.64%2010.6398C147.19%20-3.55019%20172.81%20-3.55019%20191.36%2010.6398C192.15%2011.2398%20193.01%2011.9498%20194.74%2013.3798C195.51%2014.0098%20195.89%2014.3298%20196.27%2014.6398C205%2021.5798%20215.71%2025.52%20226.82%2025.87C227.3%2025.88%20227.8%2025.8898%20228.79%2025.8998C231.02%2025.9298%20232.14%2025.9399%20233.12%2025.9899C256.36%2027.1799%20275.98%2043.8199%20281.17%2066.7299C281.39%2067.6999%20281.6%2068.8099%20282.02%2071.0199C282.2%2072.0099%20282.29%2072.4999%20282.39%2072.9799C284.66%2083.9799%20290.36%2093.9398%20298.64%20101.42C299.01%20101.75%20299.38%20102.08%20300.14%20102.73C301.83%20104.2%20302.67%20104.94%20303.39%20105.62C320.44%20121.61%20324.89%20147.11%20314.29%20168.03C313.84%20168.92%20313.29%20169.9%20312.2%20171.86C311.71%20172.74%20311.47%20173.18%20311.24%20173.61C305.99%20183.5%20304.01%20194.84%20305.6%20205.95C305.67%20206.44%20305.75%20206.93%20305.91%20207.92C306.27%20210.15%20306.45%20211.26%20306.57%20212.25C309.45%20235.57%20296.64%20257.99%20275.21%20267.13C274.3%20267.52%20273.25%20267.92%20271.17%20268.72C270.24%20269.07%20269.77%20269.25%20269.32%20269.43C259%20273.6%20250.28%20281%20244.42%20290.54C244.17%20290.96%20243.92%20291.39%20243.41%20292.25C242.27%20294.19%20241.7%20295.16%20241.16%20296C228.53%20315.73%20204.46%20324.59%20182.22%20317.67C181.28%20317.38%20180.22%20317.01%20178.12%20316.26C177.18%20315.93%20176.71%20315.76%20176.25%20315.61C165.7%20312.1%20154.3%20312.1%20143.75%20315.61C143.29%20315.76%20142.82%20315.93%20141.88%20316.26C139.78%20317.01%20138.72%20317.38%20137.78%20317.67C115.54%20324.59%2091.47%20315.73%2078.84%20296C78.3%20295.16%2077.73%20294.19%2076.59%20292.25C76.08%20291.39%2075.83%20290.96%2075.58%20290.54C69.72%20281%2061.0001%20273.6%2050.6801%20269.43C50.2301%20269.25%2049.76%20269.07%2048.83%20268.72C46.75%20267.92%2045.7001%20267.52%2044.7901%20267.13C23.3601%20257.99%2010.5501%20235.57%2013.4301%20212.25C13.5501%20211.26%2013.73%20210.15%2014.09%20207.92C14.25%20206.93%2014.3301%20206.44%2014.4001%20205.95C15.9901%20194.84%2014.01%20183.5%208.76004%20173.61C8.53004%20173.18%208.29008%20172.74%207.80008%20171.86C6.71008%20169.9%206.15999%20168.92%205.70999%20168.03C-4.89001%20147.11%20-0.439983%20121.61%2016.61%20105.62C17.33%20104.94%2018.17%20104.2%2019.86%20102.73C20.62%20102.08%2020.99%20101.75%2021.36%20101.42C29.64%2093.9398%2035.34%2083.9799%2037.61%2072.9799C37.71%2072.4999%2037.8%2072.0099%2037.98%2071.0199C38.4%2068.8099%2038.61%2067.6999%2038.83%2066.7299C44.02%2043.8199%2063.64%2027.1799%2086.88%2025.9899C87.86%2025.9399%2088.98%2025.9298%2091.21%2025.8998C92.2%2025.8898%2092.7001%2025.88%2093.1801%2025.87C104.29%2025.52%20115%2021.5798%20123.73%2014.6398C124.11%2014.3298%20124.49%2014.0098%20125.26%2013.3798Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M125.26%2013.3798C126.99%2011.9498%20127.85%2011.2398%20128.64%2010.6398C147.19%20-3.55019%20172.81%20-3.55019%20191.36%2010.6398C192.15%2011.2398%20193.01%2011.9498%20194.74%2013.3798C195.51%2014.0098%20195.89%2014.3298%20196.27%2014.6398C205%2021.5798%20215.71%2025.52%20226.82%2025.87C227.3%2025.88%20227.8%2025.8898%20228.79%2025.8998C231.02%2025.9298%20232.14%2025.9399%20233.12%2025.9899C256.36%2027.1799%20275.98%2043.8199%20281.17%2066.7299C281.39%2067.6999%20281.6%2068.8099%20282.02%2071.0199C282.2%2072.0099%20282.29%2072.4999%20282.39%2072.9799C284.66%2083.9799%20290.36%2093.9398%20298.64%20101.42C299.01%20101.75%20299.38%20102.08%20300.14%20102.73C301.83%20104.2%20302.67%20104.94%20303.39%20105.62C320.44%20121.61%20324.89%20147.11%20314.29%20168.03C313.84%20168.92%20313.29%20169.9%20312.2%20171.86C311.71%20172.74%20311.47%20173.18%20311.24%20173.61C305.99%20183.5%20304.01%20194.84%20305.6%20205.95C305.67%20206.44%20305.75%20206.93%20305.91%20207.92C306.27%20210.15%20306.45%20211.26%20306.57%20212.25C309.45%20235.57%20296.64%20257.99%20275.21%20267.13C274.3%20267.52%20273.25%20267.92%20271.17%20268.72C270.24%20269.07%20269.77%20269.25%20269.32%20269.43C259%20273.6%20250.28%20281%20244.42%20290.54C244.17%20290.96%20243.92%20291.39%20243.41%20292.25C242.27%20294.19%20241.7%20295.16%20241.16%20296C228.53%20315.73%20204.46%20324.59%20182.22%20317.67C181.28%20317.38%20180.22%20317.01%20178.12%20316.26C177.18%20315.93%20176.71%20315.76%20176.25%20315.61C165.7%20312.1%20154.3%20312.1%20143.75%20315.61C143.29%20315.76%20142.82%20315.93%20141.88%20316.26C139.78%20317.01%20138.72%20317.38%20137.78%20317.67C115.54%20324.59%2091.47%20315.73%2078.84%20296C78.3%20295.16%2077.73%20294.19%2076.59%20292.25C76.08%20291.39%2075.83%20290.96%2075.58%20290.54C69.72%20281%2061.0001%20273.6%2050.6801%20269.43C50.2301%20269.25%2049.76%20269.07%2048.83%20268.72C46.75%20267.92%2045.7001%20267.52%2044.7901%20267.13C23.3601%20257.99%2010.5501%20235.57%2013.4301%20212.25C13.5501%20211.26%2013.73%20210.15%2014.09%20207.92C14.25%20206.93%2014.3301%20206.44%2014.4001%20205.95C15.9901%20194.84%2014.01%20183.5%208.76004%20173.61C8.53004%20173.18%208.29008%20172.74%207.80008%20171.86C6.71008%20169.9%206.15999%20168.92%205.70999%20168.03C-4.89001%20147.11%20-0.439983%20121.61%2016.61%20105.62C17.33%20104.94%2018.17%20104.2%2019.86%20102.73C20.62%20102.08%2020.99%20101.75%2021.36%20101.42C29.64%2093.9398%2035.34%2083.9799%2037.61%2072.9799C37.71%2072.4999%2037.8%2072.0099%2037.98%2071.0199C38.4%2068.8099%2038.61%2067.6999%2038.83%2066.7299C44.02%2043.8199%2063.64%2027.1799%2086.88%2025.9899C87.86%2025.9399%2088.98%2025.9298%2091.21%2025.8998C92.2%2025.8898%2092.7001%2025.88%2093.1801%2025.87C104.29%2025.52%20115%2021.5798%20123.73%2014.6398C124.11%2014.3298%20124.49%2014.0098%20125.26%2013.3798Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.sided-cookie12{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M136.7%209.85021C137.24%209.32021%20137.51%209.05019%20137.74%208.83019C150.25%20-2.93981%20169.75%20-2.93981%20182.26%208.83019C182.49%209.05019%20182.76%209.32021%20183.3%209.85021C183.63%2010.1602%20183.79%2010.3201%20183.94%2010.4701C191.95%2018.1101%20203.28%2021.1401%20214.03%2018.5301C214.24%2018.4801%20214.46%2018.4202%20214.9%2018.3102C215.63%2018.1202%20216%2018.0301%20216.31%2017.9501C233.02%2014.0101%20249.92%2023.7601%20254.86%2040.2101C254.95%2040.5201%20255.05%2040.8802%20255.26%2041.6102C255.38%2042.0502%20255.44%2042.2701%20255.5%2042.4801C258.61%2053.0901%20266.91%2061.3901%20277.52%2064.5001C277.73%2064.5601%20277.95%2064.6201%20278.39%2064.7401C279.12%2064.9501%20279.48%2065.05%20279.79%2065.14C296.24%2070.08%20305.99%2086.98%20302.05%20103.69C301.97%20104%20301.88%20104.37%20301.69%20105.1C301.58%20105.54%20301.52%20105.76%20301.47%20105.97C298.86%20116.72%20301.89%20128.05%20309.53%20136.06C309.68%20136.21%20309.84%20136.37%20310.15%20136.7C310.68%20137.24%20310.95%20137.51%20311.17%20137.74C322.94%20150.25%20322.94%20169.75%20311.17%20182.26C310.95%20182.49%20310.68%20182.76%20310.15%20183.3C309.84%20183.63%20309.68%20183.79%20309.53%20183.94C301.89%20191.95%20298.86%20203.28%20301.47%20214.03C301.52%20214.24%20301.58%20214.46%20301.69%20214.9C301.88%20215.63%20301.97%20216%20302.05%20216.31C305.99%20233.02%20296.24%20249.92%20279.79%20254.86C279.48%20254.95%20279.12%20255.05%20278.39%20255.26C277.95%20255.38%20277.73%20255.44%20277.52%20255.5C266.91%20258.61%20258.61%20266.91%20255.5%20277.52C255.44%20277.73%20255.38%20277.95%20255.26%20278.39C255.05%20279.12%20254.95%20279.48%20254.86%20279.79C249.92%20296.24%20233.02%20305.99%20216.31%20302.05C216%20301.97%20215.63%20301.88%20214.9%20301.69C214.46%20301.58%20214.24%20301.52%20214.03%20301.47C203.28%20298.86%20191.95%20301.89%20183.94%20309.53C183.79%20309.68%20183.63%20309.84%20183.3%20310.15C182.76%20310.68%20182.49%20310.95%20182.26%20311.17C169.75%20322.94%20150.25%20322.94%20137.74%20311.17C137.51%20310.95%20137.24%20310.68%20136.7%20310.15C136.37%20309.84%20136.21%20309.68%20136.06%20309.53C128.05%20301.89%20116.72%20298.86%20105.97%20301.47C105.76%20301.52%20105.54%20301.58%20105.1%20301.69C104.37%20301.88%20104%20301.97%20103.69%20302.05C86.9799%20305.99%2070.08%20296.24%2065.14%20279.79C65.05%20279.48%2064.95%20279.12%2064.74%20278.39C64.62%20277.95%2064.56%20277.73%2064.5%20277.52C61.39%20266.91%2053.09%20258.61%2042.48%20255.5C42.27%20255.44%2042.05%20255.38%2041.61%20255.26C40.88%20255.05%2040.5199%20254.95%2040.2099%20254.86C23.7599%20249.92%2014.0099%20233.02%2017.9499%20216.31C18.0299%20216%2018.12%20215.63%2018.31%20214.9C18.42%20214.46%2018.48%20214.24%2018.53%20214.03C21.14%20203.28%2018.11%20191.95%2010.47%20183.94C10.32%20183.79%2010.16%20183.63%209.84996%20183.3C9.31996%20182.76%209.04994%20182.49%208.82994%20182.26C-2.94006%20169.75%20-2.94006%20150.25%208.82994%20137.74C9.04994%20137.51%209.31996%20137.24%209.84996%20136.7C10.16%20136.37%2010.32%20136.21%2010.47%20136.06C18.11%20128.05%2021.14%20116.72%2018.53%20105.97C18.48%20105.76%2018.42%20105.54%2018.31%20105.1C18.12%20104.37%2018.0299%20104%2017.9499%20103.69C14.0099%2086.98%2023.7599%2070.08%2040.2099%2065.14C40.5199%2065.05%2040.88%2064.9501%2041.61%2064.7401C42.05%2064.6201%2042.27%2064.5601%2042.48%2064.5001C53.09%2061.3901%2061.39%2053.0901%2064.5%2042.4801C64.56%2042.2701%2064.62%2042.0502%2064.74%2041.6102C64.95%2040.8802%2065.05%2040.5201%2065.14%2040.2101C70.08%2023.7601%2086.9799%2014.0101%20103.69%2017.9501C104%2018.0301%20104.37%2018.1202%20105.1%2018.3102C105.54%2018.4202%20105.76%2018.4801%20105.97%2018.5301C116.72%2021.1401%20128.05%2018.1101%20136.06%2010.4701C136.21%2010.3201%20136.37%2010.1602%20136.7%209.85021Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M136.7%209.85021C137.24%209.32021%20137.51%209.05019%20137.74%208.83019C150.25%20-2.93981%20169.75%20-2.93981%20182.26%208.83019C182.49%209.05019%20182.76%209.32021%20183.3%209.85021C183.63%2010.1602%20183.79%2010.3201%20183.94%2010.4701C191.95%2018.1101%20203.28%2021.1401%20214.03%2018.5301C214.24%2018.4801%20214.46%2018.4202%20214.9%2018.3102C215.63%2018.1202%20216%2018.0301%20216.31%2017.9501C233.02%2014.0101%20249.92%2023.7601%20254.86%2040.2101C254.95%2040.5201%20255.05%2040.8802%20255.26%2041.6102C255.38%2042.0502%20255.44%2042.2701%20255.5%2042.4801C258.61%2053.0901%20266.91%2061.3901%20277.52%2064.5001C277.73%2064.5601%20277.95%2064.6201%20278.39%2064.7401C279.12%2064.9501%20279.48%2065.05%20279.79%2065.14C296.24%2070.08%20305.99%2086.98%20302.05%20103.69C301.97%20104%20301.88%20104.37%20301.69%20105.1C301.58%20105.54%20301.52%20105.76%20301.47%20105.97C298.86%20116.72%20301.89%20128.05%20309.53%20136.06C309.68%20136.21%20309.84%20136.37%20310.15%20136.7C310.68%20137.24%20310.95%20137.51%20311.17%20137.74C322.94%20150.25%20322.94%20169.75%20311.17%20182.26C310.95%20182.49%20310.68%20182.76%20310.15%20183.3C309.84%20183.63%20309.68%20183.79%20309.53%20183.94C301.89%20191.95%20298.86%20203.28%20301.47%20214.03C301.52%20214.24%20301.58%20214.46%20301.69%20214.9C301.88%20215.63%20301.97%20216%20302.05%20216.31C305.99%20233.02%20296.24%20249.92%20279.79%20254.86C279.48%20254.95%20279.12%20255.05%20278.39%20255.26C277.95%20255.38%20277.73%20255.44%20277.52%20255.5C266.91%20258.61%20258.61%20266.91%20255.5%20277.52C255.44%20277.73%20255.38%20277.95%20255.26%20278.39C255.05%20279.12%20254.95%20279.48%20254.86%20279.79C249.92%20296.24%20233.02%20305.99%20216.31%20302.05C216%20301.97%20215.63%20301.88%20214.9%20301.69C214.46%20301.58%20214.24%20301.52%20214.03%20301.47C203.28%20298.86%20191.95%20301.89%20183.94%20309.53C183.79%20309.68%20183.63%20309.84%20183.3%20310.15C182.76%20310.68%20182.49%20310.95%20182.26%20311.17C169.75%20322.94%20150.25%20322.94%20137.74%20311.17C137.51%20310.95%20137.24%20310.68%20136.7%20310.15C136.37%20309.84%20136.21%20309.68%20136.06%20309.53C128.05%20301.89%20116.72%20298.86%20105.97%20301.47C105.76%20301.52%20105.54%20301.58%20105.1%20301.69C104.37%20301.88%20104%20301.97%20103.69%20302.05C86.9799%20305.99%2070.08%20296.24%2065.14%20279.79C65.05%20279.48%2064.95%20279.12%2064.74%20278.39C64.62%20277.95%2064.56%20277.73%2064.5%20277.52C61.39%20266.91%2053.09%20258.61%2042.48%20255.5C42.27%20255.44%2042.05%20255.38%2041.61%20255.26C40.88%20255.05%2040.5199%20254.95%2040.2099%20254.86C23.7599%20249.92%2014.0099%20233.02%2017.9499%20216.31C18.0299%20216%2018.12%20215.63%2018.31%20214.9C18.42%20214.46%2018.48%20214.24%2018.53%20214.03C21.14%20203.28%2018.11%20191.95%2010.47%20183.94C10.32%20183.79%2010.16%20183.63%209.84996%20183.3C9.31996%20182.76%209.04994%20182.49%208.82994%20182.26C-2.94006%20169.75%20-2.94006%20150.25%208.82994%20137.74C9.04994%20137.51%209.31996%20137.24%209.84996%20136.7C10.16%20136.37%2010.32%20136.21%2010.47%20136.06C18.11%20128.05%2021.14%20116.72%2018.53%20105.97C18.48%20105.76%2018.42%20105.54%2018.31%20105.1C18.12%20104.37%2018.0299%20104%2017.9499%20103.69C14.0099%2086.98%2023.7599%2070.08%2040.2099%2065.14C40.5199%2065.05%2040.88%2064.9501%2041.61%2064.7401C42.05%2064.6201%2042.27%2064.5601%2042.48%2064.5001C53.09%2061.3901%2061.39%2053.0901%2064.5%2042.4801C64.56%2042.2701%2064.62%2042.0502%2064.74%2041.6102C64.95%2040.8802%2065.05%2040.5201%2065.14%2040.2101C70.08%2023.7601%2086.9799%2014.0101%20103.69%2017.9501C104%2018.0301%20104.37%2018.1202%20105.1%2018.3102C105.54%2018.4202%20105.76%2018.4801%20105.97%2018.5301C116.72%2021.1401%20128.05%2018.1101%20136.06%2010.4701C136.21%2010.3201%20136.37%2010.1602%20136.7%209.85021Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.slanted{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='300'%20viewBox='0%200%20320%20300'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M15.715%2080.54C18.289%2055.96%2019.576%2043.67%2024.303%2033.978C31.142%2019.945%2043.077%209.11002%2057.628%203.72302C67.683%202.24113e-05%2079.933%200%20104.432%200H228.137C257.764%200%20272.578%203.8147e-06%20283.887%204.854C300.261%2011.882%20312.72%2025.849%20317.927%2043.02C321.523%2054.87%20319.967%2069.73%20316.854%2099.46L304.285%20219.46C301.711%20244.04%20300.424%20256.33%20295.697%20266.02C288.858%20280.05%20276.923%20290.89%20262.372%20296.28C252.317%20300%20240.067%20300%20215.568%20300H91.863C62.236%20300%2047.422%20300%2036.113%20295.15C19.739%20288.12%207.28%20274.15%202.073%20256.98C-1.524%20245.13%200.0330019%20230.27%203.146%20200.54L15.715%2080.54Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='300'%20viewBox='0%200%20320%20300'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M15.715%2080.54C18.289%2055.96%2019.576%2043.67%2024.303%2033.978C31.142%2019.945%2043.077%209.11002%2057.628%203.72302C67.683%202.24113e-05%2079.933%200%20104.432%200H228.137C257.764%200%20272.578%203.8147e-06%20283.887%204.854C300.261%2011.882%20312.72%2025.849%20317.927%2043.02C321.523%2054.87%20319.967%2069.73%20316.854%2099.46L304.285%20219.46C301.711%20244.04%20300.424%20256.33%20295.697%20266.02C288.858%20280.05%20276.923%20290.89%20262.372%20296.28C252.317%20300%20240.067%20300%20215.568%20300H91.863C62.236%20300%2047.422%20300%2036.113%20295.15C19.739%20288.12%207.28%20274.15%202.073%20256.98C-1.524%20245.13%200.0330019%20230.27%203.146%20200.54L15.715%2080.54Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.soft-boom{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M174.94%2084.95C197.48%20-28.315%20122.55%20-28.315%20145.08%2084.95C122.55%20-28.315%2053.327%200.35202%20117.49%2096.38C53.327%200.35202%200.35202%2053.33%2096.38%20117.49C0.35202%2053.33%20-28.315%20122.55%2084.95%20145.07C-28.315%20122.54%20-28.315%20197.46%2084.95%20174.93C-28.315%20197.46%200.36602%20266.67%2096.38%20202.51C0.36602%20266.67%2053.34%20319.65%20117.49%20223.62C53.327%20319.63%20122.55%20348.3%20145.07%20235.05C122.54%20348.32%20197.46%20348.32%20174.93%20235.05C197.46%20348.32%20266.67%20319.63%20202.51%20223.62C266.67%20319.63%20319.65%20266.66%20223.62%20202.51C319.63%20266.67%20348.3%20197.45%20235.05%20174.93C348.32%20197.46%20348.32%20122.54%20235.05%20145.07C348.32%20122.54%20319.63%2053.33%20223.62%20117.49C319.63%2053.33%20266.66%200.35202%20202.51%2096.38C266.67%200.36602%20197.45%20-28.302%20174.93%2084.95H174.94Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M174.94%2084.95C197.48%20-28.315%20122.55%20-28.315%20145.08%2084.95C122.55%20-28.315%2053.327%200.35202%20117.49%2096.38C53.327%200.35202%200.35202%2053.33%2096.38%20117.49C0.35202%2053.33%20-28.315%20122.55%2084.95%20145.07C-28.315%20122.54%20-28.315%20197.46%2084.95%20174.93C-28.315%20197.46%200.36602%20266.67%2096.38%20202.51C0.36602%20266.67%2053.34%20319.65%20117.49%20223.62C53.327%20319.63%20122.55%20348.3%20145.07%20235.05C122.54%20348.32%20197.46%20348.32%20174.93%20235.05C197.46%20348.32%20266.67%20319.63%20202.51%20223.62C266.67%20319.63%20319.65%20266.66%20223.62%20202.51C319.63%20266.67%20348.3%20197.45%20235.05%20174.93C348.32%20197.46%20348.32%20122.54%20235.05%20145.07C348.32%20122.54%20319.63%2053.33%20223.62%20117.49C319.63%2053.33%20266.66%200.35202%20202.51%2096.38C266.67%200.36602%20197.45%20-28.302%20174.93%2084.95H174.94Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.soft-burst{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M145.15%207.90401C151.98%20-2.63499%20168.02%20-2.63499%20174.85%207.90401L191.24%2033.165C195.73%2040.093%20204.8%2042.91%20212.69%2039.83L241.47%2028.603C253.48%2023.92%20266.45%2032.932%20265.51%2045.3L263.24%2074.95C262.61%2083.08%20268.21%2090.45%20276.49%2092.4L306.68%2099.49C319.27%20102.45%20324.23%20117.03%20315.86%20126.51L295.8%20149.21C290.3%20155.44%20290.3%20164.56%20295.8%20170.79L315.86%20193.49C324.23%20202.97%20319.27%20217.55%20306.68%20220.51L276.49%20227.6C268.21%20229.55%20262.61%20236.92%20263.24%20245.05L265.51%20274.7C266.45%20287.07%20253.48%20296.08%20241.47%20291.4L212.69%20280.17C204.8%20277.09%20195.73%20279.91%20191.24%20286.84L174.85%20312.1C168.02%20322.63%20151.98%20322.63%20145.15%20312.1L128.76%20286.84C124.27%20279.91%20115.2%20277.09%20107.31%20280.17L78.53%20291.4C66.52%20296.08%2053.55%20287.07%2054.49%20274.7L56.76%20245.05C57.39%20236.92%2051.79%20229.55%2043.51%20227.6L13.32%20220.51C0.729964%20217.55%20-4.22997%20202.97%204.14003%20193.49L24.2%20170.79C29.7%20164.56%2029.7%20155.44%2024.2%20149.21L4.14003%20126.51C-4.22997%20117.03%200.729964%20102.45%2013.32%2099.49L43.51%2092.4C51.79%2090.45%2057.39%2083.08%2056.76%2074.95L54.49%2045.3C53.55%2032.932%2066.52%2023.92%2078.53%2028.603L107.31%2039.83C115.2%2042.91%20124.27%2040.093%20128.76%2033.165L145.15%207.90401Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M145.15%207.90401C151.98%20-2.63499%20168.02%20-2.63499%20174.85%207.90401L191.24%2033.165C195.73%2040.093%20204.8%2042.91%20212.69%2039.83L241.47%2028.603C253.48%2023.92%20266.45%2032.932%20265.51%2045.3L263.24%2074.95C262.61%2083.08%20268.21%2090.45%20276.49%2092.4L306.68%2099.49C319.27%20102.45%20324.23%20117.03%20315.86%20126.51L295.8%20149.21C290.3%20155.44%20290.3%20164.56%20295.8%20170.79L315.86%20193.49C324.23%20202.97%20319.27%20217.55%20306.68%20220.51L276.49%20227.6C268.21%20229.55%20262.61%20236.92%20263.24%20245.05L265.51%20274.7C266.45%20287.07%20253.48%20296.08%20241.47%20291.4L212.69%20280.17C204.8%20277.09%20195.73%20279.91%20191.24%20286.84L174.85%20312.1C168.02%20322.63%20151.98%20322.63%20145.15%20312.1L128.76%20286.84C124.27%20279.91%20115.2%20277.09%20107.31%20280.17L78.53%20291.4C66.52%20296.08%2053.55%20287.07%2054.49%20274.7L56.76%20245.05C57.39%20236.92%2051.79%20229.55%2043.51%20227.6L13.32%20220.51C0.729964%20217.55%20-4.22997%20202.97%204.14003%20193.49L24.2%20170.79C29.7%20164.56%2029.7%20155.44%2024.2%20149.21L4.14003%20126.51C-4.22997%20117.03%200.729964%20102.45%2013.32%2099.49L43.51%2092.4C51.79%2090.45%2057.39%2083.08%2056.76%2074.95L54.49%2045.3C53.55%2032.932%2066.52%2023.92%2078.53%2028.603L107.31%2039.83C115.2%2042.91%20124.27%2040.093%20128.76%2033.165L145.15%207.90401Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.square{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M320%20172C320%20216.72%20320%20239.08%20312.98%20256.81C302.81%20282.49%20282.49%20302.81%20256.81%20312.98C239.08%20320%20216.72%20320%20172%20320H148C103.28%20320%2080.9199%20320%2063.1899%20312.98C37.5099%20302.81%2017.19%20282.49%207.02002%20256.81C1.95503e-05%20239.08%200%20216.72%200%20172V148C0%20103.28%201.95503e-05%2080.92%207.02002%2063.19C17.19%2037.515%2037.5099%2017.187%2063.1899%207.02197C80.9199%20-2.71797e-05%20103.28%200%20148%200H172C216.72%200%20239.08%20-2.71797e-05%20256.81%207.02197C282.49%2017.187%20302.81%2037.515%20312.98%2063.19C320%2080.92%20320%20103.28%20320%20148V172Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M320%20172C320%20216.72%20320%20239.08%20312.98%20256.81C302.81%20282.49%20282.49%20302.81%20256.81%20312.98C239.08%20320%20216.72%20320%20172%20320H148C103.28%20320%2080.9199%20320%2063.1899%20312.98C37.5099%20302.81%2017.19%20282.49%207.02002%20256.81C1.95503e-05%20239.08%200%20216.72%200%20172V148C0%20103.28%201.95503e-05%2080.92%207.02002%2063.19C17.19%2037.515%2037.5099%2017.187%2063.1899%207.02197C80.9199%20-2.71797e-05%20103.28%200%20148%200H172C216.72%200%20239.08%20-2.71797e-05%20256.81%207.02197C282.49%2017.187%20302.81%2037.515%20312.98%2063.19C320%2080.92%20320%20103.28%20320%20148V172Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.sunny{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='340'%20height='340'%20viewBox='0%200%20340%20340'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M261.856%2041.24C272.431%2041.96%20277.718%2042.32%20281.991%2044.18C288.175%2046.89%20293.111%2051.83%20295.816%2058.01C297.685%2062.28%20298.044%2067.57%20298.762%2078.14L300.402%20102.27C300.693%20106.55%20300.838%20108.69%20301.303%20110.73C301.975%20113.68%20303.142%20116.5%20304.754%20119.06C305.869%20120.84%20307.279%20122.45%20310.097%20125.68L326.001%20143.9C332.97%20151.89%20336.455%20155.88%20338.155%20160.22C340.615%20166.51%20340.615%20173.49%20338.155%20179.78C336.455%20184.12%20332.97%20188.11%20326.001%20196.1L310.097%20214.32C307.279%20217.55%20305.869%20219.16%20304.754%20220.94C303.142%20223.5%20301.975%20226.32%20301.303%20229.27C300.838%20231.31%20300.693%20233.45%20300.402%20237.73L298.762%20261.86C298.044%20272.43%20297.685%20277.72%20295.816%20281.99C293.111%20288.17%20288.175%20293.11%20281.991%20295.82C277.718%20297.68%20272.431%20298.04%20261.856%20298.76L237.725%20300.4C233.448%20300.69%20231.31%20300.84%20229.267%20301.3C226.316%20301.97%20223.499%20303.14%20220.937%20304.75C219.164%20305.87%20217.549%20307.28%20214.319%20310.1L196.097%20326C188.111%20332.97%20184.119%20336.45%20179.775%20338.15C173.491%20340.62%20166.509%20340.62%20160.225%20338.15C155.881%20336.45%20151.889%20332.97%20143.903%20326L125.681%20310.1C122.451%20307.28%20120.836%20305.87%20119.063%20304.75C116.501%20303.14%20113.684%20301.97%20110.733%20301.3C108.69%20300.84%20106.552%20300.69%20102.275%20300.4L78.1438%20298.76C67.5694%20298.04%2062.2822%20297.68%2058.0088%20295.82C51.8252%20293.11%2046.8887%20288.17%2044.1844%20281.99C42.3154%20277.72%2041.9561%20272.43%2041.2375%20261.86L39.5977%20237.73C39.3071%20233.45%2039.1618%20231.31%2038.6969%20229.27C38.0251%20226.32%2036.8584%20223.5%2035.2463%20220.94C34.1306%20219.16%2032.7213%20217.55%2029.9027%20214.32L13.999%20196.1C7.02996%20188.11%203.54542%20184.12%201.84516%20179.78C-0.615054%20173.49%20-0.615053%20166.51%201.84516%20160.22C3.54542%20155.88%207.02996%20151.89%2013.999%20143.9L29.9027%20125.68C32.7213%20122.45%2034.1306%20120.84%2035.2463%20119.06C36.8584%20116.5%2038.0251%20113.68%2038.6969%20110.73C39.1618%20108.69%2039.3071%20106.55%2039.5977%20102.27L41.2375%2078.14C41.9561%2067.57%2042.3154%2062.28%2044.1844%2058.01C46.8887%2051.83%2051.8252%2046.89%2058.0088%2044.18C62.2823%2042.32%2067.5694%2041.96%2078.1438%2041.24L102.275%2039.5999C106.552%2039.3099%20108.69%2039.1599%20110.733%2038.6999C113.684%2038.0299%20116.501%2036.86%20119.063%2035.25C120.836%2034.13%20122.451%2032.72%20125.681%2029.9L143.903%2014C151.889%207.02996%20155.881%203.54994%20160.225%201.84994C166.509%20-0.620064%20173.491%20-0.620064%20179.775%201.84994C184.119%203.54994%20188.111%207.02996%20196.097%2014L214.319%2029.9C217.549%2032.72%20219.164%2034.13%20220.937%2035.25C223.499%2036.86%20226.316%2038.0299%20229.267%2038.6999C231.31%2039.1599%20233.448%2039.3099%20237.725%2039.5999L261.856%2041.24Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='340'%20height='340'%20viewBox='0%200%20340%20340'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M261.856%2041.24C272.431%2041.96%20277.718%2042.32%20281.991%2044.18C288.175%2046.89%20293.111%2051.83%20295.816%2058.01C297.685%2062.28%20298.044%2067.57%20298.762%2078.14L300.402%20102.27C300.693%20106.55%20300.838%20108.69%20301.303%20110.73C301.975%20113.68%20303.142%20116.5%20304.754%20119.06C305.869%20120.84%20307.279%20122.45%20310.097%20125.68L326.001%20143.9C332.97%20151.89%20336.455%20155.88%20338.155%20160.22C340.615%20166.51%20340.615%20173.49%20338.155%20179.78C336.455%20184.12%20332.97%20188.11%20326.001%20196.1L310.097%20214.32C307.279%20217.55%20305.869%20219.16%20304.754%20220.94C303.142%20223.5%20301.975%20226.32%20301.303%20229.27C300.838%20231.31%20300.693%20233.45%20300.402%20237.73L298.762%20261.86C298.044%20272.43%20297.685%20277.72%20295.816%20281.99C293.111%20288.17%20288.175%20293.11%20281.991%20295.82C277.718%20297.68%20272.431%20298.04%20261.856%20298.76L237.725%20300.4C233.448%20300.69%20231.31%20300.84%20229.267%20301.3C226.316%20301.97%20223.499%20303.14%20220.937%20304.75C219.164%20305.87%20217.549%20307.28%20214.319%20310.1L196.097%20326C188.111%20332.97%20184.119%20336.45%20179.775%20338.15C173.491%20340.62%20166.509%20340.62%20160.225%20338.15C155.881%20336.45%20151.889%20332.97%20143.903%20326L125.681%20310.1C122.451%20307.28%20120.836%20305.87%20119.063%20304.75C116.501%20303.14%20113.684%20301.97%20110.733%20301.3C108.69%20300.84%20106.552%20300.69%20102.275%20300.4L78.1438%20298.76C67.5694%20298.04%2062.2822%20297.68%2058.0088%20295.82C51.8252%20293.11%2046.8887%20288.17%2044.1844%20281.99C42.3154%20277.72%2041.9561%20272.43%2041.2375%20261.86L39.5977%20237.73C39.3071%20233.45%2039.1618%20231.31%2038.6969%20229.27C38.0251%20226.32%2036.8584%20223.5%2035.2463%20220.94C34.1306%20219.16%2032.7213%20217.55%2029.9027%20214.32L13.999%20196.1C7.02996%20188.11%203.54542%20184.12%201.84516%20179.78C-0.615054%20173.49%20-0.615053%20166.51%201.84516%20160.22C3.54542%20155.88%207.02996%20151.89%2013.999%20143.9L29.9027%20125.68C32.7213%20122.45%2034.1306%20120.84%2035.2463%20119.06C36.8584%20116.5%2038.0251%20113.68%2038.6969%20110.73C39.1618%20108.69%2039.3071%20106.55%2039.5977%20102.27L41.2375%2078.14C41.9561%2067.57%2042.3154%2062.28%2044.1844%2058.01C46.8887%2051.83%2051.8252%2046.89%2058.0088%2044.18C62.2823%2042.32%2067.5694%2041.96%2078.1438%2041.24L102.275%2039.5999C106.552%2039.3099%20108.69%2039.1599%20110.733%2038.6999C113.684%2038.0299%20116.501%2036.86%20119.063%2035.25C120.836%2034.13%20122.451%2032.72%20125.681%2029.9L143.903%2014C151.889%207.02996%20155.881%203.54994%20160.225%201.84994C166.509%20-0.620064%20173.491%20-0.620064%20179.775%201.84994C184.119%203.54994%20188.111%207.02996%20196.097%2014L214.319%2029.9C217.549%2032.72%20219.164%2034.13%20220.937%2035.25C223.499%2036.86%20226.316%2038.0299%20229.267%2038.6999C231.31%2039.1599%20233.448%2039.3099%20237.725%2039.5999L261.856%2041.24Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.triangle{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='316'%20height='286'%20viewBox='0%200%20316%20286'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M104.461%2051.1999C119.597%2024.8199%20127.165%2011.63%20136.342%206.06C149.648%20-2.02%20166.352%20-2.02%20179.658%206.06C188.835%2011.63%20196.403%2024.8199%20211.539%2051.1999L293.309%20193.72C308.3%20219.85%20315.795%20232.91%20315.993%20243.58C316.28%20259.06%20307.949%20273.42%20294.364%20280.86C284.994%20286%20269.919%20286%20239.77%20286H76.2299C46.0809%20286%2031.0059%20286%2021.6359%20280.86C8.04994%20273.42%20-0.280059%20259.06%200.00694063%20243.58C0.204941%20232.91%207.69996%20219.85%2022.691%20193.72L104.461%2051.1999Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='316'%20height='286'%20viewBox='0%200%20316%20286'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M104.461%2051.1999C119.597%2024.8199%20127.165%2011.63%20136.342%206.06C149.648%20-2.02%20166.352%20-2.02%20179.658%206.06C188.835%2011.63%20196.403%2024.8199%20211.539%2051.1999L293.309%20193.72C308.3%20219.85%20315.795%20232.91%20315.993%20243.58C316.28%20259.06%20307.949%20273.42%20294.364%20280.86C284.994%20286%20269.919%20286%20239.77%20286H76.2299C46.0809%20286%2031.0059%20286%2021.6359%20280.86C8.04994%20273.42%20-0.280059%20259.06%200.00694063%20243.58C0.204941%20232.91%207.69996%20219.85%2022.691%20193.72L104.461%2051.1999Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}.shape.very-sunny{-webkit-mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M136.72%2013.1899C147.26%20-4.40006%20172.74%20-4.40006%20183.28%2013.1899L195.12%2032.96C201.27%2043.21%20213.4%2048.24%20224.99%2045.33L247.35%2039.73C267.24%2034.75%20285.25%2052.76%20280.27%2072.65L274.67%2095.01C271.76%20106.6%20276.79%20118.73%20287.04%20124.88L306.81%20136.72C324.4%20147.26%20324.4%20172.74%20306.81%20183.28L287.04%20195.12C276.79%20201.27%20271.76%20213.4%20274.67%20224.99L280.27%20247.35C285.25%20267.24%20267.24%20285.25%20247.35%20280.27L224.99%20274.67C213.4%20271.76%20201.27%20276.79%20195.12%20287.04L183.28%20306.81C172.74%20324.4%20147.26%20324.4%20136.72%20306.81L124.88%20287.04C118.73%20276.79%20106.6%20271.76%2095.01%20274.67L72.646%20280.27C52.763%20285.25%2034.747%20267.24%2039.729%20247.35L45.333%20224.99C48.238%20213.4%2043.214%20201.27%2032.96%20195.12L13.187%20183.28C-4.39599%20172.74%20-4.39599%20147.26%2013.187%20136.72L32.96%20124.88C43.214%20118.73%2048.238%20106.6%2045.333%2095.01L39.729%2072.65C34.747%2052.76%2052.763%2034.75%2072.645%2039.73L95.01%2045.33C106.6%2048.24%20118.73%2043.21%20124.88%2032.96L136.72%2013.1899Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e");mask-image:url("data:image/svg+xml,%3csvg%20width='320'%20height='320'%20viewBox='0%200%20320%20320'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M136.72%2013.1899C147.26%20-4.40006%20172.74%20-4.40006%20183.28%2013.1899L195.12%2032.96C201.27%2043.21%20213.4%2048.24%20224.99%2045.33L247.35%2039.73C267.24%2034.75%20285.25%2052.76%20280.27%2072.65L274.67%2095.01C271.76%20106.6%20276.79%20118.73%20287.04%20124.88L306.81%20136.72C324.4%20147.26%20324.4%20172.74%20306.81%20183.28L287.04%20195.12C276.79%20201.27%20271.76%20213.4%20274.67%20224.99L280.27%20247.35C285.25%20267.24%20267.24%20285.25%20247.35%20280.27L224.99%20274.67C213.4%20271.76%20201.27%20276.79%20195.12%20287.04L183.28%20306.81C172.74%20324.4%20147.26%20324.4%20136.72%20306.81L124.88%20287.04C118.73%20276.79%20106.6%20271.76%2095.01%20274.67L72.646%20280.27C52.763%20285.25%2034.747%20267.24%2039.729%20247.35L45.333%20224.99C48.238%20213.4%2043.214%20201.27%2032.96%20195.12L13.187%20183.28C-4.39599%20172.74%20-4.39599%20147.26%2013.187%20136.72L32.96%20124.88C43.214%20118.73%2048.238%20106.6%2045.333%2095.01L39.729%2072.65C34.747%2052.76%2052.763%2034.75%2072.645%2039.73L95.01%2045.33C106.6%2048.24%20118.73%2043.21%20124.88%2032.96L136.72%2013.1899Z'%20fill='%23D0BCFF'/%3e%3c/svg%3e")}@keyframes to-shape-rotate{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.checkbox,.radio,.switch{--_size: 1.5rem;direction:ltr;inline-size:auto;block-size:auto;line-height:normal;white-space:nowrap;cursor:pointer;display:inline-flex;align-items:center}:is(.checkbox,.radio,.switch).small{--_size: 1rem}:is(.checkbox,.radio,.switch).large{--_size: 2rem}:is(.checkbox,.radio,.switch).extra{--_size: 2.5rem}:is(.checkbox,.radio)>input{inline-size:var(--_size);block-size:var(--_size);opacity:0}.switch>input{inline-size:3.25rem;block-size:2rem;opacity:0}:is(.checkbox,.radio,.switch)>span{display:inline-flex;align-items:center;color:var(--on-surface);font-size:.875rem}:is(.checkbox,.radio)>span:not(:empty){padding-inline-start:.25rem}:is(.checkbox,.radio,.switch)>span:before,:is(.checkbox,.radio,.switch)>span>i,:is(.checkbox,.radio)>span:after{--_size: inherit;content:"";inline-size:var(--_size);block-size:var(--_size);box-sizing:border-box;margin:0 auto;outline:none;color:var(--primary);position:absolute;inset:auto auto auto calc(var(--_size) * -1);border-radius:50%;-webkit-user-select:none;user-select:none;z-index:1}.switch>span:before,.switch.icon>span>i{position:absolute;inset:50% auto auto 0;display:inline-flex;align-items:center;justify-content:center;border-radius:50%;transition:all var(--speed2);font-size:calc(var(--_size) - .5rem);-webkit-user-select:none;user-select:none;min-inline-size:var(--_size);min-block-size:var(--_size);content:"";color:var(--surface-variant);background-color:var(--outline)}.switch>span:before,.switch.icon>span>i{transform:translate(-3rem,-50%) scale(.6)}.switch.icon>span>i{transform:translate(-3rem,-50%) scale(1)}.checkbox>span:before{content:"check_box_outline_blank"}.checkbox>input:checked+span:before{content:"check_box";font-variation-settings:"FILL" 1}.checkbox>input:indeterminate+span:before{content:"indeterminate_check_box"}.radio>span:before{content:"radio_button_unchecked"}.radio>input:checked+span:before{content:"radio_button_checked"}:is(.radio,.checkbox,.switch).icon>span:before{content:""!important;font-variation-settings:unset!important}:is(.checkbox,.radio)>span:after{transition:all var(--speed1);background-color:currentColor;box-shadow:0 0 0 0 currentColor;opacity:0}:is(.checkbox,.radio):is(:hover)>input:not(:disabled)+span:after,:is(.checkbox,.radio)>input:not(:disabled):is(:focus)+span:after{box-shadow:0 0 0 .5rem currentColor;opacity:.1}.switch>input:not(:disabled):is(:focus,:hover)+span:before,.switch.icon>input:not(:disabled):is(:focus,:hover)+span>i{box-shadow:0 0 0 .5rem var(--active)}:is(.checkbox,.radio)>input:checked+span:before,:is(.checkbox,.radio).icon>input:checked+span>i{color:var(--primary)}.icon>input:checked+span>i:first-child,.icon>span>i:last-child{opacity:0}.icon>input:checked+span>i:last-child,.icon>span>i:first-child{opacity:1}.switch>input:checked+span:after{border:none;background-color:var(--primary)}.switch>input:checked+span:before,.switch.icon>input:checked+span>i{content:"check";color:var(--primary);background-color:var(--on-primary);transform:translate(-1.75rem,-50%) scale(1)}.switch>input:active:not(:disabled)+span:before,.switch.icon>input:active:not(:disabled)+span>i{transform:translate(-3rem,-50%) scale(1.2)}.switch>input:active:checked:not(:disabled)+span:before,.switch.icon>input:active:checked:not(:disabled)+span>i{transform:translate(-1.75rem,-50%) scale(1.2)}:is(.checkbox,.radio,.switch)>input:disabled+span{opacity:.5;cursor:not-allowed}.switch>span:after{content:"";position:absolute;inset:50% auto auto 0;background-color:var(--active);border:.125rem solid var(--outline);box-sizing:border-box;inline-size:3.25rem;block-size:2rem;border-radius:2rem;transform:translate(-3.25rem,-50%)}.field>:is(nav,.row){flex-grow:1;padding:0 1rem}.field.round>:is(nav,.row){flex-grow:1;padding:0 1.5rem}[dir=rtl] .switch{transform:scale(-1)}[dir=rtl] .switch>span:before,[dir=rtl] .switch.icon>span>i{transform:translate(-3rem,-50%) scale(-.6)}[dir=rtl] .switch.icon>span>i{transform:translate(-3rem,-50%) scale(-1)}[dir=rtl] .switch>input:checked+span:before,[dir=rtl] .switch.icon>input:checked+span>i{transform:translate(-1.75rem,-50%) scale(-1)}.switch>:focus-visible+span:after{outline:.125rem solid var(--primary);outline-offset:.25rem}:is(.checkbox,.radio)>:focus-visible+span:before{outline:.125rem solid var(--primary);outline-offset:.375rem}.slider{--_start: 0%;--_end: 0%;--_value1: "";--_value2: "";--_track: 1rem;--_thumb: max(2.5rem, calc(var(--_track) + .5rem));display:flex;align-items:center!important;inline-size:auto;block-size:var(--_thumb);flex:none;direction:ltr;margin:0 1.25rem}[dir=rtl] .slider{transform:scaleX(-1)}.slider.vertical{flex-direction:row!important;margin:.5rem auto!important;padding:50% 0;transform:rotate(-90deg);inline-size:100%}.slider.tiny{--_track: 1rem}.slider.small{--_track: 1.5rem}.slider.medium{--_track: 2.5rem}.slider.large{--_track: 3.5rem}.slider.extra{--_track: 6rem}.slider>input{-webkit-appearance:none;-moz-appearance:none;appearance:none;box-shadow:none;border:none;outline:none;pointer-events:none;inline-size:100%;block-size:var(--_track);background:none;z-index:1;padding:0;margin:0;transform:rotate(0)}.slider>input:only-of-type{pointer-events:all}.slider>input+input{position:absolute}.slider>input::-webkit-slider-thumb{-webkit-appearance:none;-moz-appearance:none;appearance:none;box-shadow:none;border:none;outline:none;pointer-events:all;block-size:var(--_thumb);inline-size:.25rem;border-radius:.25rem;background:var(--primary);cursor:grab;margin:0;z-index:1}.slider>input::-webkit-slider-thumb:active{cursor:grabbing}.slider>input::-moz-range-thumb{-webkit-appearance:none;-moz-appearance:none;appearance:none;box-shadow:none;border:none;outline:none;pointer-events:all;block-size:2.75rem;inline-size:.25rem;border-radius:.25rem;background:var(--primary);cursor:grab;margin:0}.slider>input::-moz-range-thumb:active{cursor:grabbing}.slider>input:not(:disabled):is(:focus)::-webkit-slider-thumb{transform:scaleX(.6)}.slider>input:not(:disabled):is(:focus)::-moz-range-thumb{transform:scaleX(.6)}.slider>input:disabled{cursor:not-allowed;opacity:1}.slider>input:disabled::-webkit-slider-thumb{background:var(--outline);cursor:not-allowed}.slider>input:disabled::-moz-range-thumb{background:var(--outline);cursor:not-allowed}.slider>input:disabled~span{background:var(--outline)}.slider>span{position:absolute;block-size:var(--_track);border-radius:1rem 0 0 1rem;background:var(--primary);color:var(--on-primary);z-index:0;inset:calc(50% - (var(--_track) / 2)) var(--_end) auto var(--_start);clip-path:polygon(0 0,calc(100% - .5rem) 0,calc(100% - .5rem) 100%,0 100%)}.slider>input[type=range]+input[type=range]~span{border-radius:0;clip-path:polygon(.5rem 0,max(.5rem,calc(100% - .5rem)) 0,max(.5rem,calc(100% - .5rem)) 100%,.5rem 100%)}.field>.slider{inline-size:100%}.slider:before{content:"";position:absolute;inline-size:100%;block-size:var(--_track);border-radius:1rem;background:var(--secondary-container);clip-path:polygon(calc(var(--_start) - .5rem) 0,0 0,0 100%,calc(var(--_start) - .5rem) 100%,calc(var(--_start) - .5rem) 0,calc(100% - var(--_end) + .5rem) 0,100% 0,100% 100%,calc(100% - var(--_end) + .5rem) 100%,calc(100% - var(--_end) + .5rem) 0)}.slider:has(>[disabled]):before{background:var(--outline-variant)}.slider:has([disabled]){opacity:.62}.slider>span>i{position:absolute;block-size:auto;inset:0 auto 0 .5rem;color:currentColor;z-index:1}.slider:not(.medium,.large,.extra)>span>i{display:none}.slider.vertical>i{transform:rotate(90deg)}.slider>.tooltip{visibility:hidden!important;opacity:0!important;inset:0 auto auto calc(100% - var(--_end));border-radius:2rem;transition:top var(--speed2) ease,opacity var(--speed2) ease;transform:translate(-50%,-25%)!important;padding:.75rem 1rem}.slider>.tooltip.bottom{inset:auto auto 0 calc(100% - var(--_end));transition:bottom var(--speed2) ease,opacity var(--speed2) ease;transform:translate(-50%,25%)!important}[dir=rtl] .slider>.tooltip{transform:translate(-50%,-25%) scaleX(-1)!important}[dir=rtl] .slider>.tooltip.bottom{transform:translate(-50%,25%) scaleX(-1)!important}.slider>.tooltip+.tooltip{inset:.25rem calc(100% - var(--_start)) auto auto;transform:translate(50%,-25%)!important}.slider>.tooltip+.tooltip.bottom{inset:auto calc(100% - var(--_start)) -.25rem auto;transform:translate(50%,25%)!important}[dir=rtl] .slider>.tooltip+.tooltip{transform:translate(50%,-25%) scaleX(-1)!important}[dir=rtl] .slider>.tooltip+.tooltip.bottom{transform:translate(50%,25%) scaleX(-1)!important}.slider>.tooltip:before{content:var(--_value1)}.slider>.tooltip+.tooltip:before{content:var(--_value2)}.slider>:focus~.tooltip{inset-block:-1rem auto;opacity:1!important;visibility:visible!important}.slider>:focus~.tooltip.bottom{inset-block:auto -1rem}.slider.vertical>.tooltip{inset-block:auto;block-size:2.5rem;inline-size:2.5rem;margin-block:calc(-1 * var(--_thumb)) 0!important;transform:rotate(90deg) translate(-75%,50%)!important}.slider.vertical>.tooltip.bottom{inset-block:auto;margin-block:0 calc(-1 * var(--_thumb))!important;transform:rotate(90deg) translate(75%,50%)!important}.slider.vertical>.tooltip+.tooltip{transform:rotate(90deg) translate(-75%,-50%)!important}.slider.vertical>.tooltip+.tooltip.bottom{transform:rotate(90deg) translate(75%,-50%)!important}:is(nav,.row,.field)>.slider:not(.circle,.small,.medium,.large){flex:auto}.slider.max,.slider.max.vertical,.slider.max>input,.slider.max.vertical>input{all:unset;margin:0!important;position:absolute;color:var(--primary);inset:0;border-radius:inherit;overflow:hidden;z-index:2;cursor:grab;inline-size:100%;block-size:100%}.slider.max:before{display:none}.slider.max.vertical>input{writing-mode:vertical-lr;transform:rotate(-180deg)}.slider.max>input::-webkit-slider-thumb{opacity:0;inline-size:1rem;block-size:100vh;transform:none!important}.slider.max>input::-moz-range-thumb{opacity:0;inline-size:1rem;block-size:100vh;transform:none!important}.slider.max>span{block-size:auto!important;inset:0 var(--_end) 0 var(--_start);clip-path:none;background:currentcolor;color:inherit;border-radius:0}.slider.max.vertical>span{inset:var(--_end) 0 var(--_start) 0}.slider>input:focus-visible::-webkit-slider-thumb{outline:.1875rem solid var(--primary);outline-offset:.25rem}.slider>input:focus-visible::-moz-range-thumb{outline:.1875rem solid var(--primary);outline-offset:.25rem}.slider.max>input:focus-visible{outline:.1875rem solid var(--primary);outline-offset:-.125rem}@media(pointer:coarse){.slider>:hover~.tooltip{inset-block:-1rem auto!important;opacity:1!important;visibility:visible!important}.slider>:hover~.tooltip.bottom{inset-block:auto -1rem!important}}.snackbar{position:fixed;inset:auto auto 6rem 50%;inline-size:80%;block-size:auto;z-index:200;visibility:hidden;display:flex;box-shadow:var(--elevate2);color:var(--inverse-on-surface);background-color:var(--inverse-surface);padding:1rem;cursor:pointer;text-align:start;align-items:center;border-radius:.25rem;gap:.5rem;transition:all var(--speed2);transform:translate(-50%,1rem);opacity:0}.snackbar.top{inset:6rem auto auto 50%}.snackbar:is(.active){visibility:visible;transform:translate(-50%);opacity:1}.snackbar:popover-open{visibility:visible;transform:translate(-50%);opacity:1}.snackbar>.max{flex:auto}@media only screen and (min-width:993px){.snackbar{inline-size:40%}}table{inline-size:100%;border-spacing:0;font-size:.875rem;text-align:start}.scroll>table,table :is(thead,tbody,tfoot,tr,th,td){background-color:inherit;color:inherit}:is(th,td){inline-size:auto;text-align:inherit;padding:.5rem;border-radius:0}:is(th,td)>*{vertical-align:middle}table.border>tbody>tr:not(:last-child)>td,thead>tr>th{border-block-end:.0625rem solid var(--outline)}tfoot>tr>th{border-block-start:.0625rem solid var(--outline)}table.stripes>tbody>tr:nth-child(odd){background-color:var(--active)}table.no-space :is(th,td){padding:0}table.medium-space :is(th,td){padding:.75rem}table.large-space :is(th,td){padding:1rem}table>.fixed,th.fixed{position:sticky;z-index:1;inset-block-start:0}tfoot.fixed,tfoot th.fixed{inset-block-end:0}:is(td,th).min{inline-size:.1%;white-space:nowrap}.tabs{display:flex;white-space:nowrap;border-block-end:.0625rem solid var(--surface-variant);border-radius:0}.tabs:not(.left-align,.right-align,.center-align){justify-content:space-around}.tabs>a{display:flex;font-size:.875rem;font-weight:500;color:var(--on-surface-variant);padding:.5rem 1rem;text-align:center;min-block-size:3rem;inline-size:100%;gap:.25rem}.tabs.small>a{min-block-size:2rem}.tabs.large>a{min-block-size:4rem}.tabs>a.active,.tabs>a.active>i{color:var(--primary)}.tabs>a.active:before{content:"";position:absolute;inset:auto 0 0;block-size:.125rem;background-color:var(--primary)}.tabs.min>a.active:before{margin:0 auto;max-inline-size:min(100%,4rem)}.tabs:is(.left-align,.center-align,.right-align)>a{inline-size:auto}.tooltip{--_space: -.5rem;visibility:hidden;display:flex;align-items:center;justify-content:center;gap:.5rem;background-color:var(--inverse-surface);color:var(--inverse-on-surface);font-size:.75rem;text-align:center;border-radius:.25rem;padding:.5rem;position:absolute;z-index:200;inset:0 auto auto 50%;inline-size:auto;white-space:nowrap;font-weight:500;opacity:0;transition:all var(--speed2);line-height:normal;transform:translate(-50%,-100%) scale(.9)}.tooltip:not(.max):hover{visibility:hidden;opacity:0}.tooltip.left{inset:50% auto auto 0;transform:translate(-100%,-50%) scale(.9)}.tooltip.right{inset:50% 0 auto auto;transform:translate(100%,-50%) scale(.9)}.tooltip.bottom{inset:auto auto 0 50%;transform:translate(-50%,100%) scale(.9)}.tooltip.small{inline-size:8rem;white-space:normal}.tooltip.medium{inline-size:12rem;white-space:normal}.tooltip.large{inline-size:16rem;white-space:normal}:hover>.tooltip{visibility:visible;opacity:1;transform:translate(-50%,-100%) scale(1)}:hover>.tooltip.left{transform:translate(-100%,-50%) scale(1)}:hover>.tooltip.right{transform:translate(100%,-50%) scale(1)}:hover>.tooltip.bottom{transform:translate(-50%,100%) scale(1)}.tooltip.no-space{--_space: 0}.tooltip.medium-space{--_space: -1rem}.tooltip.large-space{--_space: -1.5rem}.tooltip:not(.left,.right,.bottom){margin-block-start:var(--_space)!important}.tooltip.left,.tooltip.right{margin-inline:var(--_space)!important}.tooltip.bottom{margin-block-end:var(--_space)!important}menu:active~.tooltip,:is(button,.button):focus>menu~.tooltip,.field>:focus~menu~.tooltip{visibility:hidden}.slider>.tooltip{--_space: -1.25rem}.slider.vertical>.tooltip{--_space: -.75rem}.slider.vertical>.tooltip:is(.left,.right){--_space: -.5rem}.tooltip.max{display:block;font-size:inherit;white-space:normal;text-align:start;inline-size:20rem;border-radius:.5rem;padding:1rem;box-shadow:var(--elevate2)}:root{--eox-theme-light-background: 237, 237, 242;--eox-theme-light-code: 245, 245, 245;--eox-theme-light-error-container: 255, 218, 214;--eox-theme-light-error: 186, 26, 26;--eox-theme-light-inverse-on-surface: 240, 240, 245;--eox-theme-light-inverse-primary: 158, 202, 255;--eox-theme-light-inverse-surface: 46, 48, 52;--eox-theme-light-kbd: 33, 37, 41;--eox-theme-light-neutral-palette-key-color: 117, 119, 123;--eox-theme-light-neutral-variant-palette-key-color: 114, 119, 128;--eox-theme-light-on-background: 0, 0, 0;--eox-theme-light-on-code: 0, 0, 0;--eox-theme-light-on-error-container: 65, 0, 2;--eox-theme-light-on-error: 255, 255, 255;--eox-theme-light-on-inverse-on-surface: 0, 0, 0;--eox-theme-light-on-inverse-primary: 0, 0, 0;--eox-theme-light-on-inverse-surface: 255, 255, 255;--eox-theme-light-on-kbd: 255, 255, 255;--eox-theme-light-on-neutral-palette-key-color: 255, 255, 255;--eox-theme-light-on-neutral-variant-palette-key-color: 255, 255, 255;--eox-theme-light-on-outline-variant: 0, 0, 0;--eox-theme-light-on-outline: 255, 255, 255;--eox-theme-light-on-primary-container: 0, 29, 54;--eox-theme-light-on-primary-fixed-dim: 0, 0, 0;--eox-theme-light-on-primary-fixed-variant: 16, 73, 120;--eox-theme-light-on-primary-fixed: 0, 29, 54;--eox-theme-light-on-primary-palette-key-color: 255, 255, 255;--eox-theme-light-on-primary: 255, 255, 255;--eox-theme-light-on-scrim: 255, 255, 255;--eox-theme-light-on-secondary-container: 0, 31, 40;--eox-theme-light-on-secondary-fixed-dim: 0, 0, 0;--eox-theme-light-on-secondary-fixed-variant: 15, 77, 95;--eox-theme-light-on-secondary-fixed: 0, 31, 40;--eox-theme-light-on-secondary-palette-key-color: 255, 255, 255;--eox-theme-light-on-secondary: 255, 255, 255;--eox-theme-light-on-shadow: 255, 255, 255;--eox-theme-light-on-surface-bright: 0, 0, 0;--eox-theme-light-on-surface-container-high: 0, 0, 0;--eox-theme-light-on-surface-container-highest: 0, 0, 0;--eox-theme-light-on-surface-container-low: 0, 0, 0;--eox-theme-light-on-surface-container-lowest: 0, 0, 0;--eox-theme-light-on-surface-container: 0, 0, 0;--eox-theme-light-on-surface-dim: 0, 0, 0;--eox-theme-light-on-surface-light: 0, 0, 0;--eox-theme-light-on-surface-tint: 255, 255, 255;--eox-theme-light-on-surface: 26, 28, 31;--eox-theme-light-on-tertiary-container: 17, 19, 79;--eox-theme-light-on-tertiary-fixed-dim: 0, 0, 0;--eox-theme-light-on-tertiary-fixed-variant: 62, 65, 124;--eox-theme-light-on-tertiary-fixed: 17, 19, 79;--eox-theme-light-on-tertiary-palette-key-color: 255, 255, 255;--eox-theme-light-on-tertiary: 255, 255, 255;--eox-theme-light-outline-variant: 194, 199, 208;--eox-theme-light-outline: 114, 119, 128;--eox-theme-light-primary-container: 209, 228, 255;--eox-theme-light-primary-fixed-dim: 158, 202, 255;--eox-theme-light-primary-fixed: 209, 228, 255;--eox-theme-light-primary-palette-key-color: 0, 65, 112;--eox-theme-light-primary: 0, 65, 112;--eox-theme-light-scrim: 0, 0, 0;--eox-theme-light-secondary-container: 184, 234, 255;--eox-theme-light-secondary-fixed-dim: 154, 206, 228;--eox-theme-light-secondary-fixed: 184, 234, 255;--eox-theme-light-secondary-palette-key-color: 0, 69, 87;--eox-theme-light-secondary: 47, 101, 120;--eox-theme-light-shadow: 0, 0, 0;--eox-theme-light-surface-bright: 249, 249, 254;--eox-theme-light-surface-container-high: 231, 232, 236;--eox-theme-light-surface-container-highest: 226, 226, 231;--eox-theme-light-surface-container-low: 243, 243, 248;--eox-theme-light-surface-container-lowest: 255, 255, 255;--eox-theme-light-surface-container: 237, 237, 242;--eox-theme-light-surface-dim: 217, 218, 222;--eox-theme-light-surface-light: 231, 232, 236;--eox-theme-light-surface-tint: 49, 97, 146;--eox-theme-light-surface: 249, 249, 254;--eox-theme-light-tertiary-container: 225, 224, 255;--eox-theme-light-tertiary-fixed-dim: 191, 193, 255;--eox-theme-light-tertiary-fixed: 225, 224, 255;--eox-theme-light-tertiary-palette-key-color: 54, 57, 116;--eox-theme-light-tertiary: 86, 89, 150}:root{--eox-theme-dark-background: 30, 32, 35;--eox-theme-dark-code: 52, 52, 52;--eox-theme-dark-error-container: 147, 0, 10;--eox-theme-dark-error: 255, 180, 171;--eox-theme-dark-inverse-on-surface: 46, 48, 52;--eox-theme-dark-inverse-primary: 49, 97, 146;--eox-theme-dark-inverse-surface: 226, 226, 231;--eox-theme-dark-kbd: 33, 37, 41;--eox-theme-dark-neutral-palette-key-color: 117, 119, 123;--eox-theme-dark-neutral-variant-palette-key-color: 114, 119, 128;--eox-theme-dark-on-background: 255, 255, 255;--eox-theme-dark-on-code: 204, 204, 204;--eox-theme-dark-on-error-container: 255, 180, 171;--eox-theme-dark-on-error: 105, 0, 5;--eox-theme-dark-on-inverse-on-surface: 255, 255, 255;--eox-theme-dark-on-inverse-primary: 158, 202, 255;--eox-theme-dark-on-inverse-surface: 0, 0, 0;--eox-theme-dark-on-kbd: 255, 255, 255;--eox-theme-dark-on-neutral-palette-key-color: 255, 255, 255;--eox-theme-dark-on-neutral-variant-palette-key-color: 255, 255, 255;--eox-theme-dark-on-outline-variant: 255, 255, 255;--eox-theme-dark-on-outline: 255, 255, 255;--eox-theme-dark-on-primary-container: 209, 228, 255;--eox-theme-dark-on-primary-fixed-dim: 0, 0, 0;--eox-theme-dark-on-primary-fixed-variant: 16, 73, 120;--eox-theme-dark-on-primary-fixed: 0, 29, 54;--eox-theme-dark-on-primary-palette-key-color: 255, 255, 255;--eox-theme-dark-on-primary: 0, 50, 88;--eox-theme-dark-on-scrim: 255, 255, 255;--eox-theme-dark-on-secondary-container: 184, 234, 255;--eox-theme-dark-on-secondary-fixed-dim: 0, 0, 0;--eox-theme-dark-on-secondary-fixed-variant: 15, 77, 95;--eox-theme-dark-on-secondary-fixed: 0, 31, 40;--eox-theme-dark-on-secondary-palette-key-color: 255, 255, 255;--eox-theme-dark-on-secondary: 0, 53, 68;--eox-theme-dark-on-shadow: 255, 255, 255;--eox-theme-dark-on-surface-bright: 255, 255, 255;--eox-theme-dark-on-surface-container-high: 255, 255, 255;--eox-theme-dark-on-surface-container-highest: 255, 255, 255;--eox-theme-dark-on-surface-container-low: 255, 255, 255;--eox-theme-dark-on-surface-container-lowest: 255, 255, 255;--eox-theme-dark-on-surface-container: 255, 255, 255;--eox-theme-dark-on-surface-dim: 255, 255, 255;--eox-theme-dark-on-surface-light: 255, 255, 255;--eox-theme-dark-on-surface-tint: 0, 0, 0;--eox-theme-dark-on-surface: 226, 226, 231;--eox-theme-dark-on-tertiary-container: 225, 224, 255;--eox-theme-dark-on-tertiary-fixed-dim: 0, 0, 0;--eox-theme-dark-on-tertiary-fixed-variant: 62, 65, 124;--eox-theme-dark-on-tertiary-fixed: 17, 19, 79;--eox-theme-dark-on-tertiary-palette-key-color: 255, 255, 255;--eox-theme-dark-on-tertiary: 39, 42, 100;--eox-theme-dark-outline-variant: 66, 71, 79;--eox-theme-dark-outline: 140, 145, 154;--eox-theme-dark-primary-container: 16, 73, 120;--eox-theme-dark-primary-fixed-dim: 158, 202, 255;--eox-theme-dark-primary-fixed-variant: 209, 228, 255;--eox-theme-dark-primary-fixed: 209, 228, 255;--eox-theme-dark-primary-palette-key-color: 0, 65, 112;--eox-theme-dark-primary: 158, 202, 255;--eox-theme-dark-scrim: 0, 0, 0;--eox-theme-dark-secondary-container: 15, 77, 95;--eox-theme-dark-secondary-fixed-dim: 154, 206, 228;--eox-theme-dark-secondary-fixed-variant: 184, 234, 255;--eox-theme-dark-secondary-fixed: 184, 234, 255;--eox-theme-dark-secondary-palette-key-color: 0, 69, 87;--eox-theme-dark-secondary: 154, 206, 228;--eox-theme-dark-shadow: 0, 0, 0;--eox-theme-dark-surface-bright: 55, 57, 61;--eox-theme-dark-surface-container-high: 40, 42, 46;--eox-theme-dark-surface-container-highest: 51, 53, 56;--eox-theme-dark-surface-container-low: 26, 28, 31;--eox-theme-dark-surface-container-lowest: 12, 14, 17;--eox-theme-dark-surface-container: 30, 32, 35;--eox-theme-dark-surface-dim: 17, 19, 23;--eox-theme-dark-surface-light: 55, 57, 61;--eox-theme-dark-surface-tint: 158, 202, 255;--eox-theme-dark-surface: 17, 19, 23;--eox-theme-dark-tertiary-container: 62, 65, 124;--eox-theme-dark-tertiary-fixed-dim: 191, 193, 255;--eox-theme-dark-tertiary-fixed-variant: 225, 224, 255;--eox-theme-dark-tertiary-fixed: 225, 224, 255;--eox-theme-dark-tertiary-palette-key-color: 54, 57, 116;--eox-theme-dark-tertiary: 191, 193, 255}:root{--eox-slider-thumb-height: 20px;--eox-slider-thumb-width: 20px;--eox-slider-track-height: 6px;--eox-slider-track-color: var(--outline-variant);--eox-slider-brightness-hover: 100%;--eox-slider-brightness-down: 100%;--eox-slider-clip-edges: 4px;--eox-slider-margin: 1.125rem}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input){font-size:1.5rem;color:var(--primary);width:100%;background:none;overflow:hidden}input[type=range]:not(.slider input[type=range]){margin:var(--eox-slider-margin);width:100%}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input):active{cursor:grabbing}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input):disabled{filter:grayscale(1);opacity:.3;cursor:not-allowed}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input),input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-webkit-slider-runnable-track,input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-webkit-slider-thumb{-webkit-appearance:none;transition:all ease .1s;height:var(--eox-slider-thumb-height)}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-webkit-slider-runnable-track,input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-webkit-slider-thumb{position:relative}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-webkit-slider-runnable-track{border-radius:var(--eox-slider-track-height)}input[type=range]:not(.slider input)::-webkit-slider-thumb{--thumb-radius: calc((var(--eox-slider-thumb-height) * .5) - 1px);--clip-top: calc( (var(--eox-slider-thumb-height) - var(--eox-slider-track-height)) * .5 - .5px );--clip-bottom: calc(var(--eox-slider-thumb-height) - var(--clip-top));--clip-further: calc(100% + 1px) ;--box-fill: calc( -100vmax - var(--eox-slider-thumb-width, var(--eox-slider-thumb-height)) ) 0 0 100vmax currentColor;width:var(--eox-slider-thumb-width, var(--eox-slider-thumb-height));background:linear-gradient(currentColor 0 0) scroll no-repeat left center / 50% calc(var(--eox-slider-track-height) + 1px);background-color:currentColor;box-shadow:var(--box-fill);border-radius:var(--eox-slider-thumb-width, var(--eox-slider-thumb-height));filter:brightness(100%);clip-path:polygon(100% -1px,var(--eox-slider-clip-edges) -1px,0 var(--clip-top),-100vmax var(--clip-top),-100vmax var(--clip-bottom),0 var(--clip-bottom),var(--eox-slider-clip-edges) 100%,var(--clip-further) var(--clip-further))}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input):hover::-webkit-slider-thumb{filter:brightness(var(--eox-slider-brightness-hover));cursor:grab}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input):active::-webkit-slider-thumb{filter:brightness(var(--eox-slider-brightness-down));cursor:grabbing}input[type=range]:not(.slider input)::-webkit-slider-runnable-track{background:linear-gradient(var(--eox-slider-track-color) 0 0) scroll no-repeat center / 100% calc(var(--eox-slider-track-height) + 1px)}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input):disabled::-webkit-slider-thumb{cursor:not-allowed}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input),input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-moz-range-track,input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-moz-range-thumb{-webkit-appearance:none;-moz-appearance:none;appearance:none;transition:all ease .1s;height:var(--eox-slider-thumb-height)}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-moz-range-track,input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-moz-range-thumb,input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-moz-range-progress{background:#fff0}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-moz-range-thumb{background:currentColor;border:0;width:var(--eox-slider-thumb-width, var(--eox-slider-thumb-height));border-radius:var(--eox-slider-thumb-width, var(--eox-slider-thumb-height));cursor:grab}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input):active::-moz-range-thumb{cursor:grabbing}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-moz-range-track{width:100%;background:var(--eox-slider-track-color)}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-moz-range-progress{-webkit-appearance:none;-moz-appearance:none;appearance:none;background:currentColor;transition-delay:30ms}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-moz-range-track,input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-moz-range-progress{height:calc(var(--eox-slider-track-height) + 1px);border-radius:var(--eox-slider-track-height)}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-moz-range-thumb,input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input)::-moz-range-progress{filter:brightness(100%)}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input):hover::-moz-range-thumb,input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input):hover::-moz-range-progress{filter:brightness(var(--eox-slider-brightness-hover))}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input):active::-moz-range-thumb,input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input):active::-moz-range-progress{filter:brightness(var(--eox-slider-brightness-down))}input[type=range]:not(.slider.large input,.slider.small input,.slider.medium input,.slider.extra input):disabled::-moz-range-thumb{cursor:not-allowed}label.slider.tiny:before{height:var(--eox-slider-track-height);background:var(--outline-variant);clip-path:none}label.slider.tiny>span,.slider.tiny>input[type=range]+input[type=range]~span{height:var(--eox-slider-track-height);top:var(--eox-slider-track-height) - 1;clip-path:none}.slider.tiny>input[type=range]::-webkit-slider-thumb{box-shadow:unset;width:var(--eox-slider-thumb-width, var(--eox-slider-thumb-height));border-radius:var(--eox-slider-thumb-width, var(--eox-slider-thumb-height))}.slider.tiny>input[type=range]::-webkit-slider-runnable-track{background:unset}.slider.tiny>input[type=range]:not(:disabled):is(:focus)::-webkit-slider-thumb{transform:scaleX(1)}.slider.tiny>input:not(:disabled):is(:focus)::-moz-range-thumb{transform:scaleX(1)}tc-range-slider{--panel-bg-fill: var(--primary);--pointer-bg: var(--primary);--pointer-bg-focus: var(--primary);--pointer-bg-hover: var(--primary);--pointer-border: 0;--pointer-border-focus: 0;--pointer-border-hover: 0;--pointer-width: var( --eox-slider-thumb-width, var(--eox-slider-thumb-height) );--pointer-height: var( --eox-slider-thumb-width, var(--eox-slider-thumb-height) );--pointer-shadow: 0;--pointer-shadow-hover: 0;--height: var(--eox-slider-track-height);--width: 100%;--panel-bg-border-radius: var(--eox-slider-track-height);--panel-bg: var(--eox-slider-track-color);--panel-bg-hover: var(--eox-slider-track-color);display:block;margin:var(--eox-slider-margin)}:root{--eox-body-font-family: Inter, Roboto, "Helvetica Neue", "Arial Nova", "Nimbus Sans", Noto Sans, Arial, sans-serif;--eox-header-font-family: var(--eox-body-font-family);--size: 1rem;--font: var(--eox-body-font-family);--font-icon: "Material Symbols Subset";--speed1: .1s;--speed2: .2s;--speed3: .3s;--speed4: .4s;--active: rgb(128 128 128 / .192);--overlay: rgb(0 0 0 / .5);--elevate1: 0 .125rem .125rem 0 rgb(0 0 0 / .32);--elevate2: 0 .25rem .5rem 0 rgb(0 0 0 / .4);--elevate3: 0 .375rem .75rem 0 rgb(0 0 0 / .48);--top: env(safe-area-inset-top);--bottom: env(safe-area-inset-bottom);--left: env(safe-area-inset-left);--right: env(safe-area-inset-right)}*{font-family:var(--eox-body-font-family)}h1,h2,h3,h4,h5,h6{font-family:var(--eox-header-font-family)}:root,body.light{--primary: rgb(var(--eox-theme-light-primary));--on-primary: rgb(var(--eox-theme-light-on-primary));--primary-container: rgb(var(--eox-theme-light-primary-container));--on-primary-container: #001d36;--secondary: rgb(var(--eox-theme-light-secondary));--on-secondary: rgb(var(--eox-theme-light-on-secondary));--secondary-container: #d7e3f7;--on-secondary-container: #101c2b;--tertiary: rgb(var(--eox-theme-light-tertiary));--on-tertiary: rgb(var(--eox-theme-light-on-tertiary));--tertiary-container: #f2daff;--on-tertiary-container: #251431;--error: rgb(var(--eox-theme-light-error));--on-error: rgb(var(--eox-theme-light-on-error));--error-container: #ffdad6;--on-error-container: #410002;--background: rgb(var(--eox-theme-light-background));--on-background: #1a1c1e;--surface: rgb(var(--eox-theme-light-surface));--on-surface: rgb(var(--eox-theme-light-on-surface));--surface-variant: #dfe2eb;--on-surface-variant: #43474e;--outline: rgb(var(--eox-theme-light-outline));--outline-variant: rgb(var(--eox-theme-light-outline-variant));--shadow: #000000;--scrim: #000000;--inverse-surface: #2f3033;--inverse-on-surface: #f1f0f4;--inverse-primary: #9ecaff;--surface-dim: rgb(var(--eox-theme-light-surface-dim));--surface-bright: rgb(var(--eox-theme-light-surface-bright));--surface-container-lowest: #ffffff;--surface-container-low: #f4f3f7;--surface-container: #eeedf1;--surface-container-high: #e8e8eb;--surface-container-highest: #e2e2e6}body.dark{--primary: rgb(var(--eox-theme-dark-primary));--on-primary: rgb(var(--eox-theme-dark-on-primary));--primary-container: rgb(var(--eox-theme-dark-primary-container));--on-primary-container: #d1e4ff;--secondary: rgb(var(--eox-theme-dark-secondary));--secondary-container: #3b4858;--on-secondary-container: #d7e3f7;--on-secondary-container: rgb(var(--eox-theme-dark-on-secondary-container));--tertiary: rgb(var(--eox-theme-dark-tertiary));--on-tertiary: rgb(var(--eox-theme-dark-on-tertiary));--tertiary-container: #523f5f;--on-tertiary-container: #f2daff;--error: rgb(var(--eox-theme-dark-error));--on-error: rgb(var(--eox-theme-dark-on-error));--error-container: #93000a;--on-error-container: #ffb4ab;--background: rgb(var(--eox-theme-dark-background));--on-background: #e2e2e6;--surface: rgb(var(--eox-theme-dark-surface));--on-surface: rgb(var(--eox-theme-dark-on-surface));--surface-variant: #43474e;--on-surface-variant: #c3c7cf;--outline: rgb(var(--eox-theme-dark-outline));--outline-variant: rgb(var(--eox-theme-dark-outline-variant));--shadow: #000000;--scrim: #000000;--inverse-surface: #e2e2e6;--inverse-on-surface: #2f3033;--inverse-primary: #0161a3;--surface-dim: rgb(var(--eox-theme-dark-surface-dim));--surface-bright: rgb(var(--eox-theme-dark-surface-bright));--surface-container-lowest: #0d0e11;--surface-container-low: #1a1c1e;--surface-container: #1e2022;--surface-container-high: #282a2d;--surface-container-highest: #333538}.list.no-space>li,.list.no-space>li>details>summary{min-block-size:0rem;padding:0 1rem}:is(.checkbox,.radio,.switch).small{--_size: 1.2rem}:is(.checkbox,.radio):is(:hover)>input:not(:disabled)+span:after,:is(.checkbox,.radio)>input:not(:disabled):is(:focus)+span:after{box-shadow:0 0 0 .4rem currentColor}:is(.checkbox,.radio,.switch):is(.no-round,.square)>span:before,:is(.checkbox,.radio,.switch):is(.no-round,.square)>span>i,:is(.checkbox,.radio):is(.no-round,.square)>span:after{border-radius:.15rem}.scroll::-webkit-scrollbar,.scroll::-webkit-scrollbar-thumb,.scroll::-webkit-scrollbar-button{background:none;inline-size:.4rem;block-size:.4rem}.scroll:is(:hover,:focus)::-webkit-scrollbar-thumb{background:var(--outline);border-radius:1rem}h1.tiny{font-size:2.6875rem}h2.tiny{font-size:1.9375rem}h3.tiny{font-size:1.375rem}h4.tiny{font-size:1.125rem}h5.tiny{font-size:.875rem}h6.tiny{font-size:.625rem}.link{text-decoration:underline}.link:hover{color:var(--on-primary-container)!important}`, Vx = () => {
  const i = "eox-elements";
  if (!document.head.querySelector(`style#${i}`)) {
    const t = new CSSStyleSheet();
    t.replaceSync(R3);
    const e = Array.from(t.cssRules).filter((r) => r.cssText.includes(":root")).map((r) => r.cssText).join(" "), n = document.createElement("style");
    n.setAttribute("id", i), n.innerHTML = `
    @import url("https://eox.at/fonts/inter/inter.css");

    @font-face {
      font-family: "Material Symbols Subset";
      font-style: normal;
      font-weight: 400;
      font-display: block;
      src: url(https://cdn.jsdelivr.net/npm/@eox/ui@0.3.4/dist/material-symbols-subset.woff2) format("woff2");
    }
  
    eox-chart,
    eox-drawtools,
    eox-feedback,
    eox-geosearch,
    eox-itemfilter,
    eox-jsonform,
    eox-layercontrol,
    eox-map,
    eox-stacinfo,
    eox-storytelling,
    eox-timecontrol {
      font-family: var(--font);
      font-size: .875rem;
      line-height: 1.5rem;
      letter-spacing: .0313rem;
    }
    ${e}
  `, document.head.appendChild(n);
  }
}, $x = (i) => {
  let t;
  if (typeof i == "string") {
    const e = (n) => (
      /** @type {HTMLElement} */
      n.querySelector(i)
    );
    if (t = e(document), !t) {
      const n = document.querySelectorAll("html *");
      for (let r = 0; r < n.length && !(n[r].shadowRoot && (t = e(n[r].shadowRoot), t)); r++)
        ;
    }
  } else
    t = i;
  return t;
};
function Wx(i, t) {
  let e;
  const n = i?.length && Qy(i, t.map.getView().getCenter());
  return i && !n && (!t.projection || t.projection === "EPSG:3857" ? e = n3(i) : e = i), e;
}
function Yx(i, t) {
  if (!i || !i.length) return;
  const e = t.map.getView();
  return ru(e), setTimeout(() => e.fit(i, t.animationOptions), 0), i;
}
function Xx(i, t, e) {
  const n = (
    /** @type {ControlDictionary} **/
    i
  );
  if (t) {
    const r = (
      /** @type {ControlType[]} **/
      Object.keys(t)
    ), s = (
      /** @type {ControlType[]} **/
      Object.keys(n)
    );
    for (let o = 0, a = r.length; o < a; o++) {
      const l = r[o];
      s.includes(l) || e.removeControl(l);
    }
  }
  if (n) {
    const r = (
      /** @type {ControlType[]} **/
      Object.keys(i)
    );
    for (let s = 0, o = r.length; s < o; s++) {
      const a = r[s];
      Bx(e, t, a, i[a]);
    }
  }
  return n;
}
function Zx(i) {
  return JSON.parse(JSON.stringify(i)).reverse();
}
function Hx(i, t, e) {
  const n = Zx(i);
  t && t.forEach((l) => {
    if (!l.properties?.id || !n.find(
      (h) => h.properties.id === l.properties.id
    )) {
      const h = ch(e, l.properties?.id);
      h.get("_jsonDefinition").interactions?.forEach(
        /** @param {{type: string, options: { id: string}}} interaction  **/
        (u) => {
          u.type === "select" ? e.removeSelect(u.options.id) : e.removeInteraction(u.options.id);
        }
      ), e.map.removeLayer(h);
    }
  }), n.forEach((l) => {
    e.addOrUpdateLayer(l);
  });
  const r = n.map((l) => l.properties?.id);
  e.map.getLayers().getArray().sort((l, h) => r.indexOf(l.get("id")) - r.indexOf(h.get("id")));
  let s = e.map.getLayers().getArray().reduce(
    /**
     * @param {MinMaxZoom} acc
     * @param {EoxLayer} val
     * @returns {MinMaxZoom}
     */
    /** @type {EoxLayer[]} */
    (l, h) => (l.maxZoom = e.config?.view?.maxZoom ? e.config?.view?.maxZoom : l.maxZoom === void 0 || h.get("maxZoom") < l.maxZoom ? h.get("maxZoom") : l.maxZoom, l.minZoom = e.config?.view?.minZoom ? e.config?.view?.minZoom : l.minZoom === void 0 || h.get("minZoom") > l.minZoom ? h.get("minZoom") : l.minZoom, l),
    { minZoom: 0, maxZoom: 1 / 0 }
  );
  e.map.getLayers().getArray().map((l) => l.setMinZoom(l.get("minZoom") - 1e-12));
  const o = e.map.getView().getMinZoom(), a = e.map.getView().getMaxZoom();
  return o !== s.minZoom && e.map.getView().setMinZoom(s.minZoom >= 0 ? s.minZoom : 0), a !== s.maxZoom && e.map.getView().setMaxZoom(s.maxZoom), e.map.on("moveend", () => {
    if (!e?.controls?.Zoom) return;
    const l = e.renderRoot.querySelector("button.ol-zoom-out"), h = e.renderRoot.querySelector("button.ol-zoom-in");
    e.map.getView().getZoom() >= s.maxZoom ? h?.classList.add("disabled") : h?.classList.remove("disabled"), e.map.getView().getZoom() - 1e-12 <= s.minZoom ? l?.classList.add("disabled") : l?.classList.remove("disabled");
  }), n;
}
function Kx(i, t) {
  return i ? (Jy(t.map), qc(t.map, !0)) : qc(t.map), i;
}
function qx(i, t) {
  return Object.assign(t, {
    // Update animation options if provided in the configuration
    ...i?.animationOptions !== void 0 ? { animationOptions: i.animationOptions } : {},
    // Set the map's projection, defaulting to 'EPSG:3857' if not specified
    projection: i?.view?.projection || "EPSG:3857",
    // Set the layers, controls, and other map properties from the configuration
    layers: i?.layers || [],
    controls: i?.controls || {},
    // Set the scroll prevention option if it has not been defined yet
    ...i?.preventScroll !== void 0 && t.preventScroll === void 0 ? { preventScroll: i?.preventScroll } : {},
    // Set the zoom, center, minZoom, maxZoom and zoom extent of the map view
    zoom: i?.view?.zoom || 0,
    center: i?.view?.center || [0, 0],
    zoomExtent: i?.view?.zoomExtent
  }), i?.view?.minZoom && t.map.getView().setMinZoom(i?.view?.minZoom), i?.view?.maxZoom && t.map.getView().setMaxZoom(i?.view?.maxZoom), i;
}
function Jx(i, t, e) {
  let n = t;
  const r = e.map.getView();
  if (i && tt(i) && i !== r.getProjection().getCode()) {
    const s = tn(
      r.getCenter(),
      r.getProjection().getCode(),
      i
    ), o = tt(i), a = r.getResolution(), l = r.getProjection().getMetersPerUnit(), h = o.getMetersPerUnit(), c = Lr(
      r.getProjection(),
      1 / l,
      r.getCenter(),
      "m"
    ) * l, d = Lr(o, 1 / h, s, "m") * h, u = a * c / d, f = new Se({
      zoom: r.getZoom(),
      center: s,
      resolution: u,
      rotation: r.getRotation(),
      projection: i
    });
    [
      "change:center",
      "change:resolution",
      "change:rotation",
      "propertychange"
    ].forEach((p) => {
      const m = r.getListeners(p);
      if (m?.length)
        for (let _ = m.length - 1; _ >= 0; _--) {
          const y = (
            /** @type {any} **/
            m[_]
          );
          r.un(p, y), f.on(p, y);
        }
    }), e.map.setView(f), e.getFlatLayersArray(e.map.getLayers().getArray()).filter((p) => p instanceof yi).forEach(
      (p) => (
        /** @type {import("ol/layer").Vector} */
        p.getSource().refresh()
      )
    ), n = i, e.center = s;
  }
  return n;
}
function Qx(i, t) {
  return i && setTimeout(() => {
    const e = (
      /** @type {import("../../main").EOxMap} **/
      /** @type {any} **/
      $x(i)
    );
    e && (t.clientHeight < 1 && !e.zoom ? e.map.setView(t.map.getView()) : t.map.setView(e.map.getView()));
  }), i;
}
function tC(i) {
  return i.projection === "EPSG:4326" ? i.map.getView().getCenter() : e3(i.map.getView().getCenter(), i.projection);
}
function eC(i) {
  const t = i.map.getView().calculateExtent(i.map.getSize());
  return i.projection === "EPSG:4326" ? t : i3(t, i.projection);
}
function iC(i) {
  return i.map.getView().calculateExtent(i.map.getSize());
}
function nC(i, t) {
  i.interactions || (i.interactions = []);
  const e = i.properties?.id, n = e ? ch(t, e) : !1;
  let r;
  return n ? (E3(t, i, n), r = n) : (r = Dr(t, i), t.map.addLayer(r)), r;
}
function rC(i, t) {
  t.map.removeInteraction(t.interactions[i]), delete t.interactions[i], t.interactions[`${i}_modify`] && (t.map.removeInteraction(t.interactions[`${i}_modify`]), delete t.interactions[`${i}_modify`]);
}
function sC(i, t) {
  t.selectInteractions[i].remove(), delete t.selectInteractions[i];
}
function oC(i, t) {
  t.map.removeControl(t.mapControls[i]), delete t.mapControls[i];
}
function aC(i, t) {
  t.map.once("change:target", (e) => {
    e.target.getView().setCenter(t.center);
  }), t.map.setTarget(t.renderRoot.querySelector("div")), i ? t.map.getView().fit(i, t.animationOptions) : Za(t), t.map.on("loadend", () => {
    t.dispatchEvent(new CustomEvent("loadend", { detail: t.map }));
  }), t.dispatchEvent(new CustomEvent("mapmounted", { detail: t.map }));
}
Vx();
class lC extends bn {
  // Define static properties for the component
  static get properties() {
    return {
      map: { attribute: !1, state: !0 },
      config: { attribute: !1, type: Object },
      center: { attribute: !1, type: Array },
      layers: { attribute: !1, type: Array },
      zoom: { attribute: !1, type: Number },
      animationOptions: { attribute: !1, type: Object },
      controls: { attribute: !1, type: Object },
      interactions: { attribute: !1, type: Object },
      lonLatCenter: { attribute: !1, type: Array },
      lonLatExtent: { attribute: !1, type: Array },
      mapControls: { attribute: !1, state: !0, type: Object },
      preventScroll: { attribute: "prevent-scroll", type: Boolean },
      projection: { attribute: "projection", type: String },
      selectInteractions: { attribute: !1, state: !0, type: Object },
      sync: { attribute: "sync", type: String },
      zoomExtent: { attribute: !1, type: Array }
    };
  }
  /**
   * The current zoom extent of the map.
   * This is used to define the maximum and minimum zoom levels.
   *
   * @type {import("ol/extent").Extent}
   */
  #t;
  /**
   * Stores the controls applied to the map, such as zoom and navigation tools.
   *
   * @type {ControlDictionary}
   */
  #n;
  /**
   * The array of layers currently added to the map.
   *
   * @type {Array<EoxLayer>}
   */
  #e;
  /**
   * Indicates whether the map's scroll interactions (zooming, panning) are prevented.
   *
   * @type {boolean}
   */
  #s;
  /**
   * Holds the configuration object for initializing and managing the map's settings.
   *
   * @type {ConfigObject}
   */
  #i;
  /**
   * Options for animating changes to the map's view, such as panning or zooming.
   *
   * @type {EOxAnimationOptions}
   */
  #a;
  /**
   * Represents the sync state of the map with another map instance.
   *
   * @type {string}
   */
  #r;
  /**
   * The current center coordinates of the map.
   * Stored as an array of two numbers representing the x and y coordinates.
   *
   * @type {Array<number>}
   */
  #l = [0, 0];
  /**
   * The current zoom level of the map.
   *
   * @type {number}
   */
  #o = 0;
  /**
   * The map's projection system, specifying how coordinates are mapped on the globe.
   * Defaults to "EPSG:3857".
   *
   * @type {ProjectionLike}
   */
  #h = "EPSG:3857";
  constructor() {
    super(), this.map = new zd({
      controls: [],
      interactions: md({
        altShiftDragRotate: !1,
        pinchRotate: !1
      }),
      layers: [],
      view: new Se({
        center: [0, 0],
        zoom: 0,
        projection: this.projection
      })
    }), this.interactions = {}, this.selectInteractions = {}, this.mapControls = {};
  }
  /**
   * Sets the center of the map. If the new center is valid, updates the map's view.
   *
   * @param {Array<number>} center - The new center coordinates [x, y].
   */
  set center(t) {
    const e = Wx(t, this);
    e !== void 0 && (this.#l = e, Za(this));
  }
  /**
   * Gets the current center coordinates of the map.
   *
   * @type {Array<number>}
   * @returns {Array<number>} The current center of the map.
   */
  get center() {
    return this.#l;
  }
  /**
   * Sets the configuration for the map.
   *
   * @param {ConfigObject} config - The configuration object.
   */
  set config(t) {
    this.#i = qx(t, this);
  }
  /**
   * Gets the current configuration of the map.
   *
   * @type {ConfigObject}
   * @returns {ConfigObject} The map's configuration object.
   */
  get config() {
    return this.#i;
  }
  /**
   * Gets the current center of the map in longitude and latitude.
   *
   * @type {Array<number>}
   * @returns {Array<number>} The geographic center [longitude, latitude].
   */
  get lonLatCenter() {
    return tC(this);
  }
  /**
   * Gets the current extent of the map in longitude and latitude.
   *
   * @type {Array<number>}
   * @returns {Array<number>} The geographic extent [minLon, minLat, maxLon, maxLat].
   */
  get lonLatExtent() {
    return eC(this);
  }
  /**
   * Sets the zoom level of the map and animates the change.
   *
   * @param {number} zoom - The new zoom level.
   */
  set zoom(t) {
    t !== void 0 && (this.#o = t, Za(this));
  }
  /**
   * Gets the current zoom level of the map.
   *
   * @type {number}
   * @returns {number} The current zoom level.
   */
  get zoom() {
    return this.#o;
  }
  /**
   * Sets the zoom extent of the map.
   *
   * @param {import("ol/extent").Extent} extent - The new zoom extent.
   */
  set zoomExtent(t) {
    this.#t = Yx(t, this);
  }
  /**
   * Gets the current extent of the map.
   *
   * @type {Array<number>}
   * @returns {Array<number>} The extent in current map projection.
   */
  get zoomExtent() {
    return iC(this);
  }
  /**
   * Sets the controls for the map.
   *
   * @param {ControlDictionary} controls - An array of control configurations.
   */
  set controls(t) {
    this.#n = Xx(t, this.#n, this);
  }
  /**
   * Gets the current map controls.
   *
   * @type {ControlDictionary}
   * @returns {ControlDictionary} The current controls applied to the map.
   */
  get controls() {
    return this.#n;
  }
  /**
   * Sets the layers for the map.
   *
   * @param {Array<EoxLayer>} layers - An array of layer configurations.
   */
  set layers(t) {
    this.#e = Hx(t, this.#e, this);
  }
  /**
   * Gets the current layers of the map
   *
   * @returns {Array<EoxLayer>} The current layers applied to the map.
   */
  get layers() {
    return this.#e;
  }
  /**
   * Enables or disables scroll interactions on the map.
   *
   * @param {boolean} preventScroll - Whether to prevent scroll interactions.
   */
  set preventScroll(t) {
    this.#s = Kx(t, this);
  }
  /**
   * Gets the current scroll interaction state.
   *
   * @type {boolean}
   * @returns {boolean} `true` if scroll interactions are prevented, `false` otherwise.
   */
  get preventScroll() {
    return this.#s;
  }
  /**
   * Sets animation options for map view changes.
   *
   * @param {EOxAnimationOptions} animationOptions - The animation options.
   */
  set animationOptions(t) {
    this.#a = t;
  }
  /**
   * Gets the current animation options.
   *
   * @type {EOxAnimationOptions}
   * @returns {EOxAnimationOptions} The current animation options for the map.
   */
  get animationOptions() {
    return this.#a;
  }
  /**
   * Sets the map's projection.
   *
   * @param {ProjectionLike} projection - The projection code (e.g., "EPSG:3857").
   */
  set projection(t) {
    this.#h = Jx(t, this.#h, this);
  }
  /**
   * Gets the current map projection.
   *
   * @type {ProjectionLike}
   * @returns {ProjectionLike} The map's projection code.
   */
  get projection() {
    return this.#h || "EPSG:3857";
  }
  /**
   * Sets the sync state for the map.
   *
   * @param {string} sync - The ID of the map to sync with.
   */
  set sync(t) {
    this.#r = Qx(t, this);
  }
  /**
   * Gets the current sync state of the map.
   *
   * @type {string}
   * @returns {string} The ID of the map that this map is synced with.
   */
  get sync() {
    return this.#r;
  }
  /**
   * Adds or updates a layer on the map.
   *
   * @param {EoxLayer} json - The layer configuration in JSON format.
   * @returns {Object} The added or updated layer.
   */
  addOrUpdateLayer(t) {
    return nC(t, this);
  }
  /**
   * Removes an interaction from the map by its ID.
   *
   * @param {string | number} id - The ID of the interaction to remove.
   */
  removeInteraction(t) {
    rC(t, this);
  }
  /**
   * Removes a select interaction from the map by its ID.
   *
   * @param {string | number} id - The ID of the select interaction to remove.
   */
  removeSelect(t) {
    sC(t, this);
  }
  /**
   * Removes a control from the map by its ID.
   *
   * @param {string} id - The ID of the control to remove.
   */
  removeControl(t) {
    oC(t, this);
  }
  /**
   * Retrieves a layer from the map by its ID.
   *
   * @param {string} layerId - The ID of the layer to retrieve.
   * @returns {AnyLayerWithSource} The layer object.
   */
  getLayerById(t) {
    return ch(this, t);
  }
  /**
   * Lifecycle method called after the component's first update.
   * Sets up initial configurations like zoom extent.
   */
  firstUpdated() {
    aC(this.#t, this);
  }
  /**
   * Parses a feature from the input data.
   *
   * @type {Function}
   */
  parseFeature = qy;
  /**
   * Parses text into a feature.
   */
  parseTextToFeature = D8;
  /**
   * Registers a projection from an EPSG code.
   */
  registerProjectionFromCode = Ky;
  /**
   * Registers a custom projection.
   */
  registerProjection = Hy;
  /**
   * Retrieves all layers in a flat array.
   */
  getFlatLayersArray = M3;
  /**
   * Transforms coordinates between different projections.
   */
  transform = e3;
  /**
   * Transforms the extent between different projections.
   */
  transformExtent = i3;
  /**
   * Applies a buffer around an extent.
   */
  buffer = Ie;
  // Renders the component's HTML template
  render() {
    return gn`
      <style>
        :host {
          display: block;
        }
        .eox-map-tooltip {
          pointer-events: none !important;
        }
        ${T4}
        ${R3}
        ${f9}
      </style>
      <div style="width: 100%; height: 100%"></div>
      <slot></slot>
    `;
  }
}
customElements.define("eox-map", lC);
export {
  lC as EOxMap
};
