const xa = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
}, le = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
class Da {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
function wT(i, e, t) {
  let n, r;
  t = t || lr;
  let s = 0, o = i.length, a = !1;
  for (; s < o; )
    n = s + (o - s >> 1), r = +t(i[n], e), r < 0 ? s = n + 1 : (o = n, a = !r);
  return a ? s : ~s;
}
function lr(i, e) {
  return i > e ? 1 : i < e ? -1 : 0;
}
function dE(i, e) {
  return i < e ? 1 : i > e ? -1 : 0;
}
function ff(i, e, t) {
  if (i[0] <= e)
    return 0;
  const n = i.length;
  if (e <= i[n - 1])
    return n - 1;
  if (typeof t == "function") {
    for (let r = 1; r < n; ++r) {
      const s = i[r];
      if (s === e)
        return r;
      if (s < e)
        return t(e, i[r - 1], s) > 0 ? r - 1 : r;
    }
    return n - 1;
  }
  if (t > 0) {
    for (let r = 1; r < n; ++r)
      if (i[r] < e)
        return r - 1;
    return n - 1;
  }
  if (t < 0) {
    for (let r = 1; r < n; ++r)
      if (i[r] <= e)
        return r;
    return n - 1;
  }
  for (let r = 1; r < n; ++r) {
    if (i[r] == e)
      return r;
    if (i[r] < e)
      return i[r - 1] - e < e - i[r] ? r - 1 : r;
  }
  return n - 1;
}
function bT(i, e, t) {
  for (; e < t; ) {
    const n = i[e];
    i[e] = i[t], i[t] = n, ++e, --t;
  }
}
function ze(i, e) {
  const t = Array.isArray(e) ? e : [e], n = t.length;
  for (let r = 0; r < n; r++)
    i[i.length] = t[r];
}
function Xr(i, e) {
  const t = i.length;
  if (t !== e.length)
    return !1;
  for (let n = 0; n < t; n++)
    if (i[n] !== e[n])
      return !1;
  return !0;
}
function ST(i, e, t) {
  const n = e || lr;
  return i.every(function(r, s) {
    if (s === 0)
      return !0;
    const o = n(i[s - 1], r);
    return !(o > 0 || o === 0);
  });
}
function Wl() {
  return !0;
}
function df() {
  return !1;
}
function Yl() {
}
function gE(i) {
  let e, t, n;
  return function() {
    const r = Array.prototype.slice.call(arguments);
    return (!t || this !== n || !Xr(r, t)) && (n = this, t = r, e = i.apply(this, arguments)), e;
  };
}
function ro(i) {
  function e() {
    let t;
    try {
      t = i();
    } catch (n) {
      return Promise.reject(n);
    }
    return t instanceof Promise ? t : Promise.resolve(t);
  }
  return e();
}
function Ga(i) {
  for (const e in i)
    delete i[e];
}
function Ur(i) {
  let e;
  for (e in i)
    return !1;
  return !e;
}
class In {
  /**
   * @param {string} type Type.
   */
  constructor(e) {
    this.propagationStopped, this.defaultPrevented, this.type = e, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
class ka extends Da {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(e) {
    super(), this.eventTarget_ = e, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(e, t) {
    if (!e || !t)
      return;
    const n = this.listeners_ || (this.listeners_ = {}), r = n[e] || (n[e] = []);
    r.includes(t) || r.push(t);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(e) {
    const t = typeof e == "string", n = t ? e : e.type, r = this.listeners_ && this.listeners_[n];
    if (!r)
      return;
    const s = t ? new In(e) : (
      /** @type {Event} */
      e
    );
    s.target || (s.target = this.eventTarget_ || this);
    const o = this.dispatching_ || (this.dispatching_ = {}), a = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    n in o || (o[n] = 0, a[n] = 0), ++o[n];
    let l;
    for (let h = 0, u = r.length; h < u; ++h)
      if ("handleEvent" in r[h] ? l = /** @type {import("../events.js").ListenerObject} */
      r[h].handleEvent(s) : l = /** @type {import("../events.js").ListenerFunction} */
      r[h].call(this, s), l === !1 || s.propagationStopped) {
        l = !1;
        break;
      }
    if (--o[n] === 0) {
      let h = a[n];
      for (delete a[n]; h--; )
        this.removeEventListener(n, Yl);
      delete o[n];
    }
    return l;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.listeners_ && Ga(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(e) {
    return this.listeners_ && this.listeners_[e] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(e) {
    return this.listeners_ ? e ? e in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(e, t) {
    if (!this.listeners_)
      return;
    const n = this.listeners_[e];
    if (!n)
      return;
    const r = n.indexOf(t);
    r !== -1 && (this.pendingRemovals_ && e in this.pendingRemovals_ ? (n[r] = Yl, ++this.pendingRemovals_[e]) : (n.splice(r, 1), n.length === 0 && delete this.listeners_[e]));
  }
}
function Ce(i, e, t, n, r) {
  if (r) {
    const o = t;
    t = function(a) {
      return i.removeEventListener(e, t), o.call(n ?? this, a);
    };
  } else n && n !== i && (t = t.bind(n));
  const s = {
    target: i,
    type: e,
    listener: t
  };
  return i.addEventListener(e, t), s;
}
function ql(i, e, t, n) {
  return Ce(i, e, t, n, !0);
}
function tt(i) {
  i && i.target && (i.target.removeEventListener(i.type, i.listener), Ga(i));
}
class Eh extends ka {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(le.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(e, t) {
    if (Array.isArray(e)) {
      const n = e.length, r = new Array(n);
      for (let s = 0; s < n; ++s)
        r[s] = Ce(this, e[s], t);
      return r;
    }
    return Ce(
      this,
      /** @type {string} */
      e,
      t
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(e, t) {
    let n;
    if (Array.isArray(e)) {
      const r = e.length;
      n = new Array(r);
      for (let s = 0; s < r; ++s)
        n[s] = ql(this, e[s], t);
    } else
      n = ql(
        this,
        /** @type {string} */
        e,
        t
      );
    return t.ol_key = n, n;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(e, t) {
    const n = (
      /** @type {Object} */
      t.ol_key
    );
    if (n)
      TT(n);
    else if (Array.isArray(e))
      for (let r = 0, s = e.length; r < s; ++r)
        this.removeEventListener(e[r], t);
    else
      this.removeEventListener(e, t);
  }
}
Eh.prototype.on;
Eh.prototype.once;
Eh.prototype.un;
function TT(i) {
  if (Array.isArray(i))
    for (let e = 0, t = i.length; e < t; ++e)
      tt(i[e]);
  else
    tt(
      /** @type {import("./events.js").EventsKey} */
      i
    );
}
function de() {
  throw new Error("Unimplemented abstract method.");
}
let RT = 0;
function ie(i) {
  return i.ol_uid || (i.ol_uid = String(++RT));
}
class A_ extends In {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(e, t, n) {
    super(e), this.key = t, this.oldValue = n;
  }
}
class _r extends Eh {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, ie(this), this.values_ = null, e !== void 0 && this.setProperties(e);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(e) {
    let t;
    return this.values_ && this.values_.hasOwnProperty(e) && (t = this.values_[e]), t;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(e, t) {
    let n;
    n = `change:${e}`, this.hasListener(n) && this.dispatchEvent(new A_(n, e, t)), n = xa.PROPERTYCHANGE, this.hasListener(n) && this.dispatchEvent(new A_(n, e, t));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(e, t) {
    this.addEventListener(`change:${e}`, t);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(e, t) {
    this.removeEventListener(`change:${e}`, t);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(e, t, n) {
    const r = this.values_ || (this.values_ = {});
    if (n)
      r[e] = t;
    else {
      const s = r[e];
      r[e] = t, s !== t && this.notify(e, s);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(e, t) {
    for (const n in e)
      this.set(n, e[n], t);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(e) {
    e.values_ && Object.assign(this.values_ || (this.values_ = {}), e.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(e, t) {
    if (this.values_ && e in this.values_) {
      const n = this.values_[e];
      delete this.values_[e], Ur(this.values_) && (this.values_ = null), t || this.notify(e, n);
    }
  }
}
function Te(i, e) {
  if (!i)
    throw new Error(e);
}
let li = class pE extends _r {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(e) {
    if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), e)
      if (typeof /** @type {?} */
      e.getSimplifiedGeometry == "function") {
        const t = (
          /** @type {Geometry} */
          e
        );
        this.setGeometry(t);
      } else {
        const t = e;
        this.setProperties(t);
      }
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const e = (
      /** @type {Feature<Geometry>} */
      new pE(this.hasProperties() ? this.getProperties() : null)
    );
    e.setGeometryName(this.getGeometryName());
    const t = this.getGeometry();
    t && e.setGeometry(
      /** @type {Geometry} */
      t.clone()
    );
    const n = this.getStyle();
    return n && e.setStyle(n), e;
  }
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleGeometryChanged_() {
    this.geometryChangeKey_ && (tt(this.geometryChangeKey_), this.geometryChangeKey_ = null);
    const e = this.getGeometry();
    e && (this.geometryChangeKey_ = Ce(
      e,
      le.CHANGE,
      this.handleGeometryChange_,
      this
    )), this.changed();
  }
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(e) {
    this.set(this.geometryName_, e);
  }
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(e) {
    this.style_ = e, this.styleFunction_ = e ? PT(e) : void 0, this.changed();
  }
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(e) {
    this.id_ = e, this.changed();
  }
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(e) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = e, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
  }
};
function PT(i) {
  if (typeof i == "function")
    return i;
  let e;
  return Array.isArray(i) ? e = i : (Te(
    typeof /** @type {?} */
    i.getZIndex == "function",
    "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
  ), e = [
    /** @type {import("./style/Style.js").default} */
    i
  ]), function() {
    return e;
  };
}
const ri = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function Ea(i) {
  const e = hi();
  for (let t = 0, n = i.length; t < n; ++t)
    Pl(e, i[t]);
  return e;
}
function MT(i, e, t) {
  const n = Math.min.apply(null, i), r = Math.min.apply(null, e), s = Math.max.apply(null, i), o = Math.max.apply(null, e);
  return Xn(n, r, s, o, t);
}
function ln(i, e, t) {
  return t ? (t[0] = i[0] - e, t[1] = i[1] - e, t[2] = i[2] + e, t[3] = i[3] + e, t) : [
    i[0] - e,
    i[1] - e,
    i[2] + e,
    i[3] + e
  ];
}
function mE(i, e) {
  return e ? (e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e) : i.slice();
}
function yo(i, e, t) {
  let n, r;
  return e < i[0] ? n = i[0] - e : i[2] < e ? n = e - i[2] : n = 0, t < i[1] ? r = i[1] - t : i[3] < t ? r = t - i[3] : r = 0, n * n + r * r;
}
function nn(i, e) {
  return zp(i, e[0], e[1]);
}
function Bi(i, e) {
  return i[0] <= e[0] && e[2] <= i[2] && i[1] <= e[1] && e[3] <= i[3];
}
function zp(i, e, t) {
  return i[0] <= e && e <= i[2] && i[1] <= t && t <= i[3];
}
function Tg(i, e) {
  const t = i[0], n = i[1], r = i[2], s = i[3], o = e[0], a = e[1];
  let l = ri.UNKNOWN;
  return o < t ? l = l | ri.LEFT : o > r && (l = l | ri.RIGHT), a < n ? l = l | ri.BELOW : a > s && (l = l | ri.ABOVE), l === ri.UNKNOWN && (l = ri.INTERSECTING), l;
}
function hi() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function Xn(i, e, t, n, r) {
  return r ? (r[0] = i, r[1] = e, r[2] = t, r[3] = n, r) : [i, e, t, n];
}
function Ua(i) {
  return Xn(1 / 0, 1 / 0, -1 / 0, -1 / 0, i);
}
function Bp(i, e) {
  const t = i[0], n = i[1];
  return Xn(t, n, t, n, e);
}
function $p(i, e, t, n, r) {
  const s = Ua(r);
  return _E(s, i, e, t, n);
}
function Pn(i, e) {
  return i[0] == e[0] && i[2] == e[2] && i[1] == e[1] && i[3] == e[3];
}
function CT(i, e, t) {
  return Math.abs(i[0] - e[0]) < t && Math.abs(i[2] - e[2]) < t && Math.abs(i[1] - e[1]) < t && Math.abs(i[3] - e[3]) < t;
}
function jp(i, e) {
  return e[0] < i[0] && (i[0] = e[0]), e[2] > i[2] && (i[2] = e[2]), e[1] < i[1] && (i[1] = e[1]), e[3] > i[3] && (i[3] = e[3]), i;
}
function Pl(i, e) {
  e[0] < i[0] && (i[0] = e[0]), e[0] > i[2] && (i[2] = e[0]), e[1] < i[1] && (i[1] = e[1]), e[1] > i[3] && (i[3] = e[1]);
}
function _E(i, e, t, n, r) {
  for (; t < n; t += r)
    AT(i, e[t], e[t + 1]);
  return i;
}
function AT(i, e, t) {
  i[0] = Math.min(i[0], e), i[1] = Math.min(i[1], t), i[2] = Math.max(i[2], e), i[3] = Math.max(i[3], t);
}
function yE(i, e) {
  let t;
  return t = e(vh(i)), t || (t = e(gf(i)), t) || (t = e(wh(i)), t) || (t = e(Mn(i)), t) ? t : !1;
}
function Zl(i) {
  let e = 0;
  return qn(i) || (e = _e(i) * it(i)), e;
}
function vh(i) {
  return [i[0], i[1]];
}
function gf(i) {
  return [i[2], i[1]];
}
function Vt(i) {
  return [(i[0] + i[2]) / 2, (i[1] + i[3]) / 2];
}
function IT(i, e) {
  let t;
  if (e === "bottom-left")
    t = vh(i);
  else if (e === "bottom-right")
    t = gf(i);
  else if (e === "top-left")
    t = Mn(i);
  else if (e === "top-right")
    t = wh(i);
  else
    throw new Error("Invalid corner");
  return t;
}
function nc(i, e, t, n, r) {
  const [s, o, a, l, h, u, c, f] = Xp(
    i,
    e,
    t,
    n
  );
  return Xn(
    Math.min(s, a, h, c),
    Math.min(o, l, u, f),
    Math.max(s, a, h, c),
    Math.max(o, l, u, f),
    r
  );
}
function Xp(i, e, t, n) {
  const r = e * n[0] / 2, s = e * n[1] / 2, o = Math.cos(t), a = Math.sin(t), l = r * o, h = r * a, u = s * o, c = s * a, f = i[0], g = i[1];
  return [
    f - l + c,
    g - h - u,
    f - l - c,
    g - h + u,
    f + l - c,
    g + h + u,
    f + l + c,
    g + h - u,
    f - l + c,
    g - h - u
  ];
}
function it(i) {
  return i[3] - i[1];
}
function kt(i, e, t) {
  const n = t || hi();
  return ft(i, e) ? (i[0] > e[0] ? n[0] = i[0] : n[0] = e[0], i[1] > e[1] ? n[1] = i[1] : n[1] = e[1], i[2] < e[2] ? n[2] = i[2] : n[2] = e[2], i[3] < e[3] ? n[3] = i[3] : n[3] = e[3]) : Ua(n), n;
}
function Mn(i) {
  return [i[0], i[3]];
}
function wh(i) {
  return [i[2], i[3]];
}
function _e(i) {
  return i[2] - i[0];
}
function ft(i, e) {
  return i[0] <= e[2] && i[2] >= e[0] && i[1] <= e[3] && i[3] >= e[1];
}
function qn(i) {
  return i[2] < i[0] || i[3] < i[1];
}
function LT(i, e) {
  return e ? (e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e) : i;
}
function xE(i, e) {
  const t = (i[2] - i[0]) / 2 * (e - 1), n = (i[3] - i[1]) / 2 * (e - 1);
  i[0] -= t, i[2] += t, i[1] -= n, i[3] += n;
}
function FT(i, e, t) {
  let n = !1;
  const r = Tg(i, e), s = Tg(i, t);
  if (r === ri.INTERSECTING || s === ri.INTERSECTING)
    n = !0;
  else {
    const o = i[0], a = i[1], l = i[2], h = i[3], u = e[0], c = e[1], f = t[0], g = t[1], d = (g - c) / (f - u);
    let m, x;
    s & ri.ABOVE && !(r & ri.ABOVE) && (m = f - (g - h) / d, n = m >= o && m <= l), !n && s & ri.RIGHT && !(r & ri.RIGHT) && (x = g - (f - l) * d, n = x >= a && x <= h), !n && s & ri.BELOW && !(r & ri.BELOW) && (m = f - (g - a) / d, n = m >= o && m <= l), !n && s & ri.LEFT && !(r & ri.LEFT) && (x = g - (f - o) * d, n = x >= a && x <= h);
  }
  return n;
}
function so(i, e, t, n) {
  if (qn(i))
    return Ua(t);
  let r = [];
  if (n > 1) {
    const a = i[2] - i[0], l = i[3] - i[1];
    for (let h = 0; h < n; ++h)
      r.push(
        i[0] + a * h / n,
        i[1],
        i[2],
        i[1] + l * h / n,
        i[2] - a * h / n,
        i[3],
        i[0],
        i[3] - l * h / n
      );
  } else
    r = [
      i[0],
      i[1],
      i[2],
      i[1],
      i[2],
      i[3],
      i[0],
      i[3]
    ];
  e(r, r, 2);
  const s = [], o = [];
  for (let a = 0, l = r.length; a < l; a += 2)
    s.push(r[a]), o.push(r[a + 1]);
  return MT(s, o, t);
}
function Vp(i, e) {
  const t = e.getExtent(), n = Vt(i);
  if (e.canWrapX() && (n[0] < t[0] || n[0] >= t[2])) {
    const r = _e(t), o = Math.floor(
      (n[0] - t[0]) / r
    ) * r;
    i[0] -= o, i[2] -= o;
  }
  return i;
}
function Wp(i, e, t) {
  if (e.canWrapX()) {
    const n = e.getExtent();
    if (!isFinite(i[0]) || !isFinite(i[2]))
      return [[n[0], i[1], n[2], i[3]]];
    Vp(i, e);
    const r = _e(n);
    if (_e(i) > r && !t)
      return [[n[0], i[1], n[2], i[3]]];
    if (i[0] < n[0])
      return [
        [i[0] + r, i[1], n[2], i[3]],
        [n[0], i[1], i[2], i[3]]
      ];
    if (i[2] > n[2])
      return [
        [i[0], i[1], n[2], i[3]],
        [n[0], i[1], i[2] - r, i[3]]
      ];
  }
  return [i];
}
function EE(...i) {
  console.warn(...i);
}
function Hl(...i) {
  console.error(...i);
}
function ve(i, e, t) {
  return Math.min(Math.max(i, e), t);
}
function vE(i, e, t, n, r, s) {
  const o = r - t, a = s - n;
  if (o !== 0 || a !== 0) {
    const l = ((i - t) * o + (e - n) * a) / (o * o + a * a);
    l > 1 ? (t = r, n = s) : l > 0 && (t += o * l, n += a * l);
  }
  return Js(i, e, t, n);
}
function Js(i, e, t, n) {
  const r = t - i, s = n - e;
  return r * r + s * s;
}
function OT(i) {
  const e = i.length;
  for (let n = 0; n < e; n++) {
    let r = n, s = Math.abs(i[n][n]);
    for (let a = n + 1; a < e; a++) {
      const l = Math.abs(i[a][n]);
      l > s && (s = l, r = a);
    }
    if (s === 0)
      return null;
    const o = i[r];
    i[r] = i[n], i[n] = o;
    for (let a = n + 1; a < e; a++) {
      const l = -i[a][n] / i[n][n];
      for (let h = n; h < e + 1; h++)
        n == h ? i[a][h] = 0 : i[a][h] += l * i[n][h];
    }
  }
  const t = new Array(e);
  for (let n = e - 1; n >= 0; n--) {
    t[n] = i[n][e] / i[n][n];
    for (let r = n - 1; r >= 0; r--)
      i[r][e] -= i[r][n] * t[n];
  }
  return t;
}
function I_(i) {
  return i * 180 / Math.PI;
}
function Fr(i) {
  return i * Math.PI / 180;
}
function $n(i, e) {
  const t = i % e;
  return t * e < 0 ? t + e : t;
}
function Ji(i, e, t) {
  return i + t * (e - i);
}
function za(i, e) {
  const t = Math.pow(10, e);
  return Math.round(i * t) / t;
}
function rc(i, e) {
  return Math.round(za(i, e));
}
function ru(i, e) {
  return Math.floor(za(i, e));
}
function us(i, e) {
  return Math.ceil(za(i, e));
}
function Rg(i, e, t) {
  if (i >= e && i < t)
    return i;
  const n = t - e;
  return ((i - e) % n + n) % n + e;
}
function $s(i, e, t) {
  const n = t !== void 0 ? i.toFixed(t) : "" + i;
  let r = n.indexOf(".");
  return r = r === -1 ? n.length : r, r > e ? n : new Array(1 + e - r).join("0") + n;
}
function Yp(i, e) {
  const t = ("" + i).split("."), n = ("" + e).split(".");
  for (let r = 0; r < Math.max(t.length, n.length); r++) {
    const s = parseInt(t[r] || "0", 10), o = parseInt(n[r] || "0", 10);
    if (s > o)
      return 1;
    if (o > s)
      return -1;
  }
  return 0;
}
function wE(i, e) {
  return i[0] += +e[0], i[1] += +e[1], i;
}
function L_(i, e, t) {
  const n = $n(e + 180, 360) - 180, r = Math.abs(3600 * n), s = t || 0;
  let o = Math.floor(r / 3600), a = Math.floor((r - o * 3600) / 60), l = za(r - o * 3600 - a * 60, s);
  l >= 60 && (l = 0, a += 1), a >= 60 && (a = 0, o += 1);
  let h = o + "°";
  return (a !== 0 || l !== 0) && (h += " " + $s(a, 2) + "′"), l !== 0 && (h += " " + $s(l, 2, s) + "″"), n !== 0 && (h += " " + i.charAt(n < 0 ? 1 : 0)), h;
}
function sc(i, e) {
  let t = !0;
  for (let n = i.length - 1; n >= 0; --n)
    if (i[n] != e[n]) {
      t = !1;
      break;
    }
  return t;
}
function qp(i, e) {
  const t = Math.cos(e), n = Math.sin(e), r = i[0] * t - i[1] * n, s = i[1] * t + i[0] * n;
  return i[0] = r, i[1] = s, i;
}
function bE(i, e) {
  return i[0] *= e, i[1] *= e, i;
}
function NT(i, e) {
  const t = i[0] - e[0], n = i[1] - e[1];
  return t * t + n * n;
}
function DT(i, e) {
  return Math.sqrt(NT(i, e));
}
function Zp(i, e) {
  if (e.canWrapX()) {
    const t = _e(e.getExtent()), n = SE(i, e, t);
    n && (i[0] -= n * t);
  }
  return i;
}
function SE(i, e, t) {
  const n = e.getExtent();
  let r = 0;
  return e.canWrapX() && (i[0] < n[0] || i[0] > n[2]) && (t = t || _e(n), r = Math.floor(
    (i[0] - n[0]) / t
  )), r;
}
const GT = {
  9001: "m",
  9002: "ft",
  9003: "us-ft",
  9101: "radians",
  9102: "degrees"
};
function F_(i) {
  return GT[i];
}
const ws = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
let oo = class {
  /**
   * @param {Options} options Projection options.
   */
  constructor(e) {
    this.code_ = e.code, this.units_ = /** @type {import("./Units.js").Units} */
    e.units, this.extent_ = e.extent !== void 0 ? e.extent : null, this.worldExtent_ = e.worldExtent !== void 0 ? e.worldExtent : null, this.axisOrientation_ = e.axisOrientation !== void 0 ? e.axisOrientation : "enu", this.global_ = e.global !== void 0 ? e.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = e.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = e.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || ws[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(e) {
    this.global_ = e, this.canWrapX_ = !!(e && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(e) {
    this.defaultTileGrid_ = e;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(e) {
    this.extent_ = e, this.canWrapX_ = !!(this.global_ && e);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(e) {
    this.worldExtent_ = e;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(e) {
    this.getPointResolutionFunc_ = e;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {GetPointResolution|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
};
const bh = 6378137, Ho = Math.PI * bh, kT = [-Ho, -Ho, Ho, Ho], UT = [-180, -85, 180, 85], su = bh * Math.log(Math.tan(Math.PI / 2));
class Ro extends oo {
  /**
   * @param {string} code Code.
   */
  constructor(e) {
    super({
      code: e,
      units: "m",
      extent: kT,
      global: !0,
      worldExtent: UT,
      getPointResolution: function(t, n) {
        return t / Math.cosh(n[1] / bh);
      }
    });
  }
}
const O_ = [
  new Ro("EPSG:3857"),
  new Ro("EPSG:102100"),
  new Ro("EPSG:102113"),
  new Ro("EPSG:900913"),
  new Ro("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new Ro("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function zT(i, e, t, n) {
  const r = i.length;
  t = t > 1 ? t : 2, n = n ?? t, e === void 0 && (t > 2 ? e = i.slice() : e = new Array(r));
  for (let s = 0; s < r; s += n) {
    e[s] = Ho * i[s] / 180;
    let o = bh * Math.log(Math.tan(Math.PI * (+i[s + 1] + 90) / 360));
    o > su ? o = su : o < -su && (o = -su), e[s + 1] = o;
  }
  return e;
}
function BT(i, e, t, n) {
  const r = i.length;
  t = t > 1 ? t : 2, n = n ?? t, e === void 0 && (t > 2 ? e = i.slice() : e = new Array(r));
  for (let s = 0; s < r; s += n)
    e[s] = 180 * i[s] / Ho, e[s + 1] = 360 * Math.atan(Math.exp(i[s + 1] / bh)) / Math.PI - 90;
  return e;
}
const $T = 6378137, N_ = [-180, -90, 180, 90], jT = Math.PI * $T / 180;
class Ns extends oo {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(e, t) {
    super({
      code: e,
      units: "degrees",
      extent: N_,
      axisOrientation: t,
      global: !0,
      metersPerUnit: jT,
      worldExtent: N_
    });
  }
}
const D_ = [
  new Ns("CRS:84"),
  new Ns("EPSG:4326", "neu"),
  new Ns("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new Ns("urn:ogc:def:crs:OGC:2:84"),
  new Ns("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new Ns("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new Ns("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let Pg = {};
function ra(i) {
  return Pg[i] || Pg[i.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function XT(i, e) {
  Pg[i] = e;
}
let sa = {};
function ao(i, e, t) {
  const n = i.getCode(), r = e.getCode();
  n in sa || (sa[n] = {}), sa[n][r] = t;
}
function Bu(i, e) {
  return i in sa && e in sa[i] ? sa[i][e] : null;
}
const oc = 0.9996, Tn = 669438e-8, pf = Tn * Tn, mf = pf * Tn, Ws = Tn / (1 - Tn), G_ = Math.sqrt(1 - Tn), va = (1 - G_) / (1 + G_), TE = va * va, Hp = TE * va, Kp = Hp * va, RE = Kp * va, PE = 1 - Tn / 4 - 3 * pf / 64 - 5 * mf / 256, VT = 3 * Tn / 8 + 3 * pf / 32 + 45 * mf / 1024, WT = 15 * pf / 256 + 45 * mf / 1024, YT = 35 * mf / 3072, qT = 3 / 2 * va - 27 / 32 * Hp + 269 / 512 * RE, ZT = 21 / 16 * TE - 55 / 32 * Kp, HT = 151 / 96 * Hp - 417 / 128 * RE, KT = 1097 / 512 * Kp, ac = 6378137;
function JT(i, e, t) {
  const n = i - 5e5, o = (t.north ? e : e - 1e7) / oc / (ac * PE), a = o + qT * Math.sin(2 * o) + ZT * Math.sin(4 * o) + HT * Math.sin(6 * o) + KT * Math.sin(8 * o), l = Math.sin(a), h = l * l, u = Math.cos(a), c = l / u, f = c * c, g = f * f, d = 1 - Tn * h, m = Math.sqrt(1 - Tn * h), x = ac / m, v = (1 - Tn) / d, p = Ws * u ** 2, y = p * p, E = n / (x * oc), b = E * E, T = b * E, R = T * E, M = R * E, C = M * E, I = a - c / v * (b / 2 - R / 24 * (5 + 3 * f + 10 * p - 4 * y - 9 * Ws)) + C / 720 * (61 + 90 * f + 298 * p + 45 * g - 252 * Ws - 3 * y);
  let O = (E - T / 6 * (1 + 2 * f + p) + M / 120 * (5 - 2 * p + 28 * f - 3 * y + 8 * Ws + 24 * g)) / u;
  return O = Rg(
    O + Fr(ME(t.number)),
    -Math.PI,
    Math.PI
  ), [I_(O), I_(I)];
}
const k_ = -80, U_ = 84, QT = -180, e2 = 180;
function t2(i, e, t) {
  i = Rg(i, QT, e2), e < k_ ? e = k_ : e > U_ && (e = U_);
  const n = Fr(e), r = Math.sin(n), s = Math.cos(n), o = r / s, a = o * o, l = a * a, h = Fr(i), u = ME(t.number), c = Fr(u), f = ac / Math.sqrt(1 - Tn * r ** 2), g = Ws * s ** 2, d = s * Rg(h - c, -Math.PI, Math.PI), m = d * d, x = m * d, v = x * d, p = v * d, y = p * d, E = ac * (PE * n - VT * Math.sin(2 * n) + WT * Math.sin(4 * n) - YT * Math.sin(6 * n)), b = oc * f * (d + x / 6 * (1 - a + g) + p / 120 * (5 - 18 * a + l + 72 * g - 58 * Ws)) + 5e5;
  let T = oc * (E + f * o * (m / 2 + v / 24 * (5 - a + 9 * g + 4 * g ** 2) + y / 720 * (61 - 58 * a + l + 600 * g - 330 * Ws)));
  return t.north || (T += 1e7), [b, T];
}
function ME(i) {
  return (i - 1) * 6 - 180 + 3;
}
const i2 = [
  /^EPSG:(\d+)$/,
  /^urn:ogc:def:crs:EPSG::(\d+)$/,
  /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/
];
function CE(i) {
  let e = 0;
  for (const r of i2) {
    const s = i.match(r);
    if (s) {
      e = parseInt(s[1]);
      break;
    }
  }
  if (!e)
    return null;
  let t = 0, n = !1;
  return e > 32700 && e < 32761 ? t = e - 32700 : e > 32600 && e < 32661 && (n = !0, t = e - 32600), t ? { number: t, north: n } : null;
}
function z_(i, e) {
  return function(t, n, r, s) {
    const o = t.length;
    r = r > 1 ? r : 2, s = s ?? r, n || (r > 2 ? n = t.slice() : n = new Array(o));
    for (let a = 0; a < o; a += s) {
      const l = t[a], h = t[a + 1], u = i(l, h, e);
      n[a] = u[0], n[a + 1] = u[1];
    }
    return n;
  };
}
function n2(i) {
  return CE(i) ? new oo({ code: i, units: "m" }) : null;
}
function r2(i) {
  const e = CE(i.getCode());
  return e ? {
    forward: z_(t2, e),
    inverse: z_(JT, e)
  } : null;
}
const s2 = 63710088e-1;
function B_(i, e, t) {
  t = t || s2;
  const n = Fr(i[1]), r = Fr(e[1]), s = (r - n) / 2, o = Fr(e[0] - i[0]) / 2, a = Math.sin(s) * Math.sin(s) + Math.sin(o) * Math.sin(o) * Math.cos(n) * Math.cos(r);
  return 2 * t * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
const o2 = [r2], a2 = [n2];
let Mg = !0;
function AE(i) {
  Mg = !1;
}
function Jp(i, e) {
  if (e !== void 0) {
    for (let t = 0, n = i.length; t < n; ++t)
      e[t] = i[t];
    e = e;
  } else
    e = i.slice();
  return e;
}
function lc(i) {
  XT(i.getCode(), i), ao(i, i, Jp);
}
function l2(i) {
  i.forEach(lc);
}
function ee(i) {
  if (typeof i != "string")
    return i;
  const e = ra(i);
  if (e)
    return e;
  for (const t of a2) {
    const n = t(i);
    if (n)
      return n;
  }
  return null;
}
function Cg(i, e, t, n) {
  i = ee(i);
  let r;
  const s = i.getPointResolutionFunc();
  if (s) {
    if (r = s(e, t), n && n !== i.getUnits()) {
      const o = i.getMetersPerUnit();
      o && (r = r * o / ws[n]);
    }
  } else {
    const o = i.getUnits();
    if (o == "degrees" && !n || n == "degrees")
      r = e;
    else {
      const a = xo(
        i,
        ee("EPSG:4326")
      );
      if (!a && o !== "degrees")
        r = e * i.getMetersPerUnit();
      else {
        let h = [
          t[0] - e / 2,
          t[1],
          t[0] + e / 2,
          t[1],
          t[0],
          t[1] - e / 2,
          t[0],
          t[1] + e / 2
        ];
        h = a(h, h, 2);
        const u = B_(h.slice(0, 2), h.slice(2, 4)), c = B_(h.slice(4, 6), h.slice(6, 8));
        r = (u + c) / 2;
      }
      const l = n ? ws[n] : i.getMetersPerUnit();
      l !== void 0 && (r /= l);
    }
  }
  return r;
}
function Ag(i) {
  l2(i), i.forEach(function(e) {
    i.forEach(function(t) {
      e !== t && ao(e, t, Jp);
    });
  });
}
function h2(i, e, t, n) {
  i.forEach(function(r) {
    e.forEach(function(s) {
      ao(r, s, t), ao(s, r, n);
    });
  });
}
function Qp(i, e) {
  return i ? typeof i == "string" ? ee(i) : (
    /** @type {Projection} */
    i
  ) : ee(e);
}
function hc(i) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimensions that should be transformed.
     * @param {number} [stride] Stride.
     * @return {Array<number>} Output.
     */
    (function(e, t, n, r) {
      const s = e.length;
      n = n !== void 0 ? n : 2, r = r ?? n, t = t !== void 0 ? t : new Array(s);
      for (let o = 0; o < s; o += r) {
        const a = i(e.slice(o, o + n)), l = a.length;
        for (let h = 0, u = r; h < u; ++h)
          t[o + h] = h >= l ? e[o + h] : a[h];
      }
      return t;
    })
  );
}
function u2(i, e, t, n) {
  const r = ee(i), s = ee(e);
  ao(
    r,
    s,
    hc(t)
  ), ao(
    s,
    r,
    hc(n)
  );
}
function Ig(i, e) {
  return AE(), Sh(
    i,
    "EPSG:4326",
    e !== void 0 ? e : "EPSG:3857"
  );
}
function $_(i, e) {
  const t = Sh(
    i,
    e !== void 0 ? e : "EPSG:3857",
    "EPSG:4326"
  ), n = t[0];
  return (n < -180 || n > 180) && (t[0] = $n(n + 180, 360) - 180), t;
}
function wt(i, e) {
  if (i === e)
    return !0;
  const t = i.getUnits() === e.getUnits();
  return (i.getCode() === e.getCode() || xo(i, e) === Jp) && t;
}
function xo(i, e) {
  const t = i.getCode(), n = e.getCode();
  let r = Bu(t, n);
  if (r)
    return r;
  let s = null, o = null;
  for (const l of o2)
    s || (s = l(i)), o || (o = l(e));
  if (!s && !o)
    return null;
  const a = "EPSG:4326";
  if (o)
    if (s)
      r = yd(
        s.inverse,
        o.forward
      );
    else {
      const l = Bu(t, a);
      l && (r = yd(
        l,
        o.forward
      ));
    }
  else {
    const l = Bu(a, n);
    l && (r = yd(
      s.inverse,
      l
    ));
  }
  return r && (lc(i), lc(e), ao(i, e, r)), r;
}
function yd(i, e) {
  return function(t, n, r, s) {
    return n = i(t, n, r, s), e(n, n, r, s);
  };
}
function Vn(i, e) {
  const t = ee(i), n = ee(e);
  return xo(t, n);
}
function Sh(i, e, t) {
  const n = Vn(e, t);
  if (!n) {
    const r = ee(e).getCode(), s = ee(t).getCode();
    throw new Error(
      `No transform available between ${r} and ${s}`
    );
  }
  return n(i, void 0, i.length);
}
function Or(i, e, t, n) {
  const r = Vn(e, t);
  return so(i, r, void 0, n);
}
let c2 = null;
function f2() {
  return c2;
}
function uc(i, e) {
  return i;
}
function Pr(i, e) {
  return Mg && !sc(i, [0, 0]) && i[0] >= -180 && i[0] <= 180 && i[1] >= -90 && i[1] <= 90 && (Mg = !1, EE(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), i;
}
function _f(i, e) {
  return i;
}
function xn(i, e) {
  return i;
}
function j_(i, e, t) {
  return function(n) {
    let r, s;
    if (i.canWrapX()) {
      const o = i.getExtent(), a = _e(o);
      n = n.slice(0), s = SE(n, i, a), s && (n[0] = n[0] - s * a), n[0] = ve(n[0], o[0], o[2]), n[1] = ve(n[1], o[1], o[3]), r = t(n);
    } else
      r = t(n);
    return s && e.canWrapX() && (r[0] += s * _e(e.getExtent())), r;
  };
}
function d2() {
  Ag(O_), Ag(D_), h2(
    D_,
    O_,
    zT,
    BT
  );
}
d2();
const em = new Array(6);
function st() {
  return [1, 0, 0, 1, 0, 0];
}
function Lg(i) {
  return yf(i, 1, 0, 0, 1, 0, 0);
}
function zr(i, e) {
  const t = i[0], n = i[1], r = i[2], s = i[3], o = i[4], a = i[5], l = e[0], h = e[1], u = e[2], c = e[3], f = e[4], g = e[5];
  return i[0] = t * l + r * h, i[1] = n * l + s * h, i[2] = t * u + r * c, i[3] = n * u + s * c, i[4] = t * f + r * g + o, i[5] = n * f + s * g + a, i;
}
function yf(i, e, t, n, r, s, o) {
  return i[0] = e, i[1] = t, i[2] = n, i[3] = r, i[4] = s, i[5] = o, i;
}
function IE(i, e) {
  return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i;
}
function rt(i, e) {
  const t = e[0], n = e[1];
  return e[0] = i[0] * t + i[2] * n + i[4], e[1] = i[1] * t + i[3] * n + i[5], e;
}
function g2(i, e) {
  const t = Math.cos(e), n = Math.sin(e);
  return zr(i, yf(em, t, n, -n, t, 0, 0));
}
function Ml(i, e, t) {
  return zr(i, yf(em, e, 0, 0, t, 0, 0));
}
function xf(i, e, t) {
  return zr(i, yf(em, 1, 0, 0, 1, e, t));
}
function un(i, e, t, n, r, s, o, a) {
  const l = Math.sin(s), h = Math.cos(s);
  return i[0] = n * h, i[1] = r * l, i[2] = -n * l, i[3] = r * h, i[4] = o * n * h - a * n * l + e, i[5] = o * r * l + a * r * h + t, i;
}
function lo(i, e) {
  const t = p2(e);
  Te(t !== 0, "Transformation matrix cannot be inverted");
  const n = e[0], r = e[1], s = e[2], o = e[3], a = e[4], l = e[5];
  return i[0] = o / t, i[1] = -r / t, i[2] = -s / t, i[3] = n / t, i[4] = (s * l - o * a) / t, i[5] = -(n * l - r * a) / t, i;
}
function p2(i) {
  return i[0] * i[3] - i[1] * i[2];
}
const m2 = [1e5, 1e5, 1e5, 1e5, 2, 2];
function _2(i) {
  return "matrix(" + i.join(", ") + ")";
}
function Fg(i) {
  return i.substring(7, i.length - 1).split(",").map(parseFloat);
}
function y2(i, e) {
  const t = Fg(i), n = Fg(e);
  for (let r = 0; r < 6; ++r)
    if (Math.round((t[r] - n[r]) * m2[r]) !== 0)
      return !1;
  return !0;
}
function hr(i, e, t, n, r, s, o) {
  s = s || [], o = o || 2;
  let a = 0;
  for (let l = e; l < t; l += n) {
    const h = i[l], u = i[l + 1];
    s[a++] = r[0] * h + r[2] * u + r[4], s[a++] = r[1] * h + r[3] * u + r[5];
    for (let c = 2; c < o; c++)
      s[a++] = i[l + c];
  }
  return s && s.length != a && (s.length = a), s;
}
function LE(i, e, t, n, r, s, o) {
  o = o || [];
  const a = Math.cos(r), l = Math.sin(r), h = s[0], u = s[1];
  let c = 0;
  for (let f = e; f < t; f += n) {
    const g = i[f] - h, d = i[f + 1] - u;
    o[c++] = h + g * a - d * l, o[c++] = u + g * l + d * a;
    for (let m = f + 2; m < f + n; ++m)
      o[c++] = i[m];
  }
  return o && o.length != c && (o.length = c), o;
}
function x2(i, e, t, n, r, s, o, a) {
  a = a || [];
  const l = o[0], h = o[1];
  let u = 0;
  for (let c = e; c < t; c += n) {
    const f = i[c] - l, g = i[c + 1] - h;
    a[u++] = l + r * f, a[u++] = h + s * g;
    for (let d = c + 2; d < c + n; ++d)
      a[u++] = i[d];
  }
  return a && a.length != u && (a.length = u), a;
}
function E2(i, e, t, n, r, s, o) {
  o = o || [];
  let a = 0;
  for (let l = e; l < t; l += n) {
    o[a++] = i[l] + r, o[a++] = i[l + 1] + s;
    for (let h = l + 2; h < l + n; ++h)
      o[a++] = i[h];
  }
  return o && o.length != a && (o.length = a), o;
}
const X_ = st(), v2 = [NaN, NaN];
let tm = class extends _r {
  constructor() {
    super(), this.extent_ = hi(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = gE(
      (e, t, n) => {
        if (!n)
          return this.getSimplifiedGeometry(t);
        const r = this.clone();
        return r.applyTransform(n), r.getSimplifiedGeometry(t);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return de();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, r) {
    return de();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    return this.closestPointXY(e, t, v2, Number.MIN_VALUE) === 0;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(e, t) {
    return t = t || [NaN, NaN], this.closestPointXY(e[0], e[1], t, 1 / 0), t;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(e) {
    return this.containsXY(e[0], e[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return de();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(e) {
    if (this.extentRevision_ != this.getRevision()) {
      const t = this.computeExtent(this.extent_);
      (isNaN(t[0]) || isNaN(t[1])) && Ua(t), this.extentRevision_ = this.getRevision();
    }
    return LT(this.extent_, e);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    de();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, n) {
    de();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(e) {
    return this.getSimplifiedGeometry(e * e);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return de();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return de();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(e) {
    de();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(e) {
    return de();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    de();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(e, t) {
    const n = ee(e), r = n.getUnits() == "tile-pixels" ? function(s, o, a) {
      const l = n.getExtent(), h = n.getWorldExtent(), u = it(h) / it(l);
      un(
        X_,
        h[0],
        h[3],
        u,
        -u,
        0,
        0,
        0
      );
      const c = hr(
        s,
        0,
        s.length,
        a,
        X_,
        o
      ), f = Vn(n, t);
      return f ? f(c, c, a) : c;
    } : Vn(n, t);
    return this.applyTransform(r), this;
  }
};
class Br extends tm {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(e) {
    return $p(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return de();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @override
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = this.getSimplifiedGeometryInternal(e);
    return t.getFlatCoordinates().length < this.flatCoordinates.length ? t : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(e, t) {
    this.stride = Og(e), this.layout = e, this.flatCoordinates = t;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(e, t) {
    de();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(e, t, n) {
    let r;
    if (e)
      r = Og(e);
    else {
      for (let s = 0; s < n; ++s) {
        if (t.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        }
        t = /** @type {Array<unknown>} */
        t[0];
      }
      r = t.length, e = Eo(r);
    }
    this.layout = e, this.stride = r;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   * @override
   */
  applyTransform(e) {
    this.flatCoordinates && (e(
      this.flatCoordinates,
      this.flatCoordinates,
      this.layout.startsWith("XYZ") ? 3 : 2,
      this.stride
    ), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   * @override
   */
  rotate(e, t) {
    const n = this.getFlatCoordinates();
    if (n) {
      const r = this.getStride();
      LE(
        n,
        0,
        n.length,
        r,
        e,
        t,
        n
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   * @override
   */
  scale(e, t, n) {
    t === void 0 && (t = e), n || (n = Vt(this.getExtent()));
    const r = this.getFlatCoordinates();
    if (r) {
      const s = this.getStride();
      x2(
        r,
        0,
        r.length,
        s,
        e,
        t,
        n,
        r
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   * @override
   */
  translate(e, t) {
    const n = this.getFlatCoordinates();
    if (n) {
      const r = this.getStride();
      E2(
        n,
        0,
        n.length,
        r,
        e,
        t,
        n
      ), this.changed();
    }
  }
}
function Eo(i) {
  let e;
  return i == 2 ? e = "XY" : i == 3 ? e = "XYZ" : i == 4 && (e = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  e;
}
function Og(i) {
  let e;
  return i == "XY" ? e = 2 : i == "XYZ" || i == "XYM" ? e = 3 : i == "XYZM" && (e = 4), /** @type {number} */
  e;
}
function w2(i, e, t) {
  const n = i.getFlatCoordinates();
  if (!n)
    return null;
  const r = i.getStride();
  return hr(
    n,
    0,
    n.length,
    r,
    e,
    t
  );
}
function V_(i, e, t, n, r, s, o) {
  const a = i[e], l = i[e + 1], h = i[t] - a, u = i[t + 1] - l;
  let c;
  if (h === 0 && u === 0)
    c = e;
  else {
    const f = ((r - a) * h + (s - l) * u) / (h * h + u * u);
    if (f > 1)
      c = t;
    else if (f > 0) {
      for (let g = 0; g < n; ++g)
        o[g] = Ji(
          i[e + g],
          i[t + g],
          f
        );
      o.length = n;
      return;
    } else
      c = e;
  }
  for (let f = 0; f < n; ++f)
    o[f] = i[c + f];
  o.length = n;
}
function im(i, e, t, n, r) {
  let s = i[e], o = i[e + 1];
  for (e += n; e < t; e += n) {
    const a = i[e], l = i[e + 1], h = Js(s, o, a, l);
    h > r && (r = h), s = a, o = l;
  }
  return r;
}
function nm(i, e, t, n, r) {
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s];
    r = im(i, e, a, n, r), e = a;
  }
  return r;
}
function b2(i, e, t, n, r) {
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s];
    r = nm(i, e, a, n, r), e = a[a.length - 1];
  }
  return r;
}
function rm(i, e, t, n, r, s, o, a, l, h, u) {
  if (e == t)
    return h;
  let c, f;
  if (r === 0) {
    if (f = Js(
      o,
      a,
      i[e],
      i[e + 1]
    ), f < h) {
      for (c = 0; c < n; ++c)
        l[c] = i[e + c];
      return l.length = n, f;
    }
    return h;
  }
  u = u || [NaN, NaN];
  let g = e + n;
  for (; g < t; )
    if (V_(
      i,
      g - n,
      g,
      n,
      o,
      a,
      u
    ), f = Js(o, a, u[0], u[1]), f < h) {
      for (h = f, c = 0; c < n; ++c)
        l[c] = u[c];
      l.length = n, g += n;
    } else
      g += n * Math.max(
        (Math.sqrt(f) - Math.sqrt(h)) / r | 0,
        1
      );
  if (s && (V_(
    i,
    t - n,
    e,
    n,
    o,
    a,
    u
  ), f = Js(o, a, u[0], u[1]), f < h)) {
    for (h = f, c = 0; c < n; ++c)
      l[c] = u[c];
    l.length = n;
  }
  return h;
}
function sm(i, e, t, n, r, s, o, a, l, h, u) {
  u = u || [NaN, NaN];
  for (let c = 0, f = t.length; c < f; ++c) {
    const g = t[c];
    h = rm(
      i,
      e,
      g,
      n,
      r,
      s,
      o,
      a,
      l,
      h,
      u
    ), e = g;
  }
  return h;
}
function S2(i, e, t, n, r, s, o, a, l, h, u) {
  u = u || [NaN, NaN];
  for (let c = 0, f = t.length; c < f; ++c) {
    const g = t[c];
    h = sm(
      i,
      e,
      g,
      n,
      r,
      s,
      o,
      a,
      l,
      h,
      u
    ), e = g[g.length - 1];
  }
  return h;
}
function T2(i, e, t, n) {
  for (let r = 0, s = t.length; r < s; ++r)
    i[e++] = t[r];
  return e;
}
function Th(i, e, t, n) {
  for (let r = 0, s = t.length; r < s; ++r) {
    const o = t[r];
    for (let a = 0; a < n; ++a)
      i[e++] = o[a];
  }
  return e;
}
function Rh(i, e, t, n, r) {
  r = r || [];
  let s = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = Th(
      i,
      e,
      t[o],
      n
    );
    r[s++] = l, e = l;
  }
  return r.length = s, r;
}
function FE(i, e, t, n, r) {
  r = r || [];
  let s = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = Rh(
      i,
      e,
      t[o],
      n,
      r[s]
    );
    l.length === 0 && (l[0] = e), r[s++] = l, e = l[l.length - 1];
  }
  return r.length = s, r;
}
function cs(i, e, t, n, r) {
  r = r !== void 0 ? r : [];
  let s = 0;
  for (let o = e; o < t; o += n)
    r[s++] = i.slice(o, o + n);
  return r.length = s, r;
}
function Kl(i, e, t, n, r) {
  r = r !== void 0 ? r : [];
  let s = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    r[s++] = cs(
      i,
      e,
      l,
      n,
      r[s]
    ), e = l;
  }
  return r.length = s, r;
}
function Ng(i, e, t, n, r) {
  r = r !== void 0 ? r : [];
  let s = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    r[s++] = l.length === 1 && l[0] === e ? [] : Kl(
      i,
      e,
      l,
      n,
      r[s]
    ), e = l[l.length - 1];
  }
  return r.length = s, r;
}
function cc(i, e, t, n, r, s, o) {
  let a, l;
  const h = (t - e) / n;
  if (h === 1)
    a = e;
  else if (h === 2)
    a = e, l = r;
  else if (h !== 0) {
    let u = i[e], c = i[e + 1], f = 0;
    const g = [0];
    for (let x = e + n; x < t; x += n) {
      const v = i[x], p = i[x + 1];
      f += Math.sqrt((v - u) * (v - u) + (p - c) * (p - c)), g.push(f), u = v, c = p;
    }
    const d = r * f, m = wT(g, d);
    m < 0 ? (l = (d - g[-m - 2]) / (g[-m - 1] - g[-m - 2]), a = e + (-m - 2) * n) : a = e + m * n;
  }
  o = o > 1 ? o : 2, s = s || new Array(o);
  for (let u = 0; u < o; ++u)
    s[u] = a === void 0 ? NaN : l === void 0 ? i[a + u] : Ji(i[a + u], i[a + n + u], l);
  return s;
}
function Dg(i, e, t, n, r, s) {
  if (t == e)
    return null;
  let o;
  if (r < i[e + n - 1])
    return s ? (o = i.slice(e, e + n), o[n - 1] = r, o) : null;
  if (i[t - 1] < r)
    return s ? (o = i.slice(t - n, t), o[n - 1] = r, o) : null;
  if (r == i[e + n - 1])
    return i.slice(e, e + n);
  let a = e / n, l = t / n;
  for (; a < l; ) {
    const f = a + l >> 1;
    r < i[(f + 1) * n - 1] ? l = f : a = f + 1;
  }
  const h = i[a * n - 1];
  if (r == h)
    return i.slice((a - 1) * n, (a - 1) * n + n);
  const u = i[(a + 1) * n - 1], c = (r - h) / (u - h);
  o = [];
  for (let f = 0; f < n - 1; ++f)
    o.push(
      Ji(
        i[(a - 1) * n + f],
        i[a * n + f],
        c
      )
    );
  return o.push(r), o;
}
function R2(i, e, t, n, r, s, o) {
  if (o)
    return Dg(
      i,
      e,
      t[t.length - 1],
      n,
      r,
      s
    );
  let a;
  if (r < i[n - 1])
    return s ? (a = i.slice(0, n), a[n - 1] = r, a) : null;
  if (i[i.length - 1] < r)
    return s ? (a = i.slice(i.length - n), a[n - 1] = r, a) : null;
  for (let l = 0, h = t.length; l < h; ++l) {
    const u = t[l];
    if (e != u) {
      if (r < i[e + n - 1])
        return null;
      if (r <= i[u - 1])
        return Dg(
          i,
          e,
          u,
          n,
          r,
          !1
        );
      e = u;
    }
  }
  return null;
}
function P2(i, e, t, n, r) {
  return !yE(
    r,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(o) {
      return !Ys(
        i,
        e,
        t,
        n,
        o[0],
        o[1]
      );
    }
  );
}
function Ys(i, e, t, n, r, s) {
  let o = 0, a = i[t - n], l = i[t - n + 1];
  for (; e < t; e += n) {
    const h = i[e], u = i[e + 1];
    l <= s ? u > s && (h - a) * (s - l) - (r - a) * (u - l) > 0 && o++ : u <= s && (h - a) * (s - l) - (r - a) * (u - l) < 0 && o--, a = h, l = u;
  }
  return o !== 0;
}
function om(i, e, t, n, r, s) {
  if (t.length === 0 || !Ys(i, e, t[0], n, r, s))
    return !1;
  for (let o = 1, a = t.length; o < a; ++o)
    if (Ys(i, t[o - 1], t[o], n, r, s))
      return !1;
  return !0;
}
function M2(i, e, t, n, r, s) {
  if (t.length === 0)
    return !1;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    if (om(i, e, l, n, r, s))
      return !0;
    e = l[l.length - 1];
  }
  return !1;
}
function OE(i, e, t, n, r) {
  let s;
  for (e += n; e < t; e += n)
    if (s = r(
      i.slice(e - n, e),
      i.slice(e, e + n)
    ), s)
      return s;
  return !1;
}
function Ef(i, e, t, n, r, s) {
  return s = s ?? _E(hi(), i, e, t, n), ft(r, s) ? s[0] >= r[0] && s[2] <= r[2] || s[1] >= r[1] && s[3] <= r[3] ? !0 : OE(
    i,
    e,
    t,
    n,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(o, a) {
      return FT(r, o, a);
    }
  ) : !1;
}
function C2(i, e, t, n, r) {
  for (let s = 0, o = t.length; s < o; ++s) {
    if (Ef(i, e, t[s], n, r))
      return !0;
    e = t[s];
  }
  return !1;
}
function NE(i, e, t, n, r) {
  return !!(Ef(i, e, t, n, r) || Ys(
    i,
    e,
    t,
    n,
    r[0],
    r[1]
  ) || Ys(
    i,
    e,
    t,
    n,
    r[0],
    r[3]
  ) || Ys(
    i,
    e,
    t,
    n,
    r[2],
    r[1]
  ) || Ys(
    i,
    e,
    t,
    n,
    r[2],
    r[3]
  ));
}
function DE(i, e, t, n, r) {
  if (!NE(i, e, t[0], n, r))
    return !1;
  if (t.length === 1)
    return !0;
  for (let s = 1, o = t.length; s < o; ++s)
    if (P2(
      i,
      t[s - 1],
      t[s],
      n,
      r
    ) && !Ef(
      i,
      t[s - 1],
      t[s],
      n,
      r
    ))
      return !1;
  return !0;
}
function A2(i, e, t, n, r) {
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s];
    if (DE(i, e, a, n, r))
      return !0;
    e = a[a.length - 1];
  }
  return !1;
}
function am(i, e, t, n) {
  let r = i[e], s = i[e + 1], o = 0;
  for (let a = e + n; a < t; a += n) {
    const l = i[a], h = i[a + 1];
    o += Math.sqrt((l - r) * (l - r) + (h - s) * (h - s)), r = l, s = h;
  }
  return o;
}
function vf(i, e, t, n, r, s, o) {
  const a = (t - e) / n;
  if (a < 3) {
    for (; e < t; e += n)
      s[o++] = i[e], s[o++] = i[e + 1];
    return o;
  }
  const l = new Array(a);
  l[0] = 1, l[a - 1] = 1;
  const h = [e, t - n];
  let u = 0;
  for (; h.length > 0; ) {
    const c = h.pop(), f = h.pop();
    let g = 0;
    const d = i[f], m = i[f + 1], x = i[c], v = i[c + 1];
    for (let p = f + n; p < c; p += n) {
      const y = i[p], E = i[p + 1], b = vE(y, E, d, m, x, v);
      b > g && (u = p, g = b);
    }
    g > r && (l[(u - e) / n] = 1, f + n < u && h.push(f, u), u + n < c && h.push(u, c));
  }
  for (let c = 0; c < a; ++c)
    l[c] && (s[o++] = i[e + c * n], s[o++] = i[e + c * n + 1]);
  return o;
}
function GE(i, e, t, n, r, s, o, a) {
  for (let l = 0, h = t.length; l < h; ++l) {
    const u = t[l];
    o = vf(
      i,
      e,
      u,
      n,
      r,
      s,
      o
    ), a.push(o), e = u;
  }
  return o;
}
function zs(i, e) {
  return e * Math.round(i / e);
}
function I2(i, e, t, n, r, s, o) {
  if (e == t)
    return o;
  let a = zs(i[e], r), l = zs(i[e + 1], r);
  e += n, s[o++] = a, s[o++] = l;
  let h, u;
  do
    if (h = zs(i[e], r), u = zs(i[e + 1], r), e += n, e == t)
      return s[o++] = h, s[o++] = u, o;
  while (h == a && u == l);
  for (; e < t; ) {
    const c = zs(i[e], r), f = zs(i[e + 1], r);
    if (e += n, c == h && f == u)
      continue;
    const g = h - a, d = u - l, m = c - a, x = f - l;
    if (g * x == d * m && (g < 0 && m < g || g == m || g > 0 && m > g) && (d < 0 && x < d || d == x || d > 0 && x > d)) {
      h = c, u = f;
      continue;
    }
    s[o++] = h, s[o++] = u, a = h, l = u, h = c, u = f;
  }
  return s[o++] = h, s[o++] = u, o;
}
function lm(i, e, t, n, r, s, o, a) {
  for (let l = 0, h = t.length; l < h; ++l) {
    const u = t[l];
    o = I2(
      i,
      e,
      u,
      n,
      r,
      s,
      o
    ), a.push(o), e = u;
  }
  return o;
}
function L2(i, e, t, n, r, s, o, a) {
  for (let l = 0, h = t.length; l < h; ++l) {
    const u = t[l], c = [];
    o = lm(
      i,
      e,
      u,
      n,
      r,
      s,
      o,
      c
    ), a.push(c), e = u[u.length - 1];
  }
  return o;
}
class Wt extends Br {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(e) {
    ze(this.flatCoordinates, e), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   * @override
   */
  clone() {
    const e = new Wt(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, n, r) {
    return r < yo(this.getExtent(), e, t) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      im(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), rm(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      n,
      r
    ));
  }
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(e) {
    return OE(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t) {
    return this.layout != "XYM" && this.layout != "XYZM" ? null : (t = t !== void 0 ? t : !1, Dg(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t
    ));
  }
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return cs(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(e, t) {
    return cc(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      this.stride
    );
  }
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return am(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(
      0.5,
      this.flatMidpoint_ ?? void 0
    ), this.flatMidpointRevision_ = this.getRevision()), /** @type {Array<number>} */
    this.flatMidpoint_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = vf(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new Wt(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "LineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    return Ef(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      this.getExtent()
    );
  }
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Th(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
function kE(i, e, t, n) {
  let r = 0;
  const s = i[t - n], o = i[t - n + 1];
  let a = 0, l = 0;
  for (; e < t; e += n) {
    const h = i[e] - s, u = i[e + 1] - o;
    r += l * h - a * u, a = h, l = u;
  }
  return r / 2;
}
function UE(i, e, t, n) {
  let r = 0;
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s];
    r += kE(i, e, a, n), e = a;
  }
  return r;
}
function F2(i, e, t, n) {
  let r = 0;
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s];
    r += UE(i, e, a, n), e = a[a.length - 1];
  }
  return r;
}
class bs extends Br {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   * @override
   */
  clone() {
    return new bs(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, n, r) {
    return r < yo(this.getExtent(), e, t) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      im(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), rm(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      n,
      r
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return kE(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return cs(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = vf(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new bs(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Th(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
class Xi extends Br {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(e, t, n) {
    if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(e[0]))
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        e,
        t
      );
    else if (t !== void 0 && n)
      this.setFlatCoordinates(
        t,
        /** @type {Array<number>} */
        e
      ), this.ends_ = n;
    else {
      const r = (
        /** @type {Array<LineString>} */
        e
      ), s = [], o = [];
      for (let l = 0, h = r.length; l < h; ++l) {
        const u = r[l];
        ze(s, u.getFlatCoordinates()), o.push(s.length);
      }
      const a = r.length === 0 ? this.getLayout() : r[0].getLayout();
      this.setFlatCoordinates(a, s), this.ends_ = o;
    }
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(e) {
    ze(this.flatCoordinates, e.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   * @override
   */
  clone() {
    const e = new Xi(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, n, r) {
    return r < yo(this.getExtent(), e, t) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      nm(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), sm(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      n,
      r
    ));
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t, n) {
    return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (t = t !== void 0 ? t : !1, n = n !== void 0 ? n : !1, R2(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      n
    ));
  }
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return Kl(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(e) {
    return e < 0 || this.ends_.length <= e ? null : new Wt(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const e = this.flatCoordinates, t = this.ends_, n = this.layout, r = [];
    let s = 0;
    for (let o = 0, a = t.length; o < a; ++o) {
      const l = t[o], h = new Wt(
        e.slice(s, l),
        n
      );
      r.push(h), s = l;
    }
    return r;
  }
  /**
   * Return the sum of all line string lengths
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    const e = this.ends_;
    let t = 0, n = 0;
    for (let r = 0, s = e.length; r < s; ++r)
      n += am(
        this.flatCoordinates,
        t,
        e[r],
        this.stride
      ), t = e[r];
    return n;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const e = [], t = this.flatCoordinates;
    let n = 0;
    const r = this.ends_, s = this.stride;
    for (let o = 0, a = r.length; o < a; ++o) {
      const l = r[o], h = cc(
        t,
        n,
        l,
        s,
        0.5
      );
      ze(e, h), n = l;
    }
    return e;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], n = [];
    return t.length = GE(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      0,
      n
    ), new Xi(t, "XY", n);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "MultiLineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    return C2(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const n = Rh(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed();
  }
}
let Jt = class zE extends Br {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.setCoordinates(e, t);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   * @override
   */
  clone() {
    const e = new zE(this.flatCoordinates.slice(), this.layout);
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, n, r) {
    const s = this.flatCoordinates, o = Js(
      e,
      t,
      s[0],
      s[1]
    );
    if (o < r) {
      const a = this.stride;
      for (let l = 0; l < a; ++l)
        n[l] = s[l];
      return n.length = a, o;
    }
    return r;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(e) {
    return Bp(this.flatCoordinates, e);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    return zp(e, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = T2(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
};
class Zn extends Br {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), t && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(e) {
    ze(this.flatCoordinates, e.getFlatCoordinates()), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   * @override
   */
  clone() {
    const e = new Zn(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, n, r) {
    if (r < yo(this.getExtent(), e, t))
      return r;
    const s = this.flatCoordinates, o = this.stride;
    for (let a = 0, l = s.length; a < l; a += o) {
      const h = Js(
        e,
        t,
        s[a],
        s[a + 1]
      );
      if (h < r) {
        r = h;
        for (let u = 0; u < o; ++u)
          n[u] = s[a + u];
        n.length = o;
      }
    }
    return r;
  }
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return cs(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(e) {
    const t = this.flatCoordinates.length / this.stride;
    return e < 0 || t <= e ? null : new Jt(
      this.flatCoordinates.slice(
        e * this.stride,
        (e + 1) * this.stride
      ),
      this.layout
    );
  }
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const e = this.flatCoordinates, t = this.layout, n = this.stride, r = [];
    for (let s = 0, o = e.length; s < o; s += n) {
      const a = new Jt(e.slice(s, s + n), t);
      r.push(a);
    }
    return r;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "MultiPoint";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    const t = this.flatCoordinates, n = this.stride;
    for (let r = 0, s = t.length; r < s; r += n) {
      const o = t[r], a = t[r + 1];
      if (zp(e, o, a))
        return !0;
    }
    return !1;
  }
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Th(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
function hm(i, e, t, n, r, s, o) {
  let a, l, h, u, c, f, g;
  const d = r[s + 1], m = [];
  for (let p = 0, y = t.length; p < y; ++p) {
    const E = t[p];
    for (u = i[E - n], f = i[E - n + 1], a = e; a < E; a += n)
      c = i[a], g = i[a + 1], (d <= f && g <= d || f <= d && d <= g) && (h = (d - f) / (g - f) * (c - u) + u, m.push(h)), u = c, f = g;
  }
  let x = NaN, v = -1 / 0;
  for (m.sort(lr), u = m[0], a = 1, l = m.length; a < l; ++a) {
    c = m[a];
    const p = Math.abs(c - u);
    p > v && (h = (u + c) / 2, om(i, e, t, n, h, d) && (x = h, v = p)), u = c;
  }
  return isNaN(x) && (x = r[s]), o ? (o.push(x, d, v), o) : [x, d, v];
}
function BE(i, e, t, n, r) {
  let s = [];
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    s = hm(
      i,
      e,
      l,
      n,
      r,
      2 * o,
      s
    ), e = l[l.length - 1];
  }
  return s;
}
function O2(i, e, t, n) {
  for (; e < t - n; ) {
    for (let r = 0; r < n; ++r) {
      const s = i[e + r];
      i[e + r] = i[t - n + r], i[t - n + r] = s;
    }
    e += n, t -= n;
  }
}
function wf(i, e, t, n) {
  let r = 0, s = i[t - n], o = i[t - n + 1];
  for (; e < t; e += n) {
    const a = i[e], l = i[e + 1];
    r += (a - s) * (l + o), s = a, o = l;
  }
  return r === 0 ? void 0 : r > 0;
}
function um(i, e, t, n, r) {
  r = r !== void 0 ? r : !1;
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s], l = wf(
      i,
      e,
      a,
      n
    );
    if (s === 0) {
      if (r && l || !r && !l)
        return !1;
    } else if (r && !l || !r && l)
      return !1;
    e = a;
  }
  return !0;
}
function $E(i, e, t, n, r) {
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s];
    if (!um(i, e, a, n, r))
      return !1;
    a.length && (e = a[a.length - 1]);
  }
  return !0;
}
function fc(i, e, t, n, r) {
  r = r !== void 0 ? r : !1;
  for (let s = 0, o = t.length; s < o; ++s) {
    const a = t[s], l = wf(
      i,
      e,
      a,
      n
    );
    (s === 0 ? r && l || !r && !l : r && !l || !r && l) && O2(i, e, a, n), e = a;
  }
  return e;
}
function Gg(i, e, t, n, r) {
  for (let s = 0, o = t.length; s < o; ++s)
    e = fc(
      i,
      e,
      t[s],
      n,
      r
    );
  return e;
}
function cm(i, e) {
  const t = [];
  let n = 0, r = 0, s;
  for (let o = 0, a = e.length; o < a; ++o) {
    const l = e[o], h = wf(i, n, l, 2);
    if (s === void 0 && (s = h), h === s)
      t.push(e.slice(r, o + 1));
    else {
      if (t.length === 0)
        continue;
      t[t.length - 1].push(e[r]);
    }
    r = o + 1, n = l;
  }
  return t;
}
class ei extends Br {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(e, t, n) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, t !== void 0 && n ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.ends_ = n) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      e,
      t
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(e) {
    this.flatCoordinates ? ze(this.flatCoordinates, e.getFlatCoordinates()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   * @override
   */
  clone() {
    const e = new ei(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, n, r) {
    return r < yo(this.getExtent(), e, t) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      nm(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), sm(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      n,
      r
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(e, t) {
    return om(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return UE(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), fc(t, 0, this.ends_, this.stride, e)) : t = this.flatCoordinates, Kl(t, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const e = Vt(this.getExtent());
      this.flatInteriorPoint_ = hm(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        e,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new Jt(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(e) {
    return e < 0 || this.ends_.length <= e ? null : new bs(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const e = this.layout, t = this.flatCoordinates, n = this.ends_, r = [];
    let s = 0;
    for (let o = 0, a = n.length; o < a; ++o) {
      const l = n[o], h = new bs(
        t.slice(s, l),
        e
      );
      r.push(h), s = l;
    }
    return r;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      um(e, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = fc(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], n = [];
    return t.length = lm(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      n
    ), new ei(t, "XY", n);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    return DE(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const n = Rh(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed();
  }
}
function W_(i) {
  if (qn(i))
    throw new Error("Cannot create polygon from empty extent");
  const e = i[0], t = i[1], n = i[2], r = i[3], s = [
    e,
    t,
    e,
    r,
    n,
    r,
    n,
    t,
    e,
    t
  ];
  return new ei(s, "XY", [s.length]);
}
function jE(i, e, t, n) {
  const r = [];
  let s = hi();
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    s = $p(
      i,
      e,
      l[0],
      n
    ), r.push((s[0] + s[2]) / 2, (s[1] + s[3]) / 2), e = l[l.length - 1];
  }
  return r;
}
class Cn extends Br {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(e, t, n) {
    if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !n && !Array.isArray(e[0])) {
      const r = (
        /** @type {Array<Polygon>} */
        e
      ), s = [], o = [];
      for (let a = 0, l = r.length; a < l; ++a) {
        const h = r[a], u = s.length, c = h.getEnds();
        for (let f = 0, g = c.length; f < g; ++f)
          c[f] += u;
        ze(s, h.getFlatCoordinates()), o.push(c);
      }
      t = r.length === 0 ? this.getLayout() : r[0].getLayout(), e = s, n = o;
    }
    t !== void 0 && n ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.endss_ = n) : this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      e,
      t
    );
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(e) {
    let t;
    if (!this.flatCoordinates)
      this.flatCoordinates = e.getFlatCoordinates().slice(), t = e.getEnds().slice(), this.endss_.push();
    else {
      const n = this.flatCoordinates.length;
      ze(this.flatCoordinates, e.getFlatCoordinates()), t = e.getEnds().slice();
      for (let r = 0, s = t.length; r < s; ++r)
        t[r] += n;
    }
    this.endss_.push(t), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   * @override
   */
  clone() {
    const e = this.endss_.length, t = new Array(e);
    for (let r = 0; r < e; ++r)
      t[r] = this.endss_[r].slice();
    const n = new Cn(
      this.flatCoordinates.slice(),
      this.layout,
      t
    );
    return n.applyProperties(this), n;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, n, r) {
    return r < yo(this.getExtent(), e, t) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      b2(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), S2(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      n,
      r
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(e, t) {
    return M2(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return F2(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), Gg(
      t,
      0,
      this.endss_,
      this.stride,
      e
    )) : t = this.flatCoordinates, Ng(
      t,
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const e = jE(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = BE(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        e
      ), this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.flatInteriorPoints_
    );
  }
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new Zn(this.getFlatInteriorPoints().slice(), "XYM");
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      $E(e, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = Gg(
        this.orientedFlatCoordinates_,
        0,
        this.endss_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], n = [];
    return t.length = L2(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      n
    ), new Cn(t, "XY", n);
  }
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(e) {
    if (e < 0 || this.endss_.length <= e)
      return null;
    let t;
    if (e === 0)
      t = 0;
    else {
      const s = this.endss_[e - 1];
      t = s[s.length - 1];
    }
    const n = this.endss_[e].slice(), r = n[n.length - 1];
    if (t !== 0)
      for (let s = 0, o = n.length; s < o; ++s)
        n[s] -= t;
    return new ei(
      this.flatCoordinates.slice(t, r),
      this.layout,
      n
    );
  }
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const e = this.layout, t = this.flatCoordinates, n = this.endss_, r = [];
    let s = 0;
    for (let o = 0, a = n.length; o < a; ++o) {
      const l = n[o].slice(), h = l[l.length - 1];
      if (s !== 0)
        for (let c = 0, f = l.length; c < f; ++c)
          l[c] -= s;
      const u = new ei(
        t.slice(s, h),
        e,
        l
      );
      r.push(u), s = h;
    }
    return r;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "MultiPolygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    return A2(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 3), this.flatCoordinates || (this.flatCoordinates = []);
    const n = FE(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.endss_
    );
    if (n.length === 0)
      this.flatCoordinates.length = 0;
    else {
      const r = n[n.length - 1];
      this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1];
    }
    this.changed();
  }
}
class Qt extends tm {
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  constructor(e) {
    super(), this.geometries_ = e, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
  }
  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(tt), this.changeEventsKeys_.length = 0;
  }
  /**
   * @private
   */
  listenGeometriesChange_() {
    const e = this.geometries_;
    for (let t = 0, n = e.length; t < n; ++t)
      this.changeEventsKeys_.push(
        Ce(e[t], le.CHANGE, this.changed, this)
      );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   * @override
   */
  clone() {
    const e = new Qt(
      xd(this.geometries_)
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(e, t, n, r) {
    if (r < yo(this.getExtent(), e, t))
      return r;
    const s = this.geometries_;
    for (let o = 0, a = s.length; o < a; ++o)
      r = s[o].closestPointXY(
        e,
        t,
        n,
        r
      );
    return r;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(e, t) {
    const n = this.geometries_;
    for (let r = 0, s = n.length; r < s; ++r)
      if (n[r].containsXY(e, t))
        return !0;
    return !1;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(e) {
    Ua(e);
    const t = this.geometries_;
    for (let n = 0, r = t.length; n < r; ++n)
      jp(e, t[n].getExtent());
    return e;
  }
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return xd(this.geometries_);
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    let e = [];
    const t = this.geometries_;
    for (let n = 0, r = t.length; n < r; ++n)
      t[n].getType() === this.getType() ? e = e.concat(
        /** @type {GeometryCollection} */
        t[n].getGeometriesArrayRecursive()
      ) : e.push(t[n]);
    return e;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   * @override
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e < this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = [], n = this.geometries_;
    let r = !1;
    for (let s = 0, o = n.length; s < o; ++s) {
      const a = n[s], l = a.getSimplifiedGeometry(e);
      t.push(l), l !== a && (r = !0);
    }
    return r ? new Qt(
      t
    ) : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "GeometryCollection";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(e) {
    const t = this.geometries_;
    for (let n = 0, r = t.length; n < r; ++n)
      if (t[n].intersectsExtent(e))
        return !0;
    return !1;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   * @override
   */
  rotate(e, t) {
    const n = this.geometries_;
    for (let r = 0, s = n.length; r < s; ++r)
      n[r].rotate(e, t);
    this.changed();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   * @override
   */
  scale(e, t, n) {
    n || (n = Vt(this.getExtent()));
    const r = this.geometries_;
    for (let s = 0, o = r.length; s < o; ++s)
      r[s].scale(e, t, n);
    this.changed();
  }
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(e) {
    this.setGeometriesArray(xd(e));
  }
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(e) {
    this.unlistenGeometriesChange_(), this.geometries_ = e, this.listenGeometriesChange_(), this.changed();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   * @override
   */
  applyTransform(e) {
    const t = this.geometries_;
    for (let n = 0, r = t.length; n < r; ++n)
      t[n].applyTransform(e);
    this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   * @override
   */
  translate(e, t) {
    const n = this.geometries_;
    for (let r = 0, s = n.length; r < s; ++r)
      n[r].translate(e, t);
    this.changed();
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.unlistenGeometriesChange_(), super.disposeInternal();
  }
}
function xd(i) {
  return i.map((e) => e.clone());
}
const Y_ = st();
class fi {
  /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(e, t, n, r, s, o) {
    this.styleFunction, this.extent_, this.id_ = o, this.type_ = e, this.flatCoordinates_ = t, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = n || null, this.properties_ = s, this.squaredTolerance_, this.stride_ = r, this.simplifiedGeometry_;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(e) {
    return this.properties_[e];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_ || (this.extent_ = this.type_ === "Point" ? Bp(this.flatCoordinates_) : $p(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2
    )), this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const e = Vt(this.getExtent());
      this.flatInteriorPoints_ = hm(
        this.flatCoordinates_,
        0,
        this.ends_,
        2,
        e,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const e = cm(this.flatCoordinates_, this.ends_), t = jE(this.flatCoordinates_, 0, e, 2);
      this.flatInteriorPoints_ = BE(
        this.flatCoordinates_,
        0,
        e,
        2,
        t
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpoints_ || (this.flatMidpoints_ = cc(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2,
      0.5
    )), this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const e = this.flatCoordinates_;
      let t = 0;
      const n = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let r = 0, s = n.length; r < s; ++r) {
        const o = n[r], a = cc(e, t, o, 2, 0.5);
        ze(this.flatMidpoints_, a), t = o;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride_;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(e) {
    e = ee(e);
    const t = e.getExtent(), n = e.getWorldExtent();
    if (t && n) {
      const r = it(n) / it(t);
      un(
        Y_,
        n[0],
        n[3],
        r,
        -r,
        0,
        0,
        0
      ), hr(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        Y_,
        this.flatCoordinates_
      );
    }
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */
  applyTransform(e) {
    e(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
  }
  /**
   * @return {RenderFeature} A cloned render feature.
   */
  clone() {
    return new fi(
      this.type_,
      this.flatCoordinates_.slice(),
      this.ends_?.slice(),
      this.stride_,
      Object.assign({}, this.properties_),
      this.id_
    );
  }
  /**
   * @return {Array<number>|null} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */
  enableSimplifyTransformed() {
    return this.simplifyTransformed = gE((e, t) => {
      if (e === this.squaredTolerance_)
        return this.simplifiedGeometry_;
      this.simplifiedGeometry_ = this.clone(), t && this.simplifiedGeometry_.applyTransform(t);
      const n = this.simplifiedGeometry_.getFlatCoordinates();
      let r;
      switch (this.type_) {
        case "LineString":
          n.length = vf(
            n,
            0,
            this.simplifiedGeometry_.flatCoordinates_.length,
            this.simplifiedGeometry_.stride_,
            e,
            n,
            0
          ), r = [n.length];
          break;
        case "MultiLineString":
          r = [], n.length = GE(
            n,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            e,
            n,
            0,
            r
          );
          break;
        case "Polygon":
          r = [], n.length = lm(
            n,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            Math.sqrt(e),
            n,
            0,
            r
          );
          break;
      }
      return r && (this.simplifiedGeometry_ = new fi(
        this.type_,
        n,
        r,
        2,
        this.properties_,
        this.id_
      )), this.squaredTolerance_ = e, this.simplifiedGeometry_;
    }), this;
  }
}
fi.prototype.getFlatCoordinates = fi.prototype.getOrientedFlatCoordinates;
class Ph {
  constructor() {
    this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */
    li, this.supportedMediaTypes = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */
  getReadOptions(e, t) {
    if (t) {
      let n = t.dataProjection ? ee(t.dataProjection) : this.readProjection(e);
      t.extent && n && n.getUnits() === "tile-pixels" && (n = ee(n), n.setWorldExtent(t.extent)), t = {
        dataProjection: n,
        featureProjection: t.featureProjection
      };
    }
    return this.adaptOptions(t);
  }
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */
  adaptOptions(e) {
    return Object.assign(
      {
        dataProjection: this.dataProjection,
        featureProjection: this.defaultFeatureProjection,
        featureClass: this.featureClass
      },
      e
    );
  }
  /**
   * @abstract
   * @return {Type} The format type.
   */
  getType() {
    return de();
  }
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {FeatureType|Array<FeatureType>} Feature.
   */
  readFeature(e, t) {
    return de();
  }
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<FeatureType>} Features.
   */
  readFeatures(e, t) {
    return de();
  }
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(e, t) {
    return de();
  }
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjection(e) {
    return de();
  }
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {Feature} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeature(e, t) {
    return de();
  }
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<Feature>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeatures(e, t) {
    return de();
  }
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeGeometry(e, t) {
    return de();
  }
}
function xt(i, e, t) {
  const n = t ? ee(t.featureProjection) : null, r = t ? ee(t.dataProjection) : null;
  let s = i;
  if (n && r && !wt(n, r)) {
    e && (s = /** @type {T} */
    i.clone());
    const o = e ? n : r, a = e ? r : n;
    o.getUnits() === "tile-pixels" ? s.transform(o, a) : s.applyTransform(Vn(o, a));
  }
  if (e && t && /** @type {WriteOptions} */
  t.decimals !== void 0) {
    const o = Math.pow(
      10,
      /** @type {WriteOptions} */
      t.decimals
    ), a = function(l) {
      for (let h = 0, u = l.length; h < u; ++h)
        l[h] = Math.round(l[h] * o) / o;
      return l;
    };
    s === i && (s = /** @type {T} */
    i.clone()), s.applyTransform(a);
  }
  return s;
}
function fm(i, e) {
  const t = e ? ee(e.featureProjection) : null, n = e ? ee(e.dataProjection) : null;
  return t && n && !wt(t, n) ? Or(i, n, t) : i;
}
const N2 = {
  Point: Jt,
  LineString: Wt,
  Polygon: ei,
  MultiPoint: Zn,
  MultiLineString: Xi,
  MultiPolygon: Cn
};
function D2(i, e, t) {
  return Array.isArray(e[0]) ? ($E(i, 0, e, t) || (i = i.slice(), Gg(i, 0, e, t)), i) : (um(i, 0, e, t) || (i = i.slice(), fc(i, 0, e, t)), i);
}
function XE(i, e) {
  const t = i.geometry;
  if (!t)
    return [];
  if (Array.isArray(t))
    return t.map((s) => XE({ ...i, geometry: s })).flat();
  const n = t.type === "MultiPolygon" ? "Polygon" : t.type;
  if (n === "GeometryCollection" || n === "Circle")
    throw new Error("Unsupported geometry type: " + n);
  const r = t.layout.length;
  return xt(
    new fi(
      n,
      n === "Polygon" ? D2(t.flatCoordinates, t.ends, r) : t.flatCoordinates,
      t.ends?.flat(),
      r,
      i.properties || {},
      i.id
    ).enableSimplifyTransformed(),
    !1,
    e
  );
}
function dm(i, e) {
  if (!i)
    return null;
  if (Array.isArray(i)) {
    const n = i.map(
      (r) => dm(r, e)
    );
    return new Qt(n);
  }
  const t = N2[i.type];
  return xt(
    new t(i.flatCoordinates, i.layout || "XY", i.ends),
    !1,
    e
  );
}
class gm extends Ph {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   * @override
   */
  getType() {
    return "json";
  }
  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {FeatureType|Array<FeatureType>} Feature.
   * @api
   * @override
   */
  readFeature(e, t) {
    return this.readFeatureFromObject(
      ou(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<FeatureType>} Features.
   * @api
   * @override
   */
  readFeatures(e, t) {
    return this.readFeaturesFromObject(
      ou(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {FeatureType|Array<FeatureType>} Feature.
   */
  readFeatureFromObject(e, t) {
    return de();
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<FeatureType>} Features.
   */
  readFeaturesFromObject(e, t) {
    return de();
  }
  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   * @override
   */
  readGeometry(e, t) {
    return this.readGeometryFromObject(
      ou(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return de();
  }
  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   * @override
   */
  readProjection(e) {
    return this.readProjectionFromObject(ou(e));
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    return de();
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   * @override
   */
  writeFeature(e, t) {
    return JSON.stringify(this.writeFeatureObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeatureObject(e, t) {
    return de();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   * @override
   */
  writeFeatures(e, t) {
    return JSON.stringify(this.writeFeaturesObject(e, t));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeaturesObject(e, t) {
    return de();
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   * @override
   */
  writeGeometry(e, t) {
    return JSON.stringify(this.writeGeometryObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeGeometryObject(e, t) {
    return de();
  }
}
function ou(i) {
  if (typeof i == "string") {
    const e = JSON.parse(i);
    return e || null;
  }
  return i !== null ? i : null;
}
const G2 = {
  Point: B2,
  LineString: $2,
  Polygon: W2,
  MultiPoint: X2,
  MultiLineString: j2,
  MultiPolygon: V2
}, k2 = {
  Point: Y2,
  LineString: q2,
  Polygon: Z2,
  MultiPoint: K2,
  MultiLineString: H2,
  MultiPolygon: J2
};
class U2 extends gm {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(), this.geometryName_ = e.geometryName;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @param {string} [idField] Name of the field where to get the id from.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   * @override
   */
  readFeatureFromObject(e, t, n) {
    const r = (
      /** @type {EsriJSONFeature} */
      e
    ), s = q_(r.geometry, t), o = new li();
    if (this.geometryName_ && o.setGeometryName(this.geometryName_), o.setGeometry(s), r.attributes) {
      o.setProperties(r.attributes, !0);
      const a = r.attributes[n];
      a !== void 0 && o.setId(
        /** @type {number} */
        a
      );
    }
    return o;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   * @override
   */
  readFeaturesFromObject(e, t) {
    if (t = t || {}, e.features) {
      const n = (
        /** @type {EsriJSONFeatureSet} */
        e
      ), r = [], s = n.features;
      for (let o = 0, a = s.length; o < a; ++o)
        r.push(
          this.readFeatureFromObject(
            s[o],
            t,
            e.objectIdFieldName
          )
        );
      return r;
    }
    return [this.readFeatureFromObject(e, t)];
  }
  /**
   * @param {EsriJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @override
   */
  readGeometryFromObject(e, t) {
    return q_(e, t);
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   * @override
   */
  readProjectionFromObject(e) {
    if (e.spatialReference && e.spatialReference.wkid !== void 0) {
      const n = /** @type {EsriJSONSpatialReferenceWkid} */ e.spatialReference.wkid;
      return ee("EPSG:" + n);
    }
    return null;
  }
  /**
   * Encode a geometry as a EsriJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {EsriJSONGeometry} Object.
   * @api
   * @override
   */
  writeGeometryObject(e, t) {
    return Z_(e, this.adaptOptions(t));
  }
  /**
   * Encode a feature as a esriJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   * @api
   * @override
   */
  writeFeatureObject(e, t) {
    t = this.adaptOptions(t);
    const n = {};
    if (!e.hasProperties())
      return n.attributes = {}, n;
    const r = e.getProperties(), s = e.getGeometry();
    if (s) {
      n.geometry = Z_(s, t);
      const o = t && (t.dataProjection || t.featureProjection);
      o && (n.geometry.spatialReference = /** @type {EsriJSONSpatialReferenceWkid} */
      {
        wkid: Number(ee(o).getCode().split(":").pop())
      }), delete r[e.getGeometryName()];
    }
    return Ur(r) ? n.attributes = {} : n.attributes = r, n;
  }
  /**
   * Encode an array of features as a EsriJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {EsriJSONFeatureSet} EsriJSON Object.
   * @api
   * @override
   */
  writeFeaturesObject(e, t) {
    t = this.adaptOptions(t);
    const n = [];
    for (let r = 0, s = e.length; r < s; ++r)
      n.push(this.writeFeatureObject(e[r], t));
    return {
      features: n
    };
  }
}
function q_(i, e) {
  if (!i)
    return null;
  let t;
  if (typeof i.x == "number" && typeof i.y == "number")
    t = "Point";
  else if (i.points)
    t = "MultiPoint";
  else if (i.paths)
    /** @type {EsriJSONPolyline} */
    i.paths.length === 1 ? t = "LineString" : t = "MultiLineString";
  else if (i.rings) {
    const r = (
      /** @type {EsriJSONPolygon} */
      i
    ), s = Ba(r), o = z2(r.rings, s);
    o.length === 1 ? (t = "Polygon", i = Object.assign({}, i, { rings: o[0] })) : (t = "MultiPolygon", i = Object.assign({}, i, { rings: o }));
  }
  const n = G2[t];
  return xt(n(i), !1, e);
}
function z2(i, e) {
  const t = [], n = [], r = [];
  let s, o;
  for (s = 0, o = i.length; s < o; ++s)
    t.length = 0, Th(t, 0, i[s], e.length), wf(
      t,
      0,
      t.length,
      e.length
    ) ? n.push([i[s]]) : r.push(i[s]);
  for (; r.length; ) {
    const a = r.shift();
    let l = !1;
    for (s = n.length - 1; s >= 0; s--) {
      const h = n[s][0];
      if (Bi(
        new bs(h).getExtent(),
        new bs(a).getExtent()
      )) {
        n[s].push(a), l = !0;
        break;
      }
    }
    l || n.push([a.reverse()]);
  }
  return n;
}
function B2(i) {
  let e;
  return i.m !== void 0 && i.z !== void 0 ? e = new Jt([i.x, i.y, i.z, i.m], "XYZM") : i.z !== void 0 ? e = new Jt([i.x, i.y, i.z], "XYZ") : i.m !== void 0 ? e = new Jt([i.x, i.y, i.m], "XYM") : e = new Jt([i.x, i.y]), e;
}
function $2(i) {
  const e = Ba(i);
  return new Wt(i.paths[0], e);
}
function j2(i) {
  const e = Ba(i);
  return new Xi(i.paths, e);
}
function Ba(i) {
  let e = "XY";
  return i.hasZ === !0 && i.hasM === !0 ? e = "XYZM" : i.hasZ === !0 ? e = "XYZ" : i.hasM === !0 && (e = "XYM"), e;
}
function X2(i) {
  const e = Ba(i);
  return new Zn(i.points, e);
}
function V2(i) {
  const e = Ba(i);
  return new Cn(i.rings, e);
}
function W2(i) {
  const e = Ba(i);
  return new ei(i.rings, e);
}
function Y2(i, e) {
  const t = i.getCoordinates();
  let n;
  const r = i.getLayout();
  if (r === "XYZ")
    n = {
      x: t[0],
      y: t[1],
      z: t[2]
    };
  else if (r === "XYM")
    n = {
      x: t[0],
      y: t[1],
      m: t[2]
    };
  else if (r === "XYZM")
    n = {
      x: t[0],
      y: t[1],
      z: t[2],
      m: t[3]
    };
  else if (r === "XY")
    n = {
      x: t[0],
      y: t[1]
    };
  else
    throw new Error("Invalid geometry layout");
  return n;
}
function Mh(i) {
  const e = i.getLayout();
  return {
    hasZ: e === "XYZ" || e === "XYZM",
    hasM: e === "XYM" || e === "XYZM"
  };
}
function q2(i, e) {
  const t = Mh(i);
  return {
    hasZ: t.hasZ,
    hasM: t.hasM,
    paths: [
      /** @type {Array<EsriJSONPosition>} */
      i.getCoordinates()
    ]
  };
}
function Z2(i, e) {
  const t = Mh(i);
  return {
    hasZ: t.hasZ,
    hasM: t.hasM,
    rings: (
      /** @type {Array<Array<EsriJSONPosition>>} */
      i.getCoordinates(!1)
    )
  };
}
function H2(i, e) {
  const t = Mh(i);
  return {
    hasZ: t.hasZ,
    hasM: t.hasM,
    paths: (
      /** @type {Array<Array<EsriJSONPosition>>} */
      i.getCoordinates()
    )
  };
}
function K2(i, e) {
  const t = Mh(i);
  return {
    hasZ: t.hasZ,
    hasM: t.hasM,
    points: (
      /** @type {Array<EsriJSONPosition>} */
      i.getCoordinates()
    )
  };
}
function J2(i, e) {
  const t = Mh(i), n = i.getCoordinates(!1), r = [];
  for (let s = 0; s < n.length; s++)
    for (let o = n[s].length - 1; o >= 0; o--)
      r.push(n[s][o]);
  return {
    hasZ: t.hasZ,
    hasM: t.hasM,
    rings: (
      /** @type {Array<Array<EsriJSONPosition>>} */
      r
    )
  };
}
function Z_(i, e) {
  const t = k2[i.getType()];
  return t(
    xt(i, !0, e),
    e
  );
}
const ho = "http://www.w3.org/2001/XMLSchema-instance";
function be(i, e) {
  return $a().createElementNS(i, e);
}
function Mi(i, e) {
  return VE(i, e, []).join("");
}
function VE(i, e, t) {
  if (i.nodeType == Node.CDATA_SECTION_NODE || i.nodeType == Node.TEXT_NODE)
    t.push(i.nodeValue);
  else {
    let n;
    for (n = i.firstChild; n; n = n.nextSibling)
      VE(n, e, t);
  }
  return t;
}
function En(i) {
  return "documentElement" in i;
}
function Q2(i, e, t) {
  return i.getAttributeNS(e, t) || "";
}
function vn(i) {
  return new DOMParser().parseFromString(i, "application/xml");
}
function dc(i, e) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @this {*}
     */
    (function(t, n) {
      const r = i.call(e ?? this, t, n);
      if (r !== void 0) {
        const s = (
          /** @type {Array<*>} */
          n[n.length - 1]
        );
        ze(s, r);
      }
    })
  );
}
function ue(i, e) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @this {*}
     */
    (function(t, n) {
      const r = i.call(e ?? this, t, n);
      r !== void 0 && /** @type {Array<*>} */
      n[n.length - 1].push(r);
    })
  );
}
function ge(i, e) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @this {*}
     */
    (function(t, n) {
      const r = i.call(e ?? this, t, n);
      r !== void 0 && (n[n.length - 1] = r);
    })
  );
}
function Ze(i, e, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @this {*}
     */
    (function(n, r) {
      const s = i.call(this, n, r);
      if (s !== void 0) {
        const o = (
          /** @type {!Object} */
          r[r.length - 1]
        ), a = n.localName;
        let l;
        a in o ? l = o[a] : (l = [], o[a] = l), l.push(s);
      }
    })
  );
}
function F(i, e, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @this {*}
     */
    (function(n, r) {
      const s = i.call(this, n, r);
      if (s !== void 0) {
        const o = (
          /** @type {!Object} */
          r[r.length - 1]
        ), a = e !== void 0 ? e : n.localName;
        o[a] = s;
      }
    })
  );
}
function N(i, e) {
  return (
    /**
     * @param {Element} node Node.
     * @param {*} value Value to be written.
     * @param {Array<*>} objectStack Object stack.
     * @this {*}
     */
    (function(t, n, r) {
      i.call(e ?? this, t, n, r), /** @type {NodeStackItem} */
      r[r.length - 1].node.appendChild(t);
    })
  );
}
function WE(i, e) {
  let t, n;
  return function(r, s, o) {
    if (t === void 0) {
      t = {};
      const a = {};
      a[r.localName] = i, t[r.namespaceURI] = a, n = At(r.localName);
    }
    YE(t, n, s, o);
  };
}
function At(i, e) {
  return (
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [newNodeName] Node name.
     * @return {Node} Node.
     */
    (function(t, n, r) {
      const o = /** @type {NodeStackItem} */ n[n.length - 1].node;
      let a = i;
      a === void 0 && (a = r);
      const l = e !== void 0 ? e : o.namespaceURI;
      return be(
        l,
        /** @type {string} */
        a
      );
    })
  );
}
const ai = At();
function Vi(i, e) {
  const t = e.length, n = new Array(t);
  for (let r = 0; r < t; ++r)
    n[r] = i[e[r]];
  return n;
}
function j(i, e, t) {
  t = t !== void 0 ? t : {};
  let n, r;
  for (n = 0, r = i.length; n < r; ++n)
    t[i[n]] = e;
  return t;
}
function ji(i, e, t, n) {
  let r;
  for (r = e.firstElementChild; r; r = r.nextElementSibling) {
    const s = i[r.namespaceURI];
    if (s !== void 0) {
      const o = s[r.localName];
      o !== void 0 && o.call(n, r, t);
    }
  }
}
function V(i, e, t, n, r) {
  return n.push(i), ji(e, t, n, r), /** @type {T} */
  n.pop();
}
function YE(i, e, t, n, r, s) {
  const o = (r !== void 0 ? r : t).length;
  let a, l;
  for (let h = 0; h < o; ++h)
    a = t[h], a !== void 0 && (l = e.call(
      s,
      a,
      n,
      r !== void 0 ? r[h] : void 0
    ), l !== void 0 && i[l.namespaceURI][l.localName].call(
      s,
      l,
      a,
      n
    ));
}
function we(i, e, t, n, r, s, o) {
  return r.push(i), YE(e, t, n, r, s, o), /** @type {O|undefined} */
  r.pop();
}
let Ed;
function eR() {
  return Ed === void 0 && typeof XMLSerializer < "u" && (Ed = new XMLSerializer()), Ed;
}
let vd;
function $a() {
  return vd === void 0 && typeof document < "u" && (vd = document.implementation.createDocument("", "", null)), vd;
}
class Ch extends Ph {
  constructor() {
    super(), this.xmlSerializer_ = eR();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   * @override
   */
  getType() {
    return "xml";
  }
  /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   * @override
   */
  readFeature(e, t) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const n = vn(e);
      return this.readFeatureFromDocument(n, t);
    }
    return En(e) ? this.readFeatureFromDocument(
      /** @type {Document} */
      e,
      t
    ) : this.readFeatureFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromDocument(e, t) {
    const n = this.readFeaturesFromDocument(e, t);
    return n.length > 0 ? n[0] : null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(e, t) {
    return null;
  }
  /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   * @override
   */
  readFeatures(e, t) {
    if (!e)
      return [];
    if (typeof e == "string") {
      const n = vn(e);
      return this.readFeaturesFromDocument(n, t);
    }
    return En(e) ? this.readFeaturesFromDocument(
      /** @type {Document} */
      e,
      t
    ) : this.readFeaturesFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromDocument(e, t) {
    const n = [];
    for (let r = e.firstChild; r; r = r.nextSibling)
      r.nodeType == Node.ELEMENT_NODE && ze(
        n,
        this.readFeaturesFromNode(
          /** @type {Element} */
          r,
          t
        )
      );
    return n;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    return de();
  }
  /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @override
   */
  readGeometry(e, t) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const n = vn(e);
      return this.readGeometryFromDocument(n, t);
    }
    return En(e) ? this.readGeometryFromDocument(
      /** @type {Document} */
      e,
      t
    ) : this.readGeometryFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromDocument(e, t) {
    return null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(e, t) {
    return null;
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   * @override
   */
  readProjection(e) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const t = vn(e);
      return this.readProjectionFromDocument(t);
    }
    return En(e) ? this.readProjectionFromDocument(
      /** @type {Document} */
      e
    ) : this.readProjectionFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(e) {
    return this.dataProjection;
  }
  /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(e) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @override
   */
  writeFeature(e, t) {
    const n = this.writeFeatureNode(e, t);
    return this.xmlSerializer_.serializeToString(n);
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @protected
   * @return {Node} Node.
   */
  writeFeatureNode(e, t) {
    return null;
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Result.
   * @api
   * @override
   */
  writeFeatures(e, t) {
    const n = this.writeFeaturesNode(e, t);
    return this.xmlSerializer_.serializeToString(n);
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeFeaturesNode(e, t) {
    return null;
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @override
   */
  writeGeometry(e, t) {
    const n = this.writeGeometryNode(e, t);
    return this.xmlSerializer_.serializeToString(n);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeGeometryNode(e, t) {
    return null;
  }
}
const Nr = "http://www.opengis.net/gml", tR = /^\s*$/;
class he extends Ch {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(e) {
    super(), e = e || {}, this.featureType = e.featureType, this.featureNS = e.featureNS, this.srsName = e.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
      featureMember: ue(this.readFeaturesInternal),
      featureMembers: ge(this.readFeaturesInternal)
    }, this.supportedMediaTypes = ["application/gml+xml"];
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<Feature> | undefined} Features.
   */
  readFeaturesInternal(e, t) {
    const n = e.localName;
    let r = null;
    if (n == "FeatureCollection")
      r = V(
        [],
        this.FEATURE_COLLECTION_PARSERS,
        e,
        t,
        this
      );
    else if (n == "featureMembers" || n == "featureMember" || n == "member") {
      const s = t[0];
      let o = s.featureType, a = s.featureNS;
      const l = "p", h = "p0";
      if (!o && e.childNodes) {
        o = [], a = {};
        for (let f = 0, g = e.childNodes.length; f < g; ++f) {
          const d = (
            /** @type {Element} */
            e.childNodes[f]
          );
          if (d.nodeType === 1) {
            const m = d.nodeName.split(":").pop();
            if (!o.includes(m)) {
              let x = "", v = 0;
              const p = d.namespaceURI;
              for (const y in a) {
                if (a[y] === p) {
                  x = y;
                  break;
                }
                ++v;
              }
              x || (x = l + v, a[x] = p), o.push(x + ":" + m);
            }
          }
        }
        n != "featureMember" && (s.featureType = o, s.featureNS = a);
      }
      if (typeof a == "string") {
        const f = a;
        a = {}, a[h] = f;
      }
      const u = {}, c = Array.isArray(o) ? o : [o];
      for (const f in a) {
        const g = {};
        for (let d = 0, m = c.length; d < m; ++d)
          (c[d].includes(":") ? c[d].split(":")[0] : h) === f && (g[c[d].split(":").pop()] = n == "featureMembers" ? ue(this.readFeatureElement, this) : ge(this.readFeatureElement, this));
        u[a[f]] = g;
      }
      n == "featureMember" || n == "member" ? r = V(void 0, u, e, t) : r = V([], u, e, t);
    }
    return r === null && (r = []), r;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
   */
  readGeometryOrExtent(e, t) {
    const n = (
      /** @type {Object} */
      t[0]
    );
    return n.srsName = e.firstElementChild.getAttribute("srsName"), n.srsDimension = e.firstElementChild.getAttribute("srsDimension"), V(
      null,
      this.GEOMETRY_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Geometry.
   */
  readExtentElement(e, t) {
    const n = (
      /** @type {Object} */
      t[0]
    ), r = (
      /** @type {import("../extent.js").Extent} */
      this.readGeometryOrExtent(e, t)
    );
    return r ? fm(r, n) : void 0;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|undefined} Geometry.
   */
  readGeometryElement(e, t) {
    const n = (
      /** @type {Object} */
      t[0]
    ), r = (
      /** @type {import("../geom/Geometry.js").default} */
      this.readGeometryOrExtent(e, t)
    );
    return r ? xt(r, !1, n) : void 0;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @param {boolean} asFeature whether result should be wrapped as a feature.
   * @return {Feature|Object} Feature
   */
  readFeatureElementInternal(e, t, n) {
    let r;
    const s = {};
    for (let l = e.firstElementChild; l; l = l.nextElementSibling) {
      let h;
      const u = l.localName;
      l.childNodes.length === 0 || l.childNodes.length === 1 && (l.firstChild.nodeType === 3 || l.firstChild.nodeType === 4) ? (h = Mi(l, !1), tR.test(h) && (h = void 0)) : (n && (h = u === "boundedBy" ? this.readExtentElement(l, t) : this.readGeometryElement(l, t)), h ? u !== "boundedBy" && (r = u) : h = this.readFeatureElementInternal(l, t, !1));
      const c = l.attributes.length;
      if (c > 0 && !(h instanceof tm)) {
        h = { _content_: h };
        for (let f = 0; f < c; f++) {
          const g = l.attributes[f].name;
          h[g] = l.attributes[f].value;
        }
      }
      s[u] ? (s[u] instanceof Array || (s[u] = [s[u]]), s[u].push(h)) : s[u] = h;
    }
    if (!n)
      return s;
    const o = new li(s);
    r && o.setGeometryName(r);
    const a = e.getAttribute("fid") || Q2(e, this.namespace, "id");
    return a && o.setId(a), o;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Feature} Feature.
   */
  readFeatureElement(e, t) {
    return this.readFeatureElementInternal(e, t, !0);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Point|undefined} Point.
   */
  readPoint(e, t) {
    const n = this.readFlatCoordinatesFromNode(e, t);
    if (n)
      return new Jt(n, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPoint|undefined} MultiPoint.
   */
  readMultiPoint(e, t) {
    const n = V(
      [],
      this.MULTIPOINT_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new Zn(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiLineString(e, t) {
    const n = V(
      [],
      this.MULTILINESTRING_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new Xi(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiPolygon(e, t) {
    const n = V(
      [],
      this.MULTIPOLYGON_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new Cn(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  pointMemberParser(e, t) {
    ji(this.POINTMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  lineStringMemberParser(e, t) {
    ji(this.LINESTRINGMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  polygonMemberParser(e, t) {
    ji(this.POLYGONMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readLineString(e, t) {
    const n = this.readFlatCoordinatesFromNode(e, t);
    if (n)
      return new Wt(n, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} LinearRing flat coordinates.
   */
  readFlatLinearRing(e, t) {
    const n = V(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return n;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LinearRing|undefined} LinearRing.
   */
  readLinearRing(e, t) {
    const n = this.readFlatCoordinatesFromNode(e, t);
    if (n)
      return new bs(n, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readPolygon(e, t) {
    const n = V(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      e,
      t,
      this
    );
    if (n && n[0]) {
      const r = n[0], s = [r.length];
      let o, a;
      for (o = 1, a = n.length; o < a; ++o)
        ze(r, n[o]), s.push(r.length);
      return new ei(r, "XYZ", s);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>} Flat coordinates.
   */
  readFlatCoordinatesFromNode(e, t) {
    return V(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @override
   */
  readGeometryFromNode(e, t) {
    const n = this.readGeometryElement(e, [
      this.getReadOptions(e, t || {})
    ]);
    return n || null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @override
   */
  readFeaturesFromNode(e, t) {
    const n = {
      featureType: this.featureType,
      featureNS: this.featureNS
    };
    return n && Object.assign(n, this.getReadOptions(e, t)), this.readFeaturesInternal(e, [n]) || [];
  }
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   * @override
   */
  readProjectionFromNode(e) {
    return ee(
      this.srsName ? this.srsName : e.firstElementChild.getAttribute("srsName")
    );
  }
}
he.prototype.namespace = Nr;
he.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {}
};
he.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {}
};
he.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {}
};
he.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml": {
    pointMember: ue(he.prototype.pointMemberParser),
    pointMembers: ue(he.prototype.pointMemberParser)
  }
};
he.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: ue(
      he.prototype.lineStringMemberParser
    ),
    lineStringMembers: ue(
      he.prototype.lineStringMemberParser
    )
  }
};
he.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml": {
    polygonMember: ue(he.prototype.polygonMemberParser),
    polygonMembers: ue(he.prototype.polygonMemberParser)
  }
};
he.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: ue(he.prototype.readFlatCoordinatesFromNode)
  }
};
he.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    LineString: ue(he.prototype.readLineString)
  }
};
he.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Polygon: ue(he.prototype.readPolygon)
  }
};
he.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    LinearRing: ge(he.prototype.readFlatLinearRing)
  }
};
function Ss(i) {
  const e = Mi(i, !1);
  return Di(e);
}
function Di(i) {
  const e = /^\s*(true|1)|(false|0)\s*$/.exec(i);
  if (e)
    return e[1] !== void 0 || !1;
}
function bf(i) {
  const e = Mi(i, !1), t = Date.parse(e);
  return isNaN(t) ? void 0 : t / 1e3;
}
function De(i) {
  const e = Mi(i, !1);
  return Dn(e);
}
function Dn(i) {
  const e = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(i);
  if (e)
    return parseFloat(e[1]);
}
function Dt(i) {
  const e = Mi(i, !1);
  return Ir(e);
}
function Ir(i) {
  const e = /^\s*(\d+)\s*$/.exec(i);
  if (e)
    return parseInt(e[1], 10);
}
function W(i) {
  return Mi(i, !1).trim();
}
function wa(i, e) {
  ye(i, e ? "1" : "0");
}
function iR(i, e) {
  i.appendChild($a().createCDATASection(e));
}
function nR(i, e) {
  const t = new Date(e * 1e3), n = t.getUTCFullYear() + "-" + $s(t.getUTCMonth() + 1, 2) + "-" + $s(t.getUTCDate(), 2) + "T" + $s(t.getUTCHours(), 2) + ":" + $s(t.getUTCMinutes(), 2) + ":" + $s(t.getUTCSeconds(), 2) + "Z";
  i.appendChild($a().createTextNode(n));
}
function Ni(i, e) {
  const t = e.toPrecision();
  i.appendChild($a().createTextNode(t));
}
function gc(i, e) {
  const t = e.toString();
  i.appendChild($a().createTextNode(t));
}
const rR = /^\s/, sR = /\s$/, oR = /(\n|\t|\r|<|&| {2})/;
function ye(i, e) {
  typeof e == "string" && (rR.test(e) || sR.test(e) || oR.test(e)) ? e.split("]]>").forEach((t, n, r) => {
    n < r.length - 1 && (t += "]]"), n > 0 && (t = ">" + t), iR(i, t);
  }) : i.appendChild($a().createTextNode(e));
}
const aR = Nr + " http://schemas.opengis.net/gml/2.1.2/feature.xsd", lR = {
  MultiLineString: "lineStringMember",
  MultiCurve: "curveMember",
  MultiPolygon: "polygonMember",
  MultiSurface: "surfaceMember"
};
class Ne extends he {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(e) {
    e = e || {}, super(e), this.FEATURE_COLLECTION_PARSERS[Nr].featureMember = ue(
      this.readFeaturesInternal
    ), this.schemaLocation = e.schemaLocation ? e.schemaLocation : aR;
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatCoordinates(e, t) {
    const n = Mi(e, !1).replace(/^\s*|\s*$/g, ""), s = /** @type {import("../xml.js").NodeStackItem} */ t[0].srsName;
    let o = "enu";
    if (s) {
      const h = ee(s);
      h && (o = h.getAxisOrientation());
    }
    const a = n.trim().split(/\s+/), l = [];
    for (let h = 0, u = a.length; h < u; h++) {
      const c = a[h].split(/,+/), f = parseFloat(c[0]), g = parseFloat(c[1]), d = c.length === 3 ? parseFloat(c[2]) : 0;
      o.startsWith("en") ? l.push(f, g, d) : l.push(g, f, d);
    }
    return l;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readBox(e, t) {
    const n = V(
      [null],
      this.BOX_PARSERS_,
      e,
      t,
      this
    );
    return Xn(
      n[1][0],
      n[1][1],
      n[1][3],
      n[1][4]
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  innerBoundaryIsParser(e, t) {
    const n = V(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    n && /** @type {Array<Array<number>>} */
    t[t.length - 1].push(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  outerBoundaryIsParser(e, t) {
    const n = V(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    if (n) {
      const r = (
        /** @type {Array<Array<number>>} */
        t[t.length - 1]
      );
      r[0] = n;
    }
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(e, t, n) {
    const r = t[t.length - 1], s = r.multiSurface, o = r.surface, a = r.multiCurve;
    return Array.isArray(e) ? n = "Envelope" : (n = /** @type {import("../geom/Geometry.js").default} */
    e.getType(), n === "MultiPolygon" && s === !0 ? n = "MultiSurface" : n === "Polygon" && o === !0 ? n = "Surface" : n === "MultiLineString" && a === !0 && (n = "MultiCurve")), be("http://www.opengis.net/gml", n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(e, t, n) {
    const r = t.getId();
    r && e.setAttribute(
      "fid",
      /** @type {string} */
      r
    );
    const s = (
      /** @type {Object} */
      n[n.length - 1]
    ), o = s.featureNS, a = t.getGeometryName();
    s.serializers || (s.serializers = {}, s.serializers[o] = {});
    const l = [], h = [];
    if (t.hasProperties()) {
      const c = t.getProperties();
      for (const f in c) {
        const g = c[f];
        g != null && (l.push(f), h.push(g), f == a || typeof /** @type {?} */
        g.getSimplifiedGeometry == "function" ? f in s.serializers[o] || (s.serializers[o][f] = N(
          this.writeGeometryElement,
          this
        )) : f in s.serializers[o] || (s.serializers[o][f] = N(ye)));
      }
    }
    const u = Object.assign({}, s);
    u.node = e, we(
      /** @type {import("../xml.js").NodeStackItem} */
      u,
      s.serializers,
      At(void 0, o),
      h,
      n,
      l
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(e, t, n) {
    const s = n[n.length - 1].srsName;
    if (e.nodeName !== "LineStringSegment" && s && e.setAttribute("srsName", s), e.nodeName === "LineString" || e.nodeName === "LineStringSegment") {
      const o = this.createCoordinatesNode_(e.namespaceURI);
      e.appendChild(o), this.writeCoordinates_(o, t, n);
    } else if (e.nodeName === "Curve") {
      const o = be(e.namespaceURI, "segments");
      e.appendChild(o), this.writeCurveSegments_(o, t, n);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(e, t, n) {
    const r = this.GEOMETRY_NODE_FACTORY_(t, n);
    r && (e.appendChild(r), this.writeCurveOrLineString(r, t, n));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(e, t, n) {
    const r = n[n.length - 1], s = r.hasZ, o = r.srsName, a = r.curve;
    o && e.setAttribute("srsName", o);
    const l = t.getLineStrings();
    we(
      { node: e, hasZ: s, srsName: o, curve: a },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      l,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(e, t, n) {
    const r = (
      /** @type {import("./Feature.js").WriteOptions} */
      n[n.length - 1]
    ), s = Object.assign({}, r);
    s.node = e;
    let o;
    Array.isArray(t) ? o = fm(
      /** @type {import("../extent.js").Extent} */
      t,
      r
    ) : o = xt(
      /** @type {import("../geom/Geometry.js").default} */
      t,
      !0,
      r
    ), we(
      /** @type {import("../xml.js").NodeStackItem} */
      s,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [o],
      n,
      void 0,
      this
    );
  }
  /**
   * @param {string} namespaceURI XML namespace.
   * @return {Element} coordinates node.
   * @private
   */
  createCoordinatesNode_(e) {
    const t = be(e, "coordinates");
    return t.setAttribute("decimal", "."), t.setAttribute("cs", ","), t.setAttribute("ts", " "), t;
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCoordinates_(e, t, n) {
    const r = n[n.length - 1], s = r.hasZ, o = r.srsName, a = t.getCoordinates(), l = a.length, h = new Array(l);
    for (let u = 0; u < l; ++u) {
      const c = a[u];
      h[u] = this.getCoords_(c, o, s);
    }
    ye(e, h.join(" "));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(e, t, n) {
    const r = be(e.namespaceURI, "LineStringSegment");
    e.appendChild(r), this.writeCurveOrLineString(r, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(e, t, n) {
    const r = n[n.length - 1], s = r.hasZ, o = r.srsName;
    if (e.nodeName !== "PolygonPatch" && o && e.setAttribute("srsName", o), e.nodeName === "Polygon" || e.nodeName === "PolygonPatch") {
      const a = t.getLinearRings();
      we(
        { node: e, hasZ: s, srsName: o },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        a,
        n,
        void 0,
        this
      );
    } else if (e.nodeName === "Surface") {
      const a = be(e.namespaceURI, "patches");
      e.appendChild(a), this.writeSurfacePatches_(a, t, n);
    }
  }
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(e, t, n) {
    const r = t[t.length - 1], s = r.node, o = r.exteriorWritten;
    return o === void 0 && (r.exteriorWritten = !0), be(
      s.namespaceURI,
      o !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs"
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(e, t, n) {
    const r = be(e.namespaceURI, "PolygonPatch");
    e.appendChild(r), this.writeSurfaceOrPolygon(r, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(e, t, n) {
    const r = be(e.namespaceURI, "LinearRing");
    e.appendChild(r), this.writeLinearRing(r, t, n);
  }
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(e, t, n) {
    let s = (t ? ee(t).getAxisOrientation() : "enu").startsWith("en") ? e[0] + "," + e[1] : e[1] + "," + e[0];
    if (n) {
      const o = e[2] || 0;
      s += "," + o;
    }
    return s;
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(e, t, n) {
    const r = n[n.length - 1], s = r.hasZ, o = r.srsName;
    o && e.setAttribute("srsName", o);
    const a = this.createCoordinatesNode_(e.namespaceURI);
    e.appendChild(a);
    const l = t.getCoordinates(), h = this.getCoords_(l, o, s);
    ye(a, h);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(e, t, n) {
    const r = n[n.length - 1], s = r.hasZ, o = r.srsName;
    o && e.setAttribute("srsName", o);
    const a = t.getPoints();
    we(
      { node: e, hasZ: s, srsName: o },
      this.POINTMEMBER_SERIALIZERS,
      At("pointMember"),
      a,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(e, t, n) {
    const r = be(e.namespaceURI, "Point");
    e.appendChild(r), this.writePoint(r, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(e, t, n) {
    const s = n[n.length - 1].srsName;
    s && e.setAttribute("srsName", s);
    const o = this.createCoordinatesNode_(e.namespaceURI);
    e.appendChild(o), this.writeCoordinates_(o, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(e, t, n) {
    const r = n[n.length - 1], s = r.hasZ, o = r.srsName, a = r.surface;
    o && e.setAttribute("srsName", o);
    const l = t.getPolygons();
    we(
      { node: e, hasZ: s, srsName: o, surface: a },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      l,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(e, t, n) {
    const r = this.GEOMETRY_NODE_FACTORY_(t, n);
    r && (e.appendChild(r), this.writeSurfaceOrPolygon(r, t, n));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(e, t, n) {
    const s = n[n.length - 1].srsName;
    s && e.setAttribute("srsName", s);
    const o = ["lowerCorner", "upperCorner"], a = [t[0] + " " + t[1], t[2] + " " + t[3]];
    we(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: e },
      this.ENVELOPE_SERIALIZERS,
      ai,
      a,
      n,
      o,
      this
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(e, t, n) {
    const r = t[t.length - 1].node;
    return be(
      "http://www.opengis.net/gml",
      lR[r.nodeName]
    );
  }
}
Ne.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    coordinates: ge(Ne.prototype.readFlatCoordinates)
  }
};
Ne.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    innerBoundaryIs: Ne.prototype.innerBoundaryIsParser,
    outerBoundaryIs: Ne.prototype.outerBoundaryIsParser
  }
};
Ne.prototype.BOX_PARSERS_ = {
  "http://www.opengis.net/gml": {
    coordinates: ue(Ne.prototype.readFlatCoordinates)
  }
};
Ne.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: ge(he.prototype.readPoint),
    MultiPoint: ge(he.prototype.readMultiPoint),
    LineString: ge(he.prototype.readLineString),
    MultiLineString: ge(he.prototype.readMultiLineString),
    LinearRing: ge(he.prototype.readLinearRing),
    Polygon: ge(he.prototype.readPolygon),
    MultiPolygon: ge(he.prototype.readMultiPolygon),
    Box: ge(Ne.prototype.readBox)
  }
};
Ne.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    Curve: N(Ne.prototype.writeCurveOrLineString),
    MultiCurve: N(Ne.prototype.writeMultiCurveOrLineString),
    Point: N(Ne.prototype.writePoint),
    MultiPoint: N(Ne.prototype.writeMultiPoint),
    LineString: N(Ne.prototype.writeCurveOrLineString),
    MultiLineString: N(
      Ne.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: N(Ne.prototype.writeLinearRing),
    Polygon: N(Ne.prototype.writeSurfaceOrPolygon),
    MultiPolygon: N(
      Ne.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: N(Ne.prototype.writeSurfaceOrPolygon),
    MultiSurface: N(
      Ne.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: N(Ne.prototype.writeEnvelope)
  }
};
Ne.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: N(
      Ne.prototype.writeLineStringOrCurveMember
    ),
    curveMember: N(
      Ne.prototype.writeLineStringOrCurveMember
    )
  }
};
Ne.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    outerBoundaryIs: N(Ne.prototype.writeRing),
    innerBoundaryIs: N(Ne.prototype.writeRing)
  }
};
Ne.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    pointMember: N(Ne.prototype.writePointMember)
  }
};
Ne.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: N(
      Ne.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: N(
      Ne.prototype.writeSurfaceOrPolygonMember
    )
  }
};
Ne.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: N(ye),
    upperCorner: N(ye)
  }
};
const hR = Nr + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", uR = {
  MultiLineString: "lineStringMember",
  MultiCurve: "curveMember",
  MultiPolygon: "polygonMember",
  MultiSurface: "surfaceMember"
};
class q extends he {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(e) {
    e = e || {}, super(e), this.surface_ = e.surface !== void 0 ? e.surface : !1, this.curve_ = e.curve !== void 0 ? e.curve : !1, this.multiCurve_ = e.multiCurve !== void 0 ? e.multiCurve : !0, this.multiSurface_ = e.multiSurface !== void 0 ? e.multiSurface : !0, this.schemaLocation = e.schemaLocation ? e.schemaLocation : hR, this.hasZ = e.hasZ !== void 0 ? e.hasZ : !1;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiCurve(e, t) {
    const n = V(
      [],
      this.MULTICURVE_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new Xi(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Polygon.
   */
  readFlatCurveRing(e, t) {
    const n = V(
      [],
      this.MULTICURVE_PARSERS,
      e,
      t,
      this
    ), r = [];
    for (let s = 0, o = n.length; s < o; ++s)
      ze(r, n[s].getFlatCoordinates());
    return r;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiSurface(e, t) {
    const n = V(
      [],
      this.MULTISURFACE_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new Cn(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  curveMemberParser(e, t) {
    ji(this.CURVEMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  surfaceMemberParser(e, t) {
    ji(this.SURFACEMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPatch(e, t) {
    return V(
      [null],
      this.PATCHES_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readSegment(e, t) {
    return V([], this.SEGMENTS_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPolygonPatch(e, t) {
    return V(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readLineStringSegment(e, t) {
    return V(
      [null],
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  interiorParser(e, t) {
    const n = V(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    n && /** @type {Array<Array<number>>} */
    t[t.length - 1].push(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  exteriorParser(e, t) {
    const n = V(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    if (n) {
      const r = (
        /** @type {Array<Array<number>>} */
        t[t.length - 1]
      );
      r[0] = n;
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readSurface(e, t) {
    const n = V(
      [null],
      this.SURFACE_PARSERS,
      e,
      t,
      this
    );
    if (n && n[0]) {
      const r = n[0], s = [r.length];
      let o, a;
      for (o = 1, a = n.length; o < a; ++o)
        ze(r, n[o]), s.push(r.length);
      return new ei(r, "XYZ", s);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readCurve(e, t) {
    const n = V(
      [null],
      this.CURVE_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new Wt(n, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readEnvelope(e, t) {
    const n = V(
      [null],
      this.ENVELOPE_PARSERS,
      e,
      t,
      this
    );
    return Xn(
      n[1][0],
      n[1][1],
      n[2][0],
      n[2][1]
    );
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPos(e, t) {
    let n = Mi(e, !1);
    const r = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, s = [];
    let o;
    for (; o = r.exec(n); )
      s.push(parseFloat(o[1])), n = n.substr(o[0].length);
    if (n !== "")
      return;
    const l = t[0].srsName;
    if ((l ? ee(l).getAxisOrientation() : "enu") === "neu")
      for (let c = 0, f = s.length; c < f; c += 3) {
        const g = s[c], d = s[c + 1];
        s[c] = d, s[c + 1] = g;
      }
    const u = s.length;
    if (u == 2 && s.push(0), u !== 0)
      return s;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPosList(e, t) {
    const n = Mi(e, !1).replace(/^\s*|\s*$/g, ""), r = t[0], s = r.srsName, o = r.srsDimension, a = s ? ee(s).getAxisOrientation() : "enu", l = n.split(/\s+/);
    let h = 2;
    e.getAttribute("srsDimension") ? h = Ir(e.getAttribute("srsDimension")) : e.getAttribute("dimension") ? h = Ir(e.getAttribute("dimension")) : /** @type {Element} */ e.parentNode.getAttribute("srsDimension") ? h = Ir(
      /** @type {Element} */
      e.parentNode.getAttribute("srsDimension")
    ) : o && (h = Ir(o));
    const u = a.startsWith("en");
    let c, f, g;
    const d = [];
    for (let m = 0, x = l.length; m < x; m += h)
      c = parseFloat(l[m]), f = parseFloat(l[m + 1]), g = h === 3 ? parseFloat(l[m + 2]) : 0, u ? d.push(c, f, g) : d.push(f, c, g);
    return d;
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} value Point geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePos_(e, t, n) {
    const r = n[n.length - 1], s = r.hasZ, o = s ? "3" : "2";
    e.setAttribute("srsDimension", o);
    const a = r.srsName, l = a ? ee(a).getAxisOrientation() : "enu", h = t.getCoordinates();
    let u = l.startsWith("en") ? h[0] + " " + h[1] : h[1] + " " + h[0];
    if (s) {
      const c = h[2] || 0;
      u += " " + c;
    }
    ye(e, u);
  }
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(e, t, n) {
    let s = (t ? ee(t).getAxisOrientation() : "enu").startsWith("en") ? e[0] + " " + e[1] : e[1] + " " + e[0];
    if (n) {
      const o = e[2] || 0;
      s += " " + o;
    }
    return s;
  }
  /**
   * @param {Element} node Node.
   * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePosList_(e, t, n) {
    const r = n[n.length - 1], s = r.hasZ, o = s ? "3" : "2";
    e.setAttribute("srsDimension", o);
    const a = r.srsName, l = t.getCoordinates(), h = l.length, u = new Array(h);
    let c;
    for (let f = 0; f < h; ++f)
      c = l[f], u[f] = this.getCoords_(c, a, s);
    ye(e, u.join(" "));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(e, t, n) {
    const s = n[n.length - 1].srsName;
    s && e.setAttribute("srsName", s);
    const o = be(e.namespaceURI, "pos");
    e.appendChild(o), this.writePos_(o, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(e, t, n) {
    const s = n[n.length - 1].srsName;
    s && e.setAttribute("srsName", s);
    const o = ["lowerCorner", "upperCorner"], a = [t[0] + " " + t[1], t[2] + " " + t[3]];
    we(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: e },
      this.ENVELOPE_SERIALIZERS,
      ai,
      a,
      n,
      o,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(e, t, n) {
    const s = n[n.length - 1].srsName;
    s && e.setAttribute("srsName", s);
    const o = be(e.namespaceURI, "posList");
    e.appendChild(o), this.writePosList_(o, t, n);
  }
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(e, t, n) {
    const r = t[t.length - 1], s = r.node, o = r.exteriorWritten;
    return o === void 0 && (r.exteriorWritten = !0), be(
      s.namespaceURI,
      o !== void 0 ? "interior" : "exterior"
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Polygon} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(e, t, n) {
    const r = n[n.length - 1], s = r.hasZ, o = r.srsName;
    if (e.nodeName !== "PolygonPatch" && o && e.setAttribute("srsName", o), e.nodeName === "Polygon" || e.nodeName === "PolygonPatch") {
      const a = t.getLinearRings();
      we(
        { node: e, hasZ: s, srsName: o },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        a,
        n,
        void 0,
        this
      );
    } else if (e.nodeName === "Surface") {
      const a = be(e.namespaceURI, "patches");
      e.appendChild(a), this.writeSurfacePatches_(a, t, n);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {LineString} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(e, t, n) {
    const s = n[n.length - 1].srsName;
    if (e.nodeName !== "LineStringSegment" && s && e.setAttribute("srsName", s), e.nodeName === "LineString" || e.nodeName === "LineStringSegment") {
      const o = be(e.namespaceURI, "posList");
      e.appendChild(o), this.writePosList_(o, t, n);
    } else if (e.nodeName === "Curve") {
      const o = be(e.namespaceURI, "segments");
      e.appendChild(o), this.writeCurveSegments_(o, t, n);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {MultiPolygon} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(e, t, n) {
    const r = n[n.length - 1], s = r.hasZ, o = r.srsName, a = r.surface;
    o && e.setAttribute("srsName", o);
    const l = t.getPolygons();
    we(
      { node: e, hasZ: s, srsName: o, surface: a },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      l,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(e, t, n) {
    const r = n[n.length - 1], s = r.srsName, o = r.hasZ;
    s && e.setAttribute("srsName", s);
    const a = t.getPoints();
    we(
      { node: e, hasZ: o, srsName: s },
      this.POINTMEMBER_SERIALIZERS,
      At("pointMember"),
      a,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {MultiLineString} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(e, t, n) {
    const r = n[n.length - 1], s = r.hasZ, o = r.srsName, a = r.curve;
    o && e.setAttribute("srsName", o);
    const l = t.getLineStrings();
    we(
      { node: e, hasZ: s, srsName: o, curve: a },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      l,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(e, t, n) {
    const r = be(e.namespaceURI, "LinearRing");
    e.appendChild(r), this.writeLinearRing(r, t, n);
  }
  /**
   * @param {Node} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(e, t, n) {
    const r = this.GEOMETRY_NODE_FACTORY_(t, n);
    r && (e.appendChild(r), this.writeSurfaceOrPolygon(r, t, n));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(e, t, n) {
    const r = be(e.namespaceURI, "Point");
    e.appendChild(r), this.writePoint(r, t, n);
  }
  /**
   * @param {Node} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(e, t, n) {
    const r = this.GEOMETRY_NODE_FACTORY_(t, n);
    r && (e.appendChild(r), this.writeCurveOrLineString(r, t, n));
  }
  /**
   * @param {Element} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(e, t, n) {
    const r = be(e.namespaceURI, "PolygonPatch");
    e.appendChild(r), this.writeSurfaceOrPolygon(r, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(e, t, n) {
    const r = be(e.namespaceURI, "LineStringSegment");
    e.appendChild(r), this.writeCurveOrLineString(r, t, n);
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(e, t, n) {
    const r = (
      /** @type {import("./Feature.js").WriteOptions} */
      n[n.length - 1]
    ), s = Object.assign({}, r);
    s.node = e;
    let o;
    Array.isArray(t) ? o = fm(
      /** @type {import("../extent.js").Extent} */
      t,
      r
    ) : o = xt(
      /** @type {import("../geom/Geometry.js").default} */
      t,
      !0,
      r
    ), we(
      /** @type {import("../xml.js").NodeStackItem} */
      s,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [o],
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(e, t, n) {
    const r = t.getId();
    r && e.setAttribute(
      "fid",
      /** @type {string} */
      r
    );
    const s = (
      /** @type {Object} */
      n[n.length - 1]
    ), o = s.featureNS, a = t.getGeometryName();
    s.serializers || (s.serializers = {}, s.serializers[o] = {});
    const l = [], h = [];
    if (t.hasProperties()) {
      const c = t.getProperties();
      for (const f in c) {
        const g = c[f];
        g != null && (l.push(f), h.push(g), f == a || typeof /** @type {?} */
        g.getSimplifiedGeometry == "function" ? f in s.serializers[o] || (s.serializers[o][f] = N(
          this.writeGeometryElement,
          this
        )) : f in s.serializers[o] || (s.serializers[o][f] = N(ye)));
      }
    }
    const u = Object.assign({}, s);
    u.node = e, we(
      /** @type {import("../xml.js").NodeStackItem} */
      u,
      s.serializers,
      At(void 0, o),
      h,
      n,
      l
    );
  }
  /**
   * @param {Node} node Node.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeFeatureMembers_(e, t, n) {
    const r = (
      /** @type {Object} */
      n[n.length - 1]
    ), s = r.featureType, o = r.featureNS, a = {};
    a[o] = {}, a[o][s] = N(
      this.writeFeatureElement,
      this
    );
    const l = Object.assign({}, r);
    l.node = e, we(
      /** @type {import("../xml.js").NodeStackItem} */
      l,
      a,
      At(s, o),
      t,
      n
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(e, t, n) {
    const r = t[t.length - 1].node;
    return be(
      this.namespace,
      uR[r.nodeName]
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(e, t, n) {
    const r = t[t.length - 1], s = r.multiSurface, o = r.surface, a = r.curve, l = r.multiCurve;
    return Array.isArray(e) ? n = "Envelope" : (n = /** @type {import("../geom/Geometry.js").default} */
    e.getType(), n === "MultiPolygon" && s === !0 ? n = "MultiSurface" : n === "Polygon" && o === !0 ? n = "Surface" : n === "LineString" && a === !0 ? n = "Curve" : n === "MultiLineString" && l === !0 && (n = "MultiCurve")), be(this.namespace, n);
  }
  /**
   * Encode a geometry in GML 3.1.1 Simple Features.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   * @override
   */
  writeGeometryNode(e, t) {
    t = this.adaptOptions(t);
    const n = be(this.namespace, "geom"), r = {
      node: n,
      hasZ: this.hasZ,
      srsName: this.srsName,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_
    };
    return t && Object.assign(r, t), this.writeGeometryElement(n, e, [r]), n;
  }
  /**
   * Encode an array of features in the GML 3.1.1 format as an XML node.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Element} Node.
   * @api
   * @override
   */
  writeFeaturesNode(e, t) {
    t = this.adaptOptions(t);
    const n = be(this.namespace, "featureMembers");
    n.setAttributeNS(
      ho,
      "xsi:schemaLocation",
      this.schemaLocation
    );
    const r = {
      srsName: this.srsName,
      hasZ: this.hasZ,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
      featureNS: this.featureNS,
      featureType: this.featureType
    };
    return t && Object.assign(r, t), this.writeFeatureMembers_(n, e, [r]), n;
  }
}
q.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    pos: ge(q.prototype.readFlatPos),
    posList: ge(q.prototype.readFlatPosList),
    coordinates: ge(Ne.prototype.readFlatCoordinates)
  }
};
q.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    interior: q.prototype.interiorParser,
    exterior: q.prototype.exteriorParser
  }
};
q.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: ge(he.prototype.readPoint),
    MultiPoint: ge(he.prototype.readMultiPoint),
    LineString: ge(he.prototype.readLineString),
    MultiLineString: ge(he.prototype.readMultiLineString),
    LinearRing: ge(he.prototype.readLinearRing),
    Polygon: ge(he.prototype.readPolygon),
    MultiPolygon: ge(he.prototype.readMultiPolygon),
    Surface: ge(q.prototype.readSurface),
    MultiSurface: ge(q.prototype.readMultiSurface),
    Curve: ge(q.prototype.readCurve),
    MultiCurve: ge(q.prototype.readMultiCurve),
    Envelope: ge(q.prototype.readEnvelope)
  }
};
q.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    curveMember: ue(q.prototype.curveMemberParser),
    curveMembers: ue(q.prototype.curveMemberParser)
  }
};
q.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: ue(q.prototype.surfaceMemberParser),
    surfaceMembers: ue(q.prototype.surfaceMemberParser)
  }
};
q.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    LineString: ue(he.prototype.readLineString),
    Curve: ue(q.prototype.readCurve)
  }
};
q.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Polygon: ue(he.prototype.readPolygon),
    Surface: ue(q.prototype.readSurface)
  }
};
q.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    patches: ge(q.prototype.readPatch)
  }
};
q.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    segments: ge(q.prototype.readSegment)
  }
};
q.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: ue(q.prototype.readFlatPosList),
    upperCorner: ue(q.prototype.readFlatPosList)
  }
};
q.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml": {
    PolygonPatch: ge(q.prototype.readPolygonPatch)
  }
};
q.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml": {
    LineStringSegment: dc(
      q.prototype.readLineStringSegment
    )
  }
};
he.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    LinearRing: ge(he.prototype.readFlatLinearRing),
    Ring: ge(q.prototype.readFlatCurveRing)
  }
};
q.prototype.writeFeatures;
q.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    exterior: N(q.prototype.writeRing),
    interior: N(q.prototype.writeRing)
  }
};
q.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: N(ye),
    upperCorner: N(ye)
  }
};
q.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: N(
      q.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: N(
      q.prototype.writeSurfaceOrPolygonMember
    )
  }
};
q.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    pointMember: N(q.prototype.writePointMember)
  }
};
q.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: N(
      q.prototype.writeLineStringOrCurveMember
    ),
    curveMember: N(
      q.prototype.writeLineStringOrCurveMember
    )
  }
};
q.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    Curve: N(q.prototype.writeCurveOrLineString),
    MultiCurve: N(q.prototype.writeMultiCurveOrLineString),
    Point: N(q.prototype.writePoint),
    MultiPoint: N(q.prototype.writeMultiPoint),
    LineString: N(q.prototype.writeCurveOrLineString),
    MultiLineString: N(
      q.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: N(q.prototype.writeLinearRing),
    Polygon: N(q.prototype.writeSurfaceOrPolygon),
    MultiPolygon: N(
      q.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: N(q.prototype.writeSurfaceOrPolygon),
    MultiSurface: N(
      q.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: N(q.prototype.writeEnvelope)
  }
};
const pm = q;
pm.prototype.writeFeatures;
pm.prototype.writeFeaturesNode;
const yt = [
  null,
  "http://www.topografix.com/GPX/1/0",
  "http://www.topografix.com/GPX/1/1"
], cR = "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd", fR = {
  rte: qE,
  trk: ZE,
  wpt: HE
}, dR = j(yt, {
  rte: ue(qE),
  trk: ue(ZE),
  wpt: ue(HE)
}), gR = j(yt, {
  text: F(W, "linkText"),
  type: F(W, "linkType")
}), pR = j(yt, {
  name: F(W),
  email: $R,
  link: Ah
}), mR = j(yt, {
  name: F(W),
  desc: F(W),
  author: F(UR),
  copyright: F(zR),
  link: Ah,
  time: F(bf),
  keywords: F(W),
  bounds: BR,
  extensions: Sf
}), _R = j(yt, {
  year: F(Dt),
  license: F(W)
}), yR = j(yt, {
  rte: N(WR),
  trk: N(YR),
  wpt: N(ZR)
});
class xR extends Ch {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.dataProjection = ee("EPSG:4326"), this.readExtensions_ = e.readExtensions;
  }
  /**
   * @param {Array<Feature>} features List of features.
   * @private
   */
  handleReadExtensions_(e) {
    e || (e = []);
    for (let t = 0, n = e.length; t < n; ++t) {
      const r = e[t];
      if (this.readExtensions_) {
        const s = r.get("extensionsNode_") || null;
        this.readExtensions_(r, s);
      }
      r.set("extensionsNode_", void 0);
    }
  }
  /**
   * Reads a GPX file's metadata tag, reading among other things:
   *   - the name and description of this GPX
   *   - its author
   *   - the copyright associated with this GPX file
   *
   * Will return null if no metadata tag is present (or no valid source is given).
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {GPXMetadata | null} Metadata
   * @api
   */
  readMetadata(e) {
    return e ? typeof e == "string" ? this.readMetadataFromDocument(vn(e)) : En(e) ? this.readMetadataFromDocument(
      /** @type {Document} */
      e
    ) : this.readMetadataFromNode(e) : null;
  }
  /**
   * @param {Document} doc Document.
   * @return {GPXMetadata | null} Metadata
   */
  readMetadataFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType === Node.ELEMENT_NODE) {
        const n = this.readMetadataFromNode(
          /** @type {Element} */
          t
        );
        if (n)
          return n;
      }
    return null;
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Metadata
   */
  readMetadataFromNode(e) {
    if (!yt.includes(e.namespaceURI))
      return null;
    for (let t = e.firstElementChild; t; t = t.nextElementSibling)
      if (yt.includes(t.namespaceURI) && t.localName === "metadata")
        return V({}, mR, t, []);
    return null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   * @override
   */
  readFeatureFromNode(e, t) {
    if (!yt.includes(e.namespaceURI))
      return null;
    const n = fR[e.localName];
    if (!n)
      return null;
    const r = n(e, [this.getReadOptions(e, t)]);
    return r ? (this.handleReadExtensions_([r]), r) : null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @override
   */
  readFeaturesFromNode(e, t) {
    if (!yt.includes(e.namespaceURI))
      return [];
    if (e.localName == "gpx") {
      const n = V([], dR, e, [
        this.getReadOptions(e, t)
      ]);
      return n ? (this.handleReadExtensions_(n), n) : [];
    }
    return [];
  }
  /**
   * Encode an array of features in the GPX format as an XML node.
   * LineString geometries are output as routes (`<rte>`), and MultiLineString
   * as tracks (`<trk>`).
   *
   * @param {Array<Feature>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   * @override
   */
  writeFeaturesNode(e, t) {
    t = this.adaptOptions(t);
    const n = be("http://www.topografix.com/GPX/1/1", "gpx");
    return n.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xsi", ho), n.setAttributeNS(
      ho,
      "xsi:schemaLocation",
      cR
    ), n.setAttribute("version", "1.1"), n.setAttribute("creator", "OpenLayers"), we(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: n },
      yR,
      kR,
      e,
      [t]
    ), n;
  }
}
const ER = j(yt, {
  name: F(W),
  cmt: F(W),
  desc: F(W),
  src: F(W),
  link: Ah,
  number: F(Dt),
  extensions: Sf,
  type: F(W),
  rtept: jR
}), vR = j(yt, {
  ele: F(De),
  time: F(bf)
}), wR = j(yt, {
  name: F(W),
  cmt: F(W),
  desc: F(W),
  src: F(W),
  link: Ah,
  number: F(Dt),
  type: F(W),
  extensions: Sf,
  trkseg: VR
}), bR = j(yt, {
  trkpt: XR
}), SR = j(yt, {
  ele: F(De),
  time: F(bf)
}), TR = j(yt, {
  ele: F(De),
  time: F(bf),
  magvar: F(De),
  geoidheight: F(De),
  name: F(W),
  cmt: F(W),
  desc: F(W),
  src: F(W),
  link: Ah,
  sym: F(W),
  type: F(W),
  fix: F(W),
  sat: F(Dt),
  hdop: F(De),
  vdop: F(De),
  pdop: F(De),
  ageofdgpsdata: F(De),
  dgpsid: F(Dt),
  extensions: Sf
}), RR = ["text", "type"], PR = j(yt, {
  text: N(ye),
  type: N(ye)
}), MR = j(yt, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "rtept"
]), CR = j(yt, {
  name: N(ye),
  cmt: N(ye),
  desc: N(ye),
  src: N(ye),
  link: N(ym),
  number: N(gc),
  type: N(ye),
  rtept: WE(N(xm))
}), AR = j(yt, ["ele", "time"]), IR = j(yt, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "trkseg"
]), LR = j(yt, {
  name: N(ye),
  cmt: N(ye),
  desc: N(ye),
  src: N(ye),
  link: N(ym),
  number: N(gc),
  type: N(ye),
  trkseg: WE(N(qR))
}), FR = At("trkpt"), OR = j(yt, {
  trkpt: N(xm)
}), NR = j(yt, [
  "ele",
  "time",
  "magvar",
  "geoidheight",
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "sym",
  "type",
  "fix",
  "sat",
  "hdop",
  "vdop",
  "pdop",
  "ageofdgpsdata",
  "dgpsid"
]), DR = j(yt, {
  ele: N(Ni),
  time: N(nR),
  magvar: N(Ni),
  geoidheight: N(Ni),
  name: N(ye),
  cmt: N(ye),
  desc: N(ye),
  src: N(ye),
  link: N(ym),
  sym: N(ye),
  type: N(ye),
  fix: N(ye),
  sat: N(gc),
  hdop: N(Ni),
  vdop: N(Ni),
  pdop: N(Ni),
  ageofdgpsdata: N(Ni),
  dgpsid: N(gc)
}), GR = {
  Point: "wpt",
  LineString: "rte",
  MultiLineString: "trk"
};
function kR(i, e, t) {
  const n = (
    /** @type {Feature} */
    i.getGeometry()
  );
  if (n) {
    const r = GR[n.getType()];
    if (r) {
      const s = e[e.length - 1].node;
      return be(s.namespaceURI, r);
    }
  }
}
function mm(i, e, t, n) {
  return i.push(
    parseFloat(t.getAttribute("lon")),
    parseFloat(t.getAttribute("lat"))
  ), "ele" in n ? (i.push(
    /** @type {number} */
    n.ele
  ), delete n.ele, e.hasZ = !0) : i.push(0), "time" in n ? (i.push(
    /** @type {number} */
    n.time
  ), delete n.time, e.hasM = !0) : i.push(0), i;
}
function _m(i, e, t) {
  let n = "XY", r = 2;
  if (i.hasZ && i.hasM ? (n = "XYZM", r = 4) : i.hasZ ? (n = "XYZ", r = 3) : i.hasM && (n = "XYM", r = 3), r !== 4) {
    for (let s = 0, o = e.length / 4; s < o; s++)
      e[s * r] = e[s * 4], e[s * r + 1] = e[s * 4 + 1], i.hasZ && (e[s * r + 2] = e[s * 4 + 2]), i.hasM && (e[s * r + 2] = e[s * 4 + 3]);
    if (e.length = e.length / 4 * r, t)
      for (let s = 0, o = t.length; s < o; s++)
        t[s] = t[s] / 4 * r;
  }
  return n;
}
function UR(i, e) {
  const t = V({}, pR, i, e);
  if (t)
    return t;
}
function zR(i, e) {
  const t = V({}, _R, i, e);
  if (t) {
    const n = i.getAttribute("author");
    return n !== null && (t.author = n), t;
  }
}
function BR(i, e) {
  const t = (
    /** @type {Object} */
    e[e.length - 1]
  ), n = i.getAttribute("minlat"), r = i.getAttribute("minlon"), s = i.getAttribute("maxlat"), o = i.getAttribute("maxlon");
  r !== null && n !== null && o !== null && s !== null && (t.bounds = [
    [parseFloat(r), parseFloat(n)],
    [parseFloat(o), parseFloat(s)]
  ]);
}
function $R(i, e) {
  const t = (
    /** @type {Object} */
    e[e.length - 1]
  ), n = i.getAttribute("id"), r = i.getAttribute("domain");
  n !== null && r !== null && (t.email = `${n}@${r}`);
}
function Ah(i, e) {
  const t = (
    /** @type {Object} */
    e[e.length - 1]
  ), n = i.getAttribute("href");
  n !== null && (t.link = n), ji(gR, i, e);
}
function Sf(i, e) {
  const t = (
    /** @type {Object} */
    e[e.length - 1]
  );
  t.extensionsNode_ = i;
}
function jR(i, e) {
  const t = V({}, vR, i, e);
  if (t) {
    const n = (
      /** @type {!Object} */
      e[e.length - 1]
    ), r = (
      /** @type {Array<number>} */
      n.flatCoordinates
    ), s = (
      /** @type {LayoutOptions} */
      n.layoutOptions
    );
    mm(r, s, i, t);
  }
}
function XR(i, e) {
  const t = V({}, SR, i, e);
  if (t) {
    const n = (
      /** @type {!Object} */
      e[e.length - 1]
    ), r = (
      /** @type {Array<number>} */
      n.flatCoordinates
    ), s = (
      /** @type {LayoutOptions} */
      n.layoutOptions
    );
    mm(r, s, i, t);
  }
}
function VR(i, e) {
  const t = (
    /** @type {Object} */
    e[e.length - 1]
  );
  ji(bR, i, e);
  const n = (
    /** @type {Array<number>} */
    t.flatCoordinates
  );
  /** @type {Array<number>} */
  t.ends.push(n.length);
}
function qE(i, e) {
  const t = (
    /** @type {import("./Feature.js").ReadOptions} */
    e[0]
  ), n = V(
    {
      flatCoordinates: [],
      layoutOptions: {}
    },
    ER,
    i,
    e
  );
  if (!n)
    return;
  const r = (
    /** @type {Array<number>} */
    n.flatCoordinates
  );
  delete n.flatCoordinates;
  const s = (
    /** @type {LayoutOptions} */
    n.layoutOptions
  );
  delete n.layoutOptions;
  const o = _m(s, r), a = new Wt(r, o);
  xt(a, !1, t);
  const l = new li(a);
  return l.setProperties(n, !0), l;
}
function ZE(i, e) {
  const t = (
    /** @type {import("./Feature.js").ReadOptions} */
    e[0]
  ), n = V(
    {
      flatCoordinates: [],
      ends: [],
      layoutOptions: {}
    },
    wR,
    i,
    e
  );
  if (!n)
    return;
  const r = (
    /** @type {Array<number>} */
    n.flatCoordinates
  );
  delete n.flatCoordinates;
  const s = (
    /** @type {Array<number>} */
    n.ends
  );
  delete n.ends;
  const o = (
    /** @type {LayoutOptions} */
    n.layoutOptions
  );
  delete n.layoutOptions;
  const a = _m(o, r, s), l = new Xi(r, a, s);
  xt(l, !1, t);
  const h = new li(l);
  return h.setProperties(n, !0), h;
}
function HE(i, e) {
  const t = (
    /** @type {import("./Feature.js").ReadOptions} */
    e[0]
  ), n = V({}, TR, i, e);
  if (!n)
    return;
  const r = (
    /** @type {LayoutOptions} */
    {}
  ), s = mm([], r, i, n), o = _m(r, s), a = new Jt(s, o);
  xt(a, !1, t);
  const l = new li(a);
  return l.setProperties(n, !0), l;
}
function ym(i, e, t) {
  i.setAttribute("href", e);
  const r = t[t.length - 1].properties, s = [r.linkText, r.linkType];
  we(
    /** @type {import("../xml.js").NodeStackItem} */
    { node: i },
    PR,
    ai,
    s,
    t,
    RR
  );
}
function xm(i, e, t) {
  const n = t[t.length - 1], s = n.node.namespaceURI, o = n.properties;
  switch (i.setAttributeNS(null, "lat", String(e[1])), i.setAttributeNS(null, "lon", String(e[0])), n.geometryLayout) {
    case "XYZM":
      e[3] !== 0 && (o.time = e[3]);
    // fall through
    case "XYZ":
      e[2] !== 0 && (o.ele = e[2]);
      break;
    case "XYM":
      e[2] !== 0 && (o.time = e[2]);
      break;
  }
  const l = i.nodeName == "rtept" ? AR[s] : NR[s], h = Vi(o, l);
  we(
    /** @type {import("../xml.js").NodeStackItem} */
    { node: i, properties: o },
    DR,
    ai,
    h,
    t,
    l
  );
}
function WR(i, e, t) {
  const n = (
    /** @type {import("./Feature.js").WriteOptions} */
    t[0]
  ), r = e.getProperties(), s = { node: i };
  s.properties = r;
  const o = e.getGeometry();
  if (o.getType() == "LineString") {
    const u = (
      /** @type {LineString} */
      xt(o, !0, n)
    );
    s.geometryLayout = u.getLayout(), r.rtept = u.getCoordinates();
  }
  const a = t[t.length - 1].node, l = MR[a.namespaceURI], h = Vi(r, l);
  we(
    s,
    CR,
    ai,
    h,
    t,
    l
  );
}
function YR(i, e, t) {
  const n = (
    /** @type {import("./Feature.js").WriteOptions} */
    t[0]
  ), r = e.getProperties(), s = { node: i };
  s.properties = r;
  const o = e.getGeometry();
  if (o.getType() == "MultiLineString") {
    const u = (
      /** @type {MultiLineString} */
      xt(o, !0, n)
    );
    r.trkseg = u.getLineStrings();
  }
  const a = t[t.length - 1].node, l = IR[a.namespaceURI], h = Vi(r, l);
  we(
    s,
    LR,
    ai,
    h,
    t,
    l
  );
}
function qR(i, e, t) {
  const n = { node: i };
  n.geometryLayout = e.getLayout(), n.properties = {}, we(
    n,
    OR,
    FR,
    e.getCoordinates(),
    t
  );
}
function ZR(i, e, t) {
  const n = (
    /** @type {import("./Feature.js").WriteOptions} */
    t[0]
  ), r = t[t.length - 1];
  r.properties = e.getProperties();
  const s = e.getGeometry();
  if (s.getType() == "Point") {
    const o = (
      /** @type {Point} */
      xt(s, !0, n)
    );
    r.geometryLayout = o.getLayout(), xm(i, o.getCoordinates(), t);
  }
}
class Em extends Ph {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   * @override
   */
  getType() {
    return "text";
  }
  /**
   * Read the feature from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   * @override
   */
  readFeature(e, t) {
    return this.readFeatureFromText(
      au(e),
      this.adaptOptions(t)
    );
  }
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(e, t) {
    return de();
  }
  /**
   * Read the features from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   * @override
   */
  readFeatures(e, t) {
    return this.readFeaturesFromText(
      au(e),
      this.adaptOptions(t)
    );
  }
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromText(e, t) {
    return de();
  }
  /**
   * Read the geometry from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   * @override
   */
  readGeometry(e, t) {
    return this.readGeometryFromText(
      au(e),
      this.adaptOptions(t)
    );
  }
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromText(e, t) {
    return de();
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   * @api
   * @override
   */
  readProjection(e) {
    return this.readProjectionFromText(au(e));
  }
  /**
   * @param {string} text Text.
   * @protected
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjectionFromText(e) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as a string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   * @override
   */
  writeFeature(e, t) {
    return this.writeFeatureText(e, this.adaptOptions(t));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeatureText(e, t) {
    return de();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   * @override
   */
  writeFeatures(e, t) {
    return this.writeFeaturesText(e, this.adaptOptions(t));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeaturesText(e, t) {
    return de();
  }
  /**
   * Write a single geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Geometry.
   * @api
   * @override
   */
  writeGeometry(e, t) {
    return this.writeGeometryText(e, this.adaptOptions(t));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeGeometryText(e, t) {
    return de();
  }
}
function au(i) {
  return typeof i == "string" ? i : "";
}
const HR = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/, KR = /^H.([A-Z]{3}).*?:(.*)/, JR = /^HFDTE(\d{2})(\d{2})(\d{2})/, QR = /^HFDTEDATE:(\d{2})(\d{2})(\d{2}),(\d{2})/, eP = /\r\n|\r|\n/;
class tP extends Em {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.dataProjection = ee("EPSG:4326"), this.altitudeMode_ = e.altitudeMode ? e.altitudeMode : "none", this.lad_ = !1, this.lod_ = !1, this.ladStart_ = 0, this.ladStop_ = 0, this.lodStart_ = 0, this.lodStop_ = 0;
  }
  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @override
   */
  readFeatureFromText(e, t) {
    const n = this.altitudeMode_, r = e.split(eP), s = {}, o = [];
    let a = 2e3, l = 0, h = 1, u = -1, c, f;
    for (c = 0, f = r.length; c < f; ++c) {
      const x = r[c];
      let v;
      if (x.charAt(0) == "B") {
        if (v = HR.exec(x), v) {
          const p = parseInt(v[1], 10), y = parseInt(v[2], 10), E = parseInt(v[3], 10);
          let b = parseInt(v[4], 10) + parseInt(v[5], 10) / 6e4;
          this.lad_ && (b += parseInt(x.slice(this.ladStart_, this.ladStop_), 10) / 6e4 / 10 ** (this.ladStop_ - this.ladStart_)), v[6] == "S" && (b = -b);
          let T = parseInt(v[7], 10) + parseInt(v[8], 10) / 6e4;
          if (this.lod_ && (T += parseInt(x.slice(this.lodStart_, this.lodStop_), 10) / 6e4 / 10 ** (this.lodStop_ - this.lodStart_)), v[9] == "W" && (T = -T), o.push(T, b), n != "none") {
            let M;
            n == "gps" ? M = parseInt(v[11], 10) : n == "barometric" ? M = parseInt(v[12], 10) : M = 0, o.push(M);
          }
          let R = Date.UTC(a, l, h, p, y, E);
          R < u && (R = Date.UTC(a, l, h + 1, p, y, E)), o.push(R / 1e3), u = R;
        }
      } else if (x.charAt(0) == "H")
        v = QR.exec(x), v ? (h = parseInt(v[1], 10), l = parseInt(v[2], 10) - 1, a = 2e3 + parseInt(v[3], 10)) : (v = JR.exec(x), v ? (h = parseInt(v[1], 10), l = parseInt(v[2], 10) - 1, a = 2e3 + parseInt(v[3], 10)) : (v = KR.exec(x), v && (s[v[1]] = v[2].trim())));
      else if (x.charAt(0) == "I") {
        const p = parseInt(x.slice(1, 3), 10);
        for (let y = 0; y < p; y++) {
          const E = x.slice(7 + y * 7, 10 + y * 7);
          if (E === "LAD" || E === "LOD") {
            const b = parseInt(x.slice(3 + y * 7, 5 + y * 7), 10) - 1, T = parseInt(x.slice(5 + y * 7, 7 + y * 7), 10);
            E === "LAD" ? (this.lad_ = !0, this.ladStart_ = b, this.ladStop_ = T) : E === "LOD" && (this.lod_ = !0, this.lodStart_ = b, this.lodStop_ = T);
          }
        }
      }
    }
    if (o.length === 0)
      return null;
    const g = n == "none" ? "XYM" : "XYZM", d = new Wt(o, g), m = new li(
      xt(d, !1, t)
    );
    return m.setProperties(s, !0), m;
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   * @override
   */
  readFeaturesFromText(e, t) {
    const n = this.readFeatureFromText(e, t);
    return n ? [n] : [];
  }
}
const $t = {
  VERSION1: "version1",
  VERSION2: "version2",
  VERSION3: "version3"
}, uo = {};
uo[$t.VERSION1] = {
  level0: {
    supports: [],
    formats: [],
    qualities: ["native"]
  },
  level1: {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["native"]
  },
  level2: {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["native", "color", "grey", "bitonal"]
  }
};
uo[$t.VERSION2] = {
  level0: {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  level1: {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  level2: {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByDistortedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default", "bitonal"]
  }
};
uo[$t.VERSION3] = {
  level0: {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  level1: {
    supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  level2: {
    supports: [
      "regionByPx",
      "regionSquare",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default"]
  }
};
uo.none = {
  none: {
    supports: [],
    formats: [],
    qualities: []
  }
};
const iP = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/, H_ = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/, nP = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
function rP(i) {
  let e = i.getComplianceLevelSupportedFeatures();
  return e === void 0 && (e = uo[$t.VERSION1].level0), {
    url: i.imageInfo["@id"] === void 0 ? void 0 : i.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    supports: e.supports,
    formats: [
      ...e.formats,
      i.imageInfo.formats === void 0 ? [] : i.imageInfo.formats
    ],
    qualities: [
      ...e.qualities,
      i.imageInfo.qualities === void 0 ? [] : i.imageInfo.qualities
    ],
    resolutions: i.imageInfo.scale_factors,
    tileSize: i.imageInfo.tile_width !== void 0 ? i.imageInfo.tile_height !== void 0 ? [i.imageInfo.tile_width, i.imageInfo.tile_height] : [i.imageInfo.tile_width, i.imageInfo.tile_width] : i.imageInfo.tile_height != null ? [i.imageInfo.tile_height, i.imageInfo.tile_height] : void 0
  };
}
function sP(i) {
  const e = i.getComplianceLevelSupportedFeatures(), t = Array.isArray(i.imageInfo.profile) && i.imageInfo.profile.length > 1, n = t && i.imageInfo.profile[1].supports ? i.imageInfo.profile[1].supports : [], r = t && i.imageInfo.profile[1].formats ? i.imageInfo.profile[1].formats : [], s = t && i.imageInfo.profile[1].qualities ? i.imageInfo.profile[1].qualities : [];
  return {
    url: i.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    sizes: i.imageInfo.sizes === void 0 ? void 0 : i.imageInfo.sizes.map(function(o) {
      return [o.width, o.height];
    }),
    tileSize: i.imageInfo.tiles === void 0 ? void 0 : [
      i.imageInfo.tiles.map(function(o) {
        return o.width;
      })[0],
      i.imageInfo.tiles.map(function(o) {
        return o.height === void 0 ? o.width : o.height;
      })[0]
    ],
    resolutions: i.imageInfo.tiles === void 0 ? void 0 : i.imageInfo.tiles.map(function(o) {
      return o.scaleFactors;
    })[0],
    supports: [...e.supports, ...n],
    formats: [...e.formats, ...r],
    qualities: [...e.qualities, ...s]
  };
}
function oP(i) {
  const e = i.getComplianceLevelSupportedFeatures(), t = i.imageInfo.extraFormats === void 0 ? e.formats : [...e.formats, ...i.imageInfo.extraFormats], n = i.imageInfo.preferredFormats !== void 0 && Array.isArray(i.imageInfo.preferredFormats) && i.imageInfo.preferredFormats.length > 0 ? i.imageInfo.preferredFormats.filter(function(r) {
    return ["jpg", "png", "gif"].includes(r);
  }).reduce(function(r, s) {
    return r === void 0 && t.includes(s) ? s : r;
  }, void 0) : void 0;
  return {
    url: i.imageInfo.id,
    sizes: i.imageInfo.sizes === void 0 ? void 0 : i.imageInfo.sizes.map(function(r) {
      return [r.width, r.height];
    }),
    tileSize: i.imageInfo.tiles === void 0 ? void 0 : [
      i.imageInfo.tiles.map(function(r) {
        return r.width;
      })[0],
      i.imageInfo.tiles.map(function(r) {
        return r.height;
      })[0]
    ],
    resolutions: i.imageInfo.tiles === void 0 ? void 0 : i.imageInfo.tiles.map(function(r) {
      return r.scaleFactors;
    })[0],
    supports: i.imageInfo.extraFeatures === void 0 ? e.supports : [...e.supports, ...i.imageInfo.extraFeatures],
    formats: t,
    qualities: i.imageInfo.extraQualities === void 0 ? e.qualities : [...e.qualities, ...i.imageInfo.extraQualities],
    preferredFormat: n
  };
}
const Tf = {};
Tf[$t.VERSION1] = rP;
Tf[$t.VERSION2] = sP;
Tf[$t.VERSION3] = oP;
class aP {
  /**
   * @param {string|ImageInformationResponse} imageInfo
   * Deserialized image information JSON response object or JSON response as string
   */
  constructor(e) {
    this.setImageInfo(e);
  }
  /**
   * @param {string|ImageInformationResponse} imageInfo
   * Deserialized image information JSON response object or JSON response as string
   * @api
   */
  setImageInfo(e) {
    typeof e == "string" ? this.imageInfo = JSON.parse(e) : this.imageInfo = e;
  }
  /**
   * @return {Versions|undefined} Major IIIF version.
   * @api
   */
  getImageApiVersion() {
    if (this.imageInfo === void 0)
      return;
    let e = this.imageInfo["@context"] || "ol-no-context";
    typeof e == "string" && (e = [e]);
    for (let t = 0; t < e.length; t++)
      switch (e[t]) {
        case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
        case "http://iiif.io/api/image/1/context.json":
          return $t.VERSION1;
        case "http://iiif.io/api/image/2/context.json":
          return $t.VERSION2;
        case "http://iiif.io/api/image/3/context.json":
          return $t.VERSION3;
        case "ol-no-context":
          if (this.getComplianceLevelEntryFromProfile($t.VERSION1) && this.imageInfo.identifier)
            return $t.VERSION1;
          break;
      }
    Te(
      !1,
      "Cannot determine IIIF Image API version from provided image information JSON"
    );
  }
  /**
   * @param {Versions} version Optional IIIF image API version
   * @return {string|undefined} Compliance level as it appears in the IIIF image information
   * response.
   */
  getComplianceLevelEntryFromProfile(e) {
    if (!(this.imageInfo === void 0 || this.imageInfo.profile === void 0))
      switch (e === void 0 && (e = this.getImageApiVersion()), e) {
        case $t.VERSION1:
          if (iP.test(this.imageInfo.profile))
            return this.imageInfo.profile;
          break;
        case $t.VERSION3:
          if (nP.test(this.imageInfo.profile))
            return this.imageInfo.profile;
          break;
        case $t.VERSION2:
          if (typeof this.imageInfo.profile == "string" && H_.test(this.imageInfo.profile))
            return this.imageInfo.profile;
          if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] == "string" && H_.test(this.imageInfo.profile[0]))
            return this.imageInfo.profile[0];
          break;
      }
  }
  /**
   * @param {Versions} version Optional IIIF image API version
   * @return {string} Compliance level, on of 'level0', 'level1' or 'level2' or undefined
   */
  getComplianceLevelFromProfile(e) {
    const t = this.getComplianceLevelEntryFromProfile(e);
    if (t === void 0)
      return;
    const n = t.match(/level[0-2](?:\.json)?$/g);
    return Array.isArray(n) ? n[0].replace(".json", "") : void 0;
  }
  /**
   * @return {SupportedFeatures|undefined} Image formats, qualities and region / size calculation
   * methods that are supported by the IIIF service.
   */
  getComplianceLevelSupportedFeatures() {
    if (this.imageInfo === void 0)
      return;
    const e = this.getImageApiVersion(), t = this.getComplianceLevelFromProfile(e);
    return t === void 0 ? uo.none.none : uo[e][t];
  }
  /**
   * @param {PreferredOptions} [preferredOptions] Optional options for preferred format and quality.
   * @return {import("../source/IIIF.js").Options|undefined} IIIF tile source ready constructor options.
   * @api
   */
  getTileSourceOptions(e) {
    const t = e || {}, n = this.getImageApiVersion();
    if (n === void 0)
      return;
    const r = n === void 0 ? void 0 : Tf[n](this);
    if (r !== void 0)
      return {
        url: r.url,
        version: n,
        size: [this.imageInfo.width, this.imageInfo.height],
        sizes: r.sizes,
        format: t.format !== void 0 && r.formats.includes(t.format) ? t.format : r.preferredFormat !== void 0 ? r.preferredFormat : "jpg",
        supports: r.supports,
        quality: t.quality && r.qualities.includes(t.quality) ? t.quality : r.qualities.includes("native") ? "native" : "default",
        resolutions: Array.isArray(r.resolutions) ? r.resolutions.sort(function(s, o) {
          return o - s;
        }) : void 0,
        tileSize: r.tileSize
      };
  }
}
const se = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
}, co = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", lP = co.includes("safari") && !co.includes("chrom"), hP = lP && (co.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(co)), uP = co.includes("webkit") && !co.includes("edge"), KE = co.includes("macintosh"), cP = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, di = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, vm = typeof Image < "u" && Image.prototype.decode, JE = typeof createImageBitmap == "function", QE = (function() {
  let i = !1;
  try {
    const e = Object.defineProperty({}, "passive", {
      get: function() {
        i = !0;
      }
    });
    window.addEventListener("_", null, e), window.removeEventListener("_", null, e);
  } catch {
  }
  return i;
})();
function ot(i, e, t, n) {
  let r;
  return t && t.length ? r = /** @type {HTMLCanvasElement} */
  t.shift() : di ? r = new class extends OffscreenCanvas {
    style = {};
  }(i ?? 300, e ?? 150) : r = document.createElement("canvas"), i && (r.width = i), e && (r.height = e), /** @type {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} */
  r.getContext("2d", n);
}
let wd;
function pc() {
  return wd || (wd = ot(1, 1)), wd;
}
function Ih(i) {
  const e = i.canvas;
  e.width = 1, e.height = 1, i.clearRect(0, 0, 1, 1);
}
function K_(i, e) {
  const t = e.parentNode;
  t && t.replaceChild(i, e);
}
function fP(i) {
  for (; i.lastChild; )
    i.lastChild.remove();
}
function dP(i, e) {
  const t = i.childNodes;
  for (let n = 0; ; ++n) {
    const r = t[n], s = e[n];
    if (!r && !s)
      break;
    if (r !== s) {
      if (!r) {
        i.appendChild(s);
        continue;
      }
      if (!s) {
        i.removeChild(r), --n;
        continue;
      }
      i.insertBefore(s, r);
    }
  }
}
function ev() {
  return new Proxy(
    {
      /**
       * @type {Array<HTMLElement>}
       */
      childNodes: [],
      /**
       * @param {HTMLElement} node html node.
       * @return {HTMLElement} html node.
       */
      appendChild: function(e) {
        return this.childNodes.push(e), e;
      },
      /**
       * dummy function, as this structure is not supposed to have a parent.
       */
      remove: function() {
      },
      /**
       * @param {HTMLElement} node html node.
       * @return {HTMLElement} html node.
       */
      removeChild: function(e) {
        const t = this.childNodes.indexOf(e);
        if (t === -1)
          throw new Error("Node to remove was not found");
        return this.childNodes.splice(t, 1), e;
      },
      /**
       * @param {HTMLElement} newNode new html node.
       * @param {HTMLElement} referenceNode reference html node.
       * @return {HTMLElement} new html node.
       */
      insertBefore: function(e, t) {
        const n = this.childNodes.indexOf(t);
        if (n === -1)
          throw new Error("Reference node not found");
        return this.childNodes.splice(n, 0, e), e;
      },
      style: {}
    },
    {
      get(e, t, n) {
        return t === "firstElementChild" ? e.childNodes.length > 0 ? e.childNodes[0] : null : Reflect.get(e, t, n);
      }
    }
  );
}
function fs(i) {
  return typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas;
}
const wm = [NaN, NaN, NaN, 0];
let bd;
function gP() {
  return bd || (bd = ot(1, 1, void 0, {
    willReadFrequently: !0,
    desynchronized: !0
  })), bd;
}
const pP = /^rgba?\(\s*(\d+%?)\s+(\d+%?)\s+(\d+%?)(?:\s*\/\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i, mP = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i, _P = /^rgba?\(\s*(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)(?:\s*,\s*(\d+%|\d*\.\d+|[01]))?\s*\)$/i, yP = /^#([\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/i;
function lu(i, e) {
  return i.endsWith("%") ? Number(i.substring(0, i.length - 1)) / e : Number(i);
}
function Cl(i) {
  throw new Error('failed to parse "' + i + '" as color');
}
function tv(i) {
  if (i.toLowerCase().startsWith("rgb")) {
    const s = i.match(mP) || i.match(pP) || i.match(_P);
    if (s) {
      const o = s[4], a = 100 / 255;
      return [
        ve(lu(s[1], a) + 0.5 | 0, 0, 255),
        ve(lu(s[2], a) + 0.5 | 0, 0, 255),
        ve(lu(s[3], a) + 0.5 | 0, 0, 255),
        o !== void 0 ? ve(lu(o, 100), 0, 1) : 1
      ];
    }
    Cl(i);
  }
  if (i.startsWith("#")) {
    if (yP.test(i)) {
      const s = i.substring(1), o = s.length <= 4 ? 1 : 2, a = [0, 0, 0, 255];
      for (let l = 0, h = s.length; l < h; l += o) {
        let u = parseInt(s.substring(l, l + o), 16);
        o === 1 && (u += u << 4), a[l / o] = u;
      }
      return a[3] = a[3] / 255, a;
    }
    Cl(i);
  }
  const e = gP();
  e.fillStyle = "#abcdef";
  let t = e.fillStyle;
  e.fillStyle = i, e.fillStyle === t && (e.fillStyle = "#fedcba", t = e.fillStyle, e.fillStyle = i, e.fillStyle === t && Cl(i));
  const n = e.fillStyle;
  if (n.startsWith("#") || n.startsWith("rgba"))
    return tv(n);
  e.clearRect(0, 0, 1, 1), e.fillRect(0, 0, 1, 1);
  const r = Array.from(e.getImageData(0, 0, 1, 1).data);
  return r[3] = za(r[3] / 255, 3), r;
}
function xP(i) {
  return typeof i == "string" ? i : Sm(i);
}
const EP = 1024, rl = {};
let Sd = 0;
function vP(i) {
  if (i.length === 4)
    return i;
  const e = i.slice();
  return e[3] = 1, e;
}
function Td(i) {
  return i > 31308e-7 ? Math.pow(i, 1 / 2.4) * 269.025 - 14.025 : i * 3294.6;
}
function Rd(i) {
  return i > 0.2068965 ? Math.pow(i, 3) : (i - 4 / 29) * (108 / 841);
}
function Pd(i) {
  return i > 10.314724 ? Math.pow((i + 14.025) / 269.025, 2.4) : i / 3294.6;
}
function Md(i) {
  return i > 88564e-7 ? Math.pow(i, 1 / 3) : i / (108 / 841) + 4 / 29;
}
function J_(i) {
  const e = Pd(i[0]), t = Pd(i[1]), n = Pd(i[2]), r = Md(e * 0.222488403 + t * 0.716873169 + n * 0.06060791), s = 500 * (Md(e * 0.452247074 + t * 0.399439023 + n * 0.148375274) - r), o = 200 * (r - Md(e * 0.016863605 + t * 0.117638439 + n * 0.865350722)), a = Math.atan2(o, s) * (180 / Math.PI);
  return [
    116 * r - 16,
    Math.sqrt(s * s + o * o),
    a < 0 ? a + 360 : a,
    i[3]
  ];
}
function wP(i) {
  const e = (i[0] + 16) / 116, t = i[1], n = i[2] * Math.PI / 180, r = Rd(e), s = Rd(e + t / 500 * Math.cos(n)), o = Rd(e - t / 200 * Math.sin(n)), a = Td(s * 3.021973625 - r * 1.617392459 - o * 0.404875592), l = Td(s * -0.943766287 + r * 1.916279586 + o * 0.027607165), h = Td(s * 0.069407491 - r * 0.22898585 + o * 1.159737864);
  return [
    ve(a + 0.5 | 0, 0, 255),
    ve(l + 0.5 | 0, 0, 255),
    ve(h + 0.5 | 0, 0, 255),
    i[3]
  ];
}
function bm(i) {
  if (i === "none")
    return wm;
  if (rl.hasOwnProperty(i))
    return rl[i];
  if (Sd >= EP) {
    let t = 0;
    for (const n in rl)
      (t++ & 3) === 0 && (delete rl[n], --Sd);
  }
  const e = tv(i);
  e.length !== 4 && Cl(i);
  for (const t of e)
    isNaN(t) && Cl(i);
  return rl[i] = e, ++Sd, e;
}
function An(i) {
  return Array.isArray(i) ? i : bm(i);
}
function Sm(i) {
  let e = i[0];
  e != (e | 0) && (e = e + 0.5 | 0);
  let t = i[1];
  t != (t | 0) && (t = t + 0.5 | 0);
  let n = i[2];
  n != (n | 0) && (n = n + 0.5 | 0);
  const r = i[3] === void 0 ? 1 : Math.round(i[3] * 1e3) / 1e3;
  return "rgba(" + e + "," + t + "," + n + "," + r + ")";
}
class Rf extends ka {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
   * resolution will be assumed.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default|Loader} stateOrLoader State.
   */
  constructor(e, t, n, r) {
    super(), this.extent = e, this.pixelRatio_ = n, this.resolution = t, this.state = typeof r == "function" ? se.IDLE : r, this.image_ = null, this.loader = typeof r == "function" ? r : null;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(le.CHANGE);
  }
  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  getExtent() {
    return this.extent;
  }
  /**
   * @return {import('./DataTile.js').ImageLike} Image.
   */
  getImage() {
    return this.image_;
  }
  /**
   * @return {number} PixelRatio.
   */
  getPixelRatio() {
    return this.pixelRatio_;
  }
  /**
   * @return {number|Array<number>} Resolution.
   */
  getResolution() {
    return (
      /** @type {number} */
      this.resolution
    );
  }
  /**
   * @return {import("./ImageState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == se.IDLE && this.loader) {
      this.state = se.LOADING, this.changed();
      const e = this.getResolution(), t = Array.isArray(e) ? e[0] : e;
      ro(
        () => this.loader(
          this.getExtent(),
          t,
          this.getPixelRatio()
        )
      ).then((n) => {
        "image" in n && (this.image_ = n.image), "extent" in n && (this.extent = n.extent), "resolution" in n && (this.resolution = n.resolution), "pixelRatio" in n && (this.pixelRatio_ = n.pixelRatio), (n instanceof HTMLImageElement || JE && n instanceof ImageBitmap || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement) && (this.image_ = n), this.state = se.LOADED;
      }).catch((n) => {
        this.state = se.ERROR, console.error(n);
      }).finally(() => this.changed());
    }
  }
  /**
   * @param {import('./DataTile.js').ImageLike} image The image.
   */
  setImage(e) {
    this.image_ = e;
  }
  /**
   * @param {number|Array<number>} resolution Resolution.
   */
  setResolution(e) {
    this.resolution = e;
  }
}
function bP(i, e, t) {
  const n = (
    /** @type {HTMLImageElement} */
    i
  );
  let r = !0, s = !1, o = !1;
  const a = [
    ql(n, le.LOAD, function() {
      o = !0, s || e();
    })
  ];
  return n.src && vm ? (s = !0, n.decode().then(function() {
    r && e();
  }).catch(function(l) {
    r && (o ? e() : t());
  })) : a.push(ql(n, le.ERROR, t)), function() {
    r = !1, a.forEach(tt);
  };
}
function SP(i, e) {
  return new Promise((t, n) => {
    function r() {
      o(), t(i);
    }
    function s() {
      o(), n(new Error("Image load error"));
    }
    function o() {
      i.removeEventListener("load", r), i.removeEventListener("error", s);
    }
    i.addEventListener("load", r), i.addEventListener("error", s);
  });
}
function iv(i, e) {
  return e && (i.src = e), i.src && vm ? new Promise(
    (t, n) => i.decode().then(() => t(i)).catch(
      (r) => i.complete && i.width ? t(i) : n(r)
    )
  ) : SP(i);
}
function ja(i, e) {
  return e && (i.src = e), i.src && vm && JE ? i.decode().then(() => createImageBitmap(i)).catch((t) => {
    if (i.complete && i.width)
      return i;
    throw t;
  }) : iv(i);
}
class TP {
  constructor() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 1024;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let e = 0;
      for (const t in this.cache_) {
        const n = this.cache_[t];
        (e++ & 3) === 0 && !n.hasListener() && (delete this.cache_[t], delete this.patternCache_[t], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(e, t, n) {
    const r = Cd(e, t, n);
    return r in this.cache_ ? this.cache_[r] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(e, t, n) {
    const r = Cd(e, t, n);
    return r in this.patternCache_ ? this.patternCache_[r] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(e, t, n, r, s) {
    const o = Cd(e, t, n), a = o in this.cache_;
    this.cache_[o] = r, s && (r.getImageState() === se.IDLE && r.load(), r.getImageState() === se.LOADING ? r.ready().then(() => {
      this.patternCache_[o] = pc().createPattern(
        r.getImage(1),
        "repeat"
      );
    }) : this.patternCache_[o] = pc().createPattern(
      r.getImage(1),
      "repeat"
    )), a || ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `1024`. Change this value when
   * your map uses more than 1024 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(e) {
    this.maxCacheSize_ = e, this.expire();
  }
}
function Cd(i, e, t) {
  const n = t ? An(t) : "null";
  return e + ":" + i + ":" + n;
}
const wn = new TP();
let sl = null;
class nv extends ka {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(e, t, n, r, s) {
    super(), this.hitDetectionImage_ = null, this.image_ = e, this.crossOrigin_ = n, this.canvas_ = {}, this.color_ = s, this.imageState_ = r === void 0 ? se.IDLE : r, this.size_ = e && e.width && e.height ? [e.width, e.height] : null, this.src_ = t, this.tainted_, this.ready_ = null;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === se.LOADED) {
      sl || (sl = ot(1, 1, void 0, {
        willReadFrequently: !0
      })), sl.drawImage(this.image_, 0, 0);
      try {
        sl.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        sl = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(le.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = se.ERROR, this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = se.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(e) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(e), this.canvas_[e] ? this.canvas_[e] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(e) {
    return this.replaceColor_(e), this.canvas_[e] ? e : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const e = this.size_[0], t = this.size_[1], n = ot(e, t);
        n.fillRect(0, 0, e, t), this.hitDetectionImage_ = n.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === se.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = se.LOADING;
      try {
        this.src_ !== void 0 && (this.image_.src = this.src_);
      } catch {
        this.handleImageError_();
      }
      this.image_ instanceof HTMLImageElement && iv(this.image_, this.src_).then((e) => {
        this.image_ = e, this.handleImageLoad_();
      }).catch(this.handleImageError_.bind(this));
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(e) {
    if (!this.color_ || this.canvas_[e] || this.imageState_ !== se.LOADED)
      return;
    const t = this.image_, n = ot(
      Math.ceil(t.width * e),
      Math.ceil(t.height * e)
    ), r = n.canvas;
    n.scale(e, e), n.drawImage(t, 0, 0), n.globalCompositeOperation = "multiply", n.fillStyle = xP(this.color_), n.fillRect(0, 0, r.width / e, r.height / e), n.globalCompositeOperation = "destination-in", n.drawImage(t, 0, 0), this.canvas_[e] = r;
  }
  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    return this.ready_ || (this.ready_ = new Promise((e) => {
      if (this.imageState_ === se.LOADED || this.imageState_ === se.ERROR)
        e();
      else {
        const t = () => {
          (this.imageState_ === se.LOADED || this.imageState_ === se.ERROR) && (this.removeEventListener(le.CHANGE, t), e());
        };
        this.addEventListener(le.CHANGE, t);
      }
    })), this.ready_;
  }
}
function mc(i, e, t, n, r, s) {
  let o = e === void 0 ? void 0 : wn.get(e, t, r);
  return o || (o = new nv(
    i,
    i && "src" in i ? i.src || void 0 : e,
    t,
    n,
    r
  ), wn.set(e, t, r, o, s)), s && o && !wn.getPattern(e, t, r) && wn.set(e, t, r, o, s), o;
}
class gi {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.patternImage_ = null, this.color_ = null, e.color !== void 0 && this.setColor(e.color);
  }
  /**
   * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new gi({
      color: Array.isArray(e) ? e.slice() : e || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(e) {
    if (e !== null && typeof e == "object" && "src" in e) {
      const t = mc(
        null,
        e.src,
        "anonymous",
        void 0,
        e.offset ? null : e.color ? e.color : null,
        !(e.offset && e.size)
      );
      t.ready().then(() => {
        this.patternImage_ = null;
      }), t.getImageState() === se.IDLE && t.load(), t.getImageState() === se.LOADING && (this.patternImage_ = t);
    }
    this.color_ = e;
  }
  /**
   * @return {string} Key of the fill for cache lookup.
   */
  getKey() {
    const e = this.getColor();
    return e ? e instanceof CanvasPattern || e instanceof CanvasGradient ? ie(e) : typeof e == "object" && "src" in e ? e.src + ":" + e.offset : An(e).toString() : "";
  }
  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }
  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
}
function Q_(i) {
  return i[0] > 0 && i[1] > 0;
}
function rv(i, e, t) {
  return t === void 0 && (t = [0, 0]), t[0] = i[0] * e + 0.5 | 0, t[1] = i[1] * e + 0.5 | 0, t;
}
function dt(i, e) {
  return Array.isArray(i) ? i : (e === void 0 ? e = [i, i] : (e[0] = i, e[1] = i), e);
}
class Pf {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.opacity_ = e.opacity, this.rotateWithView_ = e.rotateWithView, this.rotation_ = e.rotation, this.scale_ = e.scale, this.scaleArray_ = dt(e.scale), this.displacement_ = e.displacement, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new Pf({
      opacity: this.getOpacity(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return de();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(e) {
    return de();
  }
  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return de();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return de();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return de();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return de();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return de();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(e) {
    this.displacement_ = e;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(e) {
    this.opacity_ = e;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = dt(e);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    de();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    de();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    de();
  }
  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
}
function ey(i, e, t, n) {
  return t !== void 0 && n !== void 0 ? [t / i, n / e] : t !== void 0 ? t / i : n !== void 0 ? n / e : 1;
}
class Ts extends Pf {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.opacity !== void 0 ? e.opacity : 1, n = e.rotation !== void 0 ? e.rotation : 0, r = e.scale !== void 0 ? e.scale : 1, s = e.rotateWithView !== void 0 ? e.rotateWithView : !1;
    super({
      opacity: t,
      rotation: n,
      scale: r,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      rotateWithView: s,
      declutterMode: e.declutterMode
    }), this.anchor_ = e.anchor !== void 0 ? e.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = e.anchorOrigin !== void 0 ? e.anchorOrigin : "top-left", this.anchorXUnits_ = e.anchorXUnits !== void 0 ? e.anchorXUnits : "fraction", this.anchorYUnits_ = e.anchorYUnits !== void 0 ? e.anchorYUnits : "fraction", this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null;
    const o = e.img !== void 0 ? e.img : null;
    let a = e.src;
    Te(
      !(a !== void 0 && o),
      "`image` and `src` cannot be provided at the same time"
    ), (a === void 0 || a.length === 0) && o && (a = /** @type {HTMLImageElement} */
    o.src || ie(o)), Te(
      a !== void 0 && a.length > 0,
      "A defined and non-empty `src` or `image` must be provided"
    ), Te(
      !((e.width !== void 0 || e.height !== void 0) && e.scale !== void 0),
      "`width` or `height` cannot be provided together with `scale`"
    );
    let l;
    if (e.src !== void 0 ? l = se.IDLE : o !== void 0 && ("complete" in o ? o.complete ? l = o.src ? se.LOADED : se.IDLE : l = se.LOADING : l = se.LOADED), this.color_ = e.color !== void 0 ? An(e.color) : null, this.iconImage_ = mc(
      o,
      /** @type {string} */
      a,
      this.crossOrigin_,
      l,
      this.color_
    ), this.offset_ = e.offset !== void 0 ? e.offset : [0, 0], this.offsetOrigin_ = e.offsetOrigin !== void 0 ? e.offsetOrigin : "top-left", this.origin_ = null, this.size_ = e.size !== void 0 ? e.size : null, this.initialOptions_, e.width !== void 0 || e.height !== void 0) {
      let h, u;
      if (e.size)
        [h, u] = e.size;
      else {
        const c = this.getImage(1);
        if (c.width && c.height)
          h = c.width, u = c.height;
        else if (c instanceof HTMLImageElement) {
          this.initialOptions_ = e;
          const f = () => {
            if (this.unlistenImageChange(f), !this.initialOptions_)
              return;
            const g = this.iconImage_.getSize();
            this.setScale(
              ey(
                g[0],
                g[1],
                e.width,
                e.height
              )
            );
          };
          this.listenImageChange(f);
          return;
        }
      }
      h !== void 0 && this.setScale(
        ey(h, u, e.width, e.height)
      );
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   * @override
   */
  clone() {
    let e, t, n;
    return this.initialOptions_ ? (t = this.initialOptions_.width, n = this.initialOptions_.height) : (e = this.getScale(), e = Array.isArray(e) ? e.slice() : e), new Ts({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: e,
      width: t,
      height: n,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    let e = this.normalizedAnchor_;
    if (!e) {
      e = this.anchor_;
      const r = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!r)
          return null;
        e = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (e[0] *= r[0]), this.anchorYUnits_ == "fraction" && (e[1] *= r[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!r)
          return null;
        e === this.anchor_ && (e = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (e[0] = -e[0] + r[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (e[1] = -e[1] + r[1]);
      }
      this.normalizedAnchor_ = e;
    }
    const t = this.getDisplacement(), n = this.getScaleArray();
    return [
      e[0] - t[0] / n[0],
      e[1] + t[1] / n[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(e) {
    this.anchor_ = e, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   * @override
   */
  getImage(e) {
    return this.iconImage_.getImage(e);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   * @override
   */
  getPixelRatio(e) {
    return this.iconImage_.getPixelRatio(e);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas|ImageBitmap} Image element.
   * @override
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let e = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const t = this.getSize(), n = this.iconImage_.getSize();
      if (!t || !n)
        return null;
      e = e.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (e[0] = n[0] - t[0] - e[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (e[1] = n[1] - t[1] - e[1]);
    }
    return this.origin_ = e, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Set the image URI
   * @param {string} src Image source URI
   * @api
   */
  setSrc(e) {
    this.iconImage_ = mc(
      null,
      e,
      this.crossOrigin_,
      se.IDLE,
      this.color_
    );
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   * @override
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const e = this.getScaleArray();
    if (this.size_)
      return this.size_[0] * e[0];
    if (this.iconImage_.getImageState() == se.LOADED)
      return this.iconImage_.getSize()[0] * e[0];
  }
  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const e = this.getScaleArray();
    if (this.size_)
      return this.size_[1] * e[1];
    if (this.iconImage_.getImageState() == se.LOADED)
      return this.iconImage_.getSize()[1] * e[1];
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   * @override
   */
  setScale(e) {
    delete this.initialOptions_, super.setScale(e);
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(e) {
    this.iconImage_.addEventListener(le.CHANGE, e);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   * @override
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(e) {
    this.iconImage_.removeEventListener(le.CHANGE, e);
  }
  /**
   * @override
   */
  ready() {
    return this.iconImage_.ready();
  }
}
class Ri {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.color_ = e.color !== void 0 ? e.color : null, this.lineCap_ = e.lineCap, this.lineDash_ = e.lineDash !== void 0 ? e.lineDash : null, this.lineDashOffset_ = e.lineDashOffset, this.lineJoin_ = e.lineJoin, this.miterLimit_ = e.miterLimit, this.width_ = e.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new Ri({
      color: Array.isArray(e) ? e.slice() : e || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(e) {
    this.color_ = e;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(e) {
    this.lineCap_ = e;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(e) {
    this.lineDash_ = e;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(e) {
    this.lineDashOffset_ = e;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(e) {
    this.lineJoin_ = e;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(e) {
    this.miterLimit_ = e;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(e) {
    this.width_ = e;
  }
}
function ar(i) {
  return i ? Array.isArray(i) ? Sm(i) : typeof i == "object" && "src" in i ? RP(i) : i : null;
}
function RP(i) {
  if (!i.offset || !i.size)
    return wn.getPattern(i.src, "anonymous", i.color);
  const e = i.src + ":" + i.offset, t = wn.getPattern(
    e,
    void 0,
    i.color
  );
  if (t)
    return t;
  const n = wn.get(i.src, "anonymous", null);
  if (n.getImageState() !== se.LOADED)
    return null;
  const r = ot(
    i.size[0],
    i.size[1]
  );
  return r.drawImage(
    n.getImage(1),
    i.offset[0],
    i.offset[1],
    i.size[0],
    i.size[1],
    0,
    0,
    i.size[0],
    i.size[1]
  ), mc(
    r.canvas,
    e,
    void 0,
    se.LOADED,
    i.color,
    !0
  ), wn.getPattern(e, void 0, i.color);
}
const hu = "ol-hidden", Mf = "ol-unselectable", Tm = "ol-control", ty = "ol-collapsed", PP = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z0-9]+?)\\s*$`
  ].join(""),
  "i"
), iy = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], kg = {
  normal: 400,
  bold: 700
}, Ug = function(i) {
  const e = i.match(PP);
  if (!e)
    return null;
  const t = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "400",
      variant: "normal"
    }
  );
  for (let n = 0, r = iy.length; n < r; ++n) {
    const s = e[n + 1];
    s !== void 0 && (t[iy[n]] = typeof s == "string" ? s.trim() : s);
  }
  return isNaN(Number(t.weight)) && t.weight in kg && (t.weight = kg[t.weight]), t.families = t.family.split(/,\s?/).map((n) => n.trim().replace(/^['"]|['"]$/g, "")), t;
}, sv = "10px sans-serif", Gi = "#000", ba = "round", Dr = [], Gr = 0, Sa = "round", Jl = 10, Ql = "#000", eh = "center", _c = "middle", qs = [0, 0, 0, 0], th = 1, js = new _r();
let ol = null, ny;
const zg = {}, MP = /* @__PURE__ */ new Set([
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui",
  "ui-serif",
  "ui-sans-serif",
  "ui-monospace",
  "ui-rounded",
  "emoji",
  "math",
  "fangsong"
]);
function CP(i, e, t) {
  return `${i} ${e} 16px "${t}"`;
}
const AP = /* @__PURE__ */ (function() {
  let e, t;
  async function n(s) {
    await t.ready;
    const o = await t.load(s);
    if (o.length === 0)
      return !1;
    const a = Ug(s), l = a.families[0].toLowerCase(), h = a.weight;
    return o.some(
      /**
       * @param {import('../css.js').FontParameters} f Font.
       * @return {boolean} Font matches.
       */
      (u) => {
        const c = u.family.replace(/^['"]|['"]$/g, "").toLowerCase(), f = kg[u.weight] || u.weight;
        return c === l && u.style === a.style && f == h;
      }
    );
  }
  async function r() {
    await t.ready;
    let s = !0;
    const o = js.getProperties(), a = Object.keys(o).filter(
      (l) => o[l] < 100
    );
    for (let l = a.length - 1; l >= 0; --l) {
      const h = a[l];
      let u = o[h];
      u < 100 && (await n(h) ? (Ga(zg), js.set(h, 100)) : (u += 10, js.set(h, u, !0), u < 100 && (s = !1)));
    }
    e = void 0, s || (e = setTimeout(r, 100));
  }
  return async function(s) {
    t || (t = di ? self.fonts : document.fonts);
    const o = Ug(s);
    if (!o)
      return;
    const a = o.families;
    let l = !1;
    for (const h of a) {
      if (MP.has(h))
        continue;
      const u = CP(o.style, o.weight, h);
      js.get(u) === void 0 && (js.set(u, 0, !0), l = !0);
    }
    l && (clearTimeout(e), e = setTimeout(r, 100));
  };
})(), IP = /* @__PURE__ */ (function() {
  let i;
  return function(e) {
    let t = zg[e];
    if (t == null) {
      if (di) {
        const n = Ug(e), r = ov(e, "Žg");
        t = (isNaN(Number(n.lineHeight)) ? 1.2 : Number(n.lineHeight)) * (r.actualBoundingBoxAscent + r.actualBoundingBoxDescent);
      } else
        i || (i = document.createElement("div"), i.innerHTML = "M", i.style.minHeight = "0", i.style.maxHeight = "none", i.style.height = "auto", i.style.padding = "0", i.style.border = "none", i.style.position = "absolute", i.style.display = "block", i.style.left = "-99999px"), i.style.font = e, document.body.appendChild(i), t = i.offsetHeight, document.body.removeChild(i);
      zg[e] = t;
    }
    return t;
  };
})();
function ov(i, e) {
  return ol || (ol = ot(1, 1)), i != ny && (ol.font = i, ny = ol.font), ol.measureText(e);
}
function av(i, e) {
  return ov(i, e).width;
}
function ry(i, e, t) {
  if (e in t)
    return t[e];
  const n = e.split(`
`).reduce((r, s) => Math.max(r, av(i, s)), 0);
  return t[e] = n, n;
}
function LP(i, e) {
  const t = [], n = [], r = [];
  let s = 0, o = 0, a = 0, l = 0;
  for (let h = 0, u = e.length; h <= u; h += 2) {
    const c = e[h];
    if (c === `
` || h === u) {
      s = Math.max(s, o), r.push(o), o = 0, a += l, l = 0;
      continue;
    }
    const f = e[h + 1] || i.font, g = av(f, c);
    t.push(g), o += g;
    const d = IP(f);
    n.push(d), l = Math.max(l, d);
  }
  return { width: s, height: a, widths: t, heights: n, lineWidths: r };
}
function FP(i, e, t, n, r, s, o, a, l, h, u) {
  i.save(), t !== 1 && (i.globalAlpha === void 0 ? i.globalAlpha = (c) => c.globalAlpha *= t : i.globalAlpha *= t), e && i.transform.apply(i, e), /** @type {*} */
  n.contextInstructions ? (i.translate(l, h), i.scale(u[0], u[1]), OP(
    /** @type {Label} */
    n,
    i
  )) : u[0] < 0 || u[1] < 0 ? (i.translate(l, h), i.scale(u[0], u[1]), i.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    n,
    r,
    s,
    o,
    a,
    0,
    0,
    o,
    a
  )) : i.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    n,
    r,
    s,
    o,
    a,
    l,
    h,
    o * u[0],
    a * u[1]
  ), i.restore();
}
function OP(i, e) {
  const t = i.contextInstructions;
  for (let n = 0, r = t.length; n < r; n += 2)
    Array.isArray(t[n + 1]) ? e[t[n]].apply(
      e,
      t[n + 1]
    ) : e[t[n]] = t[n + 1];
}
class Cf extends Pf {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    super({
      opacity: 1,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      scale: e.scale !== void 0 ? e.scale : 1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    }), this.hitDetectionCanvas_ = null, this.fill_ = e.fill !== void 0 ? e.fill : null, this.origin_ = [0, 0], this.points_ = e.points, this.radius = e.radius, this.radius2_ = e.radius2, this.angle_ = e.angle !== void 0 ? e.angle : 0, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? se.LOADING : se.LOADED, this.imageState_ === se.LOADING && this.ready().then(() => this.imageState_ = se.LOADED), this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   * @override
   */
  clone() {
    const e = this.getScale(), t = new Cf({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    const e = this.size_, t = this.getDisplacement(), n = this.getScaleArray();
    return [
      e[0] / 2 - t[0] / n[0],
      e[1] / 2 + t[1] / n[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e, this.render();
  }
  /**
   * @return {HTMLCanvasElement|OffscreenCanvas} Image element.
   * @override
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
      this.renderOptions_
    )), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement|OffscreenCanvas} Image or Canvas element.
   * @api
   * @override
   */
  getImage(e) {
    const t = this.fill_?.getKey(), n = `${e},${this.angle_},${this.radius},${this.radius2_},${this.points_},${t}` + Object.values(this.renderOptions_).join(",");
    let r = (
      /** @type {HTMLCanvasElement|OffscreenCanvas} */
      wn.get(n, null, null)?.getImage(1)
    );
    if (!r) {
      const s = this.renderOptions_, o = Math.ceil(s.size * e), a = ot(o, o);
      this.draw_(s, a, e), r = a.canvas, wn.set(
        n,
        null,
        null,
        new nv(r, void 0, null, se.LOADED, null)
      );
    }
    return r;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   * @override
   */
  getPixelRatio(e) {
    return e;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   * @override
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(e) {
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(e) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(e, t, n) {
    if (t === 0 || this.points_ === 1 / 0 || e !== "bevel" && e !== "miter")
      return t;
    let r = this.radius, s = this.radius2_ === void 0 ? r : this.radius2_;
    if (r < s) {
      const T = r;
      r = s, s = T;
    }
    const o = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, a = 2 * Math.PI / o, l = s * Math.sin(a), h = Math.sqrt(s * s - l * l), u = r - h, c = Math.sqrt(l * l + u * u), f = c / l;
    if (e === "miter" && f <= n)
      return f * t;
    const g = t / 2 / f, d = t / 2 * (u / c), x = Math.sqrt((r + g) * (r + g) + d * d) - r;
    if (this.radius2_ === void 0 || e === "bevel")
      return x * 2;
    const v = r * Math.sin(a), p = Math.sqrt(r * r - v * v), y = s - p, b = Math.sqrt(v * v + y * y) / v;
    if (b <= n) {
      const T = b * t / 2 - s - r;
      return 2 * Math.max(x, T);
    }
    return x * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let e = ba, t = Sa, n = 0, r = null, s = 0, o, a = 0;
    this.stroke_ && (o = ar(this.stroke_.getColor() ?? Ql), a = this.stroke_.getWidth() ?? th, r = this.stroke_.getLineDash(), s = this.stroke_.getLineDashOffset() ?? 0, t = this.stroke_.getLineJoin() ?? Sa, e = this.stroke_.getLineCap() ?? ba, n = this.stroke_.getMiterLimit() ?? Jl);
    const l = this.calculateLineJoinSize_(t, a, n), h = Math.max(this.radius, this.radius2_ || 0), u = Math.ceil(2 * h + l);
    return {
      strokeStyle: o,
      strokeWidth: a,
      size: u,
      lineCap: e,
      lineDash: r,
      lineDashOffset: s,
      lineJoin: t,
      miterLimit: n
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const e = this.renderOptions_.size;
    this.hitDetectionCanvas_ = null, this.size_ = [e, e];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(e, t, n) {
    if (t.scale(n, n), t.translate(e.size / 2, e.size / 2), this.createPath_(t), this.fill_) {
      let r = this.fill_.getColor();
      r === null && (r = Gi), t.fillStyle = ar(r), t.fill();
    }
    e.strokeStyle && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineCap = e.lineCap, t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement|OffscreenCanvas} Canvas containing the icon
   */
  createHitDetectionCanvas_(e) {
    let t;
    if (this.fill_) {
      let n = this.fill_.getColor(), r = 0;
      typeof n == "string" && (n = An(n)), n === null ? r = 1 : Array.isArray(n) && (r = n.length === 4 ? n[3] : 1), r === 0 && (t = ot(e.size, e.size), this.drawHitDetectionCanvas_(e, t));
    }
    return t ? t.canvas : this.getImage(1);
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(e) {
    let t = this.points_;
    const n = this.radius;
    if (t === 1 / 0)
      e.arc(0, 0, n, 0, 2 * Math.PI);
    else {
      const r = this.radius2_ === void 0 ? n : this.radius2_;
      this.radius2_ !== void 0 && (t *= 2);
      const s = this.angle_ - Math.PI / 2, o = 2 * Math.PI / t;
      for (let a = 0; a < t; a++) {
        const l = s + a * o, h = a % 2 === 0 ? n : r;
        e.lineTo(h * Math.cos(l), h * Math.sin(l));
      }
      e.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(e, t) {
    t.translate(e.size / 2, e.size / 2), this.createPath_(t), t.fillStyle = Gi, t.fill(), e.strokeStyle && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
  /**
   * @override
   */
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
}
class Xa extends Cf {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || { radius: 5 }, super({
      points: 1 / 0,
      fill: e.fill,
      radius: e.radius,
      stroke: e.stroke,
      scale: e.scale !== void 0 ? e.scale : 1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   * @override
   */
  clone() {
    const e = this.getScale(), t = new Xa({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(e) {
    this.radius = e, this.render();
  }
}
class Mt {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(e) {
    e = e || {}, this.geometry_ = null, this.geometryFunction_ = sy, e.geometry !== void 0 && this.setGeometry(e.geometry), this.fill_ = e.fill !== void 0 ? e.fill : null, this.image_ = e.image !== void 0 ? e.image : null, this.renderer_ = e.renderer !== void 0 ? e.renderer : null, this.hitDetectionRenderer_ = e.hitDetectionRenderer !== void 0 ? e.hitDetectionRenderer : null, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.text_ = e.text !== void 0 ? e.text : null, this.zIndex_ = e.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let e = this.getGeometry();
    return e && typeof e == "object" && (e = /** @type {import("../geom/Geometry.js").default} */
    e.clone()), new Mt({
      geometry: e ?? void 0,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer() ?? void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(e) {
    this.renderer_ = e;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(e) {
    this.hitDetectionRenderer_ = e;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(e) {
    this.image_ = e;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction|null} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(e) {
    typeof e == "function" ? this.geometryFunction_ = e : typeof e == "string" ? this.geometryFunction_ = function(t) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        t.get(e)
      );
    } : e ? e !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        e
      );
    }) : this.geometryFunction_ = sy, this.geometry_ = e;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(e) {
    this.zIndex_ = e;
  }
}
function NP(i) {
  let e;
  if (typeof i == "function")
    e = i;
  else {
    let t;
    Array.isArray(i) ? t = i : (Te(
      typeof /** @type {?} */
      i.getZIndex == "function",
      "Expected an `Style` or an array of `Style`"
    ), t = [
      /** @type {Style} */
      i
    ]), e = function() {
      return t;
    };
  }
  return e;
}
let Ad = null;
function lv(i, e) {
  if (!Ad) {
    const t = new gi({
      color: "rgba(255,255,255,0.4)"
    }), n = new Ri({
      color: "#3399CC",
      width: 1.25
    });
    Ad = [
      new Mt({
        image: new Xa({
          fill: t,
          stroke: n,
          radius: 5
        }),
        fill: t,
        stroke: n
      })
    ];
  }
  return Ad;
}
function sy(i) {
  return i.getGeometry();
}
const DP = "#333";
class Rs {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.font_ = e.font, this.rotation_ = e.rotation, this.rotateWithView_ = e.rotateWithView, this.keepUpright_ = e.keepUpright, this.scale_ = e.scale, this.scaleArray_ = dt(e.scale !== void 0 ? e.scale : 1), this.text_ = e.text, this.textAlign_ = e.textAlign, this.justify_ = e.justify, this.repeat_ = e.repeat, this.textBaseline_ = e.textBaseline, this.fill_ = e.fill !== void 0 ? e.fill : new gi({ color: DP }), this.maxAngle_ = e.maxAngle !== void 0 ? e.maxAngle : Math.PI / 4, this.placement_ = e.placement !== void 0 ? e.placement : "point", this.overflow_ = !!e.overflow, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.offsetX_ = e.offsetX !== void 0 ? e.offsetX : 0, this.offsetY_ = e.offsetY !== void 0 ? e.offsetY : 0, this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null, this.backgroundStroke_ = e.backgroundStroke ? e.backgroundStroke : null, this.padding_ = e.padding === void 0 ? null : e.padding, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new Rs({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      keepUpright: this.getKeepUpright(),
      scale: Array.isArray(e) ? e.slice() : e,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() instanceof gi ? this.getFill().clone() : this.getFill(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0,
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Determine whether the text can be rendered upside down.
   * @return {boolean|undefined} Keep text upright.
   * @api
   */
  getKeepUpright() {
    return this.keepUpright_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(e) {
    this.overflow_ = e;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(e) {
    this.font_ = e;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(e) {
    this.maxAngle_ = e;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(e) {
    this.offsetX_ = e;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(e) {
    this.offsetY_ = e;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(e) {
    this.placement_ = e;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(e) {
    this.repeat_ = e;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set whether the text can be rendered upside down.
   *
   * @param {boolean} keepUpright Keep text upright.
   * @api
   */
  setKeepUpright(e) {
    this.keepUpright_ = e;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = dt(e !== void 0 ? e : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(e) {
    this.textAlign_ = e;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(e) {
    this.justify_ = e;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(e) {
    this.textBaseline_ = e;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(e) {
    this.backgroundFill_ = e;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(e) {
    this.backgroundStroke_ = e;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(e) {
    this.padding_ = e;
  }
}
const Vr = ["http://www.google.com/kml/ext/2.2"], fe = [
  null,
  "http://earth.google.com/kml/2.0",
  "http://earth.google.com/kml/2.1",
  "http://earth.google.com/kml/2.2",
  "http://www.opengis.net/kml/2.2"
], GP = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd", oy = {
  fraction: "fraction",
  pixels: "pixels",
  insetPixels: "pixels"
}, kP = j(
  fe,
  {
    ExtendedData: bv,
    Region: Sv,
    MultiGeometry: F(Ev, "geometry"),
    LineString: F(yv, "geometry"),
    LinearRing: F(xv, "geometry"),
    Point: F(vv, "geometry"),
    Polygon: F(wv, "geometry"),
    Style: F(Mm),
    StyleMap: vM,
    address: F(W),
    description: F(W),
    name: F(W),
    open: F(Ss),
    phoneNumber: F(W),
    styleUrl: F(dv),
    visibility: F(Ss)
  },
  j(Vr, {
    MultiTrack: F(lM, "geometry"),
    Track: F(_v, "geometry")
  })
), UP = j(fe, {
  ExtendedData: bv,
  Region: Sv,
  Link: FM,
  address: F(W),
  description: F(W),
  name: F(W),
  open: F(Ss),
  phoneNumber: F(W),
  visibility: F(Ss)
}), zP = j(fe, {
  href: F(fv)
}), BP = j(fe, {
  Altitude: F(De),
  Longitude: F(De),
  Latitude: F(De),
  Tilt: F(De),
  AltitudeMode: F(W),
  Heading: F(De),
  Roll: F(De)
}), hv = j(fe, {
  LatLonAltBox: RM,
  Lod: MM
}), $P = j(fe, ["Document", "Placemark"]), jP = j(fe, {
  Document: N(BM),
  Placemark: N(Pv)
});
let oa, $u = null, Bg, Al, Il, Ll, yc, $g = null, Rm, jg = null, Xg, Zs = null, ay = null, Vg = null;
function xc(i) {
  return 32 / Math.min(i[0], i[1]);
}
function XP() {
  oa = [255, 255, 255, 1], $u = new gi({
    color: oa
  }), Bg = [20, 2], Al = "pixels", Il = "pixels", Ll = [64, 64], yc = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png", $g = new Ts({
    anchor: Bg,
    anchorOrigin: "bottom-left",
    anchorXUnits: Al,
    anchorYUnits: Il,
    crossOrigin: "anonymous",
    rotation: 0,
    scale: xc(Ll),
    size: Ll,
    src: yc
  }), Rm = "NO_IMAGE", jg = new Ri({
    color: oa,
    width: 1
  }), Xg = new Ri({
    color: [51, 51, 51, 1],
    width: 2
  }), Zs = new Rs({
    font: "bold 16px Helvetica",
    fill: $u,
    stroke: Xg,
    scale: 0.8
  }), ay = new Mt({
    fill: $u,
    image: $g,
    text: Zs,
    stroke: jg,
    zIndex: 0
  }), Vg = [ay];
}
let uu;
function VP(i) {
  return i;
}
class WP extends Ch {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, Vg || XP(), this.dataProjection = ee("EPSG:4326"), this.defaultStyle_ = e.defaultStyle ? e.defaultStyle : Vg, this.extractStyles_ = e.extractStyles !== void 0 ? e.extractStyles : !0, this.writeStyles_ = e.writeStyles !== void 0 ? e.writeStyles : !0, this.sharedStyles_ = {}, this.showPointNames_ = e.showPointNames !== void 0 ? e.showPointNames : !0, this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : "anonymous", this.iconUrlFunction_ = e.iconUrlFunction ? e.iconUrlFunction : VP, this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Array<Feature>|undefined} Features.
   */
  readDocumentOrFolder_(e, t) {
    const n = j(fe, {
      Document: dc(this.readDocumentOrFolder_, this),
      Folder: dc(this.readDocumentOrFolder_, this),
      Placemark: ue(this.readPlacemark_, this),
      Style: this.readSharedStyle_.bind(this),
      StyleMap: this.readSharedStyleMap_.bind(this)
    }), r = V([], n, e, t, this);
    if (r)
      return r;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Feature|undefined} Feature.
   */
  readPlacemark_(e, t) {
    const n = V(
      { geometry: null },
      kP,
      e,
      t,
      this
    );
    if (!n)
      return;
    const r = new li(), s = e.getAttribute("id");
    s !== null && r.setId(s);
    const o = (
      /** @type {import("./Feature.js").ReadOptions} */
      t[0]
    ), a = n.geometry;
    if (a && xt(a, !1, o), r.setGeometry(a), delete n.geometry, this.extractStyles_) {
      const l = n.Style, h = n.styleUrl, u = qP(
        l,
        h,
        this.defaultStyle_,
        this.sharedStyles_,
        this.showPointNames_
      );
      r.setStyle(u);
    }
    return delete n.Style, r.setProperties(n, !0), r;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */
  readSharedStyle_(e, t) {
    const n = e.getAttribute("id");
    if (n !== null) {
      const r = Mm.call(this, e, t);
      if (r) {
        let s, o = e.baseURI;
        (!o || o == "about:blank") && (o = window.location.href), o ? s = new URL("#" + n, o).href : s = "#" + n, this.sharedStyles_[s] = r;
      }
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */
  readSharedStyleMap_(e, t) {
    const n = e.getAttribute("id");
    if (n === null)
      return;
    const r = pv.call(this, e, t);
    if (!r)
      return;
    let s, o = e.baseURI;
    (!o || o == "about:blank") && (o = window.location.href), o ? s = new URL("#" + n, o).href : s = "#" + n, this.sharedStyles_[s] = r;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   * @override
   */
  readFeatureFromNode(e, t) {
    if (!fe.includes(e.namespaceURI))
      return null;
    const n = this.readPlacemark_(e, [
      this.getReadOptions(e, t)
    ]);
    return n || null;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @override
   */
  readFeaturesFromNode(e, t) {
    if (!fe.includes(e.namespaceURI))
      return [];
    let n;
    const r = e.localName;
    if (r == "Document" || r == "Folder")
      return n = this.readDocumentOrFolder_(e, [
        this.getReadOptions(e, t)
      ]), n || [];
    if (r == "Placemark") {
      const s = this.readPlacemark_(e, [
        this.getReadOptions(e, t)
      ]);
      return s ? [s] : [];
    }
    if (r == "kml") {
      n = [];
      for (let s = e.firstElementChild; s; s = s.nextElementSibling) {
        const o = this.readFeaturesFromNode(s, t);
        o && ze(n, o);
      }
      return n;
    }
    return [];
  }
  /**
   * Read the name of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {string|undefined} Name.
   * @api
   */
  readName(e) {
    if (e) {
      if (typeof e == "string") {
        const t = vn(e);
        return this.readNameFromDocument(t);
      }
      return En(e) ? this.readNameFromDocument(
        /** @type {Document} */
        e
      ) : this.readNameFromNode(
        /** @type {Element} */
        e
      );
    }
  }
  /**
   * @param {Document} doc Document.
   * @return {string|undefined} Name.
   */
  readNameFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE) {
        const n = this.readNameFromNode(
          /** @type {Element} */
          t
        );
        if (n)
          return n;
      }
  }
  /**
   * @param {Element} node Node.
   * @return {string|undefined} Name.
   */
  readNameFromNode(e) {
    for (let t = e.firstElementChild; t; t = t.nextElementSibling)
      if (fe.includes(t.namespaceURI) && t.localName == "name")
        return W(t);
    for (let t = e.firstElementChild; t; t = t.nextElementSibling) {
      const n = t.localName;
      if (fe.includes(t.namespaceURI) && (n == "Document" || n == "Folder" || n == "Placemark" || n == "kml")) {
        const r = this.readNameFromNode(t);
        if (r)
          return r;
      }
    }
  }
  /**
   * Read the network links of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Network links.
   * @api
   */
  readNetworkLinks(e) {
    const t = [];
    if (typeof e == "string") {
      const n = vn(e);
      ze(t, this.readNetworkLinksFromDocument(n));
    } else En(e) ? ze(
      t,
      this.readNetworkLinksFromDocument(
        /** @type {Document} */
        e
      )
    ) : ze(
      t,
      this.readNetworkLinksFromNode(
        /** @type {Element} */
        e
      )
    );
    return t;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Network links.
   */
  readNetworkLinksFromDocument(e) {
    const t = [];
    for (let n = (
      /** @type {Node} */
      e.firstChild
    ); n; n = n.nextSibling)
      n.nodeType == Node.ELEMENT_NODE && ze(
        t,
        this.readNetworkLinksFromNode(
          /** @type {Element} */
          n
        )
      );
    return t;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Network links.
   */
  readNetworkLinksFromNode(e) {
    const t = [];
    for (let n = e.firstElementChild; n; n = n.nextElementSibling)
      if (fe.includes(n.namespaceURI) && n.localName == "NetworkLink") {
        const r = V({}, UP, n, []);
        t.push(r);
      }
    for (let n = e.firstElementChild; n; n = n.nextElementSibling) {
      const r = n.localName;
      fe.includes(n.namespaceURI) && (r == "Document" || r == "Folder" || r == "kml") && ze(t, this.readNetworkLinksFromNode(n));
    }
    return t;
  }
  /**
   * Read the regions of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Regions.
   * @api
   */
  readRegion(e) {
    const t = [];
    if (typeof e == "string") {
      const n = vn(e);
      ze(t, this.readRegionFromDocument(n));
    } else En(e) ? ze(
      t,
      this.readRegionFromDocument(
        /** @type {Document} */
        e
      )
    ) : ze(t, this.readRegionFromNode(
      /** @type {Element} */
      e
    ));
    return t;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Region.
   */
  readRegionFromDocument(e) {
    const t = [];
    for (let n = (
      /** @type {Node} */
      e.firstChild
    ); n; n = n.nextSibling)
      n.nodeType == Node.ELEMENT_NODE && ze(t, this.readRegionFromNode(
        /** @type {Element} */
        n
      ));
    return t;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Region.
   * @api
   */
  readRegionFromNode(e) {
    const t = [];
    for (let n = e.firstElementChild; n; n = n.nextElementSibling)
      if (fe.includes(n.namespaceURI) && n.localName == "Region") {
        const r = V({}, hv, n, []);
        t.push(r);
      }
    for (let n = e.firstElementChild; n; n = n.nextElementSibling) {
      const r = n.localName;
      fe.includes(n.namespaceURI) && (r == "Document" || r == "Folder" || r == "kml") && ze(t, this.readRegionFromNode(n));
    }
    return t;
  }
  /**
   * @typedef {Object} KMLCamera Specifies the observer's viewpoint and associated view parameters.
   * @property {number} [Latitude] Latitude of the camera.
   * @property {number} [Longitude] Longitude of the camera.
   * @property {number} [Altitude] Altitude of the camera.
   * @property {string} [AltitudeMode] Floor-related altitude mode.
   * @property {number} [Heading] Horizontal camera rotation.
   * @property {number} [Tilt] Lateral camera rotation.
   * @property {number} [Roll] Vertical camera rotation.
   */
  /**
   * Read the cameras of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<KMLCamera>} Cameras.
   * @api
   */
  readCamera(e) {
    const t = [];
    if (typeof e == "string") {
      const n = vn(e);
      ze(t, this.readCameraFromDocument(n));
    } else En(e) ? ze(
      t,
      this.readCameraFromDocument(
        /** @type {Document} */
        e
      )
    ) : ze(t, this.readCameraFromNode(
      /** @type {Element} */
      e
    ));
    return t;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<KMLCamera>} Cameras.
   */
  readCameraFromDocument(e) {
    const t = [];
    for (let n = (
      /** @type {Node} */
      e.firstChild
    ); n; n = n.nextSibling)
      n.nodeType === Node.ELEMENT_NODE && ze(t, this.readCameraFromNode(
        /** @type {Element} */
        n
      ));
    return t;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<KMLCamera>} Cameras.
   * @api
   */
  readCameraFromNode(e) {
    const t = [];
    for (let n = e.firstElementChild; n; n = n.nextElementSibling)
      if (fe.includes(n.namespaceURI) && n.localName === "Camera") {
        const r = V({}, BP, n, []);
        t.push(r);
      }
    for (let n = e.firstElementChild; n; n = n.nextElementSibling) {
      const r = n.localName;
      fe.includes(n.namespaceURI) && (r === "Document" || r === "Folder" || r === "Placemark" || r === "kml") && ze(t, this.readCameraFromNode(n));
    }
    return t;
  }
  /**
   * Encode an array of features in the KML format as an XML node. GeometryCollections,
   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.
   *
   * @param {Array<Feature>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   * @override
   */
  writeFeaturesNode(e, t) {
    t = this.adaptOptions(t);
    const n = be(fe[4], "kml"), r = "http://www.w3.org/2000/xmlns/";
    n.setAttributeNS(r, "xmlns:gx", Vr[0]), n.setAttributeNS(r, "xmlns:xsi", ho), n.setAttributeNS(
      ho,
      "xsi:schemaLocation",
      GP
    );
    const s = {
      node: n
    }, o = {};
    e.length > 1 ? o.Document = e : e.length == 1 && (o.Placemark = e[0]);
    const a = $P[n.namespaceURI], l = Vi(o, a);
    return we(
      s,
      jP,
      ai,
      l,
      [t],
      a,
      this
    ), n;
  }
}
function YP(i, e) {
  const t = [0, 0];
  let n = "start";
  const r = i.getImage();
  if (r) {
    const a = r.getSize();
    if (a && a.length == 2) {
      const l = r.getScaleArray(), h = r.getAnchor();
      t[0] = l[0] * (a[0] - h[0]), t[1] = l[1] * (a[1] / 2 - h[1]), n = "left";
    }
  }
  let s = i.getText();
  return s ? (s = s.clone(), s.setFont(s.getFont() || Zs.getFont()), s.setScale(s.getScale() || Zs.getScale()), s.setFill(s.getFill() || Zs.getFill()), s.setStroke(s.getStroke() || Xg)) : s = Zs.clone(), s.setText(e), s.setOffsetX(t[0]), s.setOffsetY(t[1]), s.setTextAlign(n), new Mt({
    image: r,
    text: s
  });
}
function qP(i, e, t, n, r) {
  return (
    /**
     * @param {Feature} feature feature.
     * @param {number} resolution Resolution.
     * @return {Array<Style>|Style} Style.
     */
    (function(s, o) {
      let a = r, l = "", h = [];
      if (a) {
        const c = s.getGeometry();
        if (c)
          if (c instanceof Qt)
            h = c.getGeometriesArrayRecursive().filter(function(f) {
              const g = f.getType();
              return g === "Point" || g === "MultiPoint";
            }), a = h.length > 0;
          else {
            const f = c.getType();
            a = f === "Point" || f === "MultiPoint";
          }
      }
      a && (l = /** @type {string} */
      s.get("name"), a = a && !!l, a && /&[^&]+;/.test(l) && (uu || (uu = document.createElement("textarea")), uu.innerHTML = l, l = uu.value));
      let u = t;
      if (i ? u = i : e && (u = uv(e, t, n)), a) {
        const c = YP(u[0], l);
        if (h.length > 0) {
          c.setGeometry(new Qt(h));
          const f = new Mt({
            geometry: u[0].getGeometry(),
            image: null,
            fill: u[0].getFill(),
            stroke: u[0].getStroke(),
            text: null
          });
          return [c, f].concat(u.slice(1));
        }
        return c;
      }
      return u;
    })
  );
}
function uv(i, e, t) {
  return Array.isArray(i) ? i : typeof i == "string" ? uv(t[i], e, t) : e;
}
function Af(i) {
  const e = Mi(i, !1), t = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(e);
  if (t) {
    const n = t[1];
    return [
      parseInt(n.substr(6, 2), 16),
      parseInt(n.substr(4, 2), 16),
      parseInt(n.substr(2, 2), 16),
      parseInt(n.substr(0, 2), 16) / 255
    ];
  }
}
function cv(i) {
  let e = Mi(i, !1);
  const t = [];
  e = e.replace(/\s*,\s*/g, ",");
  const n = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
  let r;
  for (; r = n.exec(e); ) {
    const s = parseFloat(r[1]), o = parseFloat(r[2]), a = r[3] ? parseFloat(r[3]) : 0;
    t.push(s, o, a), e = e.substr(r[0].length);
  }
  if (e === "")
    return t;
}
function fv(i) {
  const e = Mi(i, !1).trim();
  let t = i.baseURI;
  return (!t || t == "about:blank") && (t = window.location.href), t ? new URL(e, t).href : e;
}
function dv(i) {
  const e = Mi(i, !1).trim().replace(/^(?!.*#)/, "#");
  let t = i.baseURI;
  return (!t || t == "about:blank") && (t = window.location.href), t ? new URL(e, t).href : e;
}
function ZP(i) {
  const e = i.getAttribute("xunits"), t = i.getAttribute("yunits");
  let n;
  return e !== "insetPixels" ? t !== "insetPixels" ? n = "bottom-left" : n = "top-left" : t !== "insetPixels" ? n = "bottom-right" : n = "top-right", {
    x: parseFloat(i.getAttribute("x")),
    xunits: oy[e],
    y: parseFloat(i.getAttribute("y")),
    yunits: oy[t],
    origin: n
  };
}
function gv(i) {
  return De(i);
}
const HP = j(fe, {
  Pair: EM
});
function pv(i, e) {
  return V(void 0, HP, i, e, this);
}
const KP = j(fe, {
  Icon: F(cM),
  color: F(Af),
  heading: F(De),
  hotSpot: F(ZP),
  scale: F(gv)
});
function JP(i, e) {
  const t = V({}, KP, i, e);
  if (!t)
    return;
  const n = (
    /** @type {Object} */
    e[e.length - 1]
  ), r = "Icon" in t ? t.Icon : {}, s = !("Icon" in t) || Object.keys(r).length > 0;
  let o;
  const a = (
    /** @type {string|undefined} */
    r.href
  );
  a ? o = a : s && (o = yc);
  let l, h, u, c = "bottom-left";
  const f = (
    /** @type {Vec2|undefined} */
    t.hotSpot
  );
  f ? (l = [f.x, f.y], h = f.xunits, u = f.yunits, c = f.origin) : /^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(o) && (o.includes("pushpin") ? (l = Bg, h = Al, u = Il) : o.includes("arrow-reverse") ? (l = [54, 42], h = Al, u = Il) : o.includes("paddle") && (l = [32, 1], h = Al, u = Il));
  let g;
  const d = (
    /** @type {number|undefined} */
    r.x
  ), m = (
    /** @type {number|undefined} */
    r.y
  );
  d !== void 0 && m !== void 0 && (g = [d, m]);
  let x;
  const v = (
    /** @type {number|undefined} */
    r.w
  ), p = (
    /** @type {number|undefined} */
    r.h
  );
  v !== void 0 && p !== void 0 && (x = [v, p]);
  let y;
  const E = (
    /** @type {number} */
    t.heading
  );
  E !== void 0 && (y = Fr(E));
  const b = (
    /** @type {number|undefined} */
    t.scale
  ), T = (
    /** @type {Array<number>|undefined} */
    t.color
  );
  if (s) {
    o == yc && (x = Ll);
    const R = new Ts({
      anchor: l,
      anchorOrigin: c,
      anchorXUnits: h,
      anchorYUnits: u,
      crossOrigin: this.crossOrigin_,
      offset: g,
      offsetOrigin: "bottom-left",
      rotation: y,
      scale: b,
      size: x,
      src: this.iconUrlFunction_(o),
      color: T
    }), M = R.getScaleArray()[0], C = R.getSize();
    if (C === null) {
      const I = R.getImageState();
      if (I === se.IDLE || I === se.LOADING) {
        const O = function() {
          const z = R.getImageState();
          if (!(z === se.IDLE || z === se.LOADING)) {
            const _ = R.getSize();
            if (_ && _.length == 2) {
              const w = xc(_);
              R.setScale(M * w);
            }
            R.unlistenImageChange(O);
          }
        };
        R.listenImageChange(O), I === se.IDLE && R.load();
      }
    } else if (C.length == 2) {
      const I = xc(C);
      R.setScale(M * I);
    }
    n.imageStyle = R;
  } else
    n.imageStyle = Rm;
}
const QP = j(fe, {
  color: F(Af),
  scale: F(gv)
});
function eM(i, e) {
  const t = V({}, QP, i, e);
  if (!t)
    return;
  const n = e[e.length - 1], r = new Rs({
    fill: new gi({
      color: (
        /** @type {import("../color.js").Color} */
        "color" in t ? t.color : oa
      )
    }),
    scale: (
      /** @type {number|undefined} */
      t.scale
    )
  });
  n.textStyle = r;
}
const tM = j(fe, {
  color: F(Af),
  width: F(De)
});
function iM(i, e) {
  const t = V({}, tM, i, e);
  if (!t)
    return;
  const n = e[e.length - 1], r = new Ri({
    color: (
      /** @type {import("../color.js").Color} */
      "color" in t ? t.color : oa
    ),
    width: (
      /** @type {number} */
      "width" in t ? t.width : 1
    )
  });
  n.strokeStyle = r;
}
const nM = j(fe, {
  color: F(Af),
  fill: F(Ss),
  outline: F(Ss)
});
function rM(i, e) {
  const t = V({}, nM, i, e);
  if (!t)
    return;
  const n = e[e.length - 1], r = new gi({
    color: (
      /** @type {import("../color.js").Color} */
      "color" in t ? t.color : oa
    )
  });
  n.fillStyle = r;
  const s = (
    /** @type {boolean|undefined} */
    t.fill
  );
  s !== void 0 && (n.fill = s);
  const o = (
    /** @type {boolean|undefined} */
    t.outline
  );
  o !== void 0 && (n.outline = o);
}
const sM = j(fe, {
  coordinates: ge(cv)
});
function mv(i, e) {
  return V(null, sM, i, e);
}
function oM(i, e) {
  const n = /** @type {GxTrackObject} */ e[e.length - 1].coordinates, r = Mi(i, !1), o = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(r);
  if (o) {
    const a = parseFloat(o[1]), l = parseFloat(o[2]), h = parseFloat(o[3]);
    n.push([a, l, h]);
  } else
    n.push([]);
}
const aM = j(Vr, {
  Track: ue(_v)
});
function lM(i, e) {
  const t = V(
    [],
    aM,
    i,
    e
  );
  if (t)
    return new Xi(t);
}
const hM = j(
  fe,
  {
    when: OM
  },
  j(Vr, {
    coord: oM
  })
);
function _v(i, e) {
  const t = V(
    /** @type {GxTrackObject} */
    {
      coordinates: [],
      whens: []
    },
    hM,
    i,
    e
  );
  if (!t)
    return;
  const n = [], r = t.coordinates, s = t.whens;
  for (let o = 0, a = Math.min(r.length, s.length); o < a; ++o)
    r[o].length == 3 && n.push(
      r[o][0],
      r[o][1],
      r[o][2],
      s[o]
    );
  return new Wt(n, "XYZM");
}
const uM = j(
  fe,
  {
    href: F(fv)
  },
  j(Vr, {
    x: F(De),
    y: F(De),
    w: F(De),
    h: F(De)
  })
);
function cM(i, e) {
  const t = V({}, uM, i, e);
  return t || null;
}
const fM = j(fe, {
  coordinates: ge(cv)
});
function Pm(i, e) {
  return V(
    null,
    fM,
    i,
    e
  );
}
const If = j(fe, {
  extrude: F(Ss),
  tessellate: F(Ss),
  altitudeMode: F(W)
});
function yv(i, e) {
  const t = V(
    {},
    If,
    i,
    e
  ), n = Pm(i, e);
  if (n) {
    const r = new Wt(n, "XYZ");
    return r.setProperties(t, !0), r;
  }
}
function xv(i, e) {
  const t = V(
    {},
    If,
    i,
    e
  ), n = Pm(i, e);
  if (n) {
    const r = new ei(n, "XYZ", [
      n.length
    ]);
    return r.setProperties(t, !0), r;
  }
}
const dM = j(fe, {
  LineString: ue(yv),
  LinearRing: ue(xv),
  MultiGeometry: ue(Ev),
  Point: ue(vv),
  Polygon: ue(wv)
});
function Ev(i, e) {
  const t = V(
    [],
    dM,
    i,
    e
  );
  if (!t)
    return null;
  if (t.length === 0)
    return new Qt(t);
  let n, r = !0;
  const s = t[0].getType();
  let o;
  for (let a = 1, l = t.length; a < l; ++a)
    if (o = t[a], o.getType() != s) {
      r = !1;
      break;
    }
  if (r) {
    let a, l;
    if (s == "Point") {
      const h = t[0];
      a = h.getLayout(), l = h.getFlatCoordinates();
      for (let u = 1, c = t.length; u < c; ++u)
        o = t[u], ze(l, o.getFlatCoordinates());
      n = new Zn(l, a), Id(n, t);
    } else if (s == "LineString")
      n = new Xi(t), Id(n, t);
    else if (s == "Polygon")
      n = new Cn(t), Id(n, t);
    else if (s == "GeometryCollection" || s.startsWith("Multi"))
      n = new Qt(t);
    else
      throw new Error("Unknown geometry type found");
  } else
    n = new Qt(t);
  return (
    /** @type {import("../geom/Geometry.js").default} */
    n
  );
}
function vv(i, e) {
  const t = V(
    {},
    If,
    i,
    e
  ), n = Pm(i, e);
  if (n) {
    const r = new Jt(n, "XYZ");
    return r.setProperties(t, !0), r;
  }
}
const gM = j(fe, {
  innerBoundaryIs: AM,
  outerBoundaryIs: LM
});
function wv(i, e) {
  const t = V(
    /** @type {Object<string,*>} */
    {},
    If,
    i,
    e
  ), n = V(
    [null],
    gM,
    i,
    e
  );
  if (n && n[0]) {
    const r = n[0], s = [r.length];
    for (let a = 1, l = n.length; a < l; ++a)
      ze(r, n[a]), s.push(r.length);
    const o = new ei(r, "XYZ", s);
    return o.setProperties(t, !0), o;
  }
}
const pM = j(fe, {
  IconStyle: JP,
  LabelStyle: eM,
  LineStyle: iM,
  PolyStyle: rM
});
function Mm(i, e) {
  const t = V(
    {},
    pM,
    i,
    e,
    this
  );
  if (!t)
    return null;
  let n = (
    /** @type {Fill} */
    "fillStyle" in t ? t.fillStyle : $u
  );
  const r = (
    /** @type {boolean|undefined} */
    t.fill
  );
  r !== void 0 && !r && (n = null);
  let s;
  "imageStyle" in t ? t.imageStyle != Rm && (s = /** @type {import("../style/Image.js").default} */
  t.imageStyle) : s = $g;
  const o = (
    /** @type {Text} */
    "textStyle" in t ? t.textStyle : Zs
  ), a = (
    /** @type {Stroke} */
    "strokeStyle" in t ? t.strokeStyle : jg
  ), l = (
    /** @type {boolean|undefined} */
    t.outline
  );
  return l !== void 0 && !l ? [
    new Mt({
      geometry: function(h) {
        const u = h.getGeometry(), c = u.getType();
        if (c === "GeometryCollection") {
          const f = (
            /** @type {import("../geom/GeometryCollection").default} */
            u
          );
          return new Qt(
            f.getGeometriesArrayRecursive().filter(function(g) {
              const d = g.getType();
              return d !== "Polygon" && d !== "MultiPolygon";
            })
          );
        }
        if (c !== "Polygon" && c !== "MultiPolygon")
          return u;
      },
      fill: n,
      image: s,
      stroke: a,
      text: o,
      zIndex: void 0
      // FIXME
    }),
    new Mt({
      geometry: function(h) {
        const u = h.getGeometry(), c = u.getType();
        if (c === "GeometryCollection") {
          const f = (
            /** @type {import("../geom/GeometryCollection").default} */
            u
          );
          return new Qt(
            f.getGeometriesArrayRecursive().filter(function(g) {
              const d = g.getType();
              return d === "Polygon" || d === "MultiPolygon";
            })
          );
        }
        if (c === "Polygon" || c === "MultiPolygon")
          return u;
      },
      fill: n,
      stroke: null,
      zIndex: void 0
      // FIXME
    })
  ] : [
    new Mt({
      fill: n,
      image: s,
      stroke: a,
      text: o,
      zIndex: void 0
      // FIXME
    })
  ];
}
function Id(i, e) {
  const t = e.length, n = new Array(e.length), r = new Array(e.length), s = new Array(e.length);
  let o, a, l;
  o = !1, a = !1, l = !1;
  for (let h = 0; h < t; ++h) {
    const u = e[h];
    n[h] = u.get("extrude"), r[h] = u.get("tessellate"), s[h] = u.get("altitudeMode"), o = o || n[h] !== void 0, a = a || r[h] !== void 0, l = l || s[h];
  }
  o && i.set("extrude", n), a && i.set("tessellate", r), l && i.set("altitudeMode", s);
}
const mM = j(fe, {
  displayName: F(W),
  value: F(W)
});
function _M(i, e) {
  const t = i.getAttribute("name");
  ji(mM, i, e);
  const n = (
    /** @type {Object} */
    e[e.length - 1]
  );
  t && n.displayName ? n[t] = {
    value: n.value,
    displayName: n.displayName,
    toString: function() {
      return n.value;
    }
  } : t !== null ? n[t] = n.value : n.displayName !== null && (n[n.displayName] = n.value), delete n.value;
}
const yM = j(fe, {
  Data: _M,
  SchemaData: bM
});
function bv(i, e) {
  ji(yM, i, e);
}
function Sv(i, e) {
  ji(hv, i, e);
}
const xM = j(fe, {
  Style: F(Mm),
  key: F(W),
  styleUrl: F(dv)
});
function EM(i, e) {
  const t = V({}, xM, i, e, this);
  if (!t)
    return;
  const n = (
    /** @type {string|undefined} */
    t.key
  );
  if (n && n == "normal") {
    const r = (
      /** @type {string|undefined} */
      t.styleUrl
    );
    r && (e[e.length - 1] = r);
    const s = (
      /** @type {Style} */
      t.Style
    );
    s && (e[e.length - 1] = s);
  }
}
function vM(i, e) {
  const t = pv.call(this, i, e);
  if (!t)
    return;
  const n = e[e.length - 1];
  if (Array.isArray(t))
    n.Style = t;
  else if (typeof t == "string")
    n.styleUrl = t;
  else
    throw new Error("`styleMapValue` has an unknown type");
}
const wM = j(fe, {
  SimpleData: SM
});
function bM(i, e) {
  ji(wM, i, e);
}
function SM(i, e) {
  const t = i.getAttribute("name");
  if (t !== null) {
    const n = W(i), r = (
      /** @type {Object} */
      e[e.length - 1]
    );
    r[t] = n;
  }
}
const TM = j(fe, {
  altitudeMode: F(W),
  minAltitude: F(De),
  maxAltitude: F(De),
  north: F(De),
  south: F(De),
  east: F(De),
  west: F(De)
});
function RM(i, e) {
  const t = V(
    {},
    TM,
    i,
    e
  );
  if (!t)
    return;
  const n = (
    /** @type {Object} */
    e[e.length - 1]
  ), r = [
    parseFloat(t.west),
    parseFloat(t.south),
    parseFloat(t.east),
    parseFloat(t.north)
  ];
  n.extent = r, n.altitudeMode = t.altitudeMode, n.minAltitude = parseFloat(t.minAltitude), n.maxAltitude = parseFloat(t.maxAltitude);
}
const PM = j(fe, {
  minLodPixels: F(De),
  maxLodPixels: F(De),
  minFadeExtent: F(De),
  maxFadeExtent: F(De)
});
function MM(i, e) {
  const t = V({}, PM, i, e);
  if (!t)
    return;
  const n = (
    /** @type {Object} */
    e[e.length - 1]
  );
  n.minLodPixels = parseFloat(t.minLodPixels), n.maxLodPixels = parseFloat(t.maxLodPixels), n.minFadeExtent = parseFloat(t.minFadeExtent), n.maxFadeExtent = parseFloat(t.maxFadeExtent);
}
const CM = j(fe, {
  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth
  // allows multiple, so we parse multiple here too.
  LinearRing: ue(mv)
});
function AM(i, e) {
  const t = V(
    /** @type {Array<Array<number>>} */
    [],
    CM,
    i,
    e
  );
  t.length > 0 && /** @type {Array<Array<number>>} */
  e[e.length - 1].push(...t);
}
const IM = j(fe, {
  LinearRing: ge(mv)
});
function LM(i, e) {
  const t = V(
    void 0,
    IM,
    i,
    e
  );
  if (t) {
    const n = (
      /** @type {Array<Array<number>>} */
      e[e.length - 1]
    );
    n[0] = t;
  }
}
function FM(i, e) {
  ji(zP, i, e);
}
function OM(i, e) {
  const n = /** @type {GxTrackObject} */ e[e.length - 1].whens, r = Mi(i, !1), s = Date.parse(r);
  n.push(isNaN(s) ? 0 : s);
}
function Lf(i, e) {
  const t = An(e), r = [(t.length == 4 ? t[3] : 1) * 255, t[2], t[1], t[0]];
  for (let s = 0; s < 4; ++s) {
    const o = Math.floor(
      /** @type {number} */
      r[s]
    ).toString(16);
    r[s] = o.length == 1 ? "0" + o : o;
  }
  ye(i, r.join(""));
}
function NM(i, e, t) {
  const n = t[t.length - 1], r = n.layout, s = n.stride;
  let o;
  if (r == "XY" || r == "XYM")
    o = 2;
  else if (r == "XYZ" || r == "XYZM")
    o = 3;
  else
    throw new Error("Invalid geometry layout");
  const a = e.length;
  let l = "";
  if (a > 0) {
    l += e[0];
    for (let h = 1; h < o; ++h)
      l += "," + e[h];
    for (let h = s; h < a; h += s) {
      l += " " + e[h];
      for (let u = 1; u < o; ++u)
        l += "," + e[h + u];
    }
  }
  ye(i, l);
}
const ju = j(fe, {
  Data: N(DM),
  value: N(kM),
  displayName: N(GM)
});
function DM(i, e, t) {
  i.setAttribute("name", e.name);
  const n = { node: i }, r = e.value;
  typeof r == "object" ? (r !== null && r.displayName && we(
    n,
    ju,
    ai,
    [r.displayName],
    t,
    ["displayName"]
  ), r !== null && r.value && we(
    n,
    ju,
    ai,
    [r.value],
    t,
    ["value"]
  )) : we(
    n,
    ju,
    ai,
    [r],
    t,
    ["value"]
  );
}
function GM(i, e) {
  ye(i, e);
}
function kM(i, e) {
  ye(i, e);
}
const UM = j(fe, {
  Placemark: N(Pv)
}), zM = function(i, e, t) {
  const n = e[e.length - 1].node;
  return be(n.namespaceURI, "Placemark");
};
function BM(i, e, t) {
  we(
    { node: i },
    UM,
    zM,
    e,
    t,
    void 0,
    this
  );
}
const $M = At("Data");
function jM(i, e, t) {
  const n = { node: i }, r = e.names, s = e.values, o = r.length;
  for (let a = 0; a < o; a++)
    we(
      n,
      ju,
      $M,
      [{ name: r[a], value: s[a] }],
      t
    );
}
const ly = j(
  fe,
  ["href"],
  j(Vr, ["x", "y", "w", "h"])
), hy = j(
  fe,
  {
    href: N(ye)
  },
  j(Vr, {
    x: N(Ni),
    y: N(Ni),
    w: N(Ni),
    h: N(Ni)
  })
), XM = function(i, e, t) {
  return be(Vr[0], "gx:" + t);
};
function VM(i, e, t) {
  const n = { node: i }, r = t[t.length - 1].node;
  let s = ly[r.namespaceURI], o = Vi(e, s);
  we(
    n,
    hy,
    ai,
    o,
    t,
    s
  ), s = ly[Vr[0]], o = Vi(e, s), we(
    n,
    hy,
    XM,
    o,
    t,
    s
  );
}
const WM = j(fe, [
  "scale",
  "heading",
  "Icon",
  "color",
  "hotSpot"
]), YM = j(fe, {
  Icon: N(VM),
  color: N(Lf),
  heading: N(Ni),
  hotSpot: N(EC),
  scale: N(Cv)
});
function qM(i, e, t) {
  const n = { node: i }, r = {}, s = e.getSrc(), o = e.getSize(), a = e.getImageSize(), l = {
    href: s
  };
  if (o) {
    l.w = o[0], l.h = o[1];
    const x = e.getAnchor(), v = e.getOrigin();
    if (v && a && v[0] !== 0 && v[1] !== o[1] && (l.x = v[0], l.y = a[1] - (v[1] + o[1])), x && (x[0] !== o[0] / 2 || x[1] !== o[1] / 2)) {
      const p = {
        x: x[0],
        xunits: "pixels",
        y: o[1] - x[1],
        yunits: "pixels"
      };
      r.hotSpot = p;
    }
  }
  r.Icon = l;
  let h = e.getScaleArray()[0], u = o;
  if (u === null && (u = Ll), u.length == 2) {
    const x = xc(u);
    h = h / x;
  }
  h !== 1 && (r.scale = h);
  const c = e.getRotation();
  c !== 0 && (r.heading = c);
  const f = e.getColor();
  f && (r.color = f);
  const g = t[t.length - 1].node, d = WM[g.namespaceURI], m = Vi(r, d);
  we(
    n,
    YM,
    ai,
    m,
    t,
    d
  );
}
const ZM = j(fe, [
  "color",
  "scale"
]), HM = j(fe, {
  color: N(Lf),
  scale: N(Cv)
});
function KM(i, e, t) {
  const n = { node: i }, r = {}, s = e.getFill();
  s && (r.color = s.getColor());
  const o = e.getScale();
  o && o !== 1 && (r.scale = o);
  const a = t[t.length - 1].node, l = ZM[a.namespaceURI], h = Vi(r, l);
  we(
    n,
    HM,
    ai,
    h,
    t,
    l
  );
}
const JM = j(fe, ["color", "width"]), QM = j(fe, {
  color: N(Lf),
  width: N(Ni)
});
function eC(i, e, t) {
  const n = { node: i }, r = {
    color: e.getColor(),
    width: Number(e.getWidth()) || 1
  }, s = t[t.length - 1].node, o = JM[s.namespaceURI], a = Vi(r, o);
  we(
    n,
    QM,
    ai,
    a,
    t,
    o
  );
}
const tC = {
  Point: "Point",
  LineString: "LineString",
  LinearRing: "LinearRing",
  Polygon: "Polygon",
  MultiPoint: "MultiGeometry",
  MultiLineString: "MultiGeometry",
  MultiPolygon: "MultiGeometry",
  GeometryCollection: "MultiGeometry"
}, Tv = function(i, e, t) {
  if (i) {
    const n = e[e.length - 1].node;
    return be(
      n.namespaceURI,
      tC[
        /** @type {import("../geom/Geometry.js").default} */
        i.getType()
      ]
    );
  }
}, iC = At("Point"), nC = At("LineString"), rC = At("LinearRing"), sC = At("Polygon"), oC = j(fe, {
  LineString: N(aa),
  Point: N(aa),
  Polygon: N(Mv),
  GeometryCollection: N(Rv)
});
function Rv(i, e, t) {
  const n = { node: i }, r = e.getType();
  let s = [], o;
  if (r === "GeometryCollection")
    e.getGeometriesArrayRecursive().forEach(function(a) {
      const l = a.getType();
      if (l === "MultiPoint")
        s = s.concat(
          /** @type {MultiPoint} */
          a.getPoints()
        );
      else if (l === "MultiLineString")
        s = s.concat(
          /** @type {MultiLineString} */
          a.getLineStrings()
        );
      else if (l === "MultiPolygon")
        s = s.concat(
          /** @type {MultiPolygon} */
          a.getPolygons()
        );
      else if (l === "Point" || l === "LineString" || l === "Polygon")
        s.push(a);
      else
        throw new Error("Unknown geometry type");
    }), o = Tv;
  else if (r === "MultiPoint")
    s = /** @type {MultiPoint} */
    e.getPoints(), o = iC;
  else if (r === "MultiLineString")
    s = /** @type {MultiLineString} */
    e.getLineStrings(), o = nC;
  else if (r === "MultiPolygon")
    s = /** @type {MultiPolygon} */
    e.getPolygons(), o = sC;
  else
    throw new Error("Unknown geometry type");
  we(
    n,
    oC,
    o,
    s,
    t
  );
}
const aC = j(fe, {
  LinearRing: N(aa)
});
function uy(i, e, t) {
  we(
    { node: i },
    aC,
    rC,
    [e],
    t
  );
}
const Ld = j(fe, {
  ExtendedData: N(jM),
  MultiGeometry: N(Rv),
  LineString: N(aa),
  LinearRing: N(aa),
  Point: N(aa),
  Polygon: N(Mv),
  Style: N(xC),
  address: N(ye),
  description: N(ye),
  name: N(ye),
  open: N(wa),
  phoneNumber: N(ye),
  styleUrl: N(ye),
  visibility: N(wa)
}), lC = j(fe, [
  "name",
  "open",
  "visibility",
  "address",
  "phoneNumber",
  "description",
  "styleUrl",
  "Style"
]), hC = At("ExtendedData");
function Pv(i, e, t) {
  const n = { node: i };
  e.getId() && i.setAttribute(
    "id",
    /** @type {string} */
    e.getId()
  );
  const r = e.getProperties(), s = {
    address: 1,
    description: 1,
    name: 1,
    open: 1,
    phoneNumber: 1,
    styleUrl: 1,
    visibility: 1
  };
  s[e.getGeometryName()] = 1;
  const o = Object.keys(r || {}).sort().filter(function(g) {
    return !s[g];
  }), a = e.getStyleFunction();
  if (a) {
    const g = a(e, 0);
    if (g) {
      const d = Array.isArray(g) ? g : [g];
      let m = d;
      if (e.getGeometry() && (m = d.filter(function(x) {
        const v = x.getGeometryFunction()(e);
        if (v) {
          const p = v.getType();
          return p === "GeometryCollection" ? (
            /** @type {GeometryCollection} */
            v.getGeometriesArrayRecursive().filter(function(y) {
              const E = y.getType();
              return E === "Point" || E === "MultiPoint";
            }).length
          ) : p === "Point" || p === "MultiPoint";
        }
      })), this.writeStyles_) {
        let x = d, v = d;
        e.getGeometry() && (x = d.filter(function(p) {
          const y = p.getGeometryFunction()(e);
          if (y) {
            const E = y.getType();
            return E === "GeometryCollection" ? (
              /** @type {GeometryCollection} */
              y.getGeometriesArrayRecursive().filter(function(b) {
                const T = b.getType();
                return T === "LineString" || T === "MultiLineString";
              }).length
            ) : E === "LineString" || E === "MultiLineString";
          }
        }), v = d.filter(function(p) {
          const y = p.getGeometryFunction()(e);
          if (y) {
            const E = y.getType();
            return E === "GeometryCollection" ? (
              /** @type {GeometryCollection} */
              y.getGeometriesArrayRecursive().filter(function(b) {
                const T = b.getType();
                return T === "Polygon" || T === "MultiPolygon";
              }).length
            ) : E === "Polygon" || E === "MultiPolygon";
          }
        })), r.Style = {
          pointStyles: m,
          lineStyles: x,
          polyStyles: v
        };
      }
      if (m.length && r.name === void 0) {
        const x = m[0].getText();
        x && (r.name = x.getText());
      }
    }
  }
  const l = t[t.length - 1].node, h = lC[l.namespaceURI], u = Vi(r, h);
  if (we(
    n,
    Ld,
    ai,
    u,
    t,
    h
  ), o.length > 0) {
    const g = Vi(r, o);
    we(
      n,
      Ld,
      hC,
      [{ names: o, values: g }],
      t
    );
  }
  const c = (
    /** @type {import("./Feature.js").WriteOptions} */
    t[0]
  );
  let f = e.getGeometry();
  f && (f = xt(f, !0, c)), we(
    n,
    Ld,
    Tv,
    [f],
    t
  );
}
const uC = j(fe, [
  "extrude",
  "tessellate",
  "altitudeMode",
  "coordinates"
]), cC = j(fe, {
  extrude: N(wa),
  tessellate: N(wa),
  altitudeMode: N(ye),
  coordinates: N(NM)
});
function aa(i, e, t) {
  const n = e.getFlatCoordinates(), r = { node: i };
  r.layout = e.getLayout(), r.stride = e.getStride();
  const s = e.getProperties();
  s.coordinates = n;
  const o = t[t.length - 1].node, a = uC[o.namespaceURI], l = Vi(s, a);
  we(
    r,
    cC,
    ai,
    l,
    t,
    a
  );
}
const fC = j(fe, [
  "color",
  "fill",
  "outline"
]), cy = j(fe, {
  outerBoundaryIs: N(uy),
  innerBoundaryIs: N(uy)
}), dC = At("innerBoundaryIs"), gC = At("outerBoundaryIs");
function Mv(i, e, t) {
  const n = e.getLinearRings(), r = n.shift(), s = { node: i };
  we(
    s,
    cy,
    dC,
    n,
    t
  ), we(
    s,
    cy,
    gC,
    [r],
    t
  );
}
const pC = j(fe, {
  color: N(Lf),
  fill: N(wa),
  outline: N(wa)
});
function mC(i, e, t) {
  const n = { node: i }, r = e.getFill(), s = e.getStroke(), o = {
    color: r ? r.getColor() : void 0,
    fill: r ? void 0 : !1,
    outline: s ? void 0 : !1
  }, a = t[t.length - 1].node, l = fC[a.namespaceURI], h = Vi(o, l);
  we(
    n,
    pC,
    ai,
    h,
    t,
    l
  );
}
function Cv(i, e) {
  Ni(i, Math.round(e * 1e6) / 1e6);
}
const _C = j(fe, [
  "IconStyle",
  "LabelStyle",
  "LineStyle",
  "PolyStyle"
]), yC = j(fe, {
  IconStyle: N(qM),
  LabelStyle: N(KM),
  LineStyle: N(eC),
  PolyStyle: N(mC)
});
function xC(i, e, t) {
  const n = { node: i }, r = {};
  if (e.pointStyles.length) {
    const l = e.pointStyles[0].getText();
    l && (r.LabelStyle = l);
    const h = e.pointStyles[0].getImage();
    h && typeof /** @type {?} */
    h.getSrc == "function" && (r.IconStyle = h);
  }
  if (e.lineStyles.length) {
    const l = e.lineStyles[0].getStroke();
    l && (r.LineStyle = l);
  }
  if (e.polyStyles.length) {
    const l = e.polyStyles[0].getStroke();
    l && !r.LineStyle && (r.LineStyle = l), r.PolyStyle = e.polyStyles[0];
  }
  const s = t[t.length - 1].node, o = _C[s.namespaceURI], a = Vi(r, o);
  we(
    n,
    yC,
    ai,
    a,
    t,
    o
  );
}
function EC(i, e) {
  i.setAttribute("x", String(e.x)), i.setAttribute("y", String(e.y)), i.setAttribute("xunits", e.xunits), i.setAttribute("yunits", e.yunits);
}
class Cm {
  /**
   * Read the source document.
   *
   * @param {Document|Element|string} source The XML source.
   * @return {Object|null} An object representing the source.
   * @api
   */
  read(e) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const t = vn(e);
      return this.readFromDocument(t);
    }
    return En(e) ? this.readFromDocument(
      /** @type {Document} */
      e
    ) : this.readFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {Object|null} Object
   */
  readFromDocument(e) {
    for (let t = e.firstChild; t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readFromNode(
          /** @type {Element} */
          t
        );
    return null;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @return {Object|null} Object
   */
  readFromNode(e) {
    de();
  }
}
const vC = "http://www.w3.org/1999/xlink";
function Va(i) {
  return i.getAttributeNS(vC, "href");
}
const Yi = [null, "http://www.opengis.net/ows/1.1"], wC = j(Yi, {
  ServiceIdentification: F(WC),
  ServiceProvider: F(qC),
  OperationsMetadata: F(XC)
});
class Av extends Cm {
  constructor() {
    super();
  }
  /**
   * @param {Element} node Node.
   * @return {Object|null} Object
   * @override
   */
  readFromNode(e) {
    const t = V({}, wC, e, []);
    return t || null;
  }
}
const bC = j(Yi, {
  DeliveryPoint: F(W),
  City: F(W),
  AdministrativeArea: F(W),
  PostalCode: F(W),
  Country: F(W),
  ElectronicMailAddress: F(W)
}), SC = j(Yi, {
  Value: Ze(ZC)
}), TC = j(Yi, {
  AllowedValues: F(GC)
}), RC = j(Yi, {
  Phone: F(VC),
  Address: F(DC)
}), PC = j(Yi, {
  HTTP: F($C)
}), MC = j(Yi, {
  Get: Ze(BC),
  Post: void 0
  // TODO
}), CC = j(Yi, {
  DCP: F(zC)
}), AC = j(Yi, {
  Operation: jC
}), IC = j(Yi, {
  Voice: F(W),
  Facsimile: F(W)
}), LC = j(Yi, {
  Constraint: Ze(kC)
}), FC = j(Yi, {
  IndividualName: F(W),
  PositionName: F(W),
  ContactInfo: F(UC)
}), OC = j(Yi, {
  Abstract: F(W),
  AccessConstraints: F(W),
  Fees: F(W),
  Title: F(W),
  ServiceTypeVersion: F(W),
  ServiceType: F(W)
}), NC = j(Yi, {
  ProviderName: F(W),
  ProviderSite: F(Va),
  ServiceContact: F(YC)
});
function DC(i, e) {
  return V({}, bC, i, e);
}
function GC(i, e) {
  return V({}, SC, i, e);
}
function kC(i, e) {
  const t = i.getAttribute("name");
  if (t)
    return V({ name: t }, TC, i, e);
}
function UC(i, e) {
  return V({}, RC, i, e);
}
function zC(i, e) {
  return V({}, PC, i, e);
}
function BC(i, e) {
  const t = Va(i);
  if (t)
    return V(
      { href: t },
      LC,
      i,
      e
    );
}
function $C(i, e) {
  return V({}, MC, i, e);
}
function jC(i, e) {
  const t = i.getAttribute("name"), n = V({}, CC, i, e);
  if (!n)
    return;
  const r = (
    /** @type {Object} */
    e[e.length - 1]
  );
  r[t] = n;
}
function XC(i, e) {
  return V({}, AC, i, e);
}
function VC(i, e) {
  return V({}, IC, i, e);
}
function WC(i, e) {
  return V({}, OC, i, e);
}
function YC(i, e) {
  return V({}, FC, i, e);
}
function qC(i, e) {
  return V({}, NC, i, e);
}
function ZC(i, e) {
  return W(i);
}
function fy(i, e, t, n, r, s) {
  r !== void 0 ? (r = r, s = s !== void 0 ? s : 0) : (r = [], s = 0);
  let o = e;
  for (; o < t; ) {
    const a = i[o++];
    r[s++] = i[o++], r[s++] = a;
    for (let l = 2; l < n; ++l)
      r[s++] = i[o++];
  }
  return r.length = s, r;
}
class HC extends Em {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(e) {
    super(), e = e || {}, this.dataProjection = ee("EPSG:4326"), this.factor_ = e.factor ? e.factor : 1e5, this.geometryLayout_ = e.geometryLayout ? e.geometryLayout : "XY";
  }
  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @override
   */
  readFeatureFromText(e, t) {
    const n = this.readGeometryFromText(e, t);
    return new li(n);
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   * @override
   */
  readFeaturesFromText(e, t) {
    return [this.readFeatureFromText(e, t)];
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @override
   */
  readGeometryFromText(e, t) {
    const n = Og(this.geometryLayout_), r = JC(e, n, this.factor_);
    fy(r, 0, r.length, n, r);
    const s = new Wt(r, this.geometryLayout_);
    return xt(
      s,
      !1,
      this.adaptOptions(t)
    );
  }
  /**
   * @param {import("../Feature.js").default<LineString>} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   * @override
   */
  writeFeatureText(e, t) {
    const n = e.getGeometry();
    if (n)
      return this.writeGeometryText(n, t);
    throw new Error("Expected `feature` to have a geometry");
  }
  /**
   * @param {Array<import("../Feature.js").default<LineString>>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   * @override
   */
  writeFeaturesText(e, t) {
    return this.writeFeatureText(e[0], t);
  }
  /**
   * @param {LineString} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   * @override
   */
  writeGeometryText(e, t) {
    e = /** @type {LineString} */
    xt(e, !0, this.adaptOptions(t));
    const n = e.getFlatCoordinates(), r = e.getStride();
    return fy(n, 0, n.length, r, n), KC(n, r, this.factor_);
  }
}
function KC(i, e, t) {
  t = t || 1e5;
  const n = new Array(e).fill(0);
  for (let r = 0, s = i.length; r < s; )
    for (let o = 0; o < e; ++o, ++r) {
      const a = i[r] * t, l = a < 0 ? Math.ceil(a - 0.5) : Math.round(a), h = l - n[o];
      n[o] = l, i[r] = h;
    }
  return QC(i);
}
function JC(i, e, t) {
  t = t || 1e5;
  const n = new Array(e).fill(0), r = eA(i);
  for (let s = 0, o = r.length; s < o; )
    for (let a = 0; a < e; ++a, ++s)
      n[a] += r[s], r[s] = n[a] / t;
  return r;
}
function QC(i) {
  for (let e = 0, t = i.length; e < t; ++e) {
    const n = i[e];
    i[e] = n < 0 ? ~(n << 1) : n << 1;
  }
  return tA(i);
}
function eA(i) {
  const e = iA(i);
  for (let t = 0, n = e.length; t < n; ++t) {
    const r = e[t];
    e[t] = r & 1 ? ~(r >> 1) : r >> 1;
  }
  return e;
}
function tA(i) {
  let e = "";
  for (let t = 0, n = i.length; t < n; ++t)
    e += nA(i[t]);
  return e;
}
function iA(i) {
  const e = [];
  let t = 0, n = 0;
  for (let r = 0, s = i.length; r < s; ++r) {
    const o = i.charCodeAt(r) - 63;
    t |= (o & 31) << n, o < 32 ? (e.push(t), t = 0, n = 0) : n += 5;
  }
  return e;
}
function nA(i) {
  let e, t = "";
  for (; i >= 32; )
    e = (32 | i & 31) + 63, t += String.fromCharCode(e), i >>= 5;
  return e = i + 63, t += String.fromCharCode(e), t;
}
class rA extends gm {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.layerName_ = e.layerName, this.layers_ = e.layers ? e.layers : null, this.dataProjection = ee(
      e.dataProjection ? e.dataProjection : "EPSG:4326"
    );
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   * @override
   */
  readFeaturesFromObject(e, t) {
    if (e.type == "Topology") {
      const n = (
        /** @type {TopoJSONTopology} */
        e
      );
      let r, s = null, o = null;
      n.transform && (r = n.transform, s = r.scale, o = r.translate);
      const a = n.arcs;
      r && dA(a, s, o);
      const l = [], h = n.objects, u = this.layerName_;
      let c;
      for (const f in h)
        this.layers_ && !this.layers_.includes(f) || (h[f].type === "GeometryCollection" ? (c = /** @type {TopoJSONGeometryCollection} */
        h[f], l.push.apply(
          l,
          fA(
            c,
            a,
            s,
            o,
            u,
            f,
            t
          )
        )) : (c = /** @type {TopoJSONGeometry} */
        h[f], l.push(
          Iv(
            c,
            a,
            s,
            o,
            u,
            f,
            t
          )
        )));
      return l;
    }
    return [];
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   * @override
   */
  readProjectionFromObject(e) {
    return this.dataProjection;
  }
}
const sA = {
  Point: oA,
  LineString: lA,
  Polygon: uA,
  MultiPoint: aA,
  MultiLineString: hA,
  MultiPolygon: cA
};
function Ff(i, e) {
  const t = [];
  let n;
  for (let r = 0, s = i.length; r < s; ++r)
    if (n = i[r], r > 0 && t.pop(), n >= 0) {
      const o = e[n];
      for (let a = 0, l = o.length; a < l; ++a)
        t.push(o[a].slice(0));
    } else {
      const o = e[~n];
      for (let a = o.length - 1; a >= 0; --a)
        t.push(o[a].slice(0));
    }
  return t;
}
function oA(i, e, t) {
  const n = i.coordinates;
  return e && t && Am(n, e, t), new Jt(n);
}
function aA(i, e, t) {
  const n = i.coordinates;
  if (e && t)
    for (let r = 0, s = n.length; r < s; ++r)
      Am(n[r], e, t);
  return new Zn(n);
}
function lA(i, e) {
  const t = Ff(i.arcs, e);
  return new Wt(t);
}
function hA(i, e) {
  const t = [];
  for (let n = 0, r = i.arcs.length; n < r; ++n)
    t[n] = Ff(i.arcs[n], e);
  return new Xi(t);
}
function uA(i, e) {
  const t = [];
  for (let n = 0, r = i.arcs.length; n < r; ++n)
    t[n] = Ff(i.arcs[n], e);
  return new ei(t);
}
function cA(i, e) {
  const t = [];
  for (let n = 0, r = i.arcs.length; n < r; ++n) {
    const s = i.arcs[n], o = [];
    for (let a = 0, l = s.length; a < l; ++a)
      o[a] = Ff(s[a], e);
    t[n] = o;
  }
  return new Cn(t);
}
function fA(i, e, t, n, r, s, o) {
  const a = i.geometries, l = [];
  for (let h = 0, u = a.length; h < u; ++h)
    l[h] = Iv(
      a[h],
      e,
      t,
      n,
      r,
      s,
      o
    );
  return l;
}
function Iv(i, e, t, n, r, s, o) {
  let a = null;
  const l = i.type;
  if (l) {
    const c = sA[l];
    l === "Point" || l === "MultiPoint" ? a = c(i, t, n) : a = c(i, e), a = xt(a, !1, o);
  }
  const h = new li({ geometry: a });
  i.id !== void 0 && h.setId(i.id);
  let u = i.properties;
  return r && (u || (u = {}), u[r] = s), u && h.setProperties(u, !0), h;
}
function dA(i, e, t) {
  for (let n = 0, r = i.length; n < r; ++n)
    gA(i[n], e, t);
}
function gA(i, e, t) {
  let n = 0, r = 0;
  for (let s = 0, o = i.length; s < o; ++s) {
    const a = i[s];
    n += a[0], r += a[1], a[0] = n, a[1] = r, Am(a, e, t);
  }
}
function Am(i, e, t) {
  i[0] = i[0] * e[0] + t[0], i[1] = i[1] * e[1] + t[1];
}
class Be extends q {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(e) {
    e = e || {}, super(e), this.schemaLocation = e.schemaLocation ? e.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @override
   */
  writeGeometryElement(e, t, n) {
    const r = n[n.length - 1];
    n[n.length - 1] = Object.assign(
      { multiCurve: !0, multiSurface: !0 },
      r
    ), super.writeGeometryElement(e, t, n);
  }
}
Be.prototype.namespace = "http://www.opengis.net/gml/3.2";
Be.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    pos: ge(q.prototype.readFlatPos),
    posList: ge(q.prototype.readFlatPosList),
    coordinates: ge(Ne.prototype.readFlatCoordinates)
  }
};
Be.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    interior: q.prototype.interiorParser,
    exterior: q.prototype.exteriorParser
  }
};
Be.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Point: ge(he.prototype.readPoint),
    MultiPoint: ge(he.prototype.readMultiPoint),
    LineString: ge(he.prototype.readLineString),
    MultiLineString: ge(he.prototype.readMultiLineString),
    LinearRing: ge(he.prototype.readLinearRing),
    Polygon: ge(he.prototype.readPolygon),
    MultiPolygon: ge(he.prototype.readMultiPolygon),
    Surface: ge(Be.prototype.readSurface),
    MultiSurface: ge(q.prototype.readMultiSurface),
    Curve: ge(Be.prototype.readCurve),
    MultiCurve: ge(q.prototype.readMultiCurve),
    Envelope: ge(Be.prototype.readEnvelope)
  }
};
Be.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    curveMember: ue(q.prototype.curveMemberParser),
    curveMembers: ue(q.prototype.curveMemberParser)
  }
};
Be.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    surfaceMember: ue(q.prototype.surfaceMemberParser),
    surfaceMembers: ue(q.prototype.surfaceMemberParser)
  }
};
Be.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineString: ue(he.prototype.readLineString),
    Curve: ue(q.prototype.readCurve)
  }
};
Be.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Polygon: ue(he.prototype.readPolygon),
    Surface: ue(q.prototype.readSurface)
  }
};
Be.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    patches: ge(q.prototype.readPatch)
  }
};
Be.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    segments: ge(q.prototype.readSegment)
  }
};
Be.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    lowerCorner: ue(q.prototype.readFlatPosList),
    upperCorner: ue(q.prototype.readFlatPosList)
  }
};
Be.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    PolygonPatch: ge(q.prototype.readPolygonPatch)
  }
};
Be.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineStringSegment: dc(
      q.prototype.readLineStringSegment
    )
  }
};
Be.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    pointMember: ue(he.prototype.pointMemberParser),
    pointMembers: ue(he.prototype.pointMemberParser)
  }
};
Be.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    lineStringMember: ue(
      he.prototype.lineStringMemberParser
    ),
    lineStringMembers: ue(
      he.prototype.lineStringMemberParser
    )
  }
};
Be.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    polygonMember: ue(he.prototype.polygonMemberParser),
    polygonMembers: ue(he.prototype.polygonMemberParser)
  }
};
Be.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Point: ue(he.prototype.readFlatCoordinatesFromNode)
  }
};
Be.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineString: ue(he.prototype.readLineString)
  }
};
Be.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Polygon: ue(he.prototype.readPolygon)
  }
};
Be.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LinearRing: ge(he.prototype.readFlatLinearRing),
    Ring: ge(Be.prototype.readFlatCurveRing)
  }
};
Be.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    exterior: N(q.prototype.writeRing),
    interior: N(q.prototype.writeRing)
  }
};
Be.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    lowerCorner: N(ye),
    upperCorner: N(ye)
  }
};
Be.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    surfaceMember: N(
      q.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: N(
      q.prototype.writeSurfaceOrPolygonMember
    )
  }
};
Be.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    pointMember: N(q.prototype.writePointMember)
  }
};
Be.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    lineStringMember: N(
      q.prototype.writeLineStringOrCurveMember
    ),
    curveMember: N(
      q.prototype.writeLineStringOrCurveMember
    )
  }
};
Be.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    Curve: N(q.prototype.writeCurveOrLineString),
    MultiCurve: N(q.prototype.writeMultiCurveOrLineString),
    Point: N(Be.prototype.writePoint),
    MultiPoint: N(q.prototype.writeMultiPoint),
    LineString: N(q.prototype.writeCurveOrLineString),
    MultiLineString: N(
      q.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: N(q.prototype.writeLinearRing),
    Polygon: N(q.prototype.writeSurfaceOrPolygon),
    MultiPolygon: N(
      q.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: N(q.prototype.writeSurfaceOrPolygon),
    MultiSurface: N(
      q.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: N(q.prototype.writeEnvelope)
  }
};
class Lv {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   */
  constructor(e) {
    this.tagName_ = e;
  }
  /**
   * The XML tag name for a filter.
   * @return {!string} Name.
   */
  getTagName() {
    return this.tagName_;
  }
}
class pA extends Lv {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {Array<import("./Filter.js").default>} conditions Conditions.
   */
  constructor(e, t) {
    super(e), this.conditions = t, Te(this.conditions.length >= 2, "At least 2 conditions are required");
  }
}
class mA extends pA {
  /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */
  constructor(e) {
    super("And", Array.prototype.slice.call(arguments));
  }
}
class _A extends Lv {
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be set
   * on geometries when this is not provided.
   */
  constructor(e, t, n) {
    if (super("BBOX"), this.geometryName = e, this.extent = t, t.length !== 4)
      throw new Error(
        "Expected an extent with four values ([minX, minY, maxX, maxY])"
      );
    this.srsName = n;
  }
}
function yA(i) {
  const e = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(mA, e))();
}
function xA(i, e, t) {
  return new _A(i, e, t);
}
const dy = {
  "http://www.opengis.net/gml": {
    boundedBy: F(
      he.prototype.readExtentElement,
      "bounds"
    )
  },
  "http://www.opengis.net/wfs/2.0": {
    member: ue(he.prototype.readFeaturesInternal)
  }
}, EA = {
  "http://www.opengis.net/wfs": {
    totalInserted: F(Dt),
    totalUpdated: F(Dt),
    totalDeleted: F(Dt)
  },
  "http://www.opengis.net/wfs/2.0": {
    totalInserted: F(Dt),
    totalUpdated: F(Dt),
    totalDeleted: F(Dt)
  }
}, vA = {
  "http://www.opengis.net/wfs": {
    TransactionSummary: F(
      py,
      "transactionSummary"
    ),
    InsertResults: F(_y, "insertIds")
  },
  "http://www.opengis.net/wfs/2.0": {
    TransactionSummary: F(
      py,
      "transactionSummary"
    ),
    InsertResults: F(_y, "insertIds")
  }
}, wA = {
  "http://www.opengis.net/wfs": {
    PropertyName: N(ye)
  },
  "http://www.opengis.net/wfs/2.0": {
    PropertyName: N(ye)
  }
}, Fv = {
  "http://www.opengis.net/wfs": {
    Insert: N(yy),
    Update: N(Ey),
    Delete: N(xy),
    Property: N(vy),
    Native: N(wy)
  },
  "http://www.opengis.net/wfs/2.0": {
    Insert: N(yy),
    Update: N(Ey),
    Delete: N(xy),
    Property: N(vy),
    Native: N(wy)
  }
}, Ov = "feature", Im = "http://www.w3.org/2000/xmlns/", Lm = {
  "2.0.0": "http://www.opengis.net/ogc/1.1",
  "1.1.0": "http://www.opengis.net/ogc",
  "1.0.0": "http://www.opengis.net/ogc"
}, Wg = {
  "2.0.0": "http://www.opengis.net/wfs/2.0",
  "1.1.0": "http://www.opengis.net/wfs",
  "1.0.0": "http://www.opengis.net/wfs"
}, Fm = {
  "2.0.0": "http://www.opengis.net/fes/2.0",
  "1.1.0": "http://www.opengis.net/fes",
  "1.0.0": "http://www.opengis.net/fes"
}, gy = {
  "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
  "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
  "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
}, Om = {
  "2.0.0": Be,
  "1.1.0": q,
  "1.0.0": Ne
}, bA = "1.1.0";
class SA extends Ch {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(e) {
    super(), e = e || {}, this.version_ = e.version ? e.version : bA, this.featureType_ = e.featureType, this.featureNS_ = e.featureNS, this.gmlFormat_ = e.gmlFormat ? e.gmlFormat : new Om[this.version_](), this.schemaLocation_ = e.schemaLocation ? e.schemaLocation : gy[this.version_];
  }
  /**
   * @return {Array<string>|string|undefined} featureType
   */
  getFeatureType() {
    return this.featureType_;
  }
  /**
   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.
   */
  setFeatureType(e) {
    this.featureType_ = e;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @override
   */
  readFeaturesFromNode(e, t) {
    const n = {
      node: e
    };
    Object.assign(n, {
      featureType: this.featureType_,
      featureNS: this.featureNS_
    }), Object.assign(n, this.getReadOptions(e, t || {}));
    const r = [n];
    let s;
    this.version_ === "2.0.0" ? s = dy : s = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
    let o = V(
      [],
      s,
      e,
      r,
      this.gmlFormat_
    );
    return o || (o = []), o;
  }
  /**
   * Read transaction response of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {TransactionResponse|undefined} Transaction response.
   * @api
   */
  readTransactionResponse(e) {
    if (e) {
      if (typeof e == "string") {
        const t = vn(e);
        return this.readTransactionResponseFromDocument(t);
      }
      return En(e) ? this.readTransactionResponseFromDocument(
        /** @type {Document} */
        e
      ) : this.readTransactionResponseFromNode(
        /** @type {Element} */
        e
      );
    }
  }
  /**
   * Read feature collection metadata of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   * @api
   */
  readFeatureCollectionMetadata(e) {
    if (e) {
      if (typeof e == "string") {
        const t = vn(e);
        return this.readFeatureCollectionMetadataFromDocument(t);
      }
      return En(e) ? this.readFeatureCollectionMetadataFromDocument(
        /** @type {Document} */
        e
      ) : this.readFeatureCollectionMetadataFromNode(
        /** @type {Element} */
        e
      );
    }
  }
  /**
   * @param {Document} doc Document.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readFeatureCollectionMetadataFromNode(
          /** @type {Element} */
          t
        );
  }
  /**
   * @param {Element} node Node.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromNode(e) {
    const t = {}, n = Ir(
      e.getAttribute("numberOfFeatures")
    );
    return t.numberOfFeatures = n, V(
      /** @type {FeatureCollectionMetadata} */
      t,
      dy,
      e,
      [],
      this.gmlFormat_
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readTransactionResponseFromNode(
          /** @type {Element} */
          t
        );
  }
  /**
   * @param {Element} node Node.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromNode(e) {
    return V(
      /** @type {TransactionResponse} */
      {},
      vA,
      e,
      []
    );
  }
  /**
   * Encode format as WFS `GetFeature` and return the Node.
   *
   * @param {WriteGetFeatureOptions} options Options.
   * @return {Node} Result.
   * @api
   */
  writeGetFeature(e) {
    const t = be(Wg[this.version_], "GetFeature");
    t.setAttribute("service", "WFS"), t.setAttribute("version", this.version_), e.handle && t.setAttribute("handle", e.handle), e.outputFormat && t.setAttribute("outputFormat", e.outputFormat), e.maxFeatures !== void 0 && t.setAttribute("maxFeatures", String(e.maxFeatures)), e.resultType && t.setAttribute("resultType", e.resultType), e.startIndex !== void 0 && t.setAttribute("startIndex", String(e.startIndex)), e.count !== void 0 && t.setAttribute("count", String(e.count)), e.viewParams !== void 0 && t.setAttribute("viewParams", e.viewParams), t.setAttributeNS(
      ho,
      "xsi:schemaLocation",
      this.schemaLocation_
    );
    const n = {
      node: t
    };
    if (Object.assign(n, {
      version: this.version_,
      srsName: e.srsName,
      featureNS: e.featureNS ? e.featureNS : this.featureNS_,
      featurePrefix: e.featurePrefix,
      propertyNames: e.propertyNames ? e.propertyNames : []
    }), Te(
      Array.isArray(e.featureTypes),
      "`options.featureTypes` must be an Array"
    ), typeof e.featureTypes[0] == "string") {
      let r = e.filter;
      e.bbox && (Te(
        e.geometryName,
        "`options.geometryName` must also be provided when `options.bbox` is set"
      ), r = this.combineBboxAndFilter(
        e.geometryName,
        e.bbox,
        e.srsName,
        r
      )), Object.assign(n, {
        geometryName: e.geometryName,
        filter: r
      }), Ly(
        t,
        /** @type {!Array<string>} */
        e.featureTypes,
        [n]
      );
    } else
      e.featureTypes.forEach((r) => {
        const s = this.combineBboxAndFilter(
          r.geometryName,
          r.bbox,
          e.srsName,
          e.filter
        );
        Object.assign(n, {
          geometryName: r.geometryName,
          filter: s
        }), Ly(t, [r.name], [n]);
      });
    return t;
  }
  /**
   * Create a bbox filter and combine it with another optional filter.
   *
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   * @param {import("./filter/Filter.js").default} [filter] Filter condition.
   * @return {import("./filter/Filter.js").default} The filter.
   */
  combineBboxAndFilter(e, t, n, r) {
    const s = xA(e, t, n);
    return r ? yA(r, s) : s;
  }
  /**
   * Encode format as WFS `Transaction` and return the Node.
   *
   * @param {Array<import("../Feature.js").default>} inserts The features to insert.
   * @param {Array<import("../Feature.js").default>} updates The features to update.
   * @param {Array<import("../Feature.js").default>} deletes The features to delete.
   * @param {WriteTransactionOptions} options Write options.
   * @return {Node} Result.
   * @api
   */
  writeTransaction(e, t, n, r) {
    const s = [], o = r.version ? r.version : this.version_, a = be(Wg[o], "Transaction");
    a.setAttribute("service", "WFS"), a.setAttribute("version", o);
    let l;
    r && (l = r.gmlOptions ? r.gmlOptions : {}, r.handle && a.setAttribute("handle", r.handle)), a.setAttributeNS(
      ho,
      "xsi:schemaLocation",
      gy[o]
    );
    const h = TA(a, l, o, r);
    return e && cu("Insert", e, s, h), t && cu("Update", t, s, h), n && cu("Delete", n, s, h), r.nativeElements && cu(
      "Native",
      r.nativeElements,
      s,
      h
    ), a;
  }
  /**
   * @param {Document} doc Document.
   * @return {import("../proj/Projection.js").default} Projection.
   * @override
   */
  readProjectionFromDocument(e) {
    for (let t = e.firstChild; t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readProjectionFromNode(
          /** @type {Element} */
          t
        );
    return null;
  }
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   * @override
   */
  readProjectionFromNode(e) {
    if (e.firstElementChild && e.firstElementChild.firstElementChild) {
      e = e.firstElementChild.firstElementChild;
      for (let t = e.firstElementChild; t; t = t.nextElementSibling)
        if (!(t.childNodes.length === 0 || t.childNodes.length === 1 && t.firstChild.nodeType === 3)) {
          const n = [{}];
          return this.gmlFormat_.readGeometryElement(t, n), ee(n.pop().srsName);
        }
    }
    return null;
  }
}
function TA(i, e, t, n) {
  const r = n.featurePrefix ? n.featurePrefix : Ov;
  let s;
  return t === "1.0.0" ? s = 2 : t === "1.1.0" ? s = 3 : t === "2.0.0" && (s = 3.2), Object.assign(
    { node: i },
    {
      version: t,
      featureNS: n.featureNS,
      featureType: n.featureType,
      featurePrefix: r,
      gmlVersion: s,
      hasZ: n.hasZ,
      srsName: n.srsName
    },
    e
  );
}
function cu(i, e, t, n) {
  we(
    n,
    Fv,
    At(i),
    e,
    t
  );
}
function py(i, e) {
  return V({}, EA, i, e);
}
const RA = {
  "http://www.opengis.net/ogc": {
    FeatureId: ue(function(i, e) {
      return i.getAttribute("fid");
    })
  },
  "http://www.opengis.net/ogc/1.1": {
    FeatureId: ue(function(i, e) {
      return i.getAttribute("fid");
    })
  }
};
function my(i, e) {
  ji(RA, i, e);
}
const PA = {
  "http://www.opengis.net/wfs": {
    Feature: my
  },
  "http://www.opengis.net/wfs/2.0": {
    Feature: my
  }
};
function _y(i, e) {
  return V([], PA, i, e);
}
function yy(i, e, t) {
  const n = t[t.length - 1], r = n.featureType, s = n.featureNS, o = n.gmlVersion, a = be(s, r);
  i.appendChild(a), o === 2 ? Ne.prototype.writeFeatureElement(a, e, t) : o === 3 ? q.prototype.writeFeatureElement(a, e, t) : Be.prototype.writeFeatureElement(a, e, t);
}
function Nv(i, e, t) {
  const r = t[t.length - 1].version, s = Lm[r], o = be(s, "Filter"), a = be(s, "FeatureId");
  o.appendChild(a), a.setAttribute(
    "fid",
    /** @type {string} */
    e
  ), i.appendChild(o);
}
function Nm(i, e) {
  i = i || Ov;
  const t = i + ":";
  return e.startsWith(t) ? e : t + e;
}
function xy(i, e, t) {
  const n = t[t.length - 1];
  Te(e.getId() !== void 0, "Features must have an id set");
  const r = n.featureType, s = n.featurePrefix, o = n.featureNS, a = Nm(s, r);
  i.setAttribute("typeName", a), i.setAttributeNS(Im, "xmlns:" + s, o);
  const l = e.getId();
  l !== void 0 && Nv(i, l, t);
}
function Ey(i, e, t) {
  const n = t[t.length - 1];
  Te(e.getId() !== void 0, "Features must have an id set");
  const r = n.version, s = n.featureType, o = n.featurePrefix, a = n.featureNS, l = Nm(o, s), h = e.getGeometryName();
  i.setAttribute("typeName", l), i.setAttributeNS(Im, "xmlns:" + o, a);
  const u = e.getId();
  if (u !== void 0) {
    const c = e.getKeys(), f = [];
    for (let g = 0, d = c.length; g < d; g++) {
      const m = e.get(c[g]);
      if (m !== void 0) {
        let x = c[g];
        m && typeof /** @type {?} */
        m.getSimplifiedGeometry == "function" && (x = h), f.push({ name: x, value: m });
      }
    }
    we(
      /** @type {import("../xml.js").NodeStackItem} */
      {
        version: r,
        gmlVersion: n.gmlVersion,
        node: i,
        hasZ: n.hasZ,
        srsName: n.srsName
      },
      Fv,
      At("Property"),
      f,
      t
    ), Nv(i, u, t);
  }
}
function vy(i, e, t) {
  const n = t[t.length - 1], r = n.version, s = Wg[r], a = be(s, r === "2.0.0" ? "ValueReference" : "Name"), l = n.gmlVersion;
  if (i.appendChild(a), ye(a, e.name), e.value !== void 0 && e.value !== null) {
    const h = be(s, "Value");
    i.appendChild(h), e.value && typeof /** @type {?} */
    e.value.getSimplifiedGeometry == "function" ? l === 2 ? Ne.prototype.writeGeometryElement(h, e.value, t) : l === 3 ? q.prototype.writeGeometryElement(h, e.value, t) : Be.prototype.writeGeometryElement(h, e.value, t) : ye(h, e.value);
  }
}
function wy(i, e, t) {
  e.vendorId && i.setAttribute("vendorId", e.vendorId), e.safeToIgnore !== void 0 && i.setAttribute("safeToIgnore", String(e.safeToIgnore)), e.value !== void 0 && ye(i, e.value);
}
const Of = {
  "http://www.opengis.net/wfs": {
    Query: N(by)
  },
  "http://www.opengis.net/wfs/2.0": {
    Query: N(by)
  },
  "http://www.opengis.net/ogc": {
    During: N(Ry),
    And: N(fu),
    Or: N(fu),
    Not: N(Py),
    BBOX: N(Sy),
    Contains: N(rs),
    Intersects: N(rs),
    Within: N(rs),
    DWithin: N(Ty),
    PropertyIsEqualTo: N(dn),
    PropertyIsNotEqualTo: N(dn),
    PropertyIsLessThan: N(dn),
    PropertyIsLessThanOrEqualTo: N(dn),
    PropertyIsGreaterThan: N(dn),
    PropertyIsGreaterThanOrEqualTo: N(dn),
    PropertyIsNull: N(My),
    PropertyIsBetween: N(Cy),
    PropertyIsLike: N(Ay)
  },
  "http://www.opengis.net/fes/2.0": {
    During: N(Ry),
    And: N(fu),
    Or: N(fu),
    Not: N(Py),
    BBOX: N(Sy),
    Contains: N(rs),
    Disjoint: N(rs),
    Intersects: N(rs),
    ResourceId: N(CA),
    Within: N(rs),
    DWithin: N(Ty),
    PropertyIsEqualTo: N(dn),
    PropertyIsNotEqualTo: N(dn),
    PropertyIsLessThan: N(dn),
    PropertyIsLessThanOrEqualTo: N(dn),
    PropertyIsGreaterThan: N(dn),
    PropertyIsGreaterThanOrEqualTo: N(dn),
    PropertyIsNull: N(My),
    PropertyIsBetween: N(Cy),
    PropertyIsLike: N(Ay)
  }
};
function by(i, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), r = n.version, s = n.featurePrefix, o = n.featureNS, a = n.propertyNames, l = n.srsName;
  let h;
  s ? h = Nm(s, e) : h = e;
  let u;
  r === "2.0.0" ? u = "typeNames" : u = "typeName", i.setAttribute(u, h), l && i.setAttribute("srsName", l), o && i.setAttributeNS(Im, "xmlns:" + s, o);
  const c = (
    /** @type {import("../xml.js").NodeStackItem} */
    Object.assign({}, n)
  );
  c.node = i, we(
    c,
    wA,
    At("PropertyName"),
    a,
    t
  );
  const f = n.filter;
  if (f) {
    const g = be(Nf(r), "Filter");
    i.appendChild(g), MA(g, f, t);
  }
}
function MA(i, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), r = { node: i };
  Object.assign(r, { context: n }), we(
    r,
    Of,
    At(e.getTagName()),
    [e],
    t
  );
}
function Sy(i, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), s = n.context.version;
  n.srsName = e.srsName;
  const o = Om[s];
  Wa(s, i, e.geometryName), o.prototype.writeGeometryElement(i, e.extent, t);
}
function CA(i, e, t) {
  i.setAttribute(
    "rid",
    /** @type {string} */
    e.rid
  );
}
function rs(i, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), s = n.context.version;
  n.srsName = e.srsName;
  const o = Om[s];
  Wa(s, i, e.geometryName), o.prototype.writeGeometryElement(i, e.geometry, t);
}
function Ty(i, e, t) {
  const s = /** @type {Object} */ t[t.length - 1].context.version;
  rs(i, e, t);
  const o = be(Nf(s), "Distance");
  ye(o, e.distance.toString()), s === "2.0.0" ? o.setAttribute("uom", e.unit) : o.setAttribute("units", e.unit), i.appendChild(o);
}
function Ry(i, e, t) {
  const s = /** @type {Object} */ t[t.length - 1].context.version;
  Ec(Fm[s], "ValueReference", i, e.propertyName);
  const o = be(Nr, "TimePeriod");
  i.appendChild(o);
  const a = be(Nr, "begin");
  o.appendChild(a), Iy(a, e.begin);
  const l = be(Nr, "end");
  o.appendChild(l), Iy(l, e.end);
}
function fu(i, e, t) {
  const r = /** @type {Object} */ t[t.length - 1].context, s = { node: i };
  Object.assign(s, { context: r });
  const o = e.conditions;
  for (let a = 0, l = o.length; a < l; ++a) {
    const h = o[a];
    we(
      s,
      Of,
      At(h.getTagName()),
      [h],
      t
    );
  }
}
function Py(i, e, t) {
  const r = /** @type {Object} */ t[t.length - 1].context, s = { node: i };
  Object.assign(s, { context: r });
  const o = e.condition;
  we(
    s,
    Of,
    At(o.getTagName()),
    [o],
    t
  );
}
function dn(i, e, t) {
  const s = /** @type {Object} */ t[t.length - 1].context.version;
  e.matchCase !== void 0 && i.setAttribute("matchCase", e.matchCase.toString()), Wa(s, i, e.propertyName), vc(s, i, "" + e.expression);
}
function My(i, e, t) {
  const s = /** @type {Object} */ t[t.length - 1].context.version;
  Wa(s, i, e.propertyName);
}
function Cy(i, e, t) {
  const s = /** @type {Object} */ t[t.length - 1].context.version, o = Nf(s);
  Wa(s, i, e.propertyName);
  const a = be(o, "LowerBoundary");
  i.appendChild(a), vc(s, a, "" + e.lowerBoundary);
  const l = be(o, "UpperBoundary");
  i.appendChild(l), vc(s, l, "" + e.upperBoundary);
}
function Ay(i, e, t) {
  const s = /** @type {Object} */ t[t.length - 1].context.version;
  i.setAttribute("wildCard", e.wildCard), i.setAttribute("singleChar", e.singleChar), i.setAttribute("escapeChar", e.escapeChar), e.matchCase !== void 0 && i.setAttribute("matchCase", e.matchCase.toString()), Wa(s, i, e.propertyName), vc(s, i, "" + e.pattern);
}
function Ec(i, e, t, n) {
  const r = be(i, e);
  ye(r, n), t.appendChild(r);
}
function vc(i, e, t) {
  Ec(Nf(i), "Literal", e, t);
}
function Wa(i, e, t) {
  i === "2.0.0" ? Ec(Fm[i], "ValueReference", e, t) : Ec(Lm[i], "PropertyName", e, t);
}
function Iy(i, e) {
  const t = be(Nr, "TimeInstant");
  i.appendChild(t);
  const n = be(Nr, "timePosition");
  t.appendChild(n), ye(n, e);
}
function Ly(i, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), r = (
    /** @type {import("../xml.js").NodeStackItem} */
    Object.assign({}, n)
  );
  r.node = i, we(
    r,
    Of,
    At("Query"),
    e,
    t
  );
}
function Nf(i) {
  let e;
  return i === "2.0.0" ? e = Fm[i] : e = Lm[i], e;
}
const Ke = {
  POINT: 1,
  LINE_STRING: 2,
  POLYGON: 3,
  MULTI_POINT: 4,
  MULTI_LINE_STRING: 5,
  MULTI_POLYGON: 6,
  GEOMETRY_COLLECTION: 7,
  /*
    CIRCULAR_STRING: 8,
    COMPOUND_CURVE: 9,
    CURVE_POLYGON: 10,
  
    MULTI_CURVE: 11,
    MULTI_SURFACE: 12,
    CURVE: 13,
    SURFACE: 14,
    */
  POLYHEDRAL_SURFACE: 15,
  TIN: 16,
  TRIANGLE: 17
};
class Fy {
  /**
   * @param {DataView} view source to read
   */
  constructor(e) {
    this.view_ = e, this.pos_ = 0, this.initialized_ = !1, this.isLittleEndian_ = !1, this.hasZ_ = !1, this.hasM_ = !1, this.srid_ = null, this.layout_ = "XY";
  }
  /**
   * @return {number} value
   */
  readUint8() {
    return this.view_.getUint8(this.pos_++);
  }
  /**
   * @param {boolean} [isLittleEndian] Whether read value as little endian
   * @return {number} value
   */
  readUint32(e) {
    return this.view_.getUint32(
      (this.pos_ += 4) - 4,
      e !== void 0 ? e : this.isLittleEndian_
    );
  }
  /**
   * @param {boolean} [isLittleEndian] Whether read value as little endian
   * @return {number} value
   */
  readDouble(e) {
    return this.view_.getFloat64(
      (this.pos_ += 8) - 8,
      e !== void 0 ? e : this.isLittleEndian_
    );
  }
  /**
   * @return {import('../coordinate.js').Coordinate} coords for Point
   */
  readPoint() {
    const e = [];
    return e.push(this.readDouble()), e.push(this.readDouble()), this.hasZ_ && e.push(this.readDouble()), this.hasM_ && e.push(this.readDouble()), e;
  }
  /**
   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing
   */
  readLineString() {
    const e = this.readUint32(), t = [];
    for (let n = 0; n < e; n++)
      t.push(this.readPoint());
    return t;
  }
  /**
   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like
   */
  readPolygon() {
    const e = this.readUint32(), t = [];
    for (let n = 0; n < e; n++)
      t.push(this.readLineString());
    return t;
  }
  /**
   * @param {number} [expectedTypeId] Expected WKB Type ID
   * @return {number} WKB Type ID
   */
  readWkbHeader(e) {
    const n = this.readUint8() > 0, r = this.readUint32(n), s = Math.floor((r & 268435455) / 1e3), o = !!(r & 2147483648) || s === 1 || s === 3, a = !!(r & 1073741824) || s === 2 || s === 3, l = !!(r & 536870912), h = (r & 268435455) % 1e3, u = (
      /** @type {import("../geom/Geometry.js").GeometryLayout} */
      ["XY", o ? "Z" : "", a ? "M" : ""].join("")
    ), c = l ? this.readUint32(n) : null;
    if (e !== void 0 && e !== h)
      throw new Error("Unexpected WKB geometry type " + h);
    if (this.initialized_) {
      if (this.isLittleEndian_ !== n)
        throw new Error("Inconsistent endian");
      if (this.layout_ !== u)
        throw new Error("Inconsistent geometry layout");
      if (c && this.srid_ !== c)
        throw new Error("Inconsistent coordinate system (SRID)");
    } else
      this.isLittleEndian_ = n, this.hasZ_ = o, this.hasM_ = a, this.layout_ = u, this.srid_ = c, this.initialized_ = !0;
    return h;
  }
  /**
   * @param {number} typeId WKB Type ID
   * @return {any} values read
   */
  readWkbPayload(e) {
    switch (e) {
      case Ke.POINT:
        return this.readPoint();
      case Ke.LINE_STRING:
        return this.readLineString();
      case Ke.POLYGON:
      case Ke.TRIANGLE:
        return this.readPolygon();
      case Ke.MULTI_POINT:
        return this.readMultiPoint();
      case Ke.MULTI_LINE_STRING:
        return this.readMultiLineString();
      case Ke.MULTI_POLYGON:
      case Ke.POLYHEDRAL_SURFACE:
      case Ke.TIN:
        return this.readMultiPolygon();
      case Ke.GEOMETRY_COLLECTION:
        return this.readGeometryCollection();
      default:
        throw new Error(
          "Unsupported WKB geometry type " + e + " is found"
        );
    }
  }
  /**
   * @param {number} expectedTypeId Expected WKB Type ID
   * @return {any} values read
   */
  readWkbBlock(e) {
    return this.readWkbPayload(this.readWkbHeader(e));
  }
  /**
   * @param {Function} reader reader function for each item
   * @param {number} [expectedTypeId] Expected WKB Type ID
   * @return {any} values read
   */
  readWkbCollection(e, t) {
    const n = this.readUint32(), r = [];
    for (let s = 0; s < n; s++) {
      const o = e.call(this, t);
      o && r.push(o);
    }
    return r;
  }
  /**
   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint
   */
  readMultiPoint() {
    return this.readWkbCollection(this.readWkbBlock, Ke.POINT);
  }
  /**
   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like
   */
  readMultiLineString() {
    return this.readWkbCollection(
      this.readWkbBlock,
      Ke.LINE_STRING
    );
  }
  /**
   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like
   */
  readMultiPolygon() {
    return this.readWkbCollection(this.readWkbBlock, Ke.POLYGON);
  }
  /**
   * @return {Array<import('../geom/Geometry.js').default>} array of geometries
   */
  readGeometryCollection() {
    return this.readWkbCollection(this.readGeometry);
  }
  /**
   * @return {import('../geom/Geometry.js').default} geometry
   */
  readGeometry() {
    const e = this.readWkbHeader(), t = this.readWkbPayload(e);
    switch (e) {
      case Ke.POINT:
        return new Jt(
          /** @type {import('../coordinate.js').Coordinate} */
          t,
          this.layout_
        );
      case Ke.LINE_STRING:
        return new Wt(
          /** @type {Array<import('../coordinate.js').Coordinate>} */
          t,
          this.layout_
        );
      case Ke.POLYGON:
      case Ke.TRIANGLE:
        return new ei(
          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */
          t,
          this.layout_
        );
      case Ke.MULTI_POINT:
        return new Zn(
          /** @type {Array<import('../coordinate.js').Coordinate>} */
          t,
          this.layout_
        );
      case Ke.MULTI_LINE_STRING:
        return new Xi(
          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */
          t,
          this.layout_
        );
      case Ke.MULTI_POLYGON:
      case Ke.POLYHEDRAL_SURFACE:
      case Ke.TIN:
        return new Cn(
          /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */
          t,
          this.layout_
        );
      case Ke.GEOMETRY_COLLECTION:
        return new Qt(
          /** @type {Array<import('../geom/Geometry.js').default>} */
          t
        );
      default:
        return null;
    }
  }
  /**
   * @return {number|null} SRID in the EWKB. `null` if not defined.
   */
  getSrid() {
    return this.srid_;
  }
}
class AA {
  /**
   * @type {Object}
   * @property {string} [layout] geometryLayout
   * @property {boolean} [littleEndian=true] littleEndian
   * @property {boolean} [ewkb=true] Whether writes in EWKB format
   * @property {Object} [nodata] NoData value for each axes
   * @param {Object} opts options
   */
  constructor(e) {
    e = e || {}, this.layout_ = e.layout, this.isLittleEndian_ = e.littleEndian !== !1, this.isEWKB_ = e.ewkb !== !1, this.writeQueue_ = [], this.nodata_ = Object.assign({ X: 0, Y: 0, Z: 0, M: 0 }, e.nodata);
  }
  /**
   * @param {number} value value
   */
  writeUint8(e) {
    this.writeQueue_.push([1, e]);
  }
  /**
   * @param {number} value value
   */
  writeUint32(e) {
    this.writeQueue_.push([4, e]);
  }
  /**
   * @param {number} value value
   */
  writeDouble(e) {
    this.writeQueue_.push([8, e]);
  }
  /**
   * @param {import('../coordinate.js').Coordinate} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writePoint(e, t) {
    const n = Object.assign.apply(
      null,
      t.split("").map((r, s) => ({ [r]: e[s] }))
    );
    for (const r of this.layout_)
      this.writeDouble(
        r in n ? n[r] : this.nodata_[r]
      );
  }
  /**
   * @param {Array<import('../coordinate.js').Coordinate>} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writeLineString(e, t) {
    this.writeUint32(e.length);
    for (let n = 0; n < e.length; n++)
      this.writePoint(e[n], t);
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writePolygon(e, t) {
    this.writeUint32(e.length);
    for (let n = 0; n < e.length; n++)
      this.writeLineString(e[n], t);
  }
  /**
   * @param {number} wkbType WKB Type ID
   * @param {number} [srid] SRID
   */
  writeWkbHeader(e, t) {
    e %= 1e3, this.layout_.includes("Z") && (e += this.isEWKB_ ? 2147483648 : 1e3), this.layout_.includes("M") && (e += this.isEWKB_ ? 1073741824 : 2e3), this.isEWKB_ && Number.isInteger(t) && (e |= 536870912), this.writeUint8(this.isLittleEndian_ ? 1 : 0), this.writeUint32(e), this.isEWKB_ && Number.isInteger(t) && this.writeUint32(t);
  }
  /**
   * @param {Array<import('../coordinate.js').Coordinate>} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writeMultiPoint(e, t) {
    this.writeUint32(e.length);
    for (let n = 0; n < e.length; n++)
      this.writeWkbHeader(1), this.writePoint(e[n], t);
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writeMultiLineString(e, t) {
    this.writeUint32(e.length);
    for (let n = 0; n < e.length; n++)
      this.writeWkbHeader(2), this.writeLineString(e[n], t);
  }
  /**
   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writeMultiPolygon(e, t) {
    this.writeUint32(e.length);
    for (let n = 0; n < e.length; n++)
      this.writeWkbHeader(3), this.writePolygon(e[n], t);
  }
  /**
   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries
   */
  writeGeometryCollection(e) {
    this.writeUint32(e.length);
    for (let t = 0; t < e.length; t++)
      this.writeGeometry(e[t]);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geom geometry
   * @param {import("../geom/Geometry.js").GeometryLayout} [layout] layout
   * @return {import("../geom/Geometry.js").GeometryLayout} minimum layout made by common axes
   */
  findMinimumLayout(e, t = "XYZM") {
    const n = (r, s) => r === s ? r : r === "XYZM" ? s : s === "XYZM" ? r : "XY";
    if (e instanceof Br)
      return n(e.getLayout(), t);
    if (e instanceof Qt) {
      const r = e.getGeometriesArray();
      for (let s = 0; s < r.length && t !== "XY"; s++)
        t = this.findMinimumLayout(r[s], t);
    }
    return t;
  }
  /**
   * @param {import("../geom/Geometry.js").default} geom geometry
   * @param {number} [srid] SRID
   */
  writeGeometry(e, t) {
    const n = {
      Point: Ke.POINT,
      LineString: Ke.LINE_STRING,
      Polygon: Ke.POLYGON,
      MultiPoint: Ke.MULTI_POINT,
      MultiLineString: Ke.MULTI_LINE_STRING,
      MultiPolygon: Ke.MULTI_POLYGON,
      GeometryCollection: Ke.GEOMETRY_COLLECTION
    }, r = e.getType(), s = n[r];
    if (!s)
      throw new Error("GeometryType " + r + " is not supported");
    this.layout_ || (this.layout_ = this.findMinimumLayout(e)), this.writeWkbHeader(s, t), e instanceof Br ? {
      Point: this.writePoint,
      LineString: this.writeLineString,
      Polygon: this.writePolygon,
      MultiPoint: this.writeMultiPoint,
      MultiLineString: this.writeMultiLineString,
      MultiPolygon: this.writeMultiPolygon
    }[r].call(this, e.getCoordinates(), e.getLayout()) : e instanceof Qt && this.writeGeometryCollection(e.getGeometriesArray());
  }
  getBuffer() {
    const e = this.writeQueue_.reduce((s, o) => s + o[0], 0), t = new ArrayBuffer(e), n = new DataView(t);
    let r = 0;
    return this.writeQueue_.forEach((s) => {
      switch (s[0]) {
        case 1:
          n.setUint8(r, s[1]);
          break;
        case 4:
          n.setUint32(r, s[1], this.isLittleEndian_);
          break;
        case 8:
          n.setFloat64(r, s[1], this.isLittleEndian_);
          break;
      }
      r += s[0];
    }), t;
  }
}
class IA extends Ph {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(e) {
    super(), e = e || {}, this.splitCollection = !!e.splitCollection, this.viewCache_ = null, this.hex_ = e.hex !== !1, this.littleEndian_ = e.littleEndian !== !1, this.ewkb_ = e.ewkb !== !1, this.layout_ = e.geometryLayout, this.nodataZ_ = e.nodataZ || 0, this.nodataM_ = e.nodataM || 0, this.srid_ = e.srid;
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   * @override
   */
  getType() {
    return this.hex_ ? "text" : "arraybuffer";
  }
  /**
   * Read a single feature from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   * @override
   */
  readFeature(e, t) {
    return new li({
      geometry: this.readGeometry(e, t)
    });
  }
  /**
   * Read all features from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   * @override
   */
  readFeatures(e, t) {
    let n = [];
    const r = this.readGeometry(e, t);
    return this.splitCollection && r instanceof Qt ? n = r.getGeometriesArray() : n = [r], n.map((s) => new li({ geometry: s }));
  }
  /**
   * Read a single geometry from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   * @override
   */
  readGeometry(e, t) {
    const n = Oy(e);
    if (!n)
      return null;
    const s = new Fy(n).readGeometry();
    return this.viewCache_ = n, t = this.getReadOptions(e, t), this.viewCache_ = null, xt(s, !1, t);
  }
  /**
   * Read the projection from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   * @api
   * @override
   */
  readProjection(e) {
    const t = this.viewCache_ || Oy(e);
    if (!t)
      return;
    const n = new Fy(t);
    return n.readWkbHeader(), n.getSrid() && ee("EPSG:" + n.getSrid()) || void 0;
  }
  /**
   * Encode a feature in this format.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   * @api
   * @override
   */
  writeFeature(e, t) {
    return this.writeGeometry(e.getGeometry(), t);
  }
  /**
   * Encode an array of features in this format.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   * @api
   * @override
   */
  writeFeatures(e, t) {
    return this.writeGeometry(
      new Qt(e.map((n) => n.getGeometry())),
      t
    );
  }
  /**
   * Write a single geometry in this format.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   * @api
   * @override
   */
  writeGeometry(e, t) {
    t = this.adaptOptions(t);
    const n = new AA({
      layout: this.layout_,
      littleEndian: this.littleEndian_,
      ewkb: this.ewkb_,
      nodata: {
        Z: this.nodataZ_,
        M: this.nodataM_
      }
    });
    let r = Number.isInteger(this.srid_) ? Number(this.srid_) : null;
    if (this.srid_ !== !1 && !Number.isInteger(this.srid_)) {
      const o = t.dataProjection && ee(t.dataProjection);
      if (o) {
        const a = o.getCode();
        a.startsWith("EPSG:") && (r = Number(a.substring(5)));
      }
    }
    n.writeGeometry(
      xt(e, !0, t),
      r
    );
    const s = n.getBuffer();
    return this.hex_ ? LA(s) : s;
  }
}
function LA(i) {
  const e = new Uint8Array(i);
  return Array.from(e.values()).map((t) => (t < 16 ? "0" : "") + Number(t).toString(16).toUpperCase()).join("");
}
function FA(i) {
  const e = new Uint8Array(i.length / 2);
  for (let t = 0; t < i.length / 2; t++)
    e[t] = parseInt(i.substr(t * 2, 2), 16);
  return new DataView(e.buffer);
}
function Oy(i) {
  return typeof i == "string" ? FA(i) : ArrayBuffer.isView(i) ? i instanceof DataView ? i : new DataView(i.buffer, i.byteOffset, i.byteLength) : i instanceof ArrayBuffer ? new DataView(i) : null;
}
const OA = {
  POINT: Jt,
  LINESTRING: Wt,
  POLYGON: ei,
  MULTIPOINT: Zn,
  MULTILINESTRING: Xi,
  MULTIPOLYGON: Cn
}, Dv = "EMPTY", Gv = "Z", kv = "M", NA = "ZM", qe = {
  START: 0,
  TEXT: 1,
  LEFT_PAREN: 2,
  RIGHT_PAREN: 3,
  NUMBER: 4,
  COMMA: 5,
  EOF: 6
}, DA = {
  Point: "POINT",
  LineString: "LINESTRING",
  Polygon: "POLYGON",
  MultiPoint: "MULTIPOINT",
  MultiLineString: "MULTILINESTRING",
  MultiPolygon: "MULTIPOLYGON",
  GeometryCollection: "GEOMETRYCOLLECTION",
  Circle: "CIRCLE"
};
class GA {
  /**
   * @param {string} wkt WKT string.
   */
  constructor(e) {
    this.wkt = e, this.index_ = -1;
  }
  /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is alphabetic.
   * @private
   */
  isAlpha_(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z";
  }
  /**
   * @param {string} c Character.
   * @param {boolean} [decimal] Whether the string number
   *     contains a dot, i.e. is a decimal number.
   * @return {boolean} Whether the character is numeric.
   * @private
   */
  isNumeric_(e, t) {
    return t = t !== void 0 ? t : !1, e >= "0" && e <= "9" || e == "." && !t;
  }
  /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is whitespace.
   * @private
   */
  isWhiteSpace_(e) {
    return e == " " || e == "	" || e == "\r" || e == `
`;
  }
  /**
   * @return {string} Next string character.
   * @private
   */
  nextChar_() {
    return this.wkt.charAt(++this.index_);
  }
  /**
   * Fetch and return the next token.
   * @return {Token} Next string token.
   */
  nextToken() {
    const e = this.nextChar_(), t = this.index_;
    let n = e, r;
    if (e == "(")
      r = qe.LEFT_PAREN;
    else if (e == ",")
      r = qe.COMMA;
    else if (e == ")")
      r = qe.RIGHT_PAREN;
    else if (this.isNumeric_(e) || e == "-")
      r = qe.NUMBER, n = this.readNumber_();
    else if (this.isAlpha_(e))
      r = qe.TEXT, n = this.readText_();
    else {
      if (this.isWhiteSpace_(e))
        return this.nextToken();
      if (e === "")
        r = qe.EOF;
      else
        throw new Error("Unexpected character: " + e);
    }
    return { position: t, value: n, type: r };
  }
  /**
   * @return {number} Numeric token value.
   * @private
   */
  readNumber_() {
    let e;
    const t = this.index_;
    let n = !1, r = !1;
    do
      e == "." ? n = !0 : (e == "e" || e == "E") && (r = !0), e = this.nextChar_();
    while (this.isNumeric_(e, n) || // if we haven't detected a scientific number before, 'e' or 'E'
    // hint that we should continue to read
    !r && (e == "e" || e == "E") || // once we know that we have a scientific number, both '-' and '+'
    // are allowed
    r && (e == "-" || e == "+"));
    return parseFloat(this.wkt.substring(t, this.index_--));
  }
  /**
   * @return {string} String token value.
   * @private
   */
  readText_() {
    let e;
    const t = this.index_;
    do
      e = this.nextChar_();
    while (this.isAlpha_(e));
    return this.wkt.substring(t, this.index_--).toUpperCase();
  }
}
let kA = class {
  /**
   * @param {Lexer} lexer The lexer.
   */
  constructor(e) {
    this.lexer_ = e, this.token_ = {
      position: 0,
      type: qe.START
    }, this.layout_ = "XY";
  }
  /**
   * Fetch the next token form the lexer and replace the active token.
   * @private
   */
  consume_() {
    this.token_ = this.lexer_.nextToken();
  }
  /**
   * Tests if the given type matches the type of the current token.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */
  isTokenType(e) {
    return this.token_.type == e;
  }
  /**
   * If the given type matches the current token, consume it.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */
  match(e) {
    const t = this.isTokenType(e);
    return t && this.consume_(), t;
  }
  /**
   * Try to parse the tokens provided by the lexer.
   * @return {import("../geom/Geometry.js").default} The geometry.
   */
  parse() {
    return this.consume_(), this.parseGeometry_();
  }
  /**
   * Try to parse the dimensional info.
   * @return {import("../geom/Geometry.js").GeometryLayout} The layout.
   * @private
   */
  parseGeometryLayout_() {
    let e = "XY";
    const t = this.token_;
    if (this.isTokenType(qe.TEXT)) {
      const n = t.value;
      n === Gv ? e = "XYZ" : n === kv ? e = "XYM" : n === NA && (e = "XYZM"), e !== "XY" && this.consume_();
    }
    return e;
  }
  /**
   * @return {Array<import("../geom/Geometry.js").default>} A collection of geometries.
   * @private
   */
  parseGeometryCollectionText_() {
    if (this.match(qe.LEFT_PAREN)) {
      const e = [];
      do
        e.push(this.parseGeometry_());
      while (this.match(qe.COMMA));
      if (this.match(qe.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<number>} All values in a point.
   * @private
   */
  parsePointText_() {
    if (this.match(qe.LEFT_PAREN)) {
      const e = this.parsePoint_();
      if (this.match(qe.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<number>>} All points in a linestring.
   * @private
   */
  parseLineStringText_() {
    if (this.match(qe.LEFT_PAREN)) {
      const e = this.parsePointList_();
      if (this.match(qe.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<Array<number>>>} All points in a polygon.
   * @private
   */
  parsePolygonText_() {
    if (this.match(qe.LEFT_PAREN)) {
      const e = this.parseLineStringTextList_();
      if (this.match(qe.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<number>>} All points in a multipoint.
   * @private
   */
  parseMultiPointText_() {
    if (this.match(qe.LEFT_PAREN)) {
      let e;
      if (this.token_.type == qe.LEFT_PAREN ? e = this.parsePointTextList_() : e = this.parsePointList_(), this.match(qe.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<Array<number>>>} All linestring points
   *                                          in a multilinestring.
   * @private
   */
  parseMultiLineStringText_() {
    if (this.match(qe.LEFT_PAREN)) {
      const e = this.parseLineStringTextList_();
      if (this.match(qe.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.
   * @private
   */
  parseMultiPolygonText_() {
    if (this.match(qe.LEFT_PAREN)) {
      const e = this.parsePolygonTextList_();
      if (this.match(qe.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<number>} A point.
   * @private
   */
  parsePoint_() {
    const e = [], t = this.layout_.length;
    for (let n = 0; n < t; ++n) {
      const r = this.token_;
      if (this.match(qe.NUMBER))
        e.push(
          /** @type {number} */
          r.value
        );
      else
        break;
    }
    if (e.length == t)
      return e;
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<number>>} An array of points.
   * @private
   */
  parsePointList_() {
    const e = [this.parsePoint_()];
    for (; this.match(qe.COMMA); )
      e.push(this.parsePoint_());
    return e;
  }
  /**
   * @return {Array<Array<number>>} An array of points.
   * @private
   */
  parsePointTextList_() {
    const e = [this.parsePointText_()];
    for (; this.match(qe.COMMA); )
      e.push(this.parsePointText_());
    return e;
  }
  /**
   * @return {Array<Array<Array<number>>>} An array of points.
   * @private
   */
  parseLineStringTextList_() {
    const e = [this.parseLineStringText_()];
    for (; this.match(qe.COMMA); )
      e.push(this.parseLineStringText_());
    return e;
  }
  /**
   * @return {Array<Array<Array<Array<number>>>>} An array of points.
   * @private
   */
  parsePolygonTextList_() {
    const e = [this.parsePolygonText_()];
    for (; this.match(qe.COMMA); )
      e.push(this.parsePolygonText_());
    return e;
  }
  /**
   * @return {boolean} Whether the token implies an empty geometry.
   * @private
   */
  isEmptyGeometry_() {
    const e = this.isTokenType(qe.TEXT) && this.token_.value == Dv;
    return e && this.consume_(), e;
  }
  /**
   * Create an error message for an unexpected token error.
   * @return {string} Error message.
   * @private
   */
  formatErrorMessage_() {
    return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
  }
  /**
   * @return {import("../geom/Geometry.js").default} The geometry.
   * @private
   */
  parseGeometry_() {
    const e = this.token_;
    if (this.match(qe.TEXT)) {
      const t = (
        /** @type {string} */
        e.value
      );
      this.layout_ = this.parseGeometryLayout_();
      const n = this.isEmptyGeometry_();
      if (t == "GEOMETRYCOLLECTION") {
        if (n)
          return new Qt([]);
        const o = this.parseGeometryCollectionText_();
        return new Qt(o);
      }
      const r = OA[t];
      if (!r)
        throw new Error("Invalid geometry type: " + t);
      let s;
      if (n)
        t == "POINT" ? s = [NaN, NaN] : s = [];
      else
        switch (t) {
          case "POINT": {
            s = this.parsePointText_();
            break;
          }
          case "LINESTRING": {
            s = this.parseLineStringText_();
            break;
          }
          case "POLYGON": {
            s = this.parsePolygonText_();
            break;
          }
          case "MULTIPOINT": {
            s = this.parseMultiPointText_();
            break;
          }
          case "MULTILINESTRING": {
            s = this.parseMultiLineStringText_();
            break;
          }
          case "MULTIPOLYGON": {
            s = this.parseMultiPolygonText_();
            break;
          }
        }
      return new r(s, this.layout_);
    }
    throw new Error(this.formatErrorMessage_());
  }
};
class UA extends Em {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.splitCollection_ = e.splitCollection !== void 0 ? e.splitCollection : !1;
  }
  /**
   * Parse a WKT string.
   * @param {string} wkt WKT string.
   * @return {import("../geom/Geometry.js").default}
   *     The geometry created.
   * @private
   */
  parse_(e) {
    const t = new GA(e);
    return new kA(t).parse();
  }
  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @override
   */
  readFeatureFromText(e, t) {
    const n = this.readGeometryFromText(e, t), r = new li();
    return r.setGeometry(n), r;
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   * @override
   */
  readFeaturesFromText(e, t) {
    let n = [];
    const r = this.readGeometryFromText(e, t);
    this.splitCollection_ && r.getType() == "GeometryCollection" ? n = /** @type {GeometryCollection} */
    r.getGeometriesArray() : n = [r];
    const s = [];
    for (let o = 0, a = n.length; o < a; ++o) {
      const l = new li();
      l.setGeometry(n[o]), s.push(l);
    }
    return s;
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @override
   */
  readGeometryFromText(e, t) {
    const n = this.parse_(e);
    return xt(n, !1, t);
  }
  /**
   * @param {import("../Feature.js").default} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   * @override
   */
  writeFeatureText(e, t) {
    const n = e.getGeometry();
    return n ? this.writeGeometryText(n, t) : "";
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   * @override
   */
  writeFeaturesText(e, t) {
    if (e.length == 1)
      return this.writeFeatureText(e[0], t);
    const n = [];
    for (let s = 0, o = e.length; s < o; ++s)
      n.push(e[s].getGeometry());
    const r = new Qt(n);
    return this.writeGeometryText(r, t);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   * @override
   */
  writeGeometryText(e, t) {
    return Bv(xt(e, !0, t));
  }
}
function Uv(i) {
  const e = i.getCoordinates();
  return e.length === 0 ? "" : e.join(" ");
}
function zA(i) {
  const e = [], t = i.getPoints();
  for (let n = 0, r = t.length; n < r; ++n)
    e.push("(" + Uv(t[n]) + ")");
  return e.join(",");
}
function BA(i) {
  const e = [], t = i.getGeometries();
  for (let n = 0, r = t.length; n < r; ++n)
    e.push(Bv(t[n]));
  return e.join(",");
}
function Dm(i) {
  const e = i.getCoordinates(), t = [];
  for (let n = 0, r = e.length; n < r; ++n)
    t.push(e[n].join(" "));
  return t.join(",");
}
function $A(i) {
  const e = [], t = i.getLineStrings();
  for (let n = 0, r = t.length; n < r; ++n)
    e.push("(" + Dm(t[n]) + ")");
  return e.join(",");
}
function zv(i) {
  const e = [], t = i.getLinearRings();
  for (let n = 0, r = t.length; n < r; ++n)
    e.push("(" + Dm(t[n]) + ")");
  return e.join(",");
}
function jA(i) {
  const e = [], t = i.getPolygons();
  for (let n = 0, r = t.length; n < r; ++n)
    e.push("(" + zv(t[n]) + ")");
  return e.join(",");
}
function XA(i) {
  const e = i.getLayout();
  let t = "";
  return (e === "XYZ" || e === "XYZM") && (t += Gv), (e === "XYM" || e === "XYZM") && (t += kv), t;
}
const VA = {
  Point: Uv,
  LineString: Dm,
  Polygon: zv,
  MultiPoint: zA,
  MultiLineString: $A,
  MultiPolygon: jA,
  GeometryCollection: BA
};
function Bv(i) {
  const e = i.getType(), t = VA[e], n = t(i);
  let r = DA[e];
  if (typeof /** @type {?} */
  i.getFlatCoordinates == "function") {
    const s = XA(
      /** @type {import("../geom/SimpleGeometry.js").default} */
      i
    );
    s.length > 0 && (r += " " + s);
  }
  return n.length === 0 ? r + " " + Dv : r + "(" + n + ")";
}
const ti = [
  null,
  "http://www.opengis.net/wms",
  "http://www.opengis.net/sld"
];
function Lh(i) {
  return Yp(i[0].version, "1.3") >= 0;
}
const WA = j(ti, {
  Service: F(gI),
  Capability: F(dI)
}), YA = j(ti, {
  Request: F(bI),
  Exception: F(yI),
  Layer: F(xI),
  UserDefinedSymbolization: F(
    cI
  )
});
class qA extends Cm {
  constructor() {
    super(), this.version = void 0;
  }
  /**
   * @param {Element} node Node.
   * @return {Object|null} Object
   * @override
   */
  readFromNode(e) {
    this.version = e.getAttribute("version").trim();
    const t = V(
      {
        version: this.version
      },
      WA,
      e,
      []
    );
    return t || null;
  }
}
const $v = {
  Name: F(W),
  Title: F(W),
  Abstract: F(W),
  KeywordList: F(qv),
  OnlineResource: F(Va),
  ContactInformation: F(pI),
  Fees: F(W),
  AccessConstraints: F(W)
}, ZA = j(ti, $v), HA = j(ti, {
  ...$v,
  LayerLimit: F(Dt),
  MaxWidth: F(Dt),
  MaxHeight: F(Dt)
}), KA = j(ti, {
  ContactPersonPrimary: F(mI),
  ContactPosition: F(W),
  ContactAddress: F(_I),
  ContactVoiceTelephone: F(W),
  ContactFacsimileTelephone: F(W),
  ContactElectronicMailAddress: F(W)
}), JA = j(ti, {
  ContactPerson: F(W),
  ContactOrganization: F(W)
}), QA = j(ti, {
  AddressType: F(W),
  Address: F(W),
  City: F(W),
  StateOrProvince: F(W),
  PostCode: F(W),
  Country: F(W)
}), eI = j(ti, {
  Format: ue(W)
}), jv = {
  Name: F(W),
  Title: F(W),
  Abstract: F(W),
  KeywordList: F(qv),
  BoundingBox: Ze(Wv),
  Dimension: Ze(EI),
  Attribution: F(uI),
  AuthorityURL: Ze(RI),
  Identifier: Ze(W),
  MetadataURL: Ze(PI),
  DataURL: Ze($r),
  FeatureListURL: Ze($r),
  Style: Ze(MI),
  Layer: Ze(Df)
}, Xv = j(ti, {
  ...jv,
  SRS: Ze(W),
  Extent: F(vI),
  ScaleHint: Ze(wI),
  LatLonBoundingBox: F(
    (i, e) => Wv(i, e, !1)
  ),
  Layer: Ze(Df)
}), Vv = j(ti, {
  ...jv,
  CRS: Ze(W),
  EX_GeographicBoundingBox: F(
    fI
  ),
  MinScaleDenominator: F(De),
  MaxScaleDenominator: F(De),
  Layer: Ze(Df)
}), tI = j(ti, {
  Title: F(W),
  OnlineResource: F(Va),
  LogoURL: F(Yv)
}), iI = j(ti, {
  westBoundLongitude: F(De),
  eastBoundLongitude: F(De),
  southBoundLatitude: F(De),
  northBoundLatitude: F(De)
}), nI = j(ti, {
  GetCapabilities: F(al),
  GetMap: F(al),
  GetFeatureInfo: F(al),
  DescribeLayer: F(al),
  GetLegendGraphic: F(al)
}), rI = j(ti, {
  Format: Ze(W),
  DCPType: Ze(SI)
}), sI = j(ti, {
  HTTP: F(TI)
}), oI = j(ti, {
  Get: F($r),
  Post: F($r)
}), aI = j(ti, {
  Name: F(W),
  Title: F(W),
  Abstract: F(W),
  LegendURL: Ze(Yv),
  StyleSheetURL: F($r),
  StyleURL: F($r)
}), lI = j(ti, {
  Format: F(W),
  OnlineResource: F(Va)
}), hI = j(ti, {
  Keyword: ue(W)
});
function uI(i, e) {
  return V({}, tI, i, e);
}
function cI(i, e) {
  return {
    SupportSLD: !!Di(i.getAttribute("SupportSLD")),
    UserLayer: !!Di(i.getAttribute("UserLayer")),
    UserStyle: !!Di(i.getAttribute("UserStyle")),
    RemoteWFS: !!Di(i.getAttribute("RemoteWFS")),
    InlineFeatureData: !!Di(
      i.getAttribute("InlineFeatureData")
    ),
    RemoteWCS: !!Di(i.getAttribute("RemoteWCS"))
  };
}
function Wv(i, e, t = !0) {
  const n = [
    Dn(i.getAttribute("minx")),
    Dn(i.getAttribute("miny")),
    Dn(i.getAttribute("maxx")),
    Dn(i.getAttribute("maxy"))
  ], r = [
    Dn(i.getAttribute("resx")),
    Dn(i.getAttribute("resy"))
  ], s = {
    extent: n,
    res: r
  };
  return t && (Lh(e) ? s.crs = i.getAttribute("CRS") : s.srs = i.getAttribute("SRS")), s;
}
function fI(i, e) {
  const t = V(
    {},
    iI,
    i,
    e
  );
  if (!t)
    return;
  const n = (
    /** @type {number|undefined} */
    t.westBoundLongitude
  ), r = (
    /** @type {number|undefined} */
    t.southBoundLatitude
  ), s = (
    /** @type {number|undefined} */
    t.eastBoundLongitude
  ), o = (
    /** @type {number|undefined} */
    t.northBoundLatitude
  );
  if (!(n === void 0 || r === void 0 || s === void 0 || o === void 0))
    return [
      n,
      r,
      s,
      o
    ];
}
function dI(i, e) {
  return V({}, YA, i, e);
}
function gI(i, e) {
  return V(
    {},
    Lh(e) ? HA : ZA,
    i,
    e
  );
}
function pI(i, e) {
  return V({}, KA, i, e);
}
function mI(i, e) {
  return V({}, JA, i, e);
}
function _I(i, e) {
  return V({}, QA, i, e);
}
function yI(i, e) {
  return V([], eI, i, e);
}
function xI(i, e) {
  const t = V(
    {},
    Lh(e) ? Vv : Xv,
    i,
    e
  );
  return t.Layer === void 0 ? Object.assign(t, Df(i, e)) : t;
}
function Df(i, e) {
  const t = Lh(e), n = (
    /**  @type {!Object<string,*>} */
    e[e.length - 1]
  ), r = V(
    {},
    t ? Vv : Xv,
    i,
    e
  );
  if (!r)
    return;
  let s = Di(i.getAttribute("queryable"));
  s === void 0 && (s = n.queryable), r.queryable = s !== void 0 ? s : !1;
  let o = Ir(i.getAttribute("cascaded"));
  o === void 0 && (o = n.cascaded), r.cascaded = o;
  let a = Di(i.getAttribute("opaque"));
  a === void 0 && (a = n.opaque), r.opaque = a !== void 0 ? a : !1;
  let l = Di(i.getAttribute("noSubsets"));
  l === void 0 && (l = n.noSubsets), r.noSubsets = l !== void 0 ? l : !1;
  let h = Dn(i.getAttribute("fixedWidth"));
  h || (h = n.fixedWidth), r.fixedWidth = h;
  let u = Dn(i.getAttribute("fixedHeight"));
  u || (u = n.fixedHeight), r.fixedHeight = u;
  const c = ["Style", "AuthorityURL"];
  t ? c.push("CRS") : c.push("SRS", "Dimension"), c.forEach(function(g) {
    if (g in n) {
      const d = r[g] || [];
      r[g] = d.concat(n[g]);
    }
  });
  const f = ["BoundingBox", "Attribution"];
  return t ? f.push(
    "Dimension",
    "EX_GeographicBoundingBox",
    "MinScaleDenominator",
    "MaxScaleDenominator"
  ) : f.push("LatLonBoundingBox", "ScaleHint", "Extent"), f.forEach(function(g) {
    if (!(g in r)) {
      const d = n[g];
      r[g] = d;
    }
  }), r;
}
function EI(i, e) {
  const t = {
    name: i.getAttribute("name"),
    units: i.getAttribute("units"),
    unitSymbol: i.getAttribute("unitSymbol")
  };
  return Lh(e) && Object.assign(t, {
    default: i.getAttribute("default"),
    multipleValues: Di(i.getAttribute("multipleValues")),
    nearestValue: Di(i.getAttribute("nearestValue")),
    current: Di(i.getAttribute("current")),
    values: W(i)
  }), t;
}
function vI(i, e) {
  return {
    name: i.getAttribute("name"),
    default: i.getAttribute("default"),
    nearestValue: Di(i.getAttribute("nearestValue"))
  };
}
function wI(i, e) {
  return {
    min: Dn(i.getAttribute("min")),
    max: Dn(i.getAttribute("max"))
  };
}
function $r(i, e) {
  return V({}, lI, i, e);
}
function bI(i, e) {
  return V({}, nI, i, e);
}
function SI(i, e) {
  return V({}, sI, i, e);
}
function TI(i, e) {
  return V({}, oI, i, e);
}
function al(i, e) {
  return V({}, rI, i, e);
}
function Yv(i, e) {
  const t = $r(i, e);
  if (t) {
    const n = [
      Ir(i.getAttribute("width")),
      Ir(i.getAttribute("height"))
    ];
    return t.size = n, t;
  }
}
function RI(i, e) {
  const t = $r(i, e);
  if (t)
    return t.name = i.getAttribute("name"), t;
}
function PI(i, e) {
  const t = $r(i, e);
  if (t)
    return t.type = i.getAttribute("type"), t;
}
function MI(i, e) {
  return V({}, aI, i, e);
}
function qv(i, e) {
  return V([], hI, i, e);
}
const CI = "_feature", AI = "_layer";
class II extends Ch {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver", this.gmlFormat_ = new Ne(), this.layers_ = e.layers ? e.layers : null;
  }
  /**
   * @return {Array<string>|null} layers
   */
  getLayers() {
    return this.layers_;
  }
  /**
   * @param {Array<string>|null} layers Layers to parse.
   */
  setLayers(e) {
    this.layers_ = e;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<import("../Feature.js").default>} Features.
   * @private
   */
  readFeatures_(e, t) {
    e.setAttribute("namespaceURI", this.featureNS_);
    const n = e.localName;
    let r = [];
    if (e.childNodes.length === 0)
      return r;
    if (n == "msGMLOutput")
      for (let s = 0, o = e.childNodes.length; s < o; s++) {
        const a = e.childNodes[s];
        if (a.nodeType !== Node.ELEMENT_NODE)
          continue;
        const l = (
          /** @type {Element} */
          a
        ), h = t[0], u = AI, c = l.localName.replace(u, "");
        if (this.layers_ && !this.layers_.includes(c))
          continue;
        const f = c + CI;
        h.featureType = f, h.featureNS = this.featureNS_;
        const g = {};
        g[f] = ue(
          this.gmlFormat_.readFeatureElement,
          this.gmlFormat_
        );
        const d = j(
          [h.featureNS, null],
          g
        );
        l.setAttribute("namespaceURI", this.featureNS_);
        const m = V(
          [],
          // @ts-ignore
          d,
          l,
          t,
          this.gmlFormat_
        );
        m && ze(r, m);
      }
    if (n == "FeatureCollection") {
      const s = V(
        [],
        this.gmlFormat_.FEATURE_COLLECTION_PARSERS,
        e,
        [{}],
        this.gmlFormat_
      );
      s && (r = s);
    }
    return r;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @override
   */
  readFeaturesFromNode(e, t) {
    const n = {};
    return t && Object.assign(n, this.getReadOptions(e, t)), this.readFeatures_(e, [n]);
  }
}
const yr = [null, "http://www.opengis.net/wmts/1.0"], Ya = [null, "http://www.opengis.net/ows/1.1"], LI = j(yr, {
  Contents: F($I)
});
let Gm = class extends Cm {
  constructor() {
    super(), this.owsParser_ = new Av();
  }
  /**
   * @param {Element} node Node.
   * @return {Object|null} Object
   * @override
   */
  readFromNode(e) {
    let t = e.getAttribute("version");
    t && (t = t.trim());
    let n = this.owsParser_.readFromNode(e);
    return n ? (n.version = t, n = V(
      n,
      LI,
      e,
      []
    ), n || null) : null;
  }
};
const FI = j(yr, {
  Layer: Ze(jI),
  TileMatrixSet: Ze(XI)
}), OI = j(
  yr,
  {
    Style: Ze(VI),
    Format: Ze(W),
    TileMatrixSetLink: Ze(WI),
    Dimension: Ze(YI),
    ResourceURL: Ze(qI)
  },
  j(Ya, {
    Title: F(W),
    Abstract: F(W),
    WGS84BoundingBox: F(Hv),
    BoundingBox: Ze(ZI),
    Identifier: F(W)
  })
), NI = j(
  yr,
  {
    LegendURL: Ze(HI)
  },
  j(Ya, {
    Title: F(W),
    Identifier: F(W)
  })
), DI = j(yr, {
  TileMatrixSet: F(W),
  TileMatrixSetLimits: F(JI)
}), GI = j(yr, {
  TileMatrixLimits: ue(QI)
}), kI = j(yr, {
  TileMatrix: F(W),
  MinTileRow: F(Dt),
  MaxTileRow: F(Dt),
  MinTileCol: F(Dt),
  MaxTileCol: F(Dt)
}), UI = j(
  yr,
  {
    Default: F(W),
    Value: Ze(W)
  },
  j(Ya, {
    Identifier: F(W)
  })
), Zv = j(Ya, {
  LowerCorner: ue(Yg),
  UpperCorner: ue(Yg)
}), zI = j(
  yr,
  {
    WellKnownScaleSet: F(W),
    TileMatrix: Ze(KI)
  },
  j(Ya, {
    SupportedCRS: F(W),
    Identifier: F(W),
    BoundingBox: F(Hv)
  })
), BI = j(
  yr,
  {
    TopLeftCorner: F(Yg),
    ScaleDenominator: F(De),
    TileWidth: F(Dt),
    TileHeight: F(Dt),
    MatrixWidth: F(Dt),
    MatrixHeight: F(Dt)
  },
  j(Ya, {
    Identifier: F(W)
  })
);
function $I(i, e) {
  return V({}, FI, i, e);
}
function jI(i, e) {
  return V({}, OI, i, e);
}
function XI(i, e) {
  return V({}, zI, i, e);
}
function VI(i, e) {
  const t = V({}, NI, i, e);
  if (!t)
    return;
  const n = i.getAttribute("isDefault") === "true";
  return t.isDefault = n, t;
}
function WI(i, e) {
  return V({}, DI, i, e);
}
function YI(i, e) {
  return V({}, UI, i, e);
}
function qI(i, e) {
  const t = i.getAttribute("format"), n = i.getAttribute("template"), r = i.getAttribute("resourceType"), s = {};
  return t && (s.format = t), n && (s.template = n), r && (s.resourceType = r), s;
}
function Hv(i, e) {
  const t = V(
    [],
    Zv,
    i,
    e
  );
  if (t.length == 2)
    return Ea(t);
}
function ZI(i, e) {
  const t = i.getAttribute("crs"), n = V(
    [],
    Zv,
    i,
    e
  );
  if (n.length == 2)
    return { extent: Ea(n), crs: t };
}
function HI(i, e) {
  const t = {};
  return t.format = i.getAttribute("format"), t.href = Va(i), t;
}
function Yg(i, e) {
  const t = W(i).split(/\s+/);
  if (!t || t.length != 2)
    return;
  const n = +t[0], r = +t[1];
  if (!(isNaN(n) || isNaN(r)))
    return [n, r];
}
function KI(i, e) {
  return V({}, BI, i, e);
}
function JI(i, e) {
  return V([], GI, i, e);
}
function QI(i, e) {
  return V({}, kI, i, e);
}
window.eoxMapAdvancedOlFormats = {
  EsriJSON: U2,
  GML: pm,
  GPX: xR,
  IGC: tP,
  IIIFInfo: aP,
  KML: WP,
  OWS: Av,
  Polyline: HC,
  TopoJSON: rA,
  WFS: SA,
  WKB: IA,
  WKT: UA,
  WMSCapabilities: qA,
  WMSGetFeatureInfo: II,
  WMTSCapabilities: Gm
};
const ki = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, Ny = {
  LENGTH: "length"
};
class du extends In {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(e, t, n) {
    super(e), this.element = t, this.index = n;
  }
}
let rn = class extends _r {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(e, t) {
    if (super(), this.on, this.once, this.un, t = t || {}, this.unique_ = !!t.unique, this.array_ = e ?? [], this.unique_)
      for (let n = 1, r = this.array_.length; n < r; ++n)
        this.assertUnique_(this.array_[n], n);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(e) {
    for (let t = 0, n = e.length; t < n; ++t)
      this.push(e[t]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(e) {
    const t = this.array_;
    for (let n = 0, r = t.length; n < r; ++n)
      e(t[n], n, t);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(e) {
    return this.array_[e];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(Ny.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(e, t) {
    if (e < 0 || e > this.getLength())
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t), this.array_.splice(e, 0, t), this.updateLength_(), this.dispatchEvent(
      new du(ki.ADD, t, e)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(e) {
    const t = this.getLength();
    return this.insertAt(t, e), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(e) {
    const t = this.array_;
    for (let n = 0, r = t.length; n < r; ++n)
      if (t[n] === e)
        return this.removeAt(n);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(e) {
    if (e < 0 || e >= this.getLength())
      return;
    const t = this.array_[e];
    return this.array_.splice(e, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new du(ki.REMOVE, t, e)
    ), t;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(e, t) {
    const n = this.getLength();
    if (e >= n) {
      this.insertAt(e, t);
      return;
    }
    if (e < 0)
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t, e);
    const r = this.array_[e];
    this.array_[e] = t, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new du(ki.REMOVE, r, e)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new du(ki.ADD, t, e)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(Ny.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(e, t) {
    const n = this.array_;
    for (let r = 0, s = n.length; r < s; ++r)
      if (n[r] === e && r !== t)
        throw new Error("Duplicate item added to a unique collection");
  }
};
function Kv(i, e, t) {
  const n = [];
  let r = i(0), s = i(1), o = e(r), a = e(s);
  const l = [s, r], h = [a, o], u = [1, 0], c = {};
  let f = 1e5, g, d, m, x, v, p;
  for (; --f > 0 && u.length > 0; )
    m = u.pop(), r = l.pop(), o = h.pop(), p = m.toString(), p in c || (n.push(o[0], o[1]), c[p] = !0), x = u.pop(), s = l.pop(), a = h.pop(), v = (m + x) / 2, g = i(v), d = e(g), vE(d[0], d[1], o[0], o[1], a[0], a[1]) < t ? (n.push(a[0], a[1]), p = x.toString(), c[p] = !0) : (u.push(x, v, v, m), h.push(a, d, d, o), l.push(s, g, g, r));
  return n;
}
function eL(i, e, t, n, r) {
  const s = ee("EPSG:4326");
  return Kv(
    /**
     * @param {number} frac Fraction.
     * @return {import("../../coordinate.js").Coordinate} Coordinate.
     */
    function(o) {
      return [i, e + (t - e) * o];
    },
    Vn(s, n),
    r
  );
}
function tL(i, e, t, n, r) {
  const s = ee("EPSG:4326");
  return Kv(
    /**
     * @param {number} frac Fraction.
     * @return {import("../../coordinate.js").Coordinate} Coordinate.
     */
    function(o) {
      return [e + (t - e) * o, i];
    },
    Vn(s, n),
    r
  );
}
const Ht = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
};
class Jv {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(e, t, n, r, s) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(e) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(e) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(e, t, n) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} [index] Render order index.
   */
  drawFeature(e, t, n) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawGeometryCollection(e, t, n) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(e, t, n) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(e, t, n) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(e, t, n) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(e, t, n) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(e, t, n) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(e, t, n) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(e, t, n) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(e, t) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(e, t) {
  }
}
class Qv extends Jv {
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(e, t, n, r, s, o, a) {
    super(), this.context_ = e, this.pixelRatio_ = t, this.extent_ = n, this.transform_ = r, this.transformRotation_ = r ? za(Math.atan2(r[1], r[0]), 10) : 0, this.viewRotation_ = s, this.squaredTolerance_ = o, this.userTransform_ = a, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = st();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(e, t, n, r) {
    if (!this.image_)
      return;
    const s = hr(
      e,
      t,
      n,
      r,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_, a = this.tmpLocalTransform_, l = o.globalAlpha;
    this.imageOpacity_ != 1 && (o.globalAlpha = l * this.imageOpacity_);
    let h = this.imageRotation_;
    this.transformRotation_ === 0 && (h -= this.viewRotation_), this.imageRotateWithView_ && (h += this.viewRotation_);
    for (let u = 0, c = s.length; u < c; u += 2) {
      const f = s[u] - this.imageAnchorX_, g = s[u + 1] - this.imageAnchorY_;
      if (h !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const d = f + this.imageAnchorX_, m = g + this.imageAnchorY_;
        un(
          a,
          d,
          m,
          1,
          1,
          h,
          -d,
          -m
        ), o.save(), o.transform.apply(o, a), o.translate(d, m), o.scale(this.imageScale_[0], this.imageScale_[1]), o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), o.restore();
      } else
        o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          f,
          g,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (o.globalAlpha = l);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(e, t, n, r) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const s = hr(
      e,
      t,
      n,
      r,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_;
    let a = this.textRotation_;
    for (this.transformRotation_ === 0 && (a -= this.viewRotation_), this.textRotateWithView_ && (a += this.viewRotation_); t < n; t += r) {
      const l = s[t] + this.textOffsetX_, h = s[t + 1] + this.textOffsetY_;
      a !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (o.save(), o.translate(l - this.textOffsetX_, h - this.textOffsetY_), o.rotate(a), o.translate(this.textOffsetX_, this.textOffsetY_), o.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && o.strokeText(this.text_, 0, 0), this.textFillState_ && o.fillText(this.text_, 0, 0), o.restore()) : (this.textStrokeState_ && o.strokeText(this.text_, l, h), this.textFillState_ && o.fillText(this.text_, l, h));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(e, t, n, r, s) {
    const o = this.context_, a = hr(
      e,
      t,
      n,
      r,
      this.transform_,
      this.pixelCoordinates_
    );
    o.moveTo(a[0], a[1]);
    let l = a.length;
    s && (l -= 2);
    for (let h = 2; h < l; h += 2)
      o.lineTo(a[h], a[h + 1]);
    return s && o.closePath(), n;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(e, t, n, r) {
    for (let s = 0, o = n.length; s < o; ++s)
      t = this.moveToLineTo_(
        e,
        t,
        n[s],
        r,
        !0
      );
    return t;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   * @override
   */
  drawCircle(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Circle.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!ft(this.extent_, e.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = w2(
          e,
          this.transform_,
          this.pixelCoordinates_
        ), n = t[2] - t[0], r = t[3] - t[1], s = Math.sqrt(n * n + r * r), o = this.context_;
        o.beginPath(), o.arc(
          t[0],
          t[1],
          s,
          0,
          2 * Math.PI
        ), this.fillState_ && o.fill(), this.strokeState_ && o.stroke();
      }
      this.text_ !== "" && this.drawText_(e.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   * @override
   */
  setStyle(e) {
    this.setFillStrokeStyle(e.getFill(), e.getStroke()), this.setImageStyle(e.getImage()), this.setTextStyle(e.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(e) {
    this.transform_ = e;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   * @override
   */
  drawGeometry(e) {
    switch (e.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          e
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          e
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          e
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          e
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          e
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          e
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          e
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   * @override
   */
  drawFeature(e, t) {
    const n = t.getGeometryFunction()(e);
    n && (this.setStyle(t), this.drawGeometry(n));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   * @override
   */
  drawGeometryCollection(e) {
    const t = e.getGeometriesArray();
    for (let n = 0, r = t.length; n < r; ++n)
      this.drawGeometry(t[n]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   * @override
   */
  drawPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/Point.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), n = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, n), this.text_ !== "" && this.drawText_(t, 0, t.length, n);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   * @override
   */
  drawMultiPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPoint.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), n = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, n), this.text_ !== "" && this.drawText_(t, 0, t.length, n);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   * @override
   */
  drawLineString(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/LineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!ft(this.extent_, e.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, n = e.getFlatCoordinates();
        t.beginPath(), this.moveToLineTo_(
          n,
          0,
          n.length,
          e.getStride(),
          !1
        ), t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatMidpoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   * @override
   */
  drawMultiLineString(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiLineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getExtent();
    if (ft(this.extent_, t)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const n = this.context_, r = e.getFlatCoordinates();
        let s = 0;
        const o = (
          /** @type {Array<number>} */
          e.getEnds()
        ), a = e.getStride();
        n.beginPath();
        for (let l = 0, h = o.length; l < h; ++l)
          s = this.moveToLineTo_(
            r,
            s,
            o[l],
            a,
            !1
          );
        n.stroke();
      }
      if (this.text_ !== "") {
        const n = e.getFlatMidpoints();
        this.drawText_(n, 0, n.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   * @override
   */
  drawPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Polygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!ft(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_;
        t.beginPath(), this.drawRings_(
          e.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          e.getEnds(),
          e.getStride()
        ), this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @override
   */
  drawMultiPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPolygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!ft(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, n = e.getOrientedFlatCoordinates();
        let r = 0;
        const s = e.getEndss(), o = e.getStride();
        t.beginPath();
        for (let a = 0, l = s.length; a < l; ++a) {
          const h = s[a];
          r = this.drawRings_(n, r, h, o);
        }
        this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoints();
        this.drawText_(t, 0, t.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(e) {
    const t = this.context_, n = this.contextFillState_;
    n ? n.fillStyle != e.fillStyle && (n.fillStyle = e.fillStyle, t.fillStyle = e.fillStyle) : (t.fillStyle = e.fillStyle, this.contextFillState_ = {
      fillStyle: e.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(e) {
    const t = this.context_, n = this.contextStrokeState_;
    n ? (n.lineCap != e.lineCap && (n.lineCap = e.lineCap, t.lineCap = e.lineCap), Xr(n.lineDash, e.lineDash) || t.setLineDash(
      n.lineDash = e.lineDash
    ), n.lineDashOffset != e.lineDashOffset && (n.lineDashOffset = e.lineDashOffset, t.lineDashOffset = e.lineDashOffset), n.lineJoin != e.lineJoin && (n.lineJoin = e.lineJoin, t.lineJoin = e.lineJoin), n.lineWidth != e.lineWidth && (n.lineWidth = e.lineWidth, t.lineWidth = e.lineWidth), n.miterLimit != e.miterLimit && (n.miterLimit = e.miterLimit, t.miterLimit = e.miterLimit), n.strokeStyle != e.strokeStyle && (n.strokeStyle = e.strokeStyle, t.strokeStyle = e.strokeStyle)) : (t.lineCap = e.lineCap, t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset, t.lineJoin = e.lineJoin, t.lineWidth = e.lineWidth, t.miterLimit = e.miterLimit, t.strokeStyle = e.strokeStyle, this.contextStrokeState_ = {
      lineCap: e.lineCap,
      lineDash: e.lineDash,
      lineDashOffset: e.lineDashOffset,
      lineJoin: e.lineJoin,
      lineWidth: e.lineWidth,
      miterLimit: e.miterLimit,
      strokeStyle: e.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(e) {
    const t = this.context_, n = this.contextTextState_, r = e.textAlign ? e.textAlign : eh;
    n ? (n.font != e.font && (n.font = e.font, t.font = e.font), n.textAlign != r && (n.textAlign = r, t.textAlign = r), n.textBaseline != e.textBaseline && (n.textBaseline = e.textBaseline, t.textBaseline = e.textBaseline)) : (t.font = e.font, t.textAlign = r, t.textBaseline = e.textBaseline, this.contextTextState_ = {
      font: e.font,
      textAlign: r,
      textBaseline: e.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @override
   */
  setFillStrokeStyle(e, t) {
    if (!e)
      this.fillState_ = null;
    else {
      const n = e.getColor();
      this.fillState_ = {
        fillStyle: ar(
          n || Gi
        )
      };
    }
    if (!t)
      this.strokeState_ = null;
    else {
      const n = t.getColor(), r = t.getLineCap(), s = t.getLineDash(), o = t.getLineDashOffset(), a = t.getLineJoin(), l = t.getWidth(), h = t.getMiterLimit(), u = s || Dr;
      this.strokeState_ = {
        lineCap: r !== void 0 ? r : ba,
        lineDash: this.pixelRatio_ === 1 ? u : u.map((c) => c * this.pixelRatio_),
        lineDashOffset: (o || Gr) * this.pixelRatio_,
        lineJoin: a !== void 0 ? a : Sa,
        lineWidth: (l !== void 0 ? l : th) * this.pixelRatio_,
        miterLimit: h !== void 0 ? h : Jl,
        strokeStyle: ar(
          n || Ql
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @override
   */
  setImageStyle(e) {
    let t;
    if (!e || !(t = e.getSize())) {
      this.image_ = null;
      return;
    }
    const n = e.getPixelRatio(this.pixelRatio_), r = e.getAnchor(), s = e.getOrigin();
    this.image_ = e.getImage(this.pixelRatio_), this.imageAnchorX_ = r[0] * n, this.imageAnchorY_ = r[1] * n, this.imageHeight_ = t[1] * n, this.imageOpacity_ = e.getOpacity(), this.imageOriginX_ = s[0], this.imageOriginY_ = s[1], this.imageRotateWithView_ = e.getRotateWithView(), this.imageRotation_ = e.getRotation();
    const o = e.getScaleArray();
    this.imageScale_ = [
      o[0] * this.pixelRatio_ / n,
      o[1] * this.pixelRatio_ / n
    ], this.imageWidth_ = t[0] * n;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @override
   */
  setTextStyle(e) {
    if (!e)
      this.text_ = "";
    else {
      const t = e.getFill();
      if (!t)
        this.textFillState_ = null;
      else {
        const g = t.getColor();
        this.textFillState_ = {
          fillStyle: ar(
            g || Gi
          )
        };
      }
      const n = e.getStroke();
      if (!n)
        this.textStrokeState_ = null;
      else {
        const g = n.getColor(), d = n.getLineCap(), m = n.getLineDash(), x = n.getLineDashOffset(), v = n.getLineJoin(), p = n.getWidth(), y = n.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: d !== void 0 ? d : ba,
          lineDash: m || Dr,
          lineDashOffset: x || Gr,
          lineJoin: v !== void 0 ? v : Sa,
          lineWidth: p !== void 0 ? p : th,
          miterLimit: y !== void 0 ? y : Jl,
          strokeStyle: ar(
            g || Ql
          )
        };
      }
      const r = e.getFont(), s = e.getOffsetX(), o = e.getOffsetY(), a = e.getRotateWithView(), l = e.getRotation(), h = e.getScaleArray(), u = e.getText(), c = e.getTextAlign(), f = e.getTextBaseline();
      this.textState_ = {
        font: r !== void 0 ? r : sv,
        textAlign: c !== void 0 ? c : eh,
        textBaseline: f !== void 0 ? f : _c
      }, this.text_ = u !== void 0 ? Array.isArray(u) ? u.reduce((g, d, m) => g += m % 2 ? " " : d, "") : u : "", this.textOffsetX_ = s !== void 0 ? this.pixelRatio_ * s : 0, this.textOffsetY_ = o !== void 0 ? this.pixelRatio_ * o : 0, this.textRotateWithView_ = a !== void 0 ? a : !1, this.textRotation_ = l !== void 0 ? l : 0, this.textScale_ = [
        this.pixelRatio_ * h[0],
        this.pixelRatio_ * h[1]
      ];
    }
  }
}
const iL = 0.5, ew = {
  Point: uL,
  LineString: aL,
  Polygon: fL,
  MultiPoint: cL,
  MultiLineString: lL,
  MultiPolygon: hL,
  GeometryCollection: oL,
  Circle: rL
};
function nL(i, e) {
  return parseInt(ie(i), 10) - parseInt(ie(e), 10);
}
function wc(i, e) {
  const t = tw(i, e);
  return t * t;
}
function tw(i, e) {
  return iL * i / e;
}
function rL(i, e, t, n, r) {
  const s = t.getFill(), o = t.getStroke();
  if (s || o) {
    const l = i.getBuilder(t.getZIndex(), "Circle");
    l.setFillStrokeStyle(s, o), l.drawCircle(e, n, r);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const l = i.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(a), l.drawText(e, n);
  }
}
function bc(i, e, t, n, r, s, o, a) {
  const l = [], h = t.getImage();
  if (h) {
    let f = !0;
    const g = h.getImageState();
    g == se.LOADED || g == se.ERROR ? f = !1 : g == se.IDLE && h.load(), f && l.push(h.ready());
  }
  const u = t.getFill();
  u && u.loading() && l.push(u.ready());
  const c = l.length > 0;
  return c && Promise.all(l).then(() => r(null)), sL(
    i,
    e,
    t,
    n,
    s,
    o,
    a
  ), c;
}
function sL(i, e, t, n, r, s, o) {
  const a = t.getGeometryFunction()(e);
  if (!a)
    return;
  const l = a.simplifyTransformed(
    n,
    r
  );
  if (t.getRenderer())
    iw(i, l, t, e, o);
  else {
    const u = ew[l.getType()];
    u(
      i,
      l,
      t,
      e,
      o,
      s
    );
  }
}
function iw(i, e, t, n, r) {
  if (e.getType() == "GeometryCollection") {
    const o = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      e.getGeometries()
    );
    for (let a = 0, l = o.length; a < l; ++a)
      iw(i, o[a], t, n, r);
    return;
  }
  i.getBuilder(t.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    e,
    n,
    t.getRenderer(),
    t.getHitDetectionRenderer(),
    r
  );
}
function oL(i, e, t, n, r, s) {
  const o = e.getGeometriesArray();
  let a, l;
  for (a = 0, l = o.length; a < l; ++a) {
    const h = ew[o[a].getType()];
    h(
      i,
      o[a],
      t,
      n,
      r,
      s
    );
  }
}
function aL(i, e, t, n, r) {
  const s = t.getStroke();
  if (s) {
    const a = i.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    a.setFillStrokeStyle(null, s), a.drawLineString(e, n, r);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const a = i.getBuilder(t.getZIndex(), "Text");
    a.setTextStyle(o), a.drawText(e, n, r);
  }
}
function lL(i, e, t, n, r) {
  const s = t.getStroke();
  if (s) {
    const a = i.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    a.setFillStrokeStyle(null, s), a.drawMultiLineString(e, n, r);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const a = i.getBuilder(t.getZIndex(), "Text");
    a.setTextStyle(o), a.drawText(e, n, r);
  }
}
function hL(i, e, t, n, r) {
  const s = t.getFill(), o = t.getStroke();
  if (o || s) {
    const l = i.getBuilder(t.getZIndex(), "Polygon");
    l.setFillStrokeStyle(s, o), l.drawMultiPolygon(e, n, r);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const l = i.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(a), l.drawText(e, n, r);
  }
}
function uL(i, e, t, n, r, s) {
  const o = t.getImage(), a = t.getText(), l = a && a.getText(), h = s && o && l ? {} : void 0;
  if (o) {
    if (o.getImageState() != se.LOADED)
      return;
    const u = i.getBuilder(t.getZIndex(), "Image");
    u.setImageStyle(o, h), u.drawPoint(e, n, r);
  }
  if (l) {
    const u = i.getBuilder(t.getZIndex(), "Text");
    u.setTextStyle(a, h), u.drawText(e, n, r);
  }
}
function cL(i, e, t, n, r, s) {
  const o = t.getImage(), a = o && o.getOpacity() !== 0, l = t.getText(), h = l && l.getText(), u = s && a && h ? {} : void 0;
  if (a) {
    if (o.getImageState() != se.LOADED)
      return;
    const c = i.getBuilder(t.getZIndex(), "Image");
    c.setImageStyle(o, u), c.drawMultiPoint(e, n, r);
  }
  if (h) {
    const c = i.getBuilder(t.getZIndex(), "Text");
    c.setTextStyle(l, u), c.drawText(e, n, r);
  }
}
function fL(i, e, t, n, r) {
  const s = t.getFill(), o = t.getStroke();
  if (s || o) {
    const l = i.getBuilder(t.getZIndex(), "Polygon");
    l.setFillStrokeStyle(s, o), l.drawPolygon(e, n, r);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const l = i.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(a), l.drawText(e, n, r);
  }
}
function dL(i) {
  if (!(i.context instanceof CanvasRenderingContext2D))
    throw new Error("Only works for render events from Canvas 2D layers");
  const e = i.inversePixelTransform[0], t = i.inversePixelTransform[1], n = Math.sqrt(e * e + t * t), r = i.frameState, s = zr(
    i.inversePixelTransform.slice(),
    r.coordinateToPixelTransform
  ), o = wc(
    r.viewState.resolution,
    n
  );
  let a;
  return new Qv(
    i.context,
    n,
    r.extent,
    s,
    r.viewState.rotation,
    o,
    a
  );
}
let gL = !1;
function nw(i, e, t, n, r, s, o) {
  const a = new XMLHttpRequest();
  a.open(
    "GET",
    typeof i == "function" ? i(t, n, r) : i,
    !0
  ), e.getType() == "arraybuffer" && (a.responseType = "arraybuffer"), a.withCredentials = gL, a.onload = function(l) {
    if (!a.status || a.status >= 200 && a.status < 300) {
      const h = e.getType();
      try {
        let u;
        h == "text" || h == "json" ? u = a.responseText : h == "xml" ? u = a.responseXML || a.responseText : h == "arraybuffer" && (u = /** @type {ArrayBuffer} */
        a.response), u ? s(
          /** @type {Array<FeatureType>} */
          e.readFeatures(u, {
            extent: t,
            featureProjection: r
          }),
          e.readProjection(u)
        ) : o();
      } catch {
        o();
      }
    } else
      o();
  }, a.onerror = o, a.send();
}
function Dy(i, e) {
  return function(t, n, r, s, o) {
    nw(
      i,
      e,
      t,
      n,
      r,
      /**
       * @param {Array<FeatureType>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      (a, l) => {
        this.addFeatures(a), s !== void 0 && s(a);
      },
      () => {
        this.changed(), o !== void 0 && o();
      }
    );
  };
}
function pL(i, e) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
function rw(i, e) {
  return [i];
}
function sw(i, e, t = 0, n = i.length - 1, r = mL) {
  for (; n > t; ) {
    if (n - t > 600) {
      const l = n - t + 1, h = e - t + 1, u = Math.log(l), c = 0.5 * Math.exp(2 * u / 3), f = 0.5 * Math.sqrt(u * c * (l - c) / l) * (h - l / 2 < 0 ? -1 : 1), g = Math.max(t, Math.floor(e - h * c / l + f)), d = Math.min(n, Math.floor(e + (l - h) * c / l + f));
      sw(i, e, g, d, r);
    }
    const s = i[e];
    let o = t, a = n;
    for (ll(i, t, e), r(i[n], s) > 0 && ll(i, t, n); o < a; ) {
      for (ll(i, o, a), o++, a--; r(i[o], s) < 0; ) o++;
      for (; r(i[a], s) > 0; ) a--;
    }
    r(i[t], s) === 0 ? ll(i, t, a) : (a++, ll(i, a, n)), a <= e && (t = a + 1), e <= a && (n = a - 1);
  }
}
function ll(i, e, t) {
  const n = i[e];
  i[e] = i[t], i[t] = n;
}
function mL(i, e) {
  return i < e ? -1 : i > e ? 1 : 0;
}
let km = class {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let t = this.data;
    const n = [];
    if (!pu(e, t)) return n;
    const r = this.toBBox, s = [];
    for (; t; ) {
      for (let o = 0; o < t.children.length; o++) {
        const a = t.children[o], l = t.leaf ? r(a) : a;
        pu(e, l) && (t.leaf ? n.push(a) : Od(e, l) ? this._all(a, n) : s.push(a));
      }
      t = s.pop();
    }
    return n;
  }
  collides(e) {
    let t = this.data;
    if (!pu(e, t)) return !1;
    const n = [];
    for (; t; ) {
      for (let r = 0; r < t.children.length; r++) {
        const s = t.children[r], o = t.leaf ? this.toBBox(s) : s;
        if (pu(e, o)) {
          if (t.leaf || Od(e, o)) return !0;
          n.push(s);
        }
      }
      t = n.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length)) return this;
    if (e.length < this._minEntries) {
      for (let n = 0; n < e.length; n++)
        this.insert(e[n]);
      return this;
    }
    let t = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = t;
    else if (this.data.height === t.height)
      this._splitRoot(this.data, t);
    else {
      if (this.data.height < t.height) {
        const n = this.data;
        this.data = t, t = n;
      }
      this._insert(t, this.data.height - t.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = zo([]), this;
  }
  remove(e, t) {
    if (!e) return this;
    let n = this.data;
    const r = this.toBBox(e), s = [], o = [];
    let a, l, h;
    for (; n || s.length; ) {
      if (n || (n = s.pop(), l = s[s.length - 1], a = o.pop(), h = !0), n.leaf) {
        const u = _L(e, n.children, t);
        if (u !== -1)
          return n.children.splice(u, 1), s.push(n), this._condense(s), this;
      }
      !h && !n.leaf && Od(n, r) ? (s.push(n), o.push(a), a = 0, l = n, n = n.children[0]) : l ? (a++, n = l.children[a], h = !1) : n = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, t) {
    return e.minX - t.minX;
  }
  compareMinY(e, t) {
    return e.minY - t.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, t) {
    const n = [];
    for (; e; )
      e.leaf ? t.push(...e.children) : n.push(...e.children), e = n.pop();
    return t;
  }
  _build(e, t, n, r) {
    const s = n - t + 1;
    let o = this._maxEntries, a;
    if (s <= o)
      return a = zo(e.slice(t, n + 1)), Po(a, this.toBBox), a;
    r || (r = Math.ceil(Math.log(s) / Math.log(o)), o = Math.ceil(s / Math.pow(o, r - 1))), a = zo([]), a.leaf = !1, a.height = r;
    const l = Math.ceil(s / o), h = l * Math.ceil(Math.sqrt(o));
    Gy(e, t, n, h, this.compareMinX);
    for (let u = t; u <= n; u += h) {
      const c = Math.min(u + h - 1, n);
      Gy(e, u, c, l, this.compareMinY);
      for (let f = u; f <= c; f += l) {
        const g = Math.min(f + l - 1, c);
        a.children.push(this._build(e, f, g, r - 1));
      }
    }
    return Po(a, this.toBBox), a;
  }
  _chooseSubtree(e, t, n, r) {
    for (; r.push(t), !(t.leaf || r.length - 1 === n); ) {
      let s = 1 / 0, o = 1 / 0, a;
      for (let l = 0; l < t.children.length; l++) {
        const h = t.children[l], u = Fd(h), c = EL(e, h) - u;
        c < o ? (o = c, s = u < s ? u : s, a = h) : c === o && u < s && (s = u, a = h);
      }
      t = a || t.children[0];
    }
    return t;
  }
  _insert(e, t, n) {
    const r = n ? e : this.toBBox(e), s = [], o = this._chooseSubtree(r, this.data, t, s);
    for (o.children.push(e), _l(o, r); t >= 0 && s[t].children.length > this._maxEntries; )
      this._split(s, t), t--;
    this._adjustParentBBoxes(r, s, t);
  }
  // split overflowed node into two
  _split(e, t) {
    const n = e[t], r = n.children.length, s = this._minEntries;
    this._chooseSplitAxis(n, s, r);
    const o = this._chooseSplitIndex(n, s, r), a = zo(n.children.splice(o, n.children.length - o));
    a.height = n.height, a.leaf = n.leaf, Po(n, this.toBBox), Po(a, this.toBBox), t ? e[t - 1].children.push(a) : this._splitRoot(n, a);
  }
  _splitRoot(e, t) {
    this.data = zo([e, t]), this.data.height = e.height + 1, this.data.leaf = !1, Po(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, t, n) {
    let r, s = 1 / 0, o = 1 / 0;
    for (let a = t; a <= n - t; a++) {
      const l = ml(e, 0, a, this.toBBox), h = ml(e, a, n, this.toBBox), u = vL(l, h), c = Fd(l) + Fd(h);
      u < s ? (s = u, r = a, o = c < o ? c : o) : u === s && c < o && (o = c, r = a);
    }
    return r || n - t;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, t, n) {
    const r = e.leaf ? this.compareMinX : yL, s = e.leaf ? this.compareMinY : xL, o = this._allDistMargin(e, t, n, r), a = this._allDistMargin(e, t, n, s);
    o < a && e.children.sort(r);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, t, n, r) {
    e.children.sort(r);
    const s = this.toBBox, o = ml(e, 0, t, s), a = ml(e, n - t, n, s);
    let l = gu(o) + gu(a);
    for (let h = t; h < n - t; h++) {
      const u = e.children[h];
      _l(o, e.leaf ? s(u) : u), l += gu(o);
    }
    for (let h = n - t - 1; h >= t; h--) {
      const u = e.children[h];
      _l(a, e.leaf ? s(u) : u), l += gu(a);
    }
    return l;
  }
  _adjustParentBBoxes(e, t, n) {
    for (let r = n; r >= 0; r--)
      _l(t[r], e);
  }
  _condense(e) {
    for (let t = e.length - 1, n; t >= 0; t--)
      e[t].children.length === 0 ? t > 0 ? (n = e[t - 1].children, n.splice(n.indexOf(e[t]), 1)) : this.clear() : Po(e[t], this.toBBox);
  }
};
function _L(i, e, t) {
  if (!t) return e.indexOf(i);
  for (let n = 0; n < e.length; n++)
    if (t(i, e[n])) return n;
  return -1;
}
function Po(i, e) {
  ml(i, 0, i.children.length, e, i);
}
function ml(i, e, t, n, r) {
  r || (r = zo(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;
  for (let s = e; s < t; s++) {
    const o = i.children[s];
    _l(r, i.leaf ? n(o) : o);
  }
  return r;
}
function _l(i, e) {
  return i.minX = Math.min(i.minX, e.minX), i.minY = Math.min(i.minY, e.minY), i.maxX = Math.max(i.maxX, e.maxX), i.maxY = Math.max(i.maxY, e.maxY), i;
}
function yL(i, e) {
  return i.minX - e.minX;
}
function xL(i, e) {
  return i.minY - e.minY;
}
function Fd(i) {
  return (i.maxX - i.minX) * (i.maxY - i.minY);
}
function gu(i) {
  return i.maxX - i.minX + (i.maxY - i.minY);
}
function EL(i, e) {
  return (Math.max(e.maxX, i.maxX) - Math.min(e.minX, i.minX)) * (Math.max(e.maxY, i.maxY) - Math.min(e.minY, i.minY));
}
function vL(i, e) {
  const t = Math.max(i.minX, e.minX), n = Math.max(i.minY, e.minY), r = Math.min(i.maxX, e.maxX), s = Math.min(i.maxY, e.maxY);
  return Math.max(0, r - t) * Math.max(0, s - n);
}
function Od(i, e) {
  return i.minX <= e.minX && i.minY <= e.minY && e.maxX <= i.maxX && e.maxY <= i.maxY;
}
function pu(i, e) {
  return e.minX <= i.maxX && e.minY <= i.maxY && e.maxX >= i.minX && e.maxY >= i.minY;
}
function zo(i) {
  return {
    children: i,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Gy(i, e, t, n, r) {
  const s = [e, t];
  for (; s.length; ) {
    if (t = s.pop(), e = s.pop(), t - e <= n) continue;
    const o = e + Math.ceil((t - e) / n / 2) * n;
    sw(i, o, e, t, r), s.push(e, o, o, t);
  }
}
class ky {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(e) {
    this.rbush_ = new km(e), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(e, t) {
    const n = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3],
      value: t
    };
    this.rbush_.insert(n), this.items_[ie(t)] = n;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(e, t) {
    const n = new Array(t.length);
    for (let r = 0, s = t.length; r < s; r++) {
      const o = e[r], a = t[r], l = {
        minX: o[0],
        minY: o[1],
        maxX: o[2],
        maxY: o[3],
        value: a
      };
      n[r] = l, this.items_[ie(a)] = l;
    }
    this.rbush_.load(n);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(e) {
    const t = ie(e), n = this.items_[t];
    return delete this.items_[t], this.rbush_.remove(n) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(e, t) {
    const n = this.items_[ie(t)], r = [n.minX, n.minY, n.maxX, n.maxY];
    Pn(r, e) || (this.remove(t), this.insert(e, t));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(t) {
      return t.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(e) {
    const t = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3]
    };
    return this.rbush_.search(t).map(function(r) {
      return r.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   */
  forEach(e) {
    return this.forEach_(this.getAll(), e);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   */
  forEachInExtent(e, t) {
    return this.forEach_(this.getInExtent(e), t);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): R} callback Callback.
   * @return {R|undefined} Callback return value.
   * @template R
   * @private
   */
  forEach_(e, t) {
    let n;
    for (let r = 0, s = e.length; r < s; r++)
      if (n = t(e[r]), n)
        return n;
    return n;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return Ur(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(e) {
    const t = this.rbush_.toJSON();
    return Xn(t.minX, t.minY, t.maxX, t.maxY, e);
  }
  /**
   * @param {RBush<T>} rbush R-Tree.
   */
  concat(e) {
    this.rbush_.load(e.rbush_.all());
    for (const t in e.items_)
      this.items_[t] = e.items_[t];
  }
}
class vo extends _r {
  /**
   * @param {Options} options Source options.
   */
  constructor(e) {
    super(), this.projection = ee(e.projection), this.attributions_ = Uy(e.attributions), this.attributionsCollapsible_ = e.attributionsCollapsible ?? !0, this.loading = !1, this.state_ = e.state !== void 0 ? e.state : "ready", this.wrapX_ = e.wrapX !== void 0 ? e.wrapX : !1, this.interpolate_ = !!e.interpolate, this.viewResolver = null, this.viewRejector = null;
    const t = this;
    this.viewPromise_ = new Promise(function(n, r) {
      t.viewResolver = n, t.viewRejector = r;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(e) {
    this.attributions_ = Uy(e), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(e) {
    this.state_ = e, this.changed();
  }
}
function Uy(i) {
  return i ? typeof i == "function" ? i : (Array.isArray(i) || (i = [i]), (e) => i) : null;
}
const Bt = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
class Kr extends In {
  /**
   * @param {string} type Type.
   * @param {FeatureType} [feature] Feature.
   * @param {Array<FeatureType>} [features] Features.
   */
  constructor(e, t, n) {
    super(e), this.feature = t, this.features = n;
  }
}
class ys extends vo {
  /**
   * @param {Options<FeatureType>} [options] Vector source options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = Yl, this.format_ = e.format || null, this.overlaps_ = e.overlaps === void 0 ? !0 : e.overlaps, this.url_ = e.url, e.loader !== void 0 ? this.loader_ = e.loader : this.url_ !== void 0 && (Te(this.format_, "`format` must be set when `url` is set"), this.loader_ = Dy(this.url_, this.format_)), this.strategy_ = e.strategy !== void 0 ? e.strategy : pL;
    const t = e.useSpatialIndex !== void 0 ? e.useSpatialIndex : !0;
    this.featuresRtree_ = t ? new ky() : null, this.loadedExtentsRtree_ = new ky(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let n, r;
    Array.isArray(e.features) ? r = e.features : e.features && (n = e.features, r = n.getArray()), !t && n === void 0 && (n = new rn(r)), r !== void 0 && this.addFeaturesInternal(r), n !== void 0 && this.bindFeaturesCollection_(n);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureType} feature Feature to add.
   * @api
   */
  addFeature(e) {
    this.addFeatureInternal(e), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @protected
   */
  addFeatureInternal(e) {
    const t = ie(e);
    if (!this.addToIndex_(t, e)) {
      this.featuresCollection_ && this.featuresCollection_.remove(e);
      return;
    }
    this.setupChangeEvents_(t, e);
    const n = e.getGeometry();
    if (n) {
      const r = n.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(r, e);
    } else
      this.nullGeometryFeatures_[t] = e;
    this.dispatchEvent(
      new Kr(Bt.ADDFEATURE, e)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @private
   */
  setupChangeEvents_(e, t) {
    t instanceof fi || (this.featureChangeKeys_[e] = [
      Ce(t, le.CHANGE, this.handleFeatureChange_, this),
      Ce(
        t,
        xa.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ]);
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(e, t) {
    let n = !0;
    if (t.getId() !== void 0) {
      const r = String(t.getId());
      if (!(r in this.idIndex_))
        this.idIndex_[r] = t;
      else if (t instanceof fi) {
        const s = this.idIndex_[r];
        s instanceof fi ? Array.isArray(s) ? s.push(t) : this.idIndex_[r] = [s, t] : n = !1;
      } else
        n = !1;
    }
    return n && (Te(
      !(e in this.uidIndex_),
      "The passed `feature` was already added to the source"
    ), this.uidIndex_[e] = t), n;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<FeatureType>} features Features to add.
   * @api
   */
  addFeatures(e) {
    this.addFeaturesInternal(e), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureType>} features Features.
   * @protected
   */
  addFeaturesInternal(e) {
    const t = [], n = [], r = [];
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s], l = ie(a);
      this.addToIndex_(l, a) && n.push(a);
    }
    for (let s = 0, o = n.length; s < o; s++) {
      const a = n[s], l = ie(a);
      this.setupChangeEvents_(l, a);
      const h = a.getGeometry();
      if (h) {
        const u = h.getExtent();
        t.push(u), r.push(a);
      } else
        this.nullGeometryFeatures_[l] = a;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(t, r), this.hasListener(Bt.ADDFEATURE))
      for (let s = 0, o = n.length; s < o; s++)
        this.dispatchEvent(
          new Kr(Bt.ADDFEATURE, n[s])
        );
  }
  /**
   * @param {!Collection<FeatureType>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(e) {
    let t = !1;
    this.addEventListener(
      Bt.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(n) {
        t || (t = !0, e.push(n.feature), t = !1);
      }
    ), this.addEventListener(
      Bt.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(n) {
        t || (t = !0, e.remove(n.feature), t = !1);
      }
    ), e.addEventListener(
      ki.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (n) => {
        t || (t = !0, this.addFeature(n.element), t = !1);
      }
    ), e.addEventListener(
      ki.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (n) => {
        t || (t = !0, this.removeFeature(n.element), t = !1);
      }
    ), this.featuresCollection_ = e;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(e) {
    if (e) {
      for (const n in this.featureChangeKeys_)
        this.featureChangeKeys_[n].forEach(tt);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      this.featuresRtree_.forEach((n) => {
        this.removeFeatureInternal(n);
      });
      for (const n in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[n]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const t = new Kr(Bt.CLEAR);
    this.dispatchEvent(t), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureType): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(e) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(e);
    this.featuresCollection_ && this.featuresCollection_.forEach(e);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(e, t) {
    const n = [e[0], e[1], e[0], e[1]];
    return this.forEachFeatureInExtent(n, function(r) {
      const s = r.getGeometry();
      if (s instanceof fi || s.intersectsCoordinate(e))
        return t(r);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(e, t) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(e, t);
    this.featuresCollection_ && this.featuresCollection_.forEach(t);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(e, t) {
    return this.forEachFeatureInExtent(
      e,
      /**
       * @param {FeatureType} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(n) {
        const r = n.getGeometry();
        if (r instanceof fi || r.intersectsExtent(e)) {
          const s = t(n);
          if (s)
            return s;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with a {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureType>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    let e;
    return this.featuresCollection_ ? e = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (e = this.featuresRtree_.getAll(), Ur(this.nullGeometryFeatures_) || ze(e, Object.values(this.nullGeometryFeatures_))), e;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesAtCoordinate(e) {
    const t = [];
    return this.forEachFeatureAtCoordinateDirect(e, function(n) {
      t.push(n);
    }), t;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(e, t) {
    if (this.featuresRtree_) {
      if (!(t && t.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(e);
      const r = Wp(e, t);
      return [].concat(
        ...r.map((s) => this.featuresRtree_.getInExtent(s))
      );
    }
    return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureType|null} Closest feature (or `null` if none found).
   * @api
   */
  getClosestFeatureToCoordinate(e, t) {
    const n = e[0], r = e[1];
    let s = null;
    const o = [NaN, NaN];
    let a = 1 / 0;
    const l = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return t = t || Wl, this.featuresRtree_.forEachInExtent(
      l,
      /**
       * @param {FeatureType} feature Feature.
       */
      function(h) {
        if (t(h)) {
          const u = h.getGeometry(), c = a;
          if (a = u instanceof fi ? 0 : u.closestPointXY(n, r, o, a), a < c) {
            s = h;
            const f = Math.sqrt(a);
            l[0] = n - f, l[1] = r - f, l[2] = n + f, l[3] = r + f;
          }
        }
      }
    ), s;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(e) {
    return this.featuresRtree_.getExtent(e);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(e) {
    const t = this.idIndex_[e.toString()];
    return t !== void 0 ? (
      /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
      t
    ) : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureType|null} The feature (or `null` if not found).
   */
  getFeatureByUid(e) {
    const t = this.uidIndex_[e];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default<FeatureType>|null}} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(e) {
    const t = (
      /** @type {FeatureType} */
      e.target
    ), n = ie(t), r = t.getGeometry();
    if (!r)
      n in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(t), this.nullGeometryFeatures_[n] = t);
    else {
      const o = r.getExtent();
      n in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[n], this.featuresRtree_ && this.featuresRtree_.insert(o, t)) : this.featuresRtree_ && this.featuresRtree_.update(o, t);
    }
    const s = t.getId();
    if (s !== void 0) {
      const o = s.toString();
      this.idIndex_[o] !== t && (this.removeFromIdIndex_(t), this.idIndex_[o] = t);
    } else
      this.removeFromIdIndex_(t), this.uidIndex_[n] = t;
    this.changed(), this.dispatchEvent(
      new Kr(Bt.CHANGEFEATURE, t)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureType} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(e) {
    const t = e.getId();
    return t !== void 0 ? t in this.idIndex_ : ie(e) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && Ur(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(e, t, n) {
    const r = this.loadedExtentsRtree_, s = this.strategy_(e, t, n);
    for (let o = 0, a = s.length; o < a; ++o) {
      const l = s[o];
      r.forEachInExtent(
        l,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(u) {
          return Bi(u.extent, l);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new Kr(Bt.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        l,
        t,
        n,
        /**
         * @param {Array<FeatureType>} features Loaded features
         */
        (u) => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new Kr(
              Bt.FEATURESLOADEND,
              void 0,
              u
            )
          );
        },
        () => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new Kr(Bt.FEATURESLOADERROR)
          );
        }
      ), r.insert(l, { extent: l.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  /**
   * @override
   */
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(e) {
    const t = this.loadedExtentsRtree_, n = t.forEachInExtent(e, function(r) {
      if (Pn(r.extent, e))
        return r;
    });
    n && t.remove(n);
  }
  /**
   * Batch remove features from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {Array<FeatureType>} features Features to remove.
   * @api
   */
  removeFeatures(e) {
    let t = !1;
    for (let n = 0, r = e.length; n < r; ++n)
      t = this.removeFeatureInternal(e[n]) || t;
    t && this.changed();
  }
  /**
   * Remove a single feature from the source. If you want to batch remove
   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
   * instead.
   * @param {FeatureType} feature Feature to remove.
   * @api
   */
  removeFeature(e) {
    if (!e)
      return;
    this.removeFeatureInternal(e) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @return {boolean} True if the feature was removed, false if it was not found.
   * @protected
   */
  removeFeatureInternal(e) {
    const t = ie(e);
    if (!(t in this.uidIndex_))
      return !1;
    t in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[t] : this.featuresRtree_ && this.featuresRtree_.remove(e), this.featureChangeKeys_[t]?.forEach(tt), delete this.featureChangeKeys_[t];
    const r = e.getId();
    if (r !== void 0) {
      const s = r.toString(), o = this.idIndex_[s];
      o === e ? delete this.idIndex_[s] : Array.isArray(o) && (o.splice(o.indexOf(e), 1), o.length === 1 && (this.idIndex_[s] = o[0]));
    }
    return delete this.uidIndex_[t], this.hasListener(Bt.REMOVEFEATURE) && this.dispatchEvent(
      new Kr(Bt.REMOVEFEATURE, e)
    ), !0;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureType} feature The feature.
   * @private
   */
  removeFromIdIndex_(e) {
    for (const t in this.idIndex_)
      if (this.idIndex_[t] === e) {
        delete this.idIndex_[t];
        break;
      }
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(e) {
    Te(this.format_, "`format` must be set when `url` is set"), this.url_ = e, this.setLoader(Dy(e, this.format_));
  }
  /**
   * @param {boolean} overlaps The source can have overlapping geometries.
   */
  setOverlaps(e) {
    this.overlaps_ = e, this.changed();
  }
}
const Xe = {
  ANIMATING: 0,
  INTERACTING: 1
}, pe = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, mu = [pe.FILL], ds = [pe.STROKE], Hs = [pe.BEGIN_PATH], zy = [pe.CLOSE_PATH];
class Fh extends Jv {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, r) {
    super(), this.tolerance = e, this.maxExtent = t, this.pixelRatio = r, this.maxLineWidth = 0, this.resolution = n, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(e) {
    const t = this.pixelRatio;
    return t == 1 ? e : e.map(function(n) {
      return n * t;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(e, t) {
    const n = this.getBufferedMaxExtent(), r = this.tmpCoordinate_, s = this.coordinates;
    let o = s.length;
    for (let a = 0, l = e.length; a < l; a += t)
      r[0] = e[a], r[1] = e[a + 1], nn(n, r) && (s[o++] = r[0], s[o++] = r[1]);
    return o;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(e, t, n, r, s, o) {
    const a = this.coordinates;
    let l = a.length;
    const h = this.getBufferedMaxExtent();
    o && (t += r);
    let u = e[t], c = e[t + 1];
    const f = this.tmpCoordinate_;
    let g = !0, d, m, x;
    for (d = t + r; d < n; d += r)
      f[0] = e[d], f[1] = e[d + 1], x = Tg(h, f), x !== m ? (g && (a[l++] = u, a[l++] = c, g = !1), a[l++] = f[0], a[l++] = f[1]) : x === ri.INTERSECTING ? (a[l++] = f[0], a[l++] = f[1], g = !1) : g = !0, u = f[0], c = f[1], m = x;
    return (s && g || d === t + r) && (a[l++] = u, a[l++] = c), l;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(e, t, n, r, s) {
    for (let o = 0, a = n.length; o < a; ++o) {
      const l = n[o], h = this.appendFlatLineCoordinates(
        e,
        t,
        l,
        r,
        !1,
        !1
      );
      s.push(h), t = l;
    }
    return t;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   * @override
   */
  drawCustom(e, t, n, r, s) {
    this.beginGeometry(e, t, s);
    const o = e.getType(), a = e.getStride(), l = this.coordinates.length;
    let h, u, c, f, g;
    switch (o) {
      case "MultiPolygon":
        h = /** @type {import("../../geom/MultiPolygon.js").default} */
        e.getOrientedFlatCoordinates(), f = [];
        const d = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        g = 0;
        for (let m = 0, x = d.length; m < x; ++m) {
          const v = [];
          g = this.drawCustomCoordinates_(
            h,
            g,
            d[m],
            a,
            v
          ), f.push(v);
        }
        this.instructions.push([
          pe.CUSTOM,
          l,
          f,
          e,
          n,
          Ng,
          s
        ]), this.hitDetectionInstructions.push([
          pe.CUSTOM,
          l,
          f,
          e,
          r || n,
          Ng,
          s
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        c = [], h = o == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          e.getOrientedFlatCoordinates()
        ) : e.getFlatCoordinates(), g = this.drawCustomCoordinates_(
          h,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          e.getEnds(),
          a,
          c
        ), this.instructions.push([
          pe.CUSTOM,
          l,
          c,
          e,
          n,
          Kl,
          s
        ]), this.hitDetectionInstructions.push([
          pe.CUSTOM,
          l,
          c,
          e,
          r || n,
          Kl,
          s
        ]);
        break;
      case "LineString":
      case "Circle":
        h = e.getFlatCoordinates(), u = this.appendFlatLineCoordinates(
          h,
          0,
          h.length,
          a,
          !1,
          !1
        ), this.instructions.push([
          pe.CUSTOM,
          l,
          u,
          e,
          n,
          cs,
          s
        ]), this.hitDetectionInstructions.push([
          pe.CUSTOM,
          l,
          u,
          e,
          r || n,
          cs,
          s
        ]);
        break;
      case "MultiPoint":
        h = e.getFlatCoordinates(), u = this.appendFlatPointCoordinates(h, a), u > l && (this.instructions.push([
          pe.CUSTOM,
          l,
          u,
          e,
          n,
          cs,
          s
        ]), this.hitDetectionInstructions.push([
          pe.CUSTOM,
          l,
          u,
          e,
          r || n,
          cs,
          s
        ]));
        break;
      case "Point":
        h = e.getFlatCoordinates(), this.coordinates.push(h[0], h[1]), u = this.coordinates.length, this.instructions.push([
          pe.CUSTOM,
          l,
          u,
          e,
          n,
          void 0,
          s
        ]), this.hitDetectionInstructions.push([
          pe.CUSTOM,
          l,
          u,
          e,
          r || n,
          void 0,
          s
        ]);
        break;
    }
    this.endGeometry(t);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} index Render order index
   */
  beginGeometry(e, t, n) {
    this.beginGeometryInstruction1_ = [
      pe.BEGIN_GEOMETRY,
      t,
      0,
      e,
      n
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      pe.BEGIN_GEOMETRY,
      t,
      0,
      e,
      n
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const e = this.hitDetectionInstructions;
    e.reverse();
    let t;
    const n = e.length;
    let r, s, o = -1;
    for (t = 0; t < n; ++t)
      r = e[t], s = /** @type {import("./Instruction.js").default} */
      r[0], s == pe.END_GEOMETRY ? o = t : s == pe.BEGIN_GEOMETRY && (r[2] = t, bT(this.hitDetectionInstructions, o, t), o = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import('../canvas.js').FillStrokeState} [state] State.
   * @return {import('../canvas.js').FillStrokeState} State.
   */
  fillStyleToState(e, t = (
    /** @type {import('../canvas.js').FillStrokeState} */
    {}
  )) {
    if (e) {
      const n = e.getColor();
      t.fillPatternScale = n && typeof n == "object" && "src" in n ? this.pixelRatio : 1, t.fillStyle = ar(
        n || Gi
      );
    } else
      t.fillStyle = void 0;
    return t;
  }
  /**
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {import("../canvas.js").FillStrokeState} State.
   */
  strokeStyleToState(e, t = (
    /** @type {import('../canvas.js').FillStrokeState} */
    {}
  )) {
    if (e) {
      const n = e.getColor();
      t.strokeStyle = ar(
        n || Ql
      );
      const r = e.getLineCap();
      t.lineCap = r !== void 0 ? r : ba;
      const s = e.getLineDash();
      t.lineDash = s ? s.slice() : Dr;
      const o = e.getLineDashOffset();
      t.lineDashOffset = o || Gr;
      const a = e.getLineJoin();
      t.lineJoin = a !== void 0 ? a : Sa;
      const l = e.getWidth();
      t.lineWidth = l !== void 0 ? l : th;
      const h = e.getMiterLimit();
      t.miterLimit = h !== void 0 ? h : Jl, t.lineWidth > this.maxLineWidth && (this.maxLineWidth = t.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      t.strokeStyle = void 0, t.lineCap = void 0, t.lineDash = null, t.lineDashOffset = void 0, t.lineJoin = void 0, t.lineWidth = void 0, t.miterLimit = void 0;
    return t;
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @override
   */
  setFillStrokeStyle(e, t) {
    const n = this.state;
    this.fillStyleToState(e, n), this.strokeStyleToState(t, n);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(e) {
    const t = e.fillStyle, n = [pe.SET_FILL_STYLE, t];
    return typeof t != "string" && n.push(e.fillPatternScale), n;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    this.instructions.push(this.createStroke(e));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(e) {
    return [
      pe.SET_STROKE_STYLE,
      e.strokeStyle,
      e.lineWidth * this.pixelRatio,
      e.lineCap,
      e.lineJoin,
      e.miterLimit,
      e.lineDash ? this.applyPixelRatio(e.lineDash) : null,
      e.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(e, t) {
    const n = e.fillStyle;
    (typeof n != "string" || e.currentFillStyle != n) && (this.instructions.push(t.call(this, e)), e.currentFillStyle = n);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(e, t) {
    const n = e.strokeStyle, r = e.lineCap, s = e.lineDash, o = e.lineDashOffset, a = e.lineJoin, l = e.lineWidth, h = e.miterLimit;
    (e.currentStrokeStyle != n || e.currentLineCap != r || s != e.currentLineDash && !Xr(e.currentLineDash, s) || e.currentLineDashOffset != o || e.currentLineJoin != a || e.currentLineWidth != l || e.currentMiterLimit != h) && (t.call(this, e), e.currentStrokeStyle = n, e.currentLineCap = r, e.currentLineDash = s, e.currentLineDashOffset = o, e.currentLineJoin = a, e.currentLineWidth = l, e.currentMiterLimit = h);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(e) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const t = [pe.END_GEOMETRY, e];
    this.instructions.push(t), this.hitDetectionInstructions.push(t);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = mE(this.maxExtent), this.maxLineWidth > 0)) {
      const e = this.resolution * (this.maxLineWidth + 1) / 2;
      ln(this.bufferedMaxExtent_, e, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
class wL extends Fh {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawPoint(e, t, n) {
    if (!this.image_ || this.maxExtent && !nn(this.maxExtent, e.getFlatCoordinates()))
      return;
    this.beginGeometry(e, t, n);
    const r = e.getFlatCoordinates(), s = e.getStride(), o = this.coordinates.length, a = this.appendFlatPointCoordinates(r, s);
    this.instructions.push([
      pe.DRAW_IMAGE,
      o,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      pe.DRAW_IMAGE,
      o,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawMultiPoint(e, t, n) {
    if (!this.image_)
      return;
    this.beginGeometry(e, t, n);
    const r = e.getFlatCoordinates(), s = [];
    for (let l = 0, h = r.length; l < h; l += e.getStride())
      (!this.maxExtent || nn(this.maxExtent, r.slice(l, l + 2))) && s.push(
        r[l],
        r[l + 1]
      );
    const o = this.coordinates.length, a = this.appendFlatPointCoordinates(s, 2);
    this.instructions.push([
      pe.DRAW_IMAGE,
      o,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      pe.DRAW_IMAGE,
      o,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   * @override
   */
  setImageStyle(e, t) {
    const n = e.getAnchor(), r = e.getSize(), s = e.getOrigin();
    this.imagePixelRatio_ = e.getPixelRatio(this.pixelRatio), this.anchorX_ = n[0], this.anchorY_ = n[1], this.hitDetectionImage_ = e.getHitDetectionImage(), this.image_ = e.getImage(this.pixelRatio), this.height_ = r[1], this.opacity_ = e.getOpacity(), this.originX_ = s[0], this.originY_ = s[1], this.rotateWithView_ = e.getRotateWithView(), this.rotation_ = e.getRotation(), this.scale_ = e.getScaleArray(), this.width_ = r[0], this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = t;
  }
}
class bL extends Fh {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(e, t, n, r) {
    const s = this.coordinates.length, o = this.appendFlatLineCoordinates(
      e,
      t,
      n,
      r,
      !1,
      !1
    ), a = [
      pe.MOVE_TO_LINE_TO,
      s,
      o
    ];
    return this.instructions.push(a), this.hitDetectionInstructions.push(a), n;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawLineString(e, t, n) {
    const r = this.state, s = r.strokeStyle, o = r.lineWidth;
    if (s === void 0 || o === void 0)
      return;
    this.updateStrokeStyle(r, this.applyStroke), this.beginGeometry(e, t, n), this.hitDetectionInstructions.push(
      [
        pe.SET_STROKE_STYLE,
        r.strokeStyle,
        r.lineWidth,
        r.lineCap,
        r.lineJoin,
        r.miterLimit,
        Dr,
        Gr
      ],
      Hs
    );
    const a = e.getFlatCoordinates(), l = e.getStride();
    this.drawFlatCoordinates_(
      a,
      0,
      a.length,
      l
    ), this.hitDetectionInstructions.push(ds), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawMultiLineString(e, t, n) {
    const r = this.state, s = r.strokeStyle, o = r.lineWidth;
    if (s === void 0 || o === void 0)
      return;
    this.updateStrokeStyle(r, this.applyStroke), this.beginGeometry(e, t, n), this.hitDetectionInstructions.push(
      [
        pe.SET_STROKE_STYLE,
        r.strokeStyle,
        r.lineWidth,
        r.lineCap,
        r.lineJoin,
        r.miterLimit,
        Dr,
        Gr
      ],
      Hs
    );
    const a = e.getEnds(), l = e.getFlatCoordinates(), h = e.getStride();
    let u = 0;
    for (let c = 0, f = a.length; c < f; ++c)
      u = this.drawFlatCoordinates_(
        l,
        u,
        /** @type {number} */
        a[c],
        h
      );
    this.hitDetectionInstructions.push(ds), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    const e = this.state;
    return e.lastStroke != null && e.lastStroke != this.coordinates.length && this.instructions.push(ds), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @override
   */
  applyStroke(e) {
    e.lastStroke != null && e.lastStroke != this.coordinates.length && (this.instructions.push(ds), e.lastStroke = this.coordinates.length), e.lastStroke = 0, super.applyStroke(e), this.instructions.push(Hs);
  }
}
class By extends Fh {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(e, t, n, r) {
    const s = this.state, o = s.fillStyle !== void 0, a = s.strokeStyle !== void 0, l = n.length;
    this.instructions.push(Hs), this.hitDetectionInstructions.push(Hs);
    for (let h = 0; h < l; ++h) {
      const u = n[h], c = this.coordinates.length, f = this.appendFlatLineCoordinates(
        e,
        t,
        u,
        r,
        !0,
        !a
      ), g = [
        pe.MOVE_TO_LINE_TO,
        c,
        f
      ];
      this.instructions.push(g), this.hitDetectionInstructions.push(g), a && (this.instructions.push(zy), this.hitDetectionInstructions.push(zy)), t = u;
    }
    return o && (this.instructions.push(mu), this.hitDetectionInstructions.push(mu)), a && (this.instructions.push(ds), this.hitDetectionInstructions.push(ds)), t;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawCircle(e, t, n) {
    const r = this.state, s = r.fillStyle, o = r.strokeStyle;
    if (s === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, n), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      pe.SET_FILL_STYLE,
      Gi
    ]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      pe.SET_STROKE_STYLE,
      r.strokeStyle,
      r.lineWidth,
      r.lineCap,
      r.lineJoin,
      r.miterLimit,
      Dr,
      Gr
    ]);
    const a = e.getFlatCoordinates(), l = e.getStride(), h = this.coordinates.length;
    this.appendFlatLineCoordinates(
      a,
      0,
      a.length,
      l,
      !1,
      !1
    );
    const u = [pe.CIRCLE, h];
    this.instructions.push(Hs, u), this.hitDetectionInstructions.push(Hs, u), r.fillStyle !== void 0 && (this.instructions.push(mu), this.hitDetectionInstructions.push(mu)), r.strokeStyle !== void 0 && (this.instructions.push(ds), this.hitDetectionInstructions.push(ds)), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawPolygon(e, t, n) {
    const r = this.state, s = r.fillStyle, o = r.strokeStyle;
    if (s === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, n), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      pe.SET_FILL_STYLE,
      Gi
    ]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      pe.SET_STROKE_STYLE,
      r.strokeStyle,
      r.lineWidth,
      r.lineCap,
      r.lineJoin,
      r.miterLimit,
      Dr,
      Gr
    ]);
    const a = e.getEnds(), l = e.getOrientedFlatCoordinates(), h = e.getStride();
    this.drawFlatCoordinatess_(
      l,
      0,
      /** @type {Array<number>} */
      a,
      h
    ), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawMultiPolygon(e, t, n) {
    const r = this.state, s = r.fillStyle, o = r.strokeStyle;
    if (s === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, n), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      pe.SET_FILL_STYLE,
      Gi
    ]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      pe.SET_STROKE_STYLE,
      r.strokeStyle,
      r.lineWidth,
      r.lineCap,
      r.lineJoin,
      r.miterLimit,
      Dr,
      Gr
    ]);
    const a = e.getEndss(), l = e.getOrientedFlatCoordinates(), h = e.getStride();
    let u = 0;
    for (let c = 0, f = a.length; c < f; ++c)
      u = this.drawFlatCoordinatess_(
        l,
        u,
        a[c],
        h
      );
    this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const e = this.tolerance;
    if (e !== 0) {
      const t = this.coordinates;
      for (let n = 0, r = t.length; n < r; ++n)
        t[n] = zs(t[n], e);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const e = this.state;
    this.updateFillStyle(e, this.createFill), this.updateStrokeStyle(e, this.applyStroke);
  }
}
function SL(i, e, t, n, r) {
  const s = [];
  let o = t, a = 0, l = e.slice(t, 2);
  for (; a < i && o + r < n; ) {
    const [h, u] = l.slice(-2), c = e[o + r], f = e[o + r + 1], g = Math.sqrt(
      (c - h) * (c - h) + (f - u) * (f - u)
    );
    if (a += g, a >= i) {
      const d = (i - a + g) / g, m = Ji(h, c, d), x = Ji(u, f, d);
      l.push(m, x), s.push(l), l = [m, x], a == i && (o += r), a = 0;
    } else if (a < i)
      l.push(
        e[o + r],
        e[o + r + 1]
      ), o += r;
    else {
      const d = g - a, m = Ji(h, c, d / g), x = Ji(u, f, d / g);
      l.push(m, x), s.push(l), l = [m, x], a = 0, o += r;
    }
  }
  return a > 0 && s.push(l), s;
}
function TL(i, e, t, n, r) {
  let s = t, o = t, a = 0, l = 0, h = t, u, c, f, g, d, m, x, v, p, y;
  for (c = t; c < n; c += r) {
    const E = e[c], b = e[c + 1];
    d !== void 0 && (p = E - d, y = b - m, g = Math.sqrt(p * p + y * y), x !== void 0 && (l += f, u = Math.acos((x * p + v * y) / (f * g)), u > i && (l > a && (a = l, s = h, o = c), l = 0, h = c - r)), f = g, x = p, v = y), d = E, m = b;
  }
  return l += g, l > a ? [h, c] : [s, o];
}
const Sc = {
  left: 0,
  center: 0.5,
  right: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class RL extends Fh {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textKeepUpright_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[Gi] = { fillStyle: Gi }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   * @override
   */
  finish() {
    const e = super.finish();
    return e.textStates = this.textStates, e.fillStates = this.fillStates, e.strokeStates = this.strokeStates, e;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   * @override
   */
  drawText(e, t, n) {
    const r = this.textFillState_, s = this.textStrokeState_, o = this.textState_;
    if (this.text_ === "" || !o || !r && !s)
      return;
    const a = this.coordinates;
    let l = a.length;
    const h = e.getType();
    let u = null, c = e.getStride();
    if (o.placement === "line" && (h == "LineString" || h == "MultiLineString" || h == "Polygon" || h == "MultiPolygon")) {
      if (!ft(this.maxExtent, e.getExtent()))
        return;
      let f;
      if (u = e.getFlatCoordinates(), h == "LineString")
        f = [u.length];
      else if (h == "MultiLineString")
        f = /** @type {import("../../geom/MultiLineString.js").default} */
        e.getEnds();
      else if (h == "Polygon")
        f = /** @type {import("../../geom/Polygon.js").default} */
        e.getEnds().slice(0, 1);
      else if (h == "MultiPolygon") {
        const x = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        f = [];
        for (let v = 0, p = x.length; v < p; ++v)
          f.push(x[v][0]);
      }
      this.beginGeometry(e, t, n);
      const g = o.repeat, d = g ? void 0 : o.textAlign;
      let m = 0;
      for (let x = 0, v = f.length; x < v; ++x) {
        let p;
        g ? p = SL(
          g * this.resolution,
          u,
          m,
          f[x],
          c
        ) : p = [u.slice(m, f[x])];
        for (let y = 0, E = p.length; y < E; ++y) {
          const b = p[y];
          let T = 0, R = b.length;
          if (d == null) {
            const C = TL(
              o.maxAngle,
              b,
              0,
              b.length,
              2
            );
            T = C[0], R = C[1];
          }
          for (let C = T; C < R; C += c)
            a.push(b[C], b[C + 1]);
          const M = a.length;
          m = f[x], this.drawChars_(l, M), l = M;
        }
      }
      this.endGeometry(t);
    } else {
      let f = o.overflow ? null : [];
      switch (h) {
        case "Point":
        case "MultiPoint":
          u = /** @type {import("../../geom/MultiPoint.js").default} */
          e.getFlatCoordinates();
          break;
        case "LineString":
          u = /** @type {import("../../geom/LineString.js").default} */
          e.getFlatMidpoint();
          break;
        case "Circle":
          u = /** @type {import("../../geom/Circle.js").default} */
          e.getCenter();
          break;
        case "MultiLineString":
          u = /** @type {import("../../geom/MultiLineString.js").default} */
          e.getFlatMidpoints(), c = 2;
          break;
        case "Polygon":
          u = /** @type {import("../../geom/Polygon.js").default} */
          e.getFlatInteriorPoint(), o.overflow || f.push(u[2] / this.resolution), c = 3;
          break;
        case "MultiPolygon":
          const E = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            e.getFlatInteriorPoints()
          );
          u = [];
          for (let b = 0, T = E.length; b < T; b += 3)
            o.overflow || f.push(E[b + 2] / this.resolution), u.push(E[b], E[b + 1]);
          if (u.length === 0)
            return;
          c = 2;
          break;
      }
      const g = this.appendFlatPointCoordinates(u, c);
      if (g === l)
        return;
      if (f && (g - l) / 2 !== u.length / c) {
        let E = l / 2;
        f = f.filter((b, T) => {
          const R = a[(E + T) * 2] === u[T * c] && a[(E + T) * 2 + 1] === u[T * c + 1];
          return R || --E, R;
        });
      }
      this.saveTextStates_();
      const d = o.backgroundFill ? this.createFill(this.fillStyleToState(o.backgroundFill)) : null, m = o.backgroundStroke ? this.createStroke(this.strokeStyleToState(o.backgroundStroke)) : null;
      this.beginGeometry(e, t, n);
      let x = o.padding;
      if (x != qs && (o.scale[0] < 0 || o.scale[1] < 0)) {
        let E = o.padding[0], b = o.padding[1], T = o.padding[2], R = o.padding[3];
        o.scale[0] < 0 && (b = -b, R = -R), o.scale[1] < 0 && (E = -E, T = -T), x = [E, b, T, R];
      }
      const v = this.pixelRatio;
      this.instructions.push([
        pe.DRAW_IMAGE,
        l,
        g,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        x == qs ? qs : x.map(function(E) {
          return E * v;
        }),
        d,
        m,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        f
      ]);
      const p = 1 / v, y = d ? d.slice(0) : null;
      y && (y[1] = Gi), this.hitDetectionInstructions.push([
        pe.DRAW_IMAGE,
        l,
        g,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [p, p],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        x,
        y,
        m,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_ ? Gi : this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        f
      ]), this.endGeometry(t);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const e = this.textStrokeState_, t = this.textState_, n = this.textFillState_, r = this.strokeKey_;
    e && (r in this.strokeStates || (this.strokeStates[r] = {
      strokeStyle: e.strokeStyle,
      lineCap: e.lineCap,
      lineDashOffset: e.lineDashOffset,
      lineWidth: e.lineWidth,
      lineJoin: e.lineJoin,
      miterLimit: e.miterLimit,
      lineDash: e.lineDash
    }));
    const s = this.textKey_;
    s in this.textStates || (this.textStates[s] = {
      font: t.font,
      textAlign: t.textAlign || eh,
      justify: t.justify,
      textBaseline: t.textBaseline || _c,
      scale: t.scale
    });
    const o = this.fillKey_;
    n && (o in this.fillStates || (this.fillStates[o] = {
      fillStyle: n.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(e, t) {
    const n = this.textStrokeState_, r = this.textState_, s = this.strokeKey_, o = this.textKey_, a = this.fillKey_;
    this.saveTextStates_();
    const l = this.pixelRatio, h = Sc[r.textBaseline], u = this.textOffsetY_ * l, c = this.text_, f = n ? n.lineWidth * Math.abs(r.scale[0]) / 2 : 0;
    this.instructions.push([
      pe.DRAW_CHARS,
      e,
      t,
      h,
      r.overflow,
      a,
      r.maxAngle,
      l,
      u,
      s,
      f * l,
      c,
      o,
      1,
      this.declutterMode_,
      this.textKeepUpright_
    ]), this.hitDetectionInstructions.push([
      pe.DRAW_CHARS,
      e,
      t,
      h,
      r.overflow,
      a && Gi,
      r.maxAngle,
      l,
      u,
      s,
      f * l,
      c,
      o,
      1 / l,
      this.declutterMode_,
      this.textKeepUpright_
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   * @override
   */
  setTextStyle(e, t) {
    let n, r, s;
    if (!e)
      this.text_ = "";
    else {
      const o = e.getFill();
      o ? (r = this.textFillState_, r || (r = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = r), r.fillStyle = ar(
        o.getColor() || Gi
      )) : (r = null, this.textFillState_ = r);
      const a = e.getStroke();
      if (!a)
        s = null, this.textStrokeState_ = s;
      else {
        s = this.textStrokeState_, s || (s = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = s);
        const m = a.getLineDash(), x = a.getLineDashOffset(), v = a.getWidth(), p = a.getMiterLimit();
        s.lineCap = a.getLineCap() || ba, s.lineDash = m ? m.slice() : Dr, s.lineDashOffset = x === void 0 ? Gr : x, s.lineJoin = a.getLineJoin() || Sa, s.lineWidth = v === void 0 ? th : v, s.miterLimit = p === void 0 ? Jl : p, s.strokeStyle = ar(
          a.getColor() || Ql
        );
      }
      n = this.textState_;
      const l = e.getFont() || sv;
      AP(l);
      const h = e.getScaleArray();
      n.overflow = e.getOverflow(), n.font = l, n.maxAngle = e.getMaxAngle(), n.placement = e.getPlacement(), n.textAlign = e.getTextAlign(), n.repeat = e.getRepeat(), n.justify = e.getJustify(), n.textBaseline = e.getTextBaseline() || _c, n.backgroundFill = e.getBackgroundFill(), n.backgroundStroke = e.getBackgroundStroke(), n.padding = e.getPadding() || qs, n.scale = h === void 0 ? [1, 1] : h;
      const u = e.getOffsetX(), c = e.getOffsetY(), f = e.getRotateWithView(), g = e.getKeepUpright(), d = e.getRotation();
      this.text_ = e.getText() || "", this.textOffsetX_ = u === void 0 ? 0 : u, this.textOffsetY_ = c === void 0 ? 0 : c, this.textRotateWithView_ = f === void 0 ? !1 : f, this.textKeepUpright_ = g === void 0 ? !0 : g, this.textRotation_ = d === void 0 ? 0 : d, this.strokeKey_ = s ? (typeof s.strokeStyle == "string" ? s.strokeStyle : ie(s.strokeStyle)) + s.lineCap + s.lineDashOffset + "|" + s.lineWidth + s.lineJoin + s.miterLimit + "[" + s.lineDash.join() + "]" : "", this.textKey_ = n.font + n.scale + (n.textAlign || "?") + (n.repeat || "?") + (n.justify || "?") + (n.textBaseline || "?"), this.fillKey_ = r && r.fillStyle ? typeof r.fillStyle == "string" ? r.fillStyle : "|" + ie(r.fillStyle) : "";
    }
    this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = t;
  }
}
const PL = {
  Circle: By,
  Default: Fh,
  Image: wL,
  LineString: bL,
  Polygon: By,
  Text: RL
};
class ow {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, r) {
    this.tolerance_ = e, this.maxExtent_ = t, this.pixelRatio_ = r, this.resolution_ = n, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const e = {};
    for (const t in this.buildersByZIndex_) {
      e[t] = e[t] || {};
      const n = this.buildersByZIndex_[t];
      for (const r in n) {
        const s = n[r].finish();
        e[t][r] = s;
      }
    }
    return e;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(e, t) {
    const n = e !== void 0 ? e.toString() : "0";
    let r = this.buildersByZIndex_[n];
    r === void 0 && (r = {}, this.buildersByZIndex_[n] = r);
    let s = r[t];
    if (s === void 0) {
      const o = PL[t];
      s = new o(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), r[t] = s;
    }
    return s;
  }
}
function ML(i, e, t, n, r, s, o, a, l, h, u, c, f = !0) {
  let g = i[e], d = i[e + 1], m = 0, x = 0, v = 0, p = 0;
  function y() {
    m = g, x = d, e += n, g = i[e], d = i[e + 1], p += v, v = Math.sqrt((g - m) * (g - m) + (d - x) * (d - x));
  }
  do
    y();
  while (e < t - n && p + v < s);
  let E = v === 0 ? 0 : (s - p) / v;
  const b = Ji(m, g, E), T = Ji(x, d, E), R = e - n, M = p, C = s + a * l(h, r, u);
  for (; e < t - n && p + v < C; )
    y();
  E = v === 0 ? 0 : (C - p) / v;
  const I = Ji(m, g, E), O = Ji(x, d, E);
  let z = !1;
  if (f)
    if (c) {
      const A = [b, T, I, O];
      LE(A, 0, 4, 2, c, A, A), z = A[0] > A[2];
    } else
      z = b > I;
  const _ = Math.PI, w = [], S = R + n === e;
  e = R, v = 0, p = M, g = i[e], d = i[e + 1];
  let P;
  if (S) {
    y(), P = Math.atan2(d - x, g - m), z && (P += P > 0 ? -_ : _);
    const A = (I + b) / 2, D = (O + T) / 2;
    return w[0] = [A, D, (C - s) / 2, P, r], w;
  }
  r = r.replace(/\n/g, " ");
  for (let A = 0, D = r.length; A < D; ) {
    y();
    let k = Math.atan2(d - x, g - m);
    if (z && (k += k > 0 ? -_ : _), P !== void 0) {
      let te = k - P;
      if (te += te > _ ? -2 * _ : te < -_ ? 2 * _ : 0, Math.abs(te) > o)
        return null;
    }
    P = k;
    const U = A;
    let G = 0;
    for (; A < D; ++A) {
      const te = z ? D - A - 1 : A, re = a * l(h, r[te], u);
      if (e + n < t && p + v < s + G + re / 2)
        break;
      G += re;
    }
    if (A === U)
      continue;
    const $ = z ? r.substring(D - U, D - A) : r.substring(U, A);
    E = v === 0 ? 0 : (s + G / 2 - p) / v;
    const H = Ji(m, g, E), ne = Ji(x, d, E);
    w.push([H, ne, G / 2, k, $]), s += G;
  }
  return w;
}
class Um {
  constructor() {
    this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = /** @type {ZIndexContextProxy} */
    new Proxy(pc(), {
      get: (e, t) => {
        if (typeof /** @type {*} */
        pc()[t] == "function")
          return this.push_(t), this.pushMethodArgs_;
      },
      set: (e, t, n) => (this.push_(t, n), !0)
    });
  }
  /**
   * @param {...*} args Arguments to push to the instructions array.
   * @private
   */
  push_(...e) {
    const t = this.instructions_, n = this.zIndex + this.offset_;
    t[n] || (t[n] = []), t[n].push(...e);
  }
  /**
   * @private
   * @param {...*} args Args.
   * @return {ZIndexContext} This.
   */
  pushMethodArgs_ = (...e) => (this.push_(e), this);
  /**
   * Push a function that renders to the context directly.
   * @param {function(CanvasRenderingContext2D): void} render Function.
   */
  pushFunction(e) {
    this.push_(e);
  }
  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   */
  draw(e) {
    this.instructions_.forEach((t) => {
      for (let n = 0, r = t.length; n < r; ++n) {
        const s = t[n];
        if (typeof s == "function") {
          s(e);
          continue;
        }
        const o = t[++n];
        if (typeof /** @type {*} */
        e[s] == "function")
          e[s](...o);
        else {
          if (typeof o == "function") {
            e[s] = o(e);
            continue;
          }
          e[s] = o;
        }
      }
    });
  }
  clear() {
    this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
  }
  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length, this.zIndex = 0;
  }
}
const Mo = hi(), Jr = [], Sr = [], Tr = [], Qr = [];
function $y(i) {
  return i[3].declutterBox;
}
const jy = new RegExp(
  /* eslint-disable prettier/prettier */
  "[֑-ࣿיִ-﷿ﹰ-ﻼࠀ-࿿-]"
  /* eslint-enable prettier/prettier */
);
function Nd(i, e) {
  return e === "start" ? e = jy.test(i) ? "right" : "left" : e === "end" && (e = jy.test(i) ? "left" : "right"), Sc[e];
}
function CL(i, e, t) {
  return t > 0 && i.push(`
`, ""), i.push(e, ""), i;
}
function AL(i, e, t) {
  return t % 2 === 0 && (i += e), i;
}
class IL {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
   * @param {boolean} [deferredRendering] Enable deferred rendering.
   */
  constructor(e, t, n, r, s) {
    this.overlaps = n, this.pixelRatio = t, this.resolution = e, this.alignAndScaleFill_, this.instructions = r.instructions, this.coordinates = r.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = st(), this.hitDetectionInstructions = r.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = r.fillStates || {}, this.strokeStates = r.strokeStates || {}, this.textStates = r.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = s ? new Um() : null;
  }
  /**
   * @return {ZIndexContext} ZIndex context.
   */
  getZIndexContext() {
    return this.zIndexContext_;
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(e, t, n, r) {
    const s = e + t + n + r;
    if (this.labels_[s])
      return this.labels_[s];
    const o = r ? this.strokeStates[r] : null, a = n ? this.fillStates[n] : null, l = this.textStates[t], h = this.pixelRatio, u = [
      l.scale[0] * h,
      l.scale[1] * h
    ], c = l.justify ? Sc[l.justify] : Nd(
      Array.isArray(e) ? e[0] : e,
      l.textAlign || eh
    ), f = r && o.lineWidth ? o.lineWidth : 0, g = Array.isArray(e) ? e : String(e).split(`
`).reduce(CL, []), { width: d, height: m, widths: x, heights: v, lineWidths: p } = LP(
      l,
      g
    ), y = d + f, E = [], b = (y + 2) * u[0], T = (m + f) * u[1], R = {
      width: b < 0 ? Math.floor(b) : Math.ceil(b),
      height: T < 0 ? Math.floor(T) : Math.ceil(T),
      contextInstructions: E
    };
    (u[0] != 1 || u[1] != 1) && E.push("scale", u), r && (E.push("strokeStyle", o.strokeStyle), E.push("lineWidth", f), E.push("lineCap", o.lineCap), E.push("lineJoin", o.lineJoin), E.push("miterLimit", o.miterLimit), E.push("setLineDash", [o.lineDash]), E.push("lineDashOffset", o.lineDashOffset)), n && E.push("fillStyle", a.fillStyle), E.push("textBaseline", "middle"), E.push("textAlign", "center");
    const M = 0.5 - c;
    let C = c * y + M * f;
    const I = [], O = [];
    let z = 0, _ = 0, w = 0, S = 0, P;
    for (let A = 0, D = g.length; A < D; A += 2) {
      const k = g[A];
      if (k === `
`) {
        _ += z, z = 0, C = c * y + M * f, ++S;
        continue;
      }
      const U = g[A + 1] || l.font;
      U !== P && (r && I.push("font", U), n && O.push("font", U), P = U), z = Math.max(z, v[w]);
      const G = [
        k,
        C + M * x[w] + c * (x[w] - p[S]),
        0.5 * (f + z) + _
      ];
      C += x[w], r && I.push("strokeText", G), n && O.push("fillText", G), ++w;
    }
    return Array.prototype.push.apply(E, I), Array.prototype.push.apply(E, O), this.labels_[s] = R, R;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(e, t, n, r, s, o, a) {
    e.beginPath(), e.moveTo.apply(e, t), e.lineTo.apply(e, n), e.lineTo.apply(e, r), e.lineTo.apply(e, s), e.lineTo.apply(e, t), o && (this.alignAndScaleFill_ = /** @type {number} */
    o[2], e.fillStyle = /** @type {string} */
    o[1], this.fill_(e)), a && (this.setStrokeStyle_(
      e,
      /** @type {Array<*>} */
      a
    ), e.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(e, t, n, r, s, o, a, l, h, u, c, f, g, d, m, x) {
    a *= f[0], l *= f[1];
    let v = n - a, p = r - l;
    const y = s + h > e ? e - h : s, E = o + u > t ? t - u : o, b = d[3] + y * f[0] + d[1], T = d[0] + E * f[1] + d[2], R = v - d[3], M = p - d[0];
    (m || c !== 0) && (Jr[0] = R, Qr[0] = R, Jr[1] = M, Sr[1] = M, Sr[0] = R + b, Tr[0] = Sr[0], Tr[1] = M + T, Qr[1] = Tr[1]);
    let C;
    return c !== 0 ? (C = un(
      st(),
      n,
      r,
      1,
      1,
      c,
      -n,
      -r
    ), rt(C, Jr), rt(C, Sr), rt(C, Tr), rt(C, Qr), Xn(
      Math.min(Jr[0], Sr[0], Tr[0], Qr[0]),
      Math.min(Jr[1], Sr[1], Tr[1], Qr[1]),
      Math.max(Jr[0], Sr[0], Tr[0], Qr[0]),
      Math.max(Jr[1], Sr[1], Tr[1], Qr[1]),
      Mo
    )) : Xn(
      Math.min(R, R + b),
      Math.min(M, M + T),
      Math.max(R, R + b),
      Math.max(M, M + T),
      Mo
    ), g && (v = Math.round(v), p = Math.round(p)), {
      drawImageX: v,
      drawImageY: p,
      drawImageW: y,
      drawImageH: E,
      originX: h,
      originY: u,
      declutterBox: {
        minX: Mo[0],
        minY: Mo[1],
        maxX: Mo[2],
        maxY: Mo[3],
        value: x
      },
      canvasTransform: C,
      scale: f
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(e, t, n, r, s, o, a) {
    const l = !!(o || a), h = r.declutterBox, u = a ? a[2] * r.scale[0] / 2 : 0;
    return h.minX - u <= t[0] && h.maxX + u >= 0 && h.minY - u <= t[1] && h.maxY + u >= 0 && (l && this.replayTextBackground_(
      e,
      Jr,
      Sr,
      Tr,
      Qr,
      /** @type {Array<*>} */
      o,
      /** @type {Array<*>} */
      a
    ), FP(
      e,
      r.canvasTransform,
      s,
      n,
      r.originX,
      r.originY,
      r.drawImageW,
      r.drawImageH,
      r.drawImageX,
      r.drawImageY,
      r.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   */
  fill_(e) {
    const t = this.alignAndScaleFill_;
    if (t) {
      const n = rt(this.renderedTransform_, [0, 0]), r = 512 * this.pixelRatio;
      e.save(), e.translate(n[0] % r, n[1] % r), t !== 1 && e.scale(t, t), e.rotate(this.viewRotation_);
    }
    e.fill(), t && e.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(e, t) {
    e.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    t[1], t[1] && (e.lineWidth = /** @type {number} */
    t[2], e.lineCap = /** @type {CanvasLineCap} */
    t[3], e.lineJoin = /** @type {CanvasLineJoin} */
    t[4], e.miterLimit = /** @type {number} */
    t[5], e.lineDashOffset = /** @type {number} */
    t[7], e.setLineDash(
      /** @type {Array<number>} */
      t[6]
    ));
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(e, t, n, r) {
    const s = this.textStates[t], o = this.createLabel(e, t, r, n), a = this.strokeStates[n], l = this.pixelRatio, h = Nd(
      Array.isArray(e) ? e[0] : e,
      s.textAlign || eh
    ), u = Sc[s.textBaseline || _c], c = a && a.lineWidth ? a.lineWidth : 0, f = o.width / l - 2 * s.scale[0], g = h * f + 2 * (0.5 - h) * c, d = u * o.height / l + 2 * (0.5 - u) * c;
    return {
      label: o,
      anchorX: g,
      anchorY: d
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(e, t, n, r, s, o, a, l) {
    const h = this.zIndexContext_;
    let u;
    this.pixelCoordinates_ && Xr(n, this.renderedTransform_) ? u = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), u = hr(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      n,
      this.pixelCoordinates_
    ), IE(this.renderedTransform_, n));
    let c = 0;
    const f = r.length;
    let g = 0, d, m, x, v, p, y, E, b, T, R, M, C, I, O = 0, z = 0;
    const _ = this.coordinateCache_, w = this.viewRotation_, S = Math.round(Math.atan2(-n[1], n[0]) * 1e12) / 1e12, P = (
      /** @type {import("../../render.js").State} */
      {
        context: e,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: w
      }
    ), A = this.instructions != r || this.overlaps ? 0 : 200;
    let D, k, U, G;
    for (; c < f; ) {
      const $ = r[c];
      switch (
        /** @type {import("./Instruction.js").default} */
        $[0]
      ) {
        case pe.BEGIN_GEOMETRY:
          D = /** @type {import("../../Feature.js").FeatureLike} */
          $[1], G = $[3], D.getGeometry() ? a !== void 0 && !ft(a, G.getExtent()) ? c = /** @type {number} */
          $[2] + 1 : ++c : c = /** @type {number} */
          $[2], h && (h.zIndex = $[4]);
          break;
        case pe.BEGIN_PATH:
          O > A && (this.fill_(e), O = 0), z > A && (e.stroke(), z = 0), !O && !z && (e.beginPath(), p = NaN, y = NaN), ++c;
          break;
        case pe.CIRCLE:
          g = /** @type {number} */
          $[1];
          const ne = u[g], te = u[g + 1], re = u[g + 2], ae = u[g + 3], Re = re - ne, xe = ae - te, Ae = Math.sqrt(Re * Re + xe * xe);
          e.moveTo(ne + Ae, te), e.arc(ne, te, Ae, 0, 2 * Math.PI, !0), ++c;
          break;
        case pe.CLOSE_PATH:
          e.closePath(), ++c;
          break;
        case pe.CUSTOM:
          g = /** @type {number} */
          $[1], d = $[2];
          const Z = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            $[3]
          ), at = $[4], ut = $[5];
          P.geometry = Z, P.feature = D, c in _ || (_[c] = []);
          const Ee = _[c];
          ut ? ut(u, g, d, 2, Ee) : (Ee[0] = u[g], Ee[1] = u[g + 1], Ee.length = 2), h && (h.zIndex = $[6]), at(Ee, P), ++c;
          break;
        case pe.DRAW_IMAGE:
          g = /** @type {number} */
          $[1], d = /** @type {number} */
          $[2], T = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          $[3], m = /** @type {number} */
          $[4], x = /** @type {number} */
          $[5];
          let gt = (
            /** @type {number} */
            $[6]
          );
          const St = (
            /** @type {number} */
            $[7]
          ), It = (
            /** @type {number} */
            $[8]
          ), Kn = (
            /** @type {number} */
            $[9]
          ), Tt = (
            /** @type {boolean} */
            $[10]
          );
          let Zi = (
            /** @type {number} */
            $[11]
          );
          const cn = (
            /** @type {import("../../size.js").Size} */
            $[12]
          );
          let wi = (
            /** @type {number} */
            $[13]
          );
          v = $[14] || "declutter";
          const Et = (
            /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
            $[15]
          );
          if (!T && $.length >= 20) {
            R = /** @type {string} */
            $[19], M = /** @type {string} */
            $[20], C = /** @type {string} */
            $[21], I = /** @type {string} */
            $[22];
            const _i = this.drawLabelWithPointPlacement_(
              R,
              M,
              C,
              I
            );
            T = _i.label, $[3] = T;
            const Er = (
              /** @type {number} */
              $[23]
            );
            m = (_i.anchorX - Er) * this.pixelRatio, $[4] = m;
            const Li = (
              /** @type {number} */
              $[24]
            );
            x = (_i.anchorY - Li) * this.pixelRatio, $[5] = x, gt = T.height, $[6] = gt, wi = T.width, $[13] = wi;
          }
          let Os;
          $.length > 25 && (Os = /** @type {number} */
          $[25]);
          let ct, nt, Ve;
          $.length > 17 ? (ct = /** @type {Array<number>} */
          $[16], nt = /** @type {Array<*>} */
          $[17], Ve = /** @type {Array<*>} */
          $[18]) : (ct = qs, nt = null, Ve = null), Tt && S ? Zi += w : !Tt && !S && (Zi -= w);
          let He = 0;
          for (; g < d; g += 2) {
            if (Os && Os[He++] < wi / this.pixelRatio)
              continue;
            const _i = this.calculateImageOrLabelDimensions_(
              T.width,
              T.height,
              u[g],
              u[g + 1],
              wi,
              gt,
              m,
              x,
              It,
              Kn,
              Zi,
              cn,
              s,
              ct,
              !!nt || !!Ve,
              D
            ), Er = [
              e,
              t,
              T,
              _i,
              St,
              nt,
              Ve
            ];
            if (l) {
              let Li, Jn, fn;
              if (Et) {
                const Ft = d - g;
                if (!Et[Ft]) {
                  Et[Ft] = { args: Er, declutterMode: v };
                  continue;
                }
                const bi = Et[Ft];
                Li = bi.args, Jn = bi.declutterMode, delete Et[Ft], fn = $y(Li);
              }
              let vr, wr;
              if (Li && (Jn !== "declutter" || !l.collides(fn)) && (vr = !0), (v !== "declutter" || !l.collides(_i.declutterBox)) && (wr = !0), Jn === "declutter" && v === "declutter") {
                const Ft = vr && wr;
                vr = Ft, wr = Ft;
              }
              vr && (Jn !== "none" && l.insert(fn), this.replayImageOrLabel_.apply(this, Li)), wr && (v !== "none" && l.insert(_i.declutterBox), this.replayImageOrLabel_.apply(this, Er));
            } else
              this.replayImageOrLabel_.apply(this, Er);
          }
          ++c;
          break;
        case pe.DRAW_CHARS:
          const Lt = (
            /** @type {number} */
            $[1]
          ), Ge = (
            /** @type {number} */
            $[2]
          ), Ue = (
            /** @type {number} */
            $[3]
          ), Ut = (
            /** @type {number} */
            $[4]
          );
          I = /** @type {string} */
          $[5];
          const Yt = (
            /** @type {number} */
            $[6]
          ), Hi = (
            /** @type {number} */
            $[7]
          ), Ai = (
            /** @type {number} */
            $[8]
          );
          C = /** @type {string} */
          $[9];
          const qt = (
            /** @type {number} */
            $[10]
          );
          R = /** @type {string|Array<string>} */
          $[11], Array.isArray(R) && (R = R.reduce(AL, "")), M = /** @type {string} */
          $[12];
          const mi = [
            /** @type {number} */
            $[13],
            /** @type {number} */
            $[13]
          ];
          v = $[14] || "declutter";
          const vt = (
            /** @type {boolean} */
            $[15]
          ), zt = this.textStates[M], ii = zt.font, lt = [
            zt.scale[0] * Hi,
            zt.scale[1] * Hi
          ];
          let Ii;
          ii in this.widths_ ? Ii = this.widths_[ii] : (Ii = {}, this.widths_[ii] = Ii);
          const iu = am(u, Lt, Ge, 2), nu = Math.abs(lt[0]) * ry(ii, R, Ii);
          if (Ut || nu <= iu) {
            const _i = this.textStates[M].textAlign, Er = (iu - nu) * Nd(R, _i), Li = ML(
              u,
              Lt,
              Ge,
              2,
              R,
              Er,
              Yt,
              Math.abs(lt[0]),
              ry,
              ii,
              Ii,
              S ? 0 : this.viewRotation_,
              vt
            );
            e: if (Li) {
              const Jn = [];
              let fn, vr, wr, Ft, bi;
              if (C)
                for (fn = 0, vr = Li.length; fn < vr; ++fn) {
                  bi = Li[fn], wr = /** @type {string} */
                  bi[4], Ft = this.createLabel(wr, M, "", C), m = /** @type {number} */
                  bi[2] + (lt[0] < 0 ? -qt : qt), x = Ue * Ft.height + (0.5 - Ue) * 2 * qt * lt[1] / lt[0] - Ai;
                  const br = this.calculateImageOrLabelDimensions_(
                    Ft.width,
                    Ft.height,
                    bi[0],
                    bi[1],
                    Ft.width,
                    Ft.height,
                    m,
                    x,
                    0,
                    0,
                    bi[3],
                    mi,
                    !1,
                    qs,
                    !1,
                    D
                  );
                  if (l && v === "declutter" && l.collides(br.declutterBox))
                    break e;
                  Jn.push([
                    e,
                    t,
                    Ft,
                    br,
                    1,
                    null,
                    null
                  ]);
                }
              if (I)
                for (fn = 0, vr = Li.length; fn < vr; ++fn) {
                  bi = Li[fn], wr = /** @type {string} */
                  bi[4], Ft = this.createLabel(wr, M, I, ""), m = /** @type {number} */
                  bi[2], x = Ue * Ft.height - Ai;
                  const br = this.calculateImageOrLabelDimensions_(
                    Ft.width,
                    Ft.height,
                    bi[0],
                    bi[1],
                    Ft.width,
                    Ft.height,
                    m,
                    x,
                    0,
                    0,
                    bi[3],
                    mi,
                    !1,
                    qs,
                    !1,
                    D
                  );
                  if (l && v === "declutter" && l.collides(br.declutterBox))
                    break e;
                  Jn.push([
                    e,
                    t,
                    Ft,
                    br,
                    1,
                    null,
                    null
                  ]);
                }
              l && v !== "none" && l.load(Jn.map($y));
              for (let br = 0, vT = Jn.length; br < vT; ++br)
                this.replayImageOrLabel_.apply(this, Jn[br]);
            }
          }
          ++c;
          break;
        case pe.END_GEOMETRY:
          if (o !== void 0) {
            D = /** @type {import("../../Feature.js").FeatureLike} */
            $[1];
            const _i = o(
              D,
              G,
              v
            );
            if (_i)
              return _i;
          }
          ++c;
          break;
        case pe.FILL:
          A ? O++ : this.fill_(e), ++c;
          break;
        case pe.MOVE_TO_LINE_TO:
          for (g = /** @type {number} */
          $[1], d = /** @type {number} */
          $[2], k = u[g], U = u[g + 1], e.moveTo(k, U), p = k + 0.5 | 0, y = U + 0.5 | 0, g += 2; g < d; g += 2)
            k = u[g], U = u[g + 1], E = k + 0.5 | 0, b = U + 0.5 | 0, (g == d - 2 || E !== p || b !== y) && (e.lineTo(k, U), p = E, y = b);
          ++c;
          break;
        case pe.SET_FILL_STYLE:
          this.alignAndScaleFill_ = $[2], O && (this.fill_(e), O = 0, z && (e.stroke(), z = 0)), e.fillStyle = $[1], ++c;
          break;
        case pe.SET_STROKE_STYLE:
          z && (e.stroke(), z = 0), this.setStrokeStyle_(
            e,
            /** @type {Array<*>} */
            $
          ), ++c;
          break;
        case pe.STROKE:
          A ? z++ : e.stroke(), ++c;
          break;
        default:
          ++c;
          break;
      }
    }
    O && this.fill_(e), z && e.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
   */
  execute(e, t, n, r, s, o) {
    this.viewRotation_ = r, this.execute_(
      e,
      t,
      n,
      this.instructions,
      s,
      void 0,
      void 0,
      o
    );
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(e, t, n, r, s) {
    return this.viewRotation_ = n, this.execute_(
      e,
      [e.canvas.width, e.canvas.height],
      t,
      this.hitDetectionInstructions,
      !0,
      r,
      s
    );
  }
}
const Xs = [
  "Polygon",
  "Circle",
  "LineString",
  "Image",
  "Text",
  "Default"
], Tc = ["Image", "Text"], LL = Xs.filter(
  (i) => !Tc.includes(i)
);
class aw {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
   */
  constructor(e, t, n, r, s, o, a) {
    this.maxExtent_ = e, this.overlaps_ = r, this.pixelRatio_ = n, this.resolution_ = t, this.renderBuffer_ = o, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = st(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(s, a);
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(e, t) {
    const n = this.getClipCoords(t);
    e.beginPath(), e.moveTo(n[0], n[1]), e.lineTo(n[2], n[3]), e.lineTo(n[4], n[5]), e.lineTo(n[6], n[7]), e.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   * @param {boolean} deferredRendering Enable deferred rendering.
   */
  createExecutors_(e, t) {
    for (const n in e) {
      let r = this.executorsByZIndex_[n];
      r === void 0 && (r = {}, this.executorsByZIndex_[n] = r);
      const s = e[n];
      for (const o in s) {
        const a = s[o];
        r[o] = new IL(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          a,
          t
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(e) {
    for (const t in this.executorsByZIndex_) {
      const n = this.executorsByZIndex_[t];
      for (let r = 0, s = e.length; r < s; ++r)
        if (e[r] in n)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, n, r, s, o) {
    r = Math.round(r);
    const a = r * 2 + 1, l = un(
      this.hitDetectionTransform_,
      r + 0.5,
      r + 0.5,
      1 / t,
      -1 / t,
      -n,
      -e[0],
      -e[1]
    ), h = !this.hitDetectionContext_;
    h && (this.hitDetectionContext_ = ot(
      a,
      a
    ));
    const u = this.hitDetectionContext_;
    u.canvas.width !== a || u.canvas.height !== a ? (u.canvas.width = a, u.canvas.height = a) : h || u.clearRect(0, 0, a, a);
    let c;
    this.renderBuffer_ !== void 0 && (c = hi(), Pl(c, e), ln(
      c,
      t * (this.renderBuffer_ + r),
      c
    ));
    const f = FL(r);
    let g;
    function d(b, T, R) {
      const M = u.getImageData(
        0,
        0,
        a,
        a
      ).data;
      for (let C = 0, I = f.length; C < I; C++)
        if (M[f[C]] > 0) {
          if (!o || R === "none" || g !== "Image" && g !== "Text" || o.includes(b)) {
            const O = (f[C] - 3) / 4, z = r - O % a, _ = r - (O / a | 0), w = s(b, T, z * z + _ * _);
            if (w)
              return w;
          }
          u.clearRect(0, 0, a, a);
          break;
        }
    }
    const m = Object.keys(this.executorsByZIndex_).map(Number);
    m.sort(lr);
    let x, v, p, y, E;
    for (x = m.length - 1; x >= 0; --x) {
      const b = m[x].toString();
      for (p = this.executorsByZIndex_[b], v = Xs.length - 1; v >= 0; --v)
        if (g = Xs[v], y = p[g], y !== void 0 && (E = y.executeHitDetection(
          u,
          l,
          n,
          d,
          c
        ), E))
          return E;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(e) {
    const t = this.maxExtent_;
    if (!t)
      return null;
    const n = t[0], r = t[1], s = t[2], o = t[3], a = [n, r, n, o, s, o, s, r];
    return hr(a, 0, 8, 2, e, a), a;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return Ur(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} targetContext Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ALL}
   * @param {import("rbush").default<import('./Executor.js').DeclutterEntry>|null} [declutterTree] Declutter tree.
   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
   */
  execute(e, t, n, r, s, o, a) {
    const l = Object.keys(this.executorsByZIndex_).map(Number);
    l.sort(a ? dE : lr), o = o || Xs;
    const h = Xs.length;
    for (let u = 0, c = l.length; u < c; ++u) {
      const f = l[u].toString(), g = this.executorsByZIndex_[f];
      for (let d = 0, m = o.length; d < m; ++d) {
        const x = o[d], v = g[x];
        if (v !== void 0) {
          const p = a === null ? void 0 : v.getZIndexContext(), y = p ? p.getContext() : e, E = this.maxExtent_ && x !== "Image" && x !== "Text";
          if (E && (y.save(), this.clip(y, n)), !p || x === "Text" || x === "Image" ? v.execute(
            y,
            t,
            n,
            r,
            s,
            a
          ) : p.pushFunction(
            (b) => v.execute(
              b,
              t,
              n,
              r,
              s,
              a
            )
          ), E && y.restore(), p) {
            p.offset();
            const b = l[u] * h + Xs.indexOf(x);
            this.deferredZIndexContexts_[b] || (this.deferredZIndexContexts_[b] = []), this.deferredZIndexContexts_[b].push(p);
          }
        }
      }
    }
    this.renderedContext_ = e;
  }
  getDeferredZIndexContexts() {
    return this.deferredZIndexContexts_;
  }
  getRenderedContext() {
    return this.renderedContext_;
  }
  renderDeferred() {
    const e = this.deferredZIndexContexts_, t = Object.keys(e).map(Number).sort(lr);
    for (let n = 0, r = t.length; n < r; ++n)
      e[t[n]].forEach((s) => {
        s.draw(this.renderedContext_), s.clear();
      }), e[t[n]].length = 0;
  }
}
const Dd = {};
function FL(i) {
  if (Dd[i] !== void 0)
    return Dd[i];
  const e = i * 2 + 1, t = i * i, n = new Array(t + 1);
  for (let s = 0; s <= i; ++s)
    for (let o = 0; o <= i; ++o) {
      const a = s * s + o * o;
      if (a > t)
        break;
      let l = n[a];
      l || (l = [], n[a] = l), l.push(((i + s) * e + (i + o)) * 4 + 3), s > 0 && l.push(((i - s) * e + (i + o)) * 4 + 3), o > 0 && (l.push(((i + s) * e + (i - o)) * 4 + 3), s > 0 && l.push(((i - s) * e + (i - o)) * 4 + 3));
    }
  const r = [];
  for (let s = 0, o = n.length; s < o; ++s)
    n[s] && r.push(...n[s]);
  return Dd[i] = r, r;
}
const Qi = 0.5;
function lw(i, e, t, n, r, s, o, a, l) {
  const h = l ? _f(r) : r, u = i[0] * Qi, c = i[1] * Qi, f = ot(u, c);
  f.imageSmoothingEnabled = !1;
  const g = f.canvas, d = new Qv(
    f,
    Qi,
    r,
    null,
    o,
    a,
    l ? xo(f2(), l) : null
  ), m = t.length, x = Math.floor((256 * 256 * 256 - 1) / m), v = {};
  for (let y = 1; y <= m; ++y) {
    const E = t[y - 1], b = E.getStyleFunction() || n;
    if (!b)
      continue;
    let T = b(E, s);
    if (!T)
      continue;
    Array.isArray(T) || (T = [T]);
    const M = (y * x).toString(16).padStart(7, "#00000");
    for (let C = 0, I = T.length; C < I; ++C) {
      const O = T[C], z = O.getGeometryFunction()(E);
      if (!z || !ft(h, z.getExtent()))
        continue;
      const _ = O.clone(), w = _.getFill();
      w && w.setColor(M);
      const S = _.getStroke();
      S && (S.setColor(M), S.setLineDash(null)), _.setText(void 0);
      const P = O.getImage();
      if (P) {
        const U = P.getImageSize();
        if (!U)
          continue;
        const G = ot(
          U[0],
          U[1],
          void 0,
          { alpha: !1 }
        ), $ = G.canvas;
        G.fillStyle = M, G.fillRect(0, 0, $.width, $.height), _.setImage(
          new Ts({
            img: $,
            anchor: P.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: P.getOrigin(),
            opacity: 1,
            size: P.getSize(),
            scale: P.getScale(),
            rotation: P.getRotation(),
            rotateWithView: P.getRotateWithView()
          })
        );
      }
      const A = _.getZIndex() || 0;
      let D = v[A];
      D || (D = {}, v[A] = D, D.Polygon = [], D.Circle = [], D.LineString = [], D.Point = []);
      const k = z.getType();
      if (k === "GeometryCollection") {
        const U = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          z.getGeometriesArrayRecursive()
        );
        for (let G = 0, $ = U.length; G < $; ++G) {
          const H = U[G];
          D[H.getType().replace("Multi", "")].push(
            H,
            _
          );
        }
      } else
        D[k.replace("Multi", "")].push(z, _);
    }
  }
  const p = Object.keys(v).map(Number).sort(lr);
  for (let y = 0, E = p.length; y < E; ++y) {
    const b = v[p[y]];
    for (const T in b) {
      const R = b[T];
      for (let M = 0, C = R.length; M < C; M += 2) {
        d.setStyle(R[M + 1]);
        for (let I = 0, O = e.length; I < O; ++I)
          d.setTransform(e[I]), d.drawGeometry(R[M]);
      }
    }
  }
  return f.getImageData(0, 0, g.width, g.height);
}
function hw(i, e, t) {
  const n = [];
  if (t) {
    const r = Math.floor(Math.round(i[0]) * Qi), s = Math.floor(Math.round(i[1]) * Qi), o = (ve(r, 0, t.width - 1) + ve(s, 0, t.height - 1) * t.width) * 4, a = t.data[o], l = t.data[o + 1], u = t.data[o + 2] + 256 * (l + 256 * a), c = Math.floor((256 * 256 * 256 - 1) / e.length);
    u && u % c === 0 && n.push(e[u / c - 1]);
  }
  return n;
}
class Fl extends In {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(e, t, n, r) {
    super(e), this.inversePixelTransform = t, this.frameState = n, this.context = r;
  }
}
const OL = 5;
class uw extends Eh {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = e, this.staleKeys_ = new Array(), this.maxStaleKeys = OL;
  }
  /**
   * @return {Array<string>} Get the list of stale keys.
   */
  getStaleKeys() {
    return this.staleKeys_;
  }
  /**
   * @param {string} key The new stale key.
   */
  prependStaleKey(e) {
    this.staleKeys_.unshift(e), this.staleKeys_.length > this.maxStaleKeys && (this.staleKeys_.length = this.maxStaleKeys);
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return de();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return de();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    return de();
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, n, r, s) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(e) {
    const t = (
      /** @type {import("../Image.js").default} */
      e.target
    );
    (t.getState() === se.LOADED || t.getState() === se.ERROR) && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(e) {
    let t = e.getState();
    return t != se.LOADED && t != se.ERROR && e.addEventListener(le.CHANGE, this.boundHandleImageChange_), t == se.IDLE && (e.load(), t = e.getState()), t == se.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const e = this.getLayer();
    e && e.getVisible() && e.getSourceState() === "ready" && e.changed();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(e) {
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
const Xy = [];
let Bo = null;
function NL() {
  Bo = ot(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class zm extends uw {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(e), this.container = null, this.renderedResolution, this.tempTransform = st(), this.pixelTransform = st(), this.inversePixelTransform = st(), this.context = null, this.deferredContext_ = null, this.containerReused = !1, this.frameState = null;
  }
  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(e, t, n) {
    Bo || NL(), Bo.clearRect(0, 0, 1, 1);
    let r;
    try {
      Bo.drawImage(e, t, n, 1, 1, 0, 0, 1, 1), r = Bo.getImageData(0, 0, 1, 1).data;
    } catch {
      return Bo = null, null;
    }
    return r;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(e) {
    let n = this.getLayer().getBackground();
    return typeof n == "function" && (n = n(e.viewState.resolution)), n || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS transform matrix.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(e, t, n) {
    const r = this.getLayer().getClassName();
    let s, o;
    if (e && e.className === r && (!n || e && e.style.backgroundColor && Xr(
      An(e.style.backgroundColor),
      An(n)
    ))) {
      const a = e.firstElementChild;
      fs(a) && (o = a.getContext("2d"));
    }
    if (o && y2(o.canvas.style.transform, t) ? (this.container = e, this.context = o, this.containerReused = !0) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null), !this.container) {
      s = di ? ev() : document.createElement("div"), s.className = r;
      let a = s.style;
      a.position = "absolute", a.width = "100%", a.height = "100%", o = ot();
      const l = (
        /** @type {HTMLCanvasElement} */
        o.canvas
      );
      s.appendChild(l), a = l.style, a.position = "absolute", a.left = "0", a.transformOrigin = "top left", this.container = s, this.context = o;
    }
    !this.containerReused && n && !this.container.style.backgroundColor && (this.container.style.backgroundColor = n);
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(e, t, n) {
    const r = Mn(n), s = wh(n), o = gf(n), a = vh(n);
    rt(t.coordinateToPixelTransform, r), rt(t.coordinateToPixelTransform, s), rt(t.coordinateToPixelTransform, o), rt(t.coordinateToPixelTransform, a);
    const l = this.inversePixelTransform;
    rt(l, r), rt(l, s), rt(l, o), rt(l, a), e.save(), e.beginPath(), e.moveTo(Math.round(r[0]), Math.round(r[1])), e.lineTo(Math.round(s[0]), Math.round(s[1])), e.lineTo(Math.round(o[0]), Math.round(o[1])), e.lineTo(Math.round(a[0]), Math.round(a[1])), e.clip();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @protected
   */
  prepareContainer(e, t) {
    const n = e.extent, r = e.viewState.resolution, s = e.viewState.rotation, o = e.pixelRatio, a = Math.round(_e(n) / r * o), l = Math.round(it(n) / r * o);
    un(
      this.pixelTransform,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / o,
      1 / o,
      s,
      -a / 2,
      -l / 2
    ), lo(this.inversePixelTransform, this.pixelTransform);
    const h = _2(this.pixelTransform);
    if (this.useContainer(t, h, this.getBackground(e)), !this.containerReused) {
      const u = this.context.canvas;
      u.width != a || u.height != l ? (u.width = a, u.height = l) : this.context.clearRect(0, 0, a, l), h !== /** @type {HTMLCanvasElement} */
      u.style.transform && (u.style.transform = h);
    }
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, n) {
    const r = this.getLayer();
    if (r.hasListener(e)) {
      const s = new Fl(
        e,
        this.inversePixelTransform,
        n,
        t
      );
      r.dispatchEvent(s);
    }
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.frameState = t, !t.declutter && this.dispatchRenderEvent_(Ht.PRERENDER, e, t);
  }
  /**
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    t.declutter || this.dispatchRenderEvent_(Ht.POSTRENDER, e, t);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(e) {
    return e.declutter && !this.deferredContext_ && (this.deferredContext_ = new Um()), e.declutter ? this.deferredContext_.getContext() : this.context;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(e) {
    e.declutter && (this.dispatchRenderEvent_(
      Ht.PRERENDER,
      this.context,
      e
    ), e.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(e), this.dispatchRenderEvent_(
      Ht.POSTRENDER,
      this.context,
      e
    ));
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(e, t, n, r, s, o, a) {
    const l = s / 2, h = o / 2, u = r / t, c = -u, f = -e[0] + a, g = -e[1];
    return un(
      this.tempTransform,
      l,
      h,
      u,
      c,
      -n,
      f,
      g
    );
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
class cw extends zm {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(e) {
    super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.clipped_ = !1, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = hi(), this.wrappedRenderedExtent_ = hi(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.renderedFrameDeclutter_, this.replayGroup_ = null, this.replayGroupChanged = !0, this.clipping = !0, this.targetContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} [declutterable] `true` to only render declutterable items,
   *     `false` to only render non-declutterable items, `undefined` to render all.
   */
  renderWorlds(e, t, n) {
    const r = t.extent, s = t.viewState, o = s.center, a = s.resolution, l = s.projection, h = s.rotation, u = l.getExtent(), c = this.getLayer().getSource(), f = this.getLayer().getDeclutter(), g = t.pixelRatio, d = t.viewHints, m = !(d[Xe.ANIMATING] || d[Xe.INTERACTING]), x = this.context, v = Math.round(_e(r) / a * g), p = Math.round(it(r) / a * g), y = c.getWrapX() && l.canWrapX(), E = y ? _e(u) : null, b = y ? Math.ceil((r[2] - u[2]) / E) + 1 : 1;
    let T = y ? Math.floor((r[0] - u[0]) / E) : 0;
    do {
      let R = this.getRenderTransform(
        o,
        a,
        0,
        g,
        v,
        p,
        T * E
      );
      t.declutter && (R = R.slice(0)), e.execute(
        x,
        [x.canvas.width, x.canvas.height],
        R,
        h,
        m,
        n === void 0 ? Xs : n ? Tc : LL,
        n ? f && t.declutter[f] : void 0
      );
    } while (++T < b);
  }
  /**
   * @private
   */
  setDrawContext_() {
    this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = ot(
      this.context.canvas.width,
      this.context.canvas.height,
      Xy
    ));
  }
  /**
   * @private
   */
  resetDrawContext_() {
    if (this.opacity_ !== 1 && this.targetContext_) {
      const e = this.targetContext_.globalAlpha;
      this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = e, Ih(this.context), Xy.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(e) {
    !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, e, !0);
  }
  /**
   * Render deferred instructions.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferredInternal(e) {
    this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.clipped_ && this.context.restore(), this.resetDrawContext_());
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(e, t) {
    const n = e.layerStatesArray[e.layerIndex];
    this.opacity_ = n.opacity;
    const r = e.viewState;
    this.prepareContainer(e, t);
    const s = this.context, o = this.replayGroup_;
    let a = o && !o.isEmpty();
    if (!a && !(this.getLayer().hasListener(Ht.PRERENDER) || this.getLayer().hasListener(Ht.POSTRENDER)))
      return this.container;
    if (this.setDrawContext_(), this.preRender(s, e), r.projection, this.clipped_ = !1, a && n.extent && this.clipping) {
      const l = xn(n.extent);
      a = ft(l, e.extent), this.clipped_ = a && !Bi(l, e.extent), this.clipped_ && this.clipUnrotated(s, e, l);
    }
    return a && this.renderWorlds(
      o,
      e,
      this.getLayer().getDeclutter() ? !1 : void 0
    ), !e.declutter && this.clipped_ && s.restore(), this.postRender(s, e), this.renderedRotation_ !== r.rotation && (this.renderedRotation_ = r.rotation, this.hitDetectionImageData_ = null), e.declutter || this.resetDrawContext_(), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   * @override
   */
  getFeatures(e) {
    return new Promise((t) => {
      if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const n = this.frameState.size.slice(), r = this.renderedCenter_, s = this.renderedResolution_, o = this.renderedRotation_, a = this.renderedProjection_, l = this.wrappedRenderedExtent_, h = this.getLayer(), u = [], c = n[0] * Qi, f = n[1] * Qi;
        u.push(
          this.getRenderTransform(
            r,
            s,
            o,
            Qi,
            c,
            f,
            0
          ).slice()
        );
        const g = h.getSource(), d = a.getExtent();
        if (g.getWrapX() && a.canWrapX() && !Bi(d, l)) {
          let m = l[0];
          const x = _e(d);
          let v = 0, p;
          for (; m < d[0]; )
            --v, p = x * v, u.push(
              this.getRenderTransform(
                r,
                s,
                o,
                Qi,
                c,
                f,
                p
              ).slice()
            ), m += x;
          for (v = 0, m = l[2]; m > d[2]; )
            ++v, p = x * v, u.push(
              this.getRenderTransform(
                r,
                s,
                o,
                Qi,
                c,
                f,
                p
              ).slice()
            ), m -= x;
        }
        this.hitDetectionImageData_ = lw(
          n,
          u,
          this.renderedFeatures_,
          h.getStyleFunction(),
          l,
          s,
          o,
          wc(s, this.renderedPixelRatio_),
          null
        );
      }
      t(
        hw(e, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   * @override
   */
  forEachFeatureAtCoordinate(e, t, n, r, s) {
    if (!this.replayGroup_)
      return;
    const o = t.viewState.resolution, a = t.viewState.rotation, l = this.getLayer(), h = {}, u = function(f, g, d) {
      const m = ie(f), x = h[m];
      if (x) {
        if (x !== !0 && d < x.distanceSq) {
          if (d === 0)
            return h[m] = !0, s.splice(s.lastIndexOf(x), 1), r(f, l, g);
          x.geometry = g, x.distanceSq = d;
        }
      } else {
        if (d === 0)
          return h[m] = !0, r(f, l, g);
        s.push(
          h[m] = {
            feature: f,
            layer: l,
            geometry: g,
            distanceSq: d,
            callback: r
          }
        );
      }
    }, c = this.getLayer().getDeclutter();
    return this.replayGroup_.forEachFeatureAtCoordinate(
      e,
      o,
      a,
      n,
      u,
      c ? t.declutter?.[c]?.all().map((f) => f.value) : null
    );
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @override
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.replayGroup_ && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(e) {
    const t = this.getLayer(), n = t.getSource();
    if (!n)
      return !1;
    const r = e.viewHints[Xe.ANIMATING], s = e.viewHints[Xe.INTERACTING], o = t.getUpdateWhileAnimating(), a = t.getUpdateWhileInteracting();
    if (this.ready && !o && r || !a && s)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const l = e.extent, h = e.viewState, u = h.projection, c = h.resolution, f = e.pixelRatio, g = t.getRevision(), d = t.getRenderBuffer();
    let m = t.getRenderOrder();
    m === void 0 && (m = nL);
    const x = h.center.slice(), v = ln(
      l,
      d * c
    ), p = v.slice(), y = [v.slice()], E = u.getExtent();
    if (n.getWrapX() && u.canWrapX() && !Bi(E, e.extent)) {
      const w = _e(E), S = Math.max(_e(v) / 2, w);
      v[0] = E[0] - S, v[2] = E[2] + S, Zp(x, u);
      const P = Vp(y[0], u);
      P[0] < E[0] && P[2] < E[2] ? y.push([
        P[0] + w,
        P[1],
        P[2] + w,
        P[3]
      ]) : P[0] > E[0] && P[2] > E[2] && y.push([
        P[0] - w,
        P[1],
        P[2] - w,
        P[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == c && this.renderedRevision_ == g && this.renderedRenderOrder_ == m && this.renderedFrameDeclutter_ === !!e.declutter && Bi(this.wrappedRenderedExtent_, v))
      return Xr(this.renderedExtent_, p) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = p), this.renderedCenter_ = x, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const b = new ow(
      tw(c, f),
      v,
      c,
      f
    );
    let T;
    for (let w = 0, S = y.length; w < S; ++w)
      n.loadFeatures(y[w], c, u);
    const R = wc(c, f);
    let M = !0;
    const C = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} index Index.
       */
      (w, S) => {
        let P;
        const A = w.getStyleFunction() || t.getStyleFunction();
        if (A && (P = A(w, c)), P) {
          const D = this.renderFeature(
            w,
            R,
            P,
            b,
            T,
            this.getLayer().getDeclutter(),
            S
          );
          M = M && !D;
        }
      }
    ), I = _f(v), O = n.getFeaturesInExtent(I);
    m && O.sort(m);
    for (let w = 0, S = O.length; w < S; ++w)
      C(O[w], w);
    this.renderedFeatures_ = O, this.ready = M;
    const z = b.finish(), _ = new aw(
      v,
      c,
      f,
      n.getOverlaps(),
      z,
      t.getRenderBuffer(),
      !!e.declutter
    );
    return this.renderedResolution_ = c, this.renderedRevision_ = g, this.renderedRenderOrder_ = m, this.renderedFrameDeclutter_ = !!e.declutter, this.renderedExtent_ = p, this.wrappedRenderedExtent_ = v, this.renderedCenter_ = x, this.renderedProjection_ = u, this.renderedPixelRatio_ = f, this.replayGroup_ = _, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, t, n, r, s, o, a) {
    if (!n)
      return !1;
    let l = !1;
    if (Array.isArray(n))
      for (let h = 0, u = n.length; h < u; ++h)
        l = bc(
          r,
          e,
          n[h],
          t,
          this.boundHandleStyleImageChange_,
          s,
          o,
          a
        ) || l;
    else
      l = bc(
        r,
        e,
        n,
        t,
        this.boundHandleStyleImageChange_,
        s,
        o,
        a
      );
    return l;
  }
}
let wo = 0;
const jt = 1 << wo++, oe = 1 << wo++, Kt = 1 << wo++, mt = 1 << wo++, Wi = 1 << wo++, bn = 1 << wo++, _u = Math.pow(2, wo) - 1, Bm = {
  [jt]: "boolean",
  [oe]: "number",
  [Kt]: "string",
  [mt]: "color",
  [Wi]: "number[]",
  [bn]: "size"
}, DL = Object.keys(Bm).map(Number).sort(lr);
function GL(i) {
  return i in Bm;
}
function Ko(i) {
  const e = [];
  for (const t of DL)
    yl(i, t) && e.push(Bm[t]);
  return e.length === 0 ? "untyped" : e.length < 3 ? e.join(" or ") : e.slice(0, -1).join(", ") + ", or " + e[e.length - 1];
}
function yl(i, e) {
  return (i & e) === e;
}
function nr(i, e) {
  return i === e;
}
class Zt {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(e, t) {
    if (!GL(e))
      throw new Error(
        `literal expressions must have a specific type, got ${Ko(e)}`
      );
    this.type = e, this.value = t;
  }
}
class fw {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(e, t, ...n) {
    this.type = e, this.operator = t, this.args = n;
  }
}
function $m() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: !1,
    geometryType: !1,
    mapState: !1
  };
}
function oi(i, e, t) {
  switch (typeof i) {
    case "boolean": {
      if (nr(e, Kt))
        return new Zt(Kt, i ? "true" : "false");
      if (!yl(e, jt))
        throw new Error(
          `got a boolean, but expected ${Ko(e)}`
        );
      return new Zt(jt, i);
    }
    case "number": {
      if (nr(e, bn))
        return new Zt(bn, dt(i));
      if (nr(e, jt))
        return new Zt(jt, !!i);
      if (nr(e, Kt))
        return new Zt(Kt, i.toString());
      if (!yl(e, oe))
        throw new Error(`got a number, but expected ${Ko(e)}`);
      return new Zt(oe, i);
    }
    case "string": {
      if (nr(e, mt))
        return new Zt(mt, bm(i));
      if (nr(e, jt))
        return new Zt(jt, !!i);
      if (!yl(e, Kt))
        throw new Error(`got a string, but expected ${Ko(e)}`);
      return new Zt(Kt, i);
    }
  }
  if (!Array.isArray(i))
    throw new Error("expression must be an array or a primitive value");
  if (i.length === 0)
    throw new Error("empty expression");
  if (typeof i[0] == "string")
    return qL(i, e, t);
  for (const n of i)
    if (typeof n != "number")
      throw new Error("expected an array of numbers");
  if (nr(e, bn)) {
    if (i.length !== 2)
      throw new Error(
        `expected an array of two values for a size, got ${i.length}`
      );
    return new Zt(bn, i);
  }
  if (nr(e, mt)) {
    if (i.length === 3)
      return new Zt(mt, [...i, 1]);
    if (i.length === 4)
      return new Zt(mt, i);
    throw new Error(
      `expected an array of 3 or 4 values for a color, got ${i.length}`
    );
  }
  if (!yl(e, Wi))
    throw new Error(
      `got an array of numbers, but expected ${Ko(e)}`
    );
  return new Zt(Wi, i);
}
const B = {
  Get: "get",
  Var: "var",
  Concat: "concat",
  GeometryType: "geometry-type",
  LineMetric: "line-metric",
  Any: "any",
  All: "all",
  Not: "!",
  Resolution: "resolution",
  Zoom: "zoom",
  Time: "time",
  Equal: "==",
  NotEqual: "!=",
  GreaterThan: ">",
  GreaterThanOrEqualTo: ">=",
  LessThan: "<",
  LessThanOrEqualTo: "<=",
  Multiply: "*",
  Divide: "/",
  Add: "+",
  Subtract: "-",
  Clamp: "clamp",
  Mod: "%",
  Pow: "^",
  Abs: "abs",
  Floor: "floor",
  Ceil: "ceil",
  Round: "round",
  Sin: "sin",
  Cos: "cos",
  Atan: "atan",
  Sqrt: "sqrt",
  Match: "match",
  Between: "between",
  Interpolate: "interpolate",
  Coalesce: "coalesce",
  Case: "case",
  In: "in",
  Number: "number",
  String: "string",
  Array: "array",
  Color: "color",
  Id: "id",
  Band: "band",
  Palette: "palette",
  ToString: "to-string",
  Has: "has"
}, kL = {
  [B.Get]: Se(Le(1, 1 / 0), Vy),
  [B.Var]: Se(Le(1, 1), UL),
  [B.Has]: Se(Le(1, 1 / 0), Vy),
  [B.Id]: Se(zL, Co),
  [B.Concat]: Se(
    Le(2, 1 / 0),
    We(Kt)
  ),
  [B.GeometryType]: Se(BL, Co),
  [B.LineMetric]: Se(Co),
  [B.Resolution]: Se(Gd, Co),
  [B.Zoom]: Se(Gd, Co),
  [B.Time]: Se(Gd, Co),
  [B.Any]: Se(
    Le(2, 1 / 0),
    We(jt)
  ),
  [B.All]: Se(
    Le(2, 1 / 0),
    We(jt)
  ),
  [B.Not]: Se(
    Le(1, 1),
    We(jt)
  ),
  [B.Equal]: Se(
    Le(2, 2),
    We(_u)
  ),
  [B.NotEqual]: Se(
    Le(2, 2),
    We(_u)
  ),
  [B.GreaterThan]: Se(
    Le(2, 2),
    We(oe)
  ),
  [B.GreaterThanOrEqualTo]: Se(
    Le(2, 2),
    We(oe)
  ),
  [B.LessThan]: Se(
    Le(2, 2),
    We(oe)
  ),
  [B.LessThanOrEqualTo]: Se(
    Le(2, 2),
    We(oe)
  ),
  [B.Multiply]: Se(
    Le(2, 1 / 0),
    Wy
  ),
  [B.Coalesce]: Se(
    Le(2, 1 / 0),
    Wy
  ),
  [B.Divide]: Se(
    Le(2, 2),
    We(oe)
  ),
  [B.Add]: Se(
    Le(2, 1 / 0),
    We(oe)
  ),
  [B.Subtract]: Se(
    Le(2, 2),
    We(oe)
  ),
  [B.Clamp]: Se(
    Le(3, 3),
    We(oe)
  ),
  [B.Mod]: Se(
    Le(2, 2),
    We(oe)
  ),
  [B.Pow]: Se(
    Le(2, 2),
    We(oe)
  ),
  [B.Abs]: Se(
    Le(1, 1),
    We(oe)
  ),
  [B.Floor]: Se(
    Le(1, 1),
    We(oe)
  ),
  [B.Ceil]: Se(
    Le(1, 1),
    We(oe)
  ),
  [B.Round]: Se(
    Le(1, 1),
    We(oe)
  ),
  [B.Sin]: Se(
    Le(1, 1),
    We(oe)
  ),
  [B.Cos]: Se(
    Le(1, 1),
    We(oe)
  ),
  [B.Atan]: Se(
    Le(1, 2),
    We(oe)
  ),
  [B.Sqrt]: Se(
    Le(1, 1),
    We(oe)
  ),
  [B.Match]: Se(
    Le(4, 1 / 0),
    Yy,
    jL
  ),
  [B.Between]: Se(
    Le(3, 3),
    We(oe)
  ),
  [B.Interpolate]: Se(
    Le(6, 1 / 0),
    Yy,
    XL
  ),
  [B.Case]: Se(
    Le(3, 1 / 0),
    $L,
    VL
  ),
  [B.In]: Se(Le(2, 2), WL),
  [B.Number]: Se(
    Le(1, 1 / 0),
    We(_u)
  ),
  [B.String]: Se(
    Le(1, 1 / 0),
    We(_u)
  ),
  [B.Array]: Se(
    Le(1, 1 / 0),
    We(oe)
  ),
  [B.Color]: Se(
    Le(1, 4),
    We(oe)
  ),
  [B.Band]: Se(
    Le(1, 3),
    We(oe)
  ),
  [B.Palette]: Se(
    Le(2, 2),
    YL
  ),
  [B.ToString]: Se(
    Le(1, 1),
    We(jt | oe | Kt | mt)
  )
};
function Vy(i, e, t) {
  const n = i.length - 1, r = new Array(n);
  for (let s = 0; s < n; ++s) {
    const o = i[s + 1];
    switch (typeof o) {
      case "number": {
        r[s] = new Zt(oe, o);
        break;
      }
      case "string": {
        r[s] = new Zt(Kt, o);
        break;
      }
      default:
        throw new Error(
          `expected a string key or numeric array index for a get operation, got ${o}`
        );
    }
    s === 0 && t.properties.add(String(o));
  }
  return r;
}
function UL(i, e, t) {
  const n = i[1];
  if (typeof n != "string")
    throw new Error("expected a string argument for var operation");
  return t.variables.add(n), [new Zt(Kt, n)];
}
function zL(i, e, t) {
  t.featureId = !0;
}
function BL(i, e, t) {
  t.geometryType = !0;
}
function Gd(i, e, t) {
  t.mapState = !0;
}
function Co(i, e, t) {
  const n = i[0];
  if (i.length !== 1)
    throw new Error(`expected no arguments for ${n} operation`);
  return [];
}
function Le(i, e) {
  return function(t, n, r) {
    const s = t[0], o = t.length - 1;
    if (i === e) {
      if (o !== i) {
        const a = i === 1 ? "" : "s";
        throw new Error(
          `expected ${i} argument${a} for ${s}, got ${o}`
        );
      }
    } else if (o < i || o > e) {
      const a = e === 1 / 0 ? `${i} or more` : `${i} to ${e}`;
      throw new Error(
        `expected ${a} arguments for ${s}, got ${o}`
      );
    }
  };
}
function Wy(i, e, t) {
  const n = i.length - 1, r = new Array(n);
  for (let s = 0; s < n; ++s) {
    const o = oi(i[s + 1], e, t);
    r[s] = o;
  }
  return r;
}
function We(i) {
  return function(e, t, n) {
    const r = e.length - 1, s = new Array(r);
    for (let o = 0; o < r; ++o) {
      const a = oi(e[o + 1], i, n);
      s[o] = a;
    }
    return s;
  };
}
function $L(i, e, t) {
  const n = i[0], r = i.length - 1;
  if (r % 2 === 0)
    throw new Error(
      `expected an odd number of arguments for ${n}, got ${r} instead`
    );
}
function Yy(i, e, t) {
  const n = i[0], r = i.length - 1;
  if (r % 2 === 1)
    throw new Error(
      `expected an even number of arguments for operation ${n}, got ${r} instead`
    );
}
function jL(i, e, t) {
  const n = i.length - 1, r = Kt | oe | jt, s = oi(i[1], r, t), o = oi(i[i.length - 1], e, t), a = new Array(n - 2);
  for (let l = 0; l < n - 2; l += 2) {
    try {
      const h = oi(i[l + 2], s.type, t);
      a[l] = h;
    } catch (h) {
      throw new Error(
        `failed to parse argument ${l + 1} of match expression: ${h.message}`
      );
    }
    try {
      const h = oi(i[l + 3], o.type, t);
      a[l + 1] = h;
    } catch (h) {
      throw new Error(
        `failed to parse argument ${l + 2} of match expression: ${h.message}`
      );
    }
  }
  return [s, ...a, o];
}
function XL(i, e, t) {
  const n = i[1];
  let r;
  switch (n[0]) {
    case "linear":
      r = 1;
      break;
    case "exponential":
      const l = n[1];
      if (typeof l != "number" || l <= 0)
        throw new Error(
          `expected a number base for exponential interpolation, got ${JSON.stringify(l)} instead`
        );
      r = l;
      break;
    default:
      throw new Error(
        `invalid interpolation type: ${JSON.stringify(n)}`
      );
  }
  const s = new Zt(oe, r);
  let o;
  try {
    o = oi(i[2], oe, t);
  } catch (l) {
    throw new Error(
      `failed to parse argument 1 in interpolate expression: ${l.message}`
    );
  }
  const a = new Array(i.length - 3);
  for (let l = 0; l < a.length; l += 2) {
    try {
      const h = oi(i[l + 3], oe, t);
      a[l] = h;
    } catch (h) {
      throw new Error(
        `failed to parse argument ${l + 2} for interpolate expression: ${h.message}`
      );
    }
    try {
      const h = oi(i[l + 4], e, t);
      a[l + 1] = h;
    } catch (h) {
      throw new Error(
        `failed to parse argument ${l + 3} for interpolate expression: ${h.message}`
      );
    }
  }
  return [s, o, ...a];
}
function VL(i, e, t) {
  const n = oi(i[i.length - 1], e, t), r = new Array(i.length - 1);
  for (let s = 0; s < r.length - 1; s += 2) {
    try {
      const o = oi(i[s + 1], jt, t);
      r[s] = o;
    } catch (o) {
      throw new Error(
        `failed to parse argument ${s} of case expression: ${o.message}`
      );
    }
    try {
      const o = oi(i[s + 2], n.type, t);
      r[s + 1] = o;
    } catch (o) {
      throw new Error(
        `failed to parse argument ${s + 1} of case expression: ${o.message}`
      );
    }
  }
  return r[r.length - 1] = n, r;
}
function WL(i, e, t) {
  let n = i[2];
  if (!Array.isArray(n))
    throw new Error(
      'the second argument for the "in" operator must be an array'
    );
  let r;
  if (typeof n[0] == "string") {
    if (n[0] !== "literal")
      throw new Error(
        'for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions'
      );
    if (!Array.isArray(n[1]))
      throw new Error(
        'failed to parse "in" expression: the literal operator must be followed by an array'
      );
    n = n[1], r = Kt;
  } else
    r = oe;
  const s = new Array(n.length);
  for (let a = 0; a < s.length; a++)
    try {
      const l = oi(n[a], r, t);
      s[a] = l;
    } catch (l) {
      throw new Error(
        `failed to parse haystack item ${a} for "in" expression: ${l.message}`
      );
    }
  return [oi(i[1], r, t), ...s];
}
function YL(i, e, t) {
  let n;
  try {
    n = oi(i[1], oe, t);
  } catch (o) {
    throw new Error(
      `failed to parse first argument in palette expression: ${o.message}`
    );
  }
  const r = i[2];
  if (!Array.isArray(r))
    throw new Error("the second argument of palette must be an array");
  const s = new Array(r.length);
  for (let o = 0; o < s.length; o++) {
    let a;
    try {
      a = oi(r[o], mt, t);
    } catch (l) {
      throw new Error(
        `failed to parse color at index ${o} in palette expression: ${l.message}`
      );
    }
    if (!(a instanceof Zt))
      throw new Error(
        `the palette color at index ${o} must be a literal value`
      );
    s[o] = a;
  }
  return [n, ...s];
}
function Se(...i) {
  return function(e, t, n) {
    const r = e[0];
    let s;
    for (let o = 0; o < i.length; o++) {
      const a = i[o](e, t, n);
      if (o == i.length - 1) {
        if (!a)
          throw new Error(
            "expected last argument validator to return the parsed args"
          );
        s = a;
      }
    }
    return new fw(t, r, ...s);
  };
}
function qL(i, e, t) {
  const n = i[0], r = kL[n];
  if (!r)
    throw new Error(`unknown operator: ${n}`);
  return r(i, e, t);
}
function jm(i) {
  if (!i)
    return "";
  const e = i.getType();
  switch (e) {
    case "Point":
    case "LineString":
    case "Polygon":
      return e;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        e.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return jm(
        /** @type {import("../geom/GeometryCollection.js").default} */
        i.getGeometries()[0]
      );
    default:
      return "";
  }
}
function dw() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function Wr(i, e, t) {
  const n = oi(i, e, t);
  return Wn(n);
}
function Wn(i, e) {
  if (i instanceof Zt) {
    if (i.type === mt && typeof i.value == "string") {
      const n = bm(i.value);
      return function() {
        return n;
      };
    }
    return function() {
      return i.value;
    };
  }
  const t = i.operator;
  switch (t) {
    case B.Number:
    case B.String:
    case B.Coalesce:
      return ZL(i);
    case B.Get:
    case B.Var:
    case B.Has:
      return HL(i);
    case B.Id:
      return (n) => n.featureId;
    case B.GeometryType:
      return (n) => n.geometryType;
    case B.Concat: {
      const n = i.args.map((r) => Wn(r));
      return (r) => "".concat(...n.map((s) => s(r).toString()));
    }
    case B.Resolution:
      return (n) => n.resolution;
    case B.Any:
    case B.All:
    case B.Between:
    case B.In:
    case B.Not:
      return JL(i);
    case B.Equal:
    case B.NotEqual:
    case B.LessThan:
    case B.LessThanOrEqualTo:
    case B.GreaterThan:
    case B.GreaterThanOrEqualTo:
      return KL(i);
    case B.Multiply:
    case B.Divide:
    case B.Add:
    case B.Subtract:
    case B.Clamp:
    case B.Mod:
    case B.Pow:
    case B.Abs:
    case B.Floor:
    case B.Ceil:
    case B.Round:
    case B.Sin:
    case B.Cos:
    case B.Atan:
    case B.Sqrt:
      return QL(i);
    case B.Case:
      return eF(i);
    case B.Match:
      return tF(i);
    case B.Interpolate:
      return iF(i);
    case B.ToString:
      return nF(i);
    default:
      throw new Error(`Unsupported operator ${t}`);
  }
}
function ZL(i, e) {
  const t = i.operator, n = i.args.length, r = new Array(n);
  for (let s = 0; s < n; ++s)
    r[s] = Wn(i.args[s]);
  switch (t) {
    case B.Coalesce:
      return (s) => {
        for (let o = 0; o < n; ++o) {
          const a = r[o](s);
          if (typeof a < "u" && a !== null)
            return a;
        }
        throw new Error("Expected one of the values to be non-null");
      };
    case B.Number:
    case B.String:
      return (s) => {
        for (let o = 0; o < n; ++o) {
          const a = r[o](s);
          if (typeof a === t)
            return a;
        }
        throw new Error(`Expected one of the values to be a ${t}`);
      };
    default:
      throw new Error(`Unsupported assertion operator ${t}`);
  }
}
function HL(i, e) {
  const n = (
    /** @type {string} */
    /** @type {LiteralExpression} */
    i.args[0].value
  );
  switch (i.operator) {
    case B.Get:
      return (r) => {
        const s = i.args;
        let o = r.properties[n];
        for (let a = 1, l = s.length; a < l; ++a) {
          const u = (
            /** @type {string|number} */
            /** @type {LiteralExpression} */
            s[a].value
          );
          o = o[u];
        }
        return o;
      };
    case B.Var:
      return (r) => r.variables[n];
    case B.Has:
      return (r) => {
        const s = i.args;
        if (!(n in r.properties))
          return !1;
        let o = r.properties[n];
        for (let a = 1, l = s.length; a < l; ++a) {
          const u = (
            /** @type {string|number} */
            /** @type {LiteralExpression} */
            s[a].value
          );
          if (!o || !Object.hasOwn(o, u))
            return !1;
          o = o[u];
        }
        return !0;
      };
    default:
      throw new Error(`Unsupported accessor operator ${i.operator}`);
  }
}
function KL(i, e) {
  const t = i.operator, n = Wn(i.args[0]), r = Wn(i.args[1]);
  switch (t) {
    case B.Equal:
      return (s) => n(s) === r(s);
    case B.NotEqual:
      return (s) => n(s) !== r(s);
    case B.LessThan:
      return (s) => n(s) < r(s);
    case B.LessThanOrEqualTo:
      return (s) => n(s) <= r(s);
    case B.GreaterThan:
      return (s) => n(s) > r(s);
    case B.GreaterThanOrEqualTo:
      return (s) => n(s) >= r(s);
    default:
      throw new Error(`Unsupported comparison operator ${t}`);
  }
}
function JL(i, e) {
  const t = i.operator, n = i.args.length, r = new Array(n);
  for (let s = 0; s < n; ++s)
    r[s] = Wn(i.args[s]);
  switch (t) {
    case B.Any:
      return (s) => {
        for (let o = 0; o < n; ++o)
          if (r[o](s))
            return !0;
        return !1;
      };
    case B.All:
      return (s) => {
        for (let o = 0; o < n; ++o)
          if (!r[o](s))
            return !1;
        return !0;
      };
    case B.Between:
      return (s) => {
        const o = r[0](s), a = r[1](s), l = r[2](s);
        return o >= a && o <= l;
      };
    case B.In:
      return (s) => {
        const o = r[0](s);
        for (let a = 1; a < n; ++a)
          if (o === r[a](s))
            return !0;
        return !1;
      };
    case B.Not:
      return (s) => !r[0](s);
    default:
      throw new Error(`Unsupported logical operator ${t}`);
  }
}
function QL(i, e) {
  const t = i.operator, n = i.args.length, r = new Array(n);
  for (let s = 0; s < n; ++s)
    r[s] = Wn(i.args[s]);
  switch (t) {
    case B.Multiply:
      return (s) => {
        let o = 1;
        for (let a = 0; a < n; ++a)
          o *= r[a](s);
        return o;
      };
    case B.Divide:
      return (s) => r[0](s) / r[1](s);
    case B.Add:
      return (s) => {
        let o = 0;
        for (let a = 0; a < n; ++a)
          o += r[a](s);
        return o;
      };
    case B.Subtract:
      return (s) => r[0](s) - r[1](s);
    case B.Clamp:
      return (s) => {
        const o = r[0](s), a = r[1](s);
        if (o < a)
          return a;
        const l = r[2](s);
        return o > l ? l : o;
      };
    case B.Mod:
      return (s) => r[0](s) % r[1](s);
    case B.Pow:
      return (s) => Math.pow(r[0](s), r[1](s));
    case B.Abs:
      return (s) => Math.abs(r[0](s));
    case B.Floor:
      return (s) => Math.floor(r[0](s));
    case B.Ceil:
      return (s) => Math.ceil(r[0](s));
    case B.Round:
      return (s) => Math.round(r[0](s));
    case B.Sin:
      return (s) => Math.sin(r[0](s));
    case B.Cos:
      return (s) => Math.cos(r[0](s));
    case B.Atan:
      return n === 2 ? (s) => Math.atan2(r[0](s), r[1](s)) : (s) => Math.atan(r[0](s));
    case B.Sqrt:
      return (s) => Math.sqrt(r[0](s));
    default:
      throw new Error(`Unsupported numeric operator ${t}`);
  }
}
function eF(i, e) {
  const t = i.args.length, n = new Array(t);
  for (let r = 0; r < t; ++r)
    n[r] = Wn(i.args[r]);
  return (r) => {
    for (let s = 0; s < t - 1; s += 2)
      if (n[s](r))
        return n[s + 1](r);
    return n[t - 1](r);
  };
}
function tF(i, e) {
  const t = i.args.length, n = new Array(t);
  for (let r = 0; r < t; ++r)
    n[r] = Wn(i.args[r]);
  return (r) => {
    const s = n[0](r);
    for (let o = 1; o < t - 1; o += 2)
      if (s === n[o](r))
        return n[o + 1](r);
    return n[t - 1](r);
  };
}
function iF(i, e) {
  const t = i.args.length, n = new Array(t);
  for (let r = 0; r < t; ++r)
    n[r] = Wn(i.args[r]);
  return (r) => {
    const s = n[0](r), o = n[1](r);
    let a, l;
    for (let h = 2; h < t; h += 2) {
      const u = n[h](r);
      let c = n[h + 1](r);
      const f = Array.isArray(c);
      if (f && (c = vP(c)), u >= o)
        return h === 2 ? c : f ? rF(
          s,
          o,
          a,
          l,
          u,
          c
        ) : xl(
          s,
          o,
          a,
          l,
          u,
          c
        );
      a = u, l = c;
    }
    return l;
  };
}
function nF(i, e) {
  const t = i.operator, n = i.args.length, r = new Array(n);
  for (let s = 0; s < n; ++s)
    r[s] = Wn(i.args[s]);
  switch (t) {
    case B.ToString:
      return (s) => {
        const o = r[0](s);
        return i.args[0].type === mt ? Sm(o) : o.toString();
      };
    default:
      throw new Error(`Unsupported convert operator ${t}`);
  }
}
function xl(i, e, t, n, r, s) {
  const o = r - t;
  if (o === 0)
    return n;
  const a = e - t, l = i === 1 ? a / o : (Math.pow(i, a) - 1) / (Math.pow(i, o) - 1);
  return n + l * (s - n);
}
function rF(i, e, t, n, r, s) {
  if (r - t === 0)
    return n;
  const a = J_(n), l = J_(s);
  let h = l[2] - a[2];
  h > 180 ? h -= 360 : h < -180 && (h += 360);
  const u = [
    xl(i, e, t, a[0], r, l[0]),
    xl(i, e, t, a[1], r, l[1]),
    a[2] + xl(i, e, t, 0, r, h),
    xl(i, e, t, n[3], r, s[3])
  ];
  return wP(u);
}
function sF(i) {
  return !0;
}
function oF(i) {
  const e = $m(), t = aF(i, e), n = dw();
  return function(r, s) {
    if (n.properties = r.getPropertiesInternal(), n.resolution = s, e.featureId) {
      const o = r.getId();
      o !== void 0 ? n.featureId = o : n.featureId = null;
    }
    return e.geometryType && (n.geometryType = jm(
      r.getGeometry()
    )), t(n);
  };
}
function qy(i) {
  const e = $m(), t = i.length, n = new Array(t);
  for (let o = 0; o < t; ++o)
    n[o] = qg(i[o], e);
  const r = dw(), s = new Array(t);
  return function(o, a) {
    if (r.properties = o.getPropertiesInternal(), r.resolution = a, e.featureId) {
      const h = o.getId();
      h !== void 0 ? r.featureId = h : r.featureId = null;
    }
    let l = 0;
    for (let h = 0; h < t; ++h) {
      const u = n[h](r);
      u && (s[l] = u, l += 1);
    }
    return s.length = l, s;
  };
}
function aF(i, e) {
  const t = i.length, n = new Array(t);
  for (let r = 0; r < t; ++r) {
    const s = i[r], o = "filter" in s ? Wr(s.filter, jt, e) : sF;
    let a;
    if (Array.isArray(s.style)) {
      const l = s.style.length;
      a = new Array(l);
      for (let h = 0; h < l; ++h)
        a[h] = qg(s.style[h], e);
    } else
      a = [qg(s.style, e)];
    n[r] = { filter: o, styles: a };
  }
  return function(r) {
    const s = [];
    let o = !1;
    for (let a = 0; a < t; ++a) {
      const l = n[a].filter;
      if (l(r) && !(i[a].else && o)) {
        o = !0;
        for (const h of n[a].styles) {
          const u = h(r);
          u && s.push(u);
        }
      }
    }
    return s;
  };
}
function qg(i, e) {
  const t = ih(i, "", e), n = nh(i, "", e), r = lF(i, e), s = hF(i, e), o = Ui(i, "z-index", e);
  if (!t && !n && !r && !s && !Ur(i))
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(i)
    );
  const a = new Mt();
  return function(l) {
    let h = !0;
    if (t) {
      const u = t(l);
      u && (h = !1), a.setFill(u);
    }
    if (n) {
      const u = n(l);
      u && (h = !1), a.setStroke(u);
    }
    if (r) {
      const u = r(l);
      u && (h = !1), a.setText(u);
    }
    if (s) {
      const u = s(l);
      u && (h = !1), a.setImage(u);
    }
    return o && a.setZIndex(o(l)), h ? null : a;
  };
}
function ih(i, e, t) {
  let n;
  if (e + "fill-pattern-src" in i)
    n = dF(i, e + "fill-", t);
  else {
    if (i[e + "fill-color"] === "none")
      return (s) => null;
    n = Xm(
      i,
      e + "fill-color",
      t
    );
  }
  if (!n)
    return null;
  const r = new gi();
  return function(s) {
    const o = n(s);
    return o === wm ? null : (r.setColor(o), r);
  };
}
function nh(i, e, t) {
  const n = Ui(
    i,
    e + "stroke-width",
    t
  ), r = Xm(
    i,
    e + "stroke-color",
    t
  );
  if (!n && !r)
    return null;
  const s = Mr(
    i,
    e + "stroke-line-cap",
    t
  ), o = Mr(
    i,
    e + "stroke-line-join",
    t
  ), a = gw(
    i,
    e + "stroke-line-dash",
    t
  ), l = Ui(
    i,
    e + "stroke-line-dash-offset",
    t
  ), h = Ui(
    i,
    e + "stroke-miter-limit",
    t
  ), u = new Ri();
  return function(c) {
    if (r) {
      const f = r(c);
      if (f === wm)
        return null;
      u.setColor(f);
    }
    if (n && u.setWidth(n(c)), s) {
      const f = s(c);
      if (f !== "butt" && f !== "round" && f !== "square")
        throw new Error("Expected butt, round, or square line cap");
      u.setLineCap(f);
    }
    if (o) {
      const f = o(c);
      if (f !== "bevel" && f !== "round" && f !== "miter")
        throw new Error("Expected bevel, round, or miter line join");
      u.setLineJoin(f);
    }
    return a && u.setLineDash(a(c)), l && u.setLineDashOffset(l(c)), h && u.setMiterLimit(h(c)), u;
  };
}
function lF(i, e) {
  const t = "text-", n = Mr(i, t + "value", e);
  if (!n)
    return null;
  const r = ih(i, t, e), s = ih(
    i,
    t + "background-",
    e
  ), o = nh(i, t, e), a = nh(
    i,
    t + "background-",
    e
  ), l = Mr(i, t + "font", e), h = Ui(
    i,
    t + "max-angle",
    e
  ), u = Ui(
    i,
    t + "offset-x",
    e
  ), c = Ui(
    i,
    t + "offset-y",
    e
  ), f = la(
    i,
    t + "overflow",
    e
  ), g = Mr(
    i,
    t + "placement",
    e
  ), d = Ui(i, t + "repeat", e), m = Gf(i, t + "scale", e), x = la(
    i,
    t + "rotate-with-view",
    e
  ), v = Ui(
    i,
    t + "rotation",
    e
  ), p = Mr(i, t + "align", e), y = Mr(
    i,
    t + "justify",
    e
  ), E = Mr(
    i,
    t + "baseline",
    e
  ), b = la(
    i,
    t + "keep-upright",
    e
  ), T = gw(
    i,
    t + "padding",
    e
  ), R = kf(
    i,
    t + "declutter-mode"
  ), M = new Rs({ declutterMode: R });
  return function(C) {
    if (M.setText(n(C)), r && M.setFill(r(C)), s && M.setBackgroundFill(s(C)), o && M.setStroke(o(C)), a && M.setBackgroundStroke(a(C)), l && M.setFont(l(C)), h && M.setMaxAngle(h(C)), u && M.setOffsetX(u(C)), c && M.setOffsetY(c(C)), f && M.setOverflow(f(C)), g) {
      const I = g(C);
      if (I !== "point" && I !== "line")
        throw new Error("Expected point or line for text-placement");
      M.setPlacement(I);
    }
    if (d && M.setRepeat(d(C)), m && M.setScale(m(C)), x && M.setRotateWithView(x(C)), v && M.setRotation(v(C)), p) {
      const I = p(C);
      if (I !== "left" && I !== "center" && I !== "right" && I !== "end" && I !== "start")
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      M.setTextAlign(I);
    }
    if (y) {
      const I = y(C);
      if (I !== "left" && I !== "right" && I !== "center")
        throw new Error("Expected left, right, or center for text-justify");
      M.setJustify(I);
    }
    if (E) {
      const I = E(C);
      if (I !== "bottom" && I !== "top" && I !== "middle" && I !== "alphabetic" && I !== "hanging")
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      M.setTextBaseline(I);
    }
    return T && M.setPadding(T(C)), b && M.setKeepUpright(b(C)), M;
  };
}
function hF(i, e) {
  return "icon-src" in i ? uF(i, e) : "shape-points" in i ? cF(i, e) : "circle-radius" in i ? fF(i, e) : null;
}
function uF(i, e) {
  const t = "icon-", n = t + "src", r = pw(i[n], n), s = Rc(
    i,
    t + "anchor",
    e
  ), o = Gf(i, t + "scale", e), a = Ui(
    i,
    t + "opacity",
    e
  ), l = Rc(
    i,
    t + "displacement",
    e
  ), h = Ui(
    i,
    t + "rotation",
    e
  ), u = la(
    i,
    t + "rotate-with-view",
    e
  ), c = Hy(i, t + "anchor-origin"), f = Ky(
    i,
    t + "anchor-x-units"
  ), g = Ky(
    i,
    t + "anchor-y-units"
  ), d = _F(i, t + "color"), m = pF(i, t + "cross-origin"), x = mF(i, t + "offset"), v = Hy(i, t + "offset-origin"), p = Pc(i, t + "width"), y = Pc(i, t + "height"), E = gF(i, t + "size"), b = kf(
    i,
    t + "declutter-mode"
  ), T = new Ts({
    src: r,
    anchorOrigin: c,
    anchorXUnits: f,
    anchorYUnits: g,
    color: d,
    crossOrigin: m,
    offset: x,
    offsetOrigin: v,
    height: y,
    width: p,
    size: E,
    declutterMode: b
  });
  return function(R) {
    return a && T.setOpacity(a(R)), l && T.setDisplacement(l(R)), h && T.setRotation(h(R)), u && T.setRotateWithView(u(R)), o && T.setScale(o(R)), s && T.setAnchor(s(R)), T;
  };
}
function cF(i, e) {
  const t = "shape-", n = t + "points", r = t + "radius", s = Zg(i[n], n), o = Zg(i[r], r), a = ih(i, t, e), l = nh(i, t, e), h = Gf(i, t + "scale", e), u = Rc(
    i,
    t + "displacement",
    e
  ), c = Ui(
    i,
    t + "rotation",
    e
  ), f = la(
    i,
    t + "rotate-with-view",
    e
  ), g = Pc(i, t + "radius2"), d = Pc(i, t + "angle"), m = kf(
    i,
    t + "declutter-mode"
  ), x = new Cf({
    points: s,
    radius: o,
    radius2: g,
    angle: d,
    declutterMode: m
  });
  return function(v) {
    return a && x.setFill(a(v)), l && x.setStroke(l(v)), u && x.setDisplacement(u(v)), c && x.setRotation(c(v)), f && x.setRotateWithView(f(v)), h && x.setScale(h(v)), x;
  };
}
function fF(i, e) {
  const t = "circle-", n = ih(i, t, e), r = nh(i, t, e), s = Ui(i, t + "radius", e), o = Gf(i, t + "scale", e), a = Rc(
    i,
    t + "displacement",
    e
  ), l = Ui(
    i,
    t + "rotation",
    e
  ), h = la(
    i,
    t + "rotate-with-view",
    e
  ), u = kf(
    i,
    t + "declutter-mode"
  ), c = new Xa({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode: u
  });
  return function(f) {
    return s && c.setRadius(s(f)), n && c.setFill(n(f)), r && c.setStroke(r(f)), a && c.setDisplacement(a(f)), l && c.setRotation(l(f)), h && c.setRotateWithView(h(f)), o && c.setScale(o(f)), c;
  };
}
function Ui(i, e, t) {
  if (!(e in i))
    return;
  const n = Wr(i[e], oe, t);
  return function(r) {
    return Zg(n(r), e);
  };
}
function Mr(i, e, t) {
  if (!(e in i))
    return null;
  const n = Wr(i[e], Kt, t);
  return function(r) {
    return pw(n(r), e);
  };
}
function dF(i, e, t) {
  const n = Mr(
    i,
    e + "pattern-src",
    t
  ), r = Zy(
    i,
    e + "pattern-offset",
    t
  ), s = Zy(
    i,
    e + "pattern-size",
    t
  ), o = Xm(
    i,
    e + "color",
    t
  );
  return function(a) {
    return {
      src: n(a),
      offset: r && r(a),
      size: s && s(a),
      color: o && o(a)
    };
  };
}
function la(i, e, t) {
  if (!(e in i))
    return null;
  const n = Wr(i[e], jt, t);
  return function(r) {
    const s = n(r);
    if (typeof s != "boolean")
      throw new Error(`Expected a boolean for ${e}`);
    return s;
  };
}
function Xm(i, e, t) {
  if (!(e in i))
    return null;
  const n = Wr(i[e], mt, t);
  return function(r) {
    return mw(n(r), e);
  };
}
function gw(i, e, t) {
  if (!(e in i))
    return null;
  const n = Wr(i[e], Wi, t);
  return function(r) {
    return Oh(n(r), e);
  };
}
function Rc(i, e, t) {
  if (!(e in i))
    return null;
  const n = Wr(i[e], Wi, t);
  return function(r) {
    const s = Oh(n(r), e);
    if (s.length !== 2)
      throw new Error(`Expected two numbers for ${e}`);
    return s;
  };
}
function Zy(i, e, t) {
  if (!(e in i))
    return null;
  const n = Wr(i[e], Wi, t);
  return function(r) {
    return _w(n(r), e);
  };
}
function Gf(i, e, t) {
  if (!(e in i))
    return null;
  const n = Wr(
    i[e],
    Wi | oe,
    t
  );
  return function(r) {
    return yF(n(r), e);
  };
}
function Pc(i, e) {
  const t = i[e];
  if (t !== void 0) {
    if (typeof t != "number")
      throw new Error(`Expected a number for ${e}`);
    return t;
  }
}
function gF(i, e) {
  const t = i[e];
  if (t !== void 0) {
    if (typeof t == "number")
      return dt(t);
    if (!Array.isArray(t))
      throw new Error(`Expected a number or size array for ${e}`);
    if (t.length !== 2 || typeof t[0] != "number" || typeof t[1] != "number")
      throw new Error(`Expected a number or size array for ${e}`);
    return t;
  }
}
function pF(i, e) {
  const t = i[e];
  if (t !== void 0) {
    if (typeof t != "string")
      throw new Error(`Expected a string for ${e}`);
    return t;
  }
}
function Hy(i, e) {
  const t = i[e];
  if (t !== void 0) {
    if (t !== "bottom-left" && t !== "bottom-right" && t !== "top-left" && t !== "top-right")
      throw new Error(
        `Expected bottom-left, bottom-right, top-left, or top-right for ${e}`
      );
    return t;
  }
}
function Ky(i, e) {
  const t = i[e];
  if (t !== void 0) {
    if (t !== "pixels" && t !== "fraction")
      throw new Error(`Expected pixels or fraction for ${e}`);
    return t;
  }
}
function mF(i, e) {
  const t = i[e];
  if (t !== void 0)
    return Oh(t, e);
}
function kf(i, e) {
  const t = i[e];
  if (t !== void 0) {
    if (typeof t != "string")
      throw new Error(`Expected a string for ${e}`);
    if (t !== "declutter" && t !== "obstacle" && t !== "none")
      throw new Error(`Expected declutter, obstacle, or none for ${e}`);
    return t;
  }
}
function _F(i, e) {
  const t = i[e];
  if (t !== void 0)
    return mw(t, e);
}
function Oh(i, e) {
  if (!Array.isArray(i))
    throw new Error(`Expected an array for ${e}`);
  const t = i.length;
  for (let n = 0; n < t; ++n)
    if (typeof i[n] != "number")
      throw new Error(`Expected an array of numbers for ${e}`);
  return i;
}
function pw(i, e) {
  if (typeof i != "string")
    throw new Error(`Expected a string for ${e}`);
  return i;
}
function Zg(i, e) {
  if (typeof i != "number")
    throw new Error(`Expected a number for ${e}`);
  return i;
}
function mw(i, e) {
  if (typeof i == "string")
    return i;
  const t = Oh(i, e), n = t.length;
  if (n < 3 || n > 4)
    throw new Error(`Expected a color with 3 or 4 values for ${e}`);
  return t;
}
function _w(i, e) {
  const t = Oh(i, e);
  if (t.length !== 2)
    throw new Error(`Expected an array of two numbers for ${e}`);
  return t;
}
function yF(i, e) {
  return typeof i == "number" ? i : _w(i, e);
}
const Fn = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};
function Jy(i, e, t) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    (function(n, r, s, o, a) {
      if (!n)
        return;
      if (!r && !e)
        return n;
      const l = e ? 0 : s[0] * r, h = e ? 0 : s[1] * r, u = a ? a[0] : 0, c = a ? a[1] : 0;
      let f = i[0] + l / 2 + u, g = i[2] - l / 2 + u, d = i[1] + h / 2 + c, m = i[3] - h / 2 + c;
      f > g && (f = (g + f) / 2, g = f), d > m && (d = (m + d) / 2, m = d);
      let x = ve(n[0], f, g), v = ve(n[1], d, m);
      if (o && t && r) {
        const p = 30 * r;
        x += -p * Math.log(1 + Math.max(0, f - n[0]) / p) + p * Math.log(1 + Math.max(0, n[0] - g) / p), v += -p * Math.log(1 + Math.max(0, d - n[1]) / p) + p * Math.log(1 + Math.max(0, n[1] - m) / p);
      }
      return [x, v];
    })
  );
}
function xF(i) {
  return i;
}
function yw(i) {
  return Math.pow(i, 3);
}
function qa(i) {
  return 1 - yw(1 - i);
}
function EF(i) {
  return 3 * i * i - 2 * i * i * i;
}
function vF(i) {
  return i;
}
function Vm(i, e, t, n) {
  const r = _e(e) / t[0], s = it(e) / t[1];
  return n ? Math.min(i, Math.max(r, s)) : Math.min(i, Math.min(r, s));
}
function Wm(i, e, t) {
  let n = Math.min(i, e);
  const r = 50;
  return n *= Math.log(1 + r * Math.max(0, i / e - 1)) / r + 1, t && (n = Math.max(n, t), n /= Math.log(1 + r * Math.max(0, t / i - 1)) / r + 1), ve(n, t / 2, e * 2);
}
function wF(i, e, t, n) {
  return e = e !== void 0 ? e : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  (function(r, s, o, a) {
    if (r !== void 0) {
      const l = i[0], h = i[i.length - 1], u = t ? Vm(
        l,
        t,
        o,
        n
      ) : l;
      if (a)
        return e ? Wm(
          r,
          u,
          h
        ) : ve(r, h, u);
      const c = Math.min(u, r), f = Math.floor(ff(i, c, s));
      return i[f] > u && f < i.length - 1 ? i[f + 1] : i[f];
    }
  });
}
function bF(i, e, t, n, r, s) {
  return n = n !== void 0 ? n : !0, t = t !== void 0 ? t : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  (function(o, a, l, h) {
    if (o !== void 0) {
      const u = r ? Vm(
        e,
        r,
        l,
        s
      ) : e;
      if (h)
        return n ? Wm(
          o,
          u,
          t
        ) : ve(o, t, u);
      const c = 1e-9, f = Math.ceil(
        Math.log(e / u) / Math.log(i) - c
      ), g = -a * (0.5 - c) + 0.5, d = Math.min(u, o), m = Math.floor(
        Math.log(e / d) / Math.log(i) + g
      ), x = Math.max(f, m), v = e / Math.pow(i, x);
      return ve(v, t, u);
    }
  });
}
function Qy(i, e, t, n, r) {
  return t = t !== void 0 ? t : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  (function(s, o, a, l) {
    if (s !== void 0) {
      const h = n ? Vm(
        i,
        n,
        a,
        r
      ) : i;
      return !t || !l ? ve(s, e, h) : Wm(
        s,
        h,
        e
      );
    }
  });
}
function Ym(i) {
  if (i !== void 0)
    return 0;
}
function e1(i) {
  if (i !== void 0)
    return i;
}
function SF(i) {
  const e = 2 * Math.PI / i;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    (function(t, n) {
      if (n)
        return t;
      if (t !== void 0)
        return t = Math.floor(t / e + 0.5) * e, t;
    })
  );
}
function TF(i) {
  const e = Fr(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    (function(t, n) {
      return n || t === void 0 ? t : Math.abs(t) <= e ? 0 : t;
    })
  );
}
const xw = 42, Ta = 256, kd = 0;
class sr extends _r {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = Object.assign({}, e), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = Qp(e.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, e.projection && AE(), e.center && (e.center = Pr(e.center, this.projection_)), e.extent && (e.extent = xn(e.extent, this.projection_)), this.applyOptions_(e);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(e) {
    const t = Object.assign({}, e);
    for (const a in Fn)
      delete t[a];
    this.setProperties(t, !0);
    const n = PF(e);
    this.maxResolution_ = n.maxResolution, this.minResolution_ = n.minResolution, this.zoomFactor_ = n.zoomFactor, this.resolutions_ = e.resolutions, this.padding_ = e.padding, this.minZoom_ = n.minZoom;
    const r = RF(e), s = n.constraint, o = MF(e);
    this.constraints_ = {
      center: r,
      resolution: s,
      rotation: o
    }, this.setRotation(e.rotation !== void 0 ? e.rotation : 0), this.setCenterInternal(
      e.center !== void 0 ? e.center : null
    ), e.resolution !== void 0 ? this.setResolution(e.resolution) : e.zoom !== void 0 && this.setZoom(e.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(e) {
    let t = this.padding_;
    this.padding_ = e;
    const n = this.getCenterInternal();
    if (n) {
      const r = e || [0, 0, 0, 0];
      t = t || [0, 0, 0, 0];
      const s = this.getResolution(), o = s / 2 * (r[3] - t[3] + t[1] - r[1]), a = s / 2 * (r[0] - t[0] + t[2] - r[2]);
      this.setCenterInternal([n[0] + o, n[1] - a]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(e) {
    const t = this.getProperties();
    return t.resolution !== void 0 ? t.resolution = this.getResolution() : t.zoom = this.getZoom(), t.center = this.getCenterInternal(), t.rotation = this.getRotation(), Object.assign({}, t, e);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(e) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const t = new Array(arguments.length);
    for (let n = 0; n < t.length; ++n) {
      let r = arguments[n];
      r.center && (r = Object.assign({}, r), r.center = Pr(
        r.center,
        this.getProjection()
      )), r.anchor && (r = Object.assign({}, r), r.anchor = Pr(
        r.anchor,
        this.getProjection()
      )), t[n] = r;
    }
    this.animateInternal.apply(this, t);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(e) {
    let t = arguments.length, n;
    t > 1 && typeof arguments[t - 1] == "function" && (n = arguments[t - 1], --t);
    let r = 0;
    for (; r < t && !this.isDef(); ++r) {
      const u = arguments[r];
      u.center && this.setCenterInternal(u.center), u.zoom !== void 0 ? this.setZoom(u.zoom) : u.resolution && this.setResolution(u.resolution), u.rotation !== void 0 && this.setRotation(u.rotation);
    }
    if (r === t) {
      n && yu(n, !0);
      return;
    }
    let s = Date.now(), o = this.targetCenter_.slice(), a = this.targetResolution_, l = this.targetRotation_;
    const h = [];
    for (; r < t; ++r) {
      const u = (
        /** @type {AnimationOptions} */
        arguments[r]
      ), c = {
        start: s,
        complete: !1,
        anchor: u.anchor,
        duration: u.duration !== void 0 ? u.duration : 1e3,
        easing: u.easing || EF,
        callback: n
      };
      if (u.center && (c.sourceCenter = o, c.targetCenter = u.center.slice(), o = c.targetCenter), u.zoom !== void 0 ? (c.sourceResolution = a, c.targetResolution = this.getResolutionForZoom(u.zoom), a = c.targetResolution) : u.resolution && (c.sourceResolution = a, c.targetResolution = u.resolution, a = c.targetResolution), u.rotation !== void 0) {
        c.sourceRotation = l;
        const f = $n(u.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
        c.targetRotation = l + f, l = c.targetRotation;
      }
      CF(c) ? c.complete = !0 : s += c.duration, h.push(c);
    }
    this.animations_.push(h), this.setHint(Xe.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[Xe.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[Xe.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(Xe.ANIMATING, -this.hints_[Xe.ANIMATING]);
    let e;
    for (let t = 0, n = this.animations_.length; t < n; ++t) {
      const r = this.animations_[t];
      if (r[0].callback && yu(r[0].callback, !1), !e)
        for (let s = 0, o = r.length; s < o; ++s) {
          const a = r[s];
          if (!a.complete) {
            e = a.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = e, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const e = Date.now();
    let t = !1;
    for (let n = this.animations_.length - 1; n >= 0; --n) {
      const r = this.animations_[n];
      let s = !0;
      for (let o = 0, a = r.length; o < a; ++o) {
        const l = r[o];
        if (l.complete)
          continue;
        const h = e - l.start;
        let u = l.duration > 0 ? h / l.duration : 1;
        u >= 1 ? (l.complete = !0, u = 1) : s = !1;
        const c = l.easing(u);
        if (l.sourceCenter) {
          const f = l.sourceCenter[0], g = l.sourceCenter[1], d = l.targetCenter[0], m = l.targetCenter[1];
          this.nextCenter_ = l.targetCenter;
          const x = f + c * (d - f), v = g + c * (m - g);
          this.targetCenter_ = [x, v];
        }
        if (l.sourceResolution && l.targetResolution) {
          const f = c === 1 ? l.targetResolution : l.sourceResolution + c * (l.targetResolution - l.sourceResolution);
          if (l.anchor) {
            const g = this.getViewportSize_(this.getRotation()), d = this.constraints_.resolution(
              f,
              0,
              g,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              d,
              l.anchor
            );
          }
          this.nextResolution_ = l.targetResolution, this.targetResolution_ = f, this.applyTargetState_(!0);
        }
        if (l.sourceRotation !== void 0 && l.targetRotation !== void 0) {
          const f = c === 1 ? $n(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : l.sourceRotation + c * (l.targetRotation - l.sourceRotation);
          if (l.anchor) {
            const g = this.constraints_.rotation(
              f,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              g,
              l.anchor
            );
          }
          this.nextRotation_ = l.targetRotation, this.targetRotation_ = f;
        }
        if (this.applyTargetState_(!0), t = !0, !l.complete)
          break;
      }
      if (s) {
        this.animations_[n] = null, this.setHint(Xe.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const o = r[0].callback;
        o && yu(o, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), t && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(e, t) {
    let n;
    const r = this.getCenterInternal();
    return r !== void 0 && (n = [r[0] - t[0], r[1] - t[1]], qp(n, e - this.getRotation()), wE(n, t)), n;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(e, t) {
    let n;
    const r = this.getCenterInternal(), s = this.getResolution();
    if (r !== void 0 && s !== void 0) {
      const o = t[0] - e * (t[0] - r[0]) / s, a = t[1] - e * (t[1] - r[1]) / s;
      n = [o, a];
    }
    return n;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(e) {
    const t = this.viewportSize_;
    if (e) {
      const n = t[0], r = t[1];
      return [
        Math.abs(n * Math.cos(e)) + Math.abs(r * Math.sin(e)),
        Math.abs(n * Math.sin(e)) + Math.abs(r * Math.cos(e))
      ];
    }
    return t;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(e) {
    this.viewportSize_ = Array.isArray(e) ? e.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const e = this.getCenterInternal();
    return e && uc(e, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Fn.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(e) {
    return e !== void 0 ? (e[0] = this.hints_[0], e[1] = this.hints_[1], e) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(e) {
    const t = this.calculateExtentInternal(e);
    return _f(t, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(e) {
    e = e || this.getViewportSizeMinusPadding_();
    const t = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    Te(t, "The view center is not defined");
    const n = (
      /** @type {!number} */
      this.getResolution()
    );
    Te(n !== void 0, "The view resolution is not defined");
    const r = (
      /** @type {!number} */
      this.getRotation()
    );
    return Te(r !== void 0, "The view rotation is not defined"), nc(t, n, r, e);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: e }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: e }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(e) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: e }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(Fn.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(e, t) {
    return this.getResolutionForExtentInternal(
      xn(e, this.getProjection()),
      t
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(e, t) {
    t = t || this.getViewportSizeMinusPadding_();
    const n = _e(e) / t[0], r = it(e) / t[1];
    return Math.max(n, r);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(e) {
    e = e || 2;
    const t = this.getConstrainedResolution(this.maxResolution_), n = this.minResolution_, r = Math.log(t / n) / Math.log(e);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      (function(s) {
        return t / Math.pow(e, s * r);
      })
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(Fn.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(e) {
    const t = Math.log(e || 2), n = this.getConstrainedResolution(this.maxResolution_), r = this.minResolution_, s = Math.log(n / r) / t;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      (function(o) {
        return Math.log(n / o) / t / s;
      })
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(e) {
    let t = this.getViewportSize_(e);
    const n = this.padding_;
    return n && (t = [
      t[0] - n[1] - n[3],
      t[1] - n[0] - n[2]
    ]), t;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const e = this.getProjection(), t = this.getResolution(), n = this.getRotation();
    let r = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const s = this.padding_;
    if (s) {
      const o = this.getViewportSizeMinusPadding_();
      r = Ud(
        r,
        this.getViewportSize_(),
        [o[0] / 2 + s[3], o[1] / 2 + s[0]],
        t,
        n
      );
    }
    return {
      center: r.slice(0),
      projection: e !== void 0 ? e : null,
      resolution: t,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: n,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let e;
    const t = this.getResolution();
    return t !== void 0 && (e = this.getZoomForResolution(t)), e;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(e) {
    let t = this.minZoom_ || 0, n, r;
    if (this.resolutions_) {
      const s = ff(this.resolutions_, e, 1);
      t = s, n = this.resolutions_[s], s == this.resolutions_.length - 1 ? r = 2 : r = n / this.resolutions_[s + 1];
    } else
      n = this.maxResolution_, r = this.zoomFactor_;
    return t + Math.log(n / e) / Math.log(r);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(e) {
    if (this.resolutions_?.length) {
      if (this.resolutions_.length === 1)
        return this.resolutions_[0];
      const t = ve(
        Math.floor(e),
        0,
        this.resolutions_.length - 2
      ), n = this.resolutions_[t] / this.resolutions_[t + 1];
      return this.resolutions_[t] / Math.pow(n, ve(e - t, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, e - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(e, t) {
    let n;
    if (Te(
      Array.isArray(e) || typeof /** @type {?} */
      e.getSimplifiedGeometry == "function",
      "Invalid extent or geometry provided as `geometry`"
    ), Array.isArray(e)) {
      Te(
        !qn(e),
        "Cannot fit empty extent provided as `geometry`"
      );
      const r = xn(e, this.getProjection());
      n = W_(r);
    } else if (e.getType() === "Circle") {
      const r = xn(
        e.getExtent(),
        this.getProjection()
      );
      n = W_(r), n.rotate(this.getRotation(), Vt(r));
    } else
      n = e;
    this.fitInternal(n, t);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(e) {
    const t = this.getRotation(), n = Math.cos(t), r = Math.sin(-t), s = e.getFlatCoordinates(), o = e.getStride();
    let a = 1 / 0, l = 1 / 0, h = -1 / 0, u = -1 / 0;
    for (let c = 0, f = s.length; c < f; c += o) {
      const g = s[c] * n - s[c + 1] * r, d = s[c] * r + s[c + 1] * n;
      a = Math.min(a, g), l = Math.min(l, d), h = Math.max(h, g), u = Math.max(u, d);
    }
    return [a, l, h, u];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(e, t) {
    t = t || {};
    let n = t.size;
    n || (n = this.getViewportSizeMinusPadding_());
    const r = t.padding !== void 0 ? t.padding : [0, 0, 0, 0], s = t.nearest !== void 0 ? t.nearest : !1;
    let o;
    t.minResolution !== void 0 ? o = t.minResolution : t.maxZoom !== void 0 ? o = this.getResolutionForZoom(t.maxZoom) : o = 0;
    const a = this.rotatedExtentForGeometry(e);
    let l = this.getResolutionForExtentInternal(a, [
      n[0] - r[1] - r[3],
      n[1] - r[0] - r[2]
    ]);
    l = isNaN(l) ? o : Math.max(l, o), l = this.getConstrainedResolution(l, s ? 0 : 1);
    const h = this.getRotation(), u = Math.sin(h), c = Math.cos(h), f = Vt(a);
    f[0] += (r[1] - r[3]) / 2 * l, f[1] += (r[0] - r[2]) / 2 * l;
    const g = f[0] * c - f[1] * u, d = f[1] * c + f[0] * u, m = this.getConstrainedCenter([g, d], l), x = t.callback ? t.callback : Yl;
    t.duration !== void 0 ? this.animateInternal(
      {
        resolution: l,
        center: m,
        duration: t.duration,
        easing: t.easing
      },
      x
    ) : (this.targetResolution_ = l, this.targetCenter_ = m, this.applyTargetState_(!1, !0), yu(x, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(e, t, n) {
    this.centerOnInternal(
      Pr(e, this.getProjection()),
      t,
      n
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(e, t, n) {
    this.setCenterInternal(
      Ud(
        e,
        t,
        n,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(e, t, n, r) {
    let s;
    const o = this.padding_;
    if (o && e) {
      const a = this.getViewportSizeMinusPadding_(-n), l = Ud(
        e,
        r,
        [a[0] / 2 + o[3], a[1] / 2 + o[0]],
        t,
        n
      );
      s = [
        e[0] - l[0],
        e[1] - l[1]
      ];
    }
    return s;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(e) {
    const t = uc(this.targetCenter_, this.getProjection());
    this.setCenter([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(e) {
    const t = this.targetCenter_;
    this.setCenterInternal([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(e, t) {
    t = t && Pr(t, this.getProjection()), this.adjustResolutionInternal(e, t);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(e, t) {
    const n = this.getAnimating() || this.getInteracting(), r = this.getViewportSize_(this.getRotation()), s = this.constraints_.resolution(
      this.targetResolution_ * e,
      0,
      r,
      n
    );
    t && (this.targetCenter_ = this.calculateCenterZoom(s, t)), this.targetResolution_ *= e, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(e, t) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -e), t);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(e, t) {
    t && (t = Pr(t, this.getProjection())), this.adjustRotationInternal(e, t);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(e, t) {
    const n = this.getAnimating() || this.getInteracting(), r = this.constraints_.rotation(
      this.targetRotation_ + e,
      n
    );
    t && (this.targetCenter_ = this.calculateCenterRotate(r, t)), this.targetRotation_ += e, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(e) {
    this.setCenterInternal(
      e && Pr(e, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(e) {
    this.targetCenter_ = e, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(e, t) {
    return this.hints_[e] += t, this.changed(), this.hints_[e];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(e) {
    this.targetResolution_ = e, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(e) {
    this.targetRotation_ = e, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(e) {
    this.setResolution(this.getResolutionForZoom(e));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(e, t) {
    const n = this.getAnimating() || this.getInteracting() || t, r = this.constraints_.rotation(
      this.targetRotation_,
      n
    ), s = this.getViewportSize_(r), o = this.constraints_.resolution(
      this.targetResolution_,
      0,
      s,
      n
    ), a = this.constraints_.center(
      this.targetCenter_,
      o,
      s,
      n,
      this.calculateCenterShift(
        this.targetCenter_,
        o,
        r,
        s
      )
    );
    this.get(Fn.ROTATION) !== r && this.set(Fn.ROTATION, r), this.get(Fn.RESOLUTION) !== o && (this.set(Fn.RESOLUTION, o), this.set("zoom", this.getZoom(), !0)), (!a || !this.get(Fn.CENTER) || !sc(this.get(Fn.CENTER), a)) && this.set(Fn.CENTER, a), this.getAnimating() && !e && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(e, t, n) {
    e = e !== void 0 ? e : 200;
    const r = t || 0, s = this.constraints_.rotation(this.targetRotation_), o = this.getViewportSize_(s), a = this.constraints_.resolution(
      this.targetResolution_,
      r,
      o
    ), l = this.constraints_.center(
      this.targetCenter_,
      a,
      o,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        a,
        s,
        o
      )
    );
    if (e === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = a, this.targetRotation_ = s, this.targetCenter_ = l, this.applyTargetState_();
      return;
    }
    n = n || (e === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== a || this.getRotation() !== s || !this.getCenterInternal() || !sc(this.getCenterInternal(), l)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: s,
      center: l,
      resolution: a,
      duration: e,
      easing: qa,
      anchor: n
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(Xe.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(e, t, n) {
    n = n && Pr(n, this.getProjection()), this.endInteractionInternal(e, t, n);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(e, t, n) {
    this.getInteracting() && (this.setHint(Xe.INTERACTING, -1), this.resolveConstraints(e, t, n));
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(e, t) {
    const n = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      e,
      t || this.getResolution(),
      n
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(e, t) {
    const n = this.getResolutionForZoom(e);
    return this.getZoomForResolution(
      this.getConstrainedResolution(n, t)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(e, t) {
    t = t || 0;
    const n = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(e, t, n);
  }
}
function yu(i, e) {
  setTimeout(function() {
    i(e);
  }, 0);
}
function RF(i) {
  if (i.extent !== void 0) {
    const t = i.smoothExtentConstraint !== void 0 ? i.smoothExtentConstraint : !0;
    return Jy(i.extent, i.constrainOnlyCenter, t);
  }
  const e = Qp(i.projection, "EPSG:3857");
  if (i.multiWorld !== !0 && e.isGlobal()) {
    const t = e.getExtent().slice();
    return t[0] = -1 / 0, t[2] = 1 / 0, Jy(t, !1, !1);
  }
  return xF;
}
function PF(i) {
  let e, t, n, o = i.minZoom !== void 0 ? i.minZoom : kd, a = i.maxZoom !== void 0 ? i.maxZoom : 28;
  const l = i.zoomFactor !== void 0 ? i.zoomFactor : 2, h = i.multiWorld !== void 0 ? i.multiWorld : !1, u = i.smoothResolutionConstraint !== void 0 ? i.smoothResolutionConstraint : !0, c = i.showFullExtent !== void 0 ? i.showFullExtent : !1, f = Qp(i.projection, "EPSG:3857"), g = f.getExtent();
  let d = i.constrainOnlyCenter, m = i.extent;
  if (!h && !m && f.isGlobal() && (d = !1, m = g), i.resolutions !== void 0) {
    const x = i.resolutions;
    t = x[o], n = x[a] !== void 0 ? x[a] : x[x.length - 1], i.constrainResolution ? e = wF(
      x,
      u,
      !d && m,
      c
    ) : e = Qy(
      t,
      n,
      u,
      !d && m,
      c
    );
  } else {
    const v = (g ? Math.max(_e(g), it(g)) : (
      // use an extent that can fit the whole world if need be
      360 * ws.degrees / f.getMetersPerUnit()
    )) / Ta / Math.pow(2, kd), p = v / Math.pow(2, 28 - kd);
    t = i.maxResolution, t !== void 0 ? o = 0 : t = v / Math.pow(l, o), n = i.minResolution, n === void 0 && (i.maxZoom !== void 0 ? i.maxResolution !== void 0 ? n = t / Math.pow(l, a) : n = v / Math.pow(l, a) : n = p), a = o + Math.floor(
      Math.log(t / n) / Math.log(l)
    ), n = t / Math.pow(l, a - o), i.constrainResolution ? e = bF(
      l,
      t,
      n,
      u,
      !d && m,
      c
    ) : e = Qy(
      t,
      n,
      u,
      !d && m,
      c
    );
  }
  return {
    constraint: e,
    maxResolution: t,
    minResolution: n,
    minZoom: o,
    zoomFactor: l
  };
}
function MF(i) {
  if (i.enableRotation !== void 0 ? i.enableRotation : !0) {
    const t = i.constrainRotation;
    return t === void 0 || t === !0 ? TF() : t === !1 ? e1 : typeof t == "number" ? SF(t) : e1;
  }
  return Ym;
}
function CF(i) {
  return !(i.sourceCenter && i.targetCenter && !sc(i.sourceCenter, i.targetCenter) || i.sourceResolution !== i.targetResolution || i.sourceRotation !== i.targetRotation);
}
function Ud(i, e, t, n, r) {
  const s = Math.cos(-r);
  let o = Math.sin(-r), a = i[0] * s - i[1] * o, l = i[1] * s + i[0] * o;
  a += (e[0] / 2 - t[0]) * n, l += (t[1] - e[1] / 2) * n, o = -o;
  const h = a * s - l * o, u = l * s + a * o;
  return [h, u];
}
const je = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
class Ew extends _r {
  /**
   * @param {Options} options Layer options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.background_ = e.background;
    const t = Object.assign({}, e);
    typeof e.properties == "object" && (delete t.properties, Object.assign(t, e.properties)), t[je.OPACITY] = e.opacity !== void 0 ? e.opacity : 1, Te(
      typeof t[je.OPACITY] == "number",
      "Layer opacity must be a number"
    ), t[je.VISIBLE] = e.visible !== void 0 ? e.visible : !0, t[je.Z_INDEX] = e.zIndex, t[je.MAX_RESOLUTION] = e.maxResolution !== void 0 ? e.maxResolution : 1 / 0, t[je.MIN_RESOLUTION] = e.minResolution !== void 0 ? e.minResolution : 0, t[je.MIN_ZOOM] = e.minZoom !== void 0 ? e.minZoom : -1 / 0, t[je.MAX_ZOOM] = e.maxZoom !== void 0 ? e.maxZoom : 1 / 0, this.className_ = t.className !== void 0 ? t.className : "ol-layer", delete t.className, this.setProperties(t), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(e) {
    const t = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: e === void 0 ? !0 : e
    }, n = this.getZIndex();
    return t.opacity = ve(Math.round(this.getOpacity() * 100) / 100, 0, 1), t.visible = this.getVisible(), t.extent = this.getExtent(), t.zIndex = n === void 0 && !t.managed ? 1 / 0 : n, t.maxResolution = this.getMaxResolution(), t.minResolution = Math.max(this.getMinResolution(), 0), t.minZoom = this.getMinZoom(), t.maxZoom = this.getMaxZoom(), this.state_ = t, t;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return de();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return de();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(je.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(je.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(je.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(je.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(je.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(je.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return de();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(je.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get(je.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(e) {
    this.background_ = e, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(e) {
    this.set(je.EXTENT, e);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(e) {
    this.set(je.MAX_RESOLUTION, e);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(e) {
    this.set(je.MIN_RESOLUTION, e);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(e) {
    this.set(je.MAX_ZOOM, e);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(e) {
    this.set(je.MIN_ZOOM, e);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(e) {
    Te(typeof e == "number", "Layer opacity must be a number"), this.set(je.OPACITY, e);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(e) {
    this.set(je.VISIBLE, e);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(e) {
    this.set(je.Z_INDEX, e);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
}
class Yr extends Ew {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(e) {
    const t = Object.assign({}, e);
    delete t.source, super(t), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, e.render && (this.render = e.render), e.map && this.setMap(e.map), this.addChangeListener(
      je.SOURCE,
      this.handleSourcePropertyChange_
    );
    const n = e.source ? (
      /** @type {SourceType} */
      e.source
    ) : null;
    this.setSource(n);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(e) {
    return e = e || [], e.push(this), e;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(e) {
    return e = e || [], e.push(this.getLayerState()), e;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(je.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    const e = this.getSource();
    return e ? e.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && (tt(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
    const e = this.getSource();
    e && (this.sourceChangeKey_ = Ce(
      e,
      le.CHANGE,
      this.handleSourceChange_,
      this
    ), e.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
      this.dispatchEvent("sourceready");
    }, 0))), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return this.renderer_ ? this.renderer_.getFeatures(e) : Promise.resolve([]);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(e);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(e) {
    let t;
    const n = this.getMapInternal();
    !e && n && (e = n.getView()), e instanceof sr ? t = {
      viewState: e.getState(),
      extent: e.calculateExtent()
    } : t = e, !t.layerStatesArray && n && (t.layerStatesArray = n.getLayerGroup().getLayerStatesArray());
    let r;
    if (t.layerStatesArray) {
      if (r = t.layerStatesArray.find(
        (o) => o.layer === this
      ), !r)
        return !1;
    } else
      r = this.getLayerState();
    const s = this.getExtent();
    return qm(r, t.viewState) && (!s || ft(s, t.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(e) {
    if (!this.isVisible(e))
      return [];
    const t = this.getSource()?.getAttributions();
    if (!t)
      return [];
    const n = e instanceof sr ? e.getViewStateAndExtent() : e;
    let r = t(n);
    return Array.isArray(r) || (r = [r]), r;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(e, t) {
    const n = this.getRenderer();
    return n.prepareFrame(e) ? (this.rendered = !0, n.renderFrame(e, t)) : null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /** @return {string} Declutter */
  getDeclutter() {
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, t) {
  }
  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(e) {
    const t = this.getRenderer();
    t && t.renderDeferred(e);
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(e) {
    e || this.unrender(), this.set(je.MAP, e);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(je.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.mapPrecomposeKey_ && (tt(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), e || this.changed(), this.mapRenderKey_ && (tt(this.mapRenderKey_), this.mapRenderKey_ = null), e && (this.mapPrecomposeKey_ = Ce(
      e,
      Ht.PRECOMPOSE,
      this.handlePrecompose_,
      this
    ), this.mapRenderKey_ = Ce(this, le.CHANGE, e.render, e), this.changed());
  }
  /**
   * @param {import("../events/Event.js").default} renderEvent Render event
   * @private
   */
  handlePrecompose_(e) {
    const t = (
      /** @type {import("../render/Event.js").default} */
      e.frameState.layerStatesArray
    ), n = this.getLayerState(!1);
    Te(
      !t.some(
        (r) => r.layer === n.layer
      ),
      "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
    ), t.push(n);
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(e) {
    this.set(je.SOURCE, e);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * This will clear the renderer so that a new one can be created next time it is needed
   */
  clearRenderer() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.clearRenderer(), this.setSource(null), super.disposeInternal();
  }
}
function qm(i, e) {
  if (!i.visible)
    return !1;
  const t = e.resolution;
  if (t < i.minResolution || t >= i.maxResolution)
    return !1;
  const n = e.zoom;
  return n > i.minZoom && n <= i.maxZoom;
}
const t1 = {
  RENDER_ORDER: "renderOrder"
};
class bo extends Yr {
  /**
   * @param {Options<FeatureType, VectorSourceType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.style, delete t.renderBuffer, delete t.updateWhileAnimating, delete t.updateWhileInteracting, super(t), this.declutter_ = e.declutter ? String(e.declutter) : void 0, this.renderBuffer_ = e.renderBuffer !== void 0 ? e.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(e.style), this.updateWhileAnimating_ = e.updateWhileAnimating !== void 0 ? e.updateWhileAnimating : !1, this.updateWhileInteracting_ = e.updateWhileInteracting !== void 0 ? e.updateWhileInteracting : !1;
  }
  /**
   * @return {string} Declutter group.
   * @override
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   * @override
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {import("../render.js").OrderFunction|null|undefined} Render order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(t1.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   * @override
   */
  renderDeclutter(e, t) {
    const n = this.getDeclutter();
    n in e.declutter || (e.declutter[n] = new km(9)), this.getRenderer().renderDeclutter(e, t);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(e) {
    this.set(t1.RENDER_ORDER, e);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(e) {
    this.style_ = e === void 0 ? lv : e;
    const t = AF(e);
    this.styleFunction_ = e === null ? void 0 : NP(t), this.changed();
  }
  /**
   * @param {boolean|string|number} declutter Declutter images and text.
   * @api
   */
  setDeclutter(e) {
    this.declutter_ = e ? String(e) : void 0, this.changed();
  }
}
function AF(i) {
  if (i === void 0)
    return lv;
  if (!i)
    return null;
  if (typeof i == "function" || i instanceof Mt)
    return i;
  if (!Array.isArray(i))
    return qy([i]);
  if (i.length === 0)
    return [];
  const e = i.length, t = i[0];
  if (t instanceof Mt) {
    const r = new Array(e);
    for (let s = 0; s < e; ++s) {
      const o = i[s];
      if (!(o instanceof Mt))
        throw new Error("Expected a list of style instances");
      r[s] = o;
    }
    return r;
  }
  if ("style" in t) {
    const r = new Array(e);
    for (let s = 0; s < e; ++s) {
      const o = i[s];
      if (!("style" in o))
        throw new Error("Expected a list of rules with a style property");
      r[s] = o;
    }
    return oF(r);
  }
  return qy(
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    i
  );
}
class Nh extends bo {
  /**
   * @param {Options<VectorSourceType, FeatureType>} [options] Options.
   */
  constructor(e) {
    super(e);
  }
  /**
   * @override
   */
  createRenderer() {
    return new cw(this);
  }
}
const IF = new Ri({
  color: "rgba(0,0,0,0.2)"
}), LF = [
  90,
  45,
  30,
  20,
  10,
  5,
  2,
  1,
  30 / 60,
  20 / 60,
  10 / 60,
  5 / 60,
  2 / 60,
  1 / 60,
  30 / 3600,
  20 / 3600,
  10 / 3600,
  5 / 3600,
  2 / 3600,
  1 / 3600
];
class FF extends Nh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign(
      {
        updateWhileAnimating: !0,
        updateWhileInteracting: !0,
        renderBuffer: 0
      },
      e
    );
    delete t.maxLines, delete t.strokeStyle, delete t.targetSize, delete t.showLabels, delete t.lonLabelFormatter, delete t.latLabelFormatter, delete t.lonLabelPosition, delete t.latLabelPosition, delete t.lonLabelStyle, delete t.latLabelStyle, delete t.intervals, super(t), this.projection_ = null, this.maxLat_ = 1 / 0, this.maxLon_ = 1 / 0, this.minLat_ = -1 / 0, this.minLon_ = -1 / 0, this.maxX_ = 1 / 0, this.maxY_ = 1 / 0, this.minX_ = -1 / 0, this.minY_ = -1 / 0, this.targetSize_ = e.targetSize !== void 0 ? e.targetSize : 100, this.maxLines_ = e.maxLines !== void 0 ? e.maxLines : 100, this.meridians_ = [], this.parallels_ = [], this.strokeStyle_ = e.strokeStyle !== void 0 ? e.strokeStyle : IF, this.fromLonLatTransform_ = void 0, this.toLonLatTransform_ = void 0, this.projectionCenterLonLat_ = null, this.bottomLeft_ = null, this.bottomRight_ = null, this.topLeft_ = null, this.topRight_ = null, this.meridiansLabels_ = null, this.parallelsLabels_ = null, e.showLabels && (this.lonLabelFormatter_ = e.lonLabelFormatter == null ? L_.bind(this, "EW") : e.lonLabelFormatter, this.latLabelFormatter_ = e.latLabelFormatter == null ? L_.bind(this, "NS") : e.latLabelFormatter, this.lonLabelPosition_ = e.lonLabelPosition == null ? 0 : e.lonLabelPosition, this.latLabelPosition_ = e.latLabelPosition == null ? 1 : e.latLabelPosition, this.lonLabelStyleBase_ = new Mt({
      text: e.lonLabelStyle !== void 0 ? e.lonLabelStyle.clone() : new Rs({
        font: "12px Calibri,sans-serif",
        textBaseline: "bottom",
        fill: new gi({
          color: "rgba(0,0,0,1)"
        }),
        stroke: new Ri({
          color: "rgba(255,255,255,1)",
          width: 3
        })
      })
    }), this.lonLabelStyle_ = (n) => {
      const r = n.get("graticule_label");
      return this.lonLabelStyleBase_.getText().setText(r), this.lonLabelStyleBase_;
    }, this.latLabelStyleBase_ = new Mt({
      text: e.latLabelStyle !== void 0 ? e.latLabelStyle.clone() : new Rs({
        font: "12px Calibri,sans-serif",
        textAlign: "right",
        fill: new gi({
          color: "rgba(0,0,0,1)"
        }),
        stroke: new Ri({
          color: "rgba(255,255,255,1)",
          width: 3
        })
      })
    }), this.latLabelStyle_ = (n) => {
      const r = n.get("graticule_label");
      return this.latLabelStyleBase_.getText().setText(r), this.latLabelStyleBase_;
    }, this.meridiansLabels_ = [], this.parallelsLabels_ = [], this.addEventListener(Ht.POSTRENDER, this.drawLabels_.bind(this))), this.intervals_ = e.intervals !== void 0 ? e.intervals : LF, this.setSource(
      new ys({
        loader: this.loaderFunction.bind(this),
        strategy: this.strategyFunction.bind(this),
        features: new rn(),
        overlaps: !1,
        useSpatialIndex: !1,
        wrapX: e.wrapX
      })
    ), this.featurePool_ = [], this.lineStyle_ = new Mt({
      stroke: this.strokeStyle_
    }), this.loadedExtent_ = null, this.renderedExtent_ = null, this.renderedResolution_ = null, this.setRenderOrder(null);
  }
  /**
   * Strategy function for loading features based on the view's extent and
   * resolution.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @return {Array<import("../extent.js").Extent>} Extents.
   */
  strategyFunction(e, t) {
    let n = e.slice();
    return this.projection_ && this.getSource().getWrapX() && Vp(n, this.projection_), this.loadedExtent_ && (CT(this.loadedExtent_, n, t) ? n = this.loadedExtent_.slice() : this.getSource().removeLoadedExtent(this.loadedExtent_)), [n];
  }
  /**
   * Update geometries in the source based on current view
   * @param {import("../extent").Extent} extent Extent
   * @param {number} resolution Resolution
   * @param {import("../proj/Projection.js").default} projection Projection
   */
  loaderFunction(e, t, n) {
    this.loadedExtent_ = e;
    const r = this.getSource(), s = this.getExtent() || [
      -1 / 0,
      -1 / 0,
      1 / 0,
      1 / 0
    ], o = kt(s, e);
    if (this.renderedExtent_ && Pn(this.renderedExtent_, o) && this.renderedResolution_ === t || (this.renderedExtent_ = o, this.renderedResolution_ = t, qn(o)))
      return;
    const a = Vt(o), l = t * t / 4;
    (!this.projection_ || !wt(this.projection_, n)) && this.updateProjectionInfo_(n), this.createGraticule_(o, a, t, l);
    let u = this.meridians_.length + this.parallels_.length;
    this.meridiansLabels_ && (u += this.meridians_.length), this.parallelsLabels_ && (u += this.parallels_.length);
    let c;
    for (; u > this.featurePool_.length; )
      c = new li(), this.featurePool_.push(c);
    const f = r.getFeaturesCollection();
    f.clear();
    let g = 0, d, m;
    for (d = 0, m = this.meridians_.length; d < m; ++d)
      c = this.featurePool_[g++], c.setGeometry(this.meridians_[d]), c.setStyle(this.lineStyle_), f.push(c);
    for (d = 0, m = this.parallels_.length; d < m; ++d)
      c = this.featurePool_[g++], c.setGeometry(this.parallels_[d]), c.setStyle(this.lineStyle_), f.push(c);
  }
  /**
   * @param {number} lon Longitude.
   * @param {number} minLat Minimal latitude.
   * @param {number} maxLat Maximal latitude.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} index Index.
   * @return {number} Index.
   * @private
   */
  addMeridian_(e, t, n, r, s, o) {
    const a = this.getMeridian_(
      e,
      t,
      n,
      r,
      o
    );
    if (ft(a.getExtent(), s)) {
      if (this.meridiansLabels_) {
        const l = this.lonLabelFormatter_(e);
        o in this.meridiansLabels_ ? this.meridiansLabels_[o].text = l : this.meridiansLabels_[o] = {
          geom: new Jt([]),
          text: l
        };
      }
      this.meridians_[o++] = a;
    }
    return o;
  }
  /**
   * @param {number} lat Latitude.
   * @param {number} minLon Minimal longitude.
   * @param {number} maxLon Maximal longitude.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} index Index.
   * @return {number} Index.
   * @private
   */
  addParallel_(e, t, n, r, s, o) {
    const a = this.getParallel_(
      e,
      t,
      n,
      r,
      o
    );
    if (ft(a.getExtent(), s)) {
      if (this.parallelsLabels_) {
        const l = this.latLabelFormatter_(e);
        o in this.parallelsLabels_ ? this.parallelsLabels_[o].text = l : this.parallelsLabels_[o] = {
          geom: new Jt([]),
          text: l
        };
      }
      this.parallels_[o++] = a;
    }
    return o;
  }
  /**
   * @param {import("../render/Event.js").default} event Render event.
   * @private
   */
  drawLabels_(e) {
    const t = e.frameState.viewState.rotation, n = e.frameState.viewState.resolution, r = e.frameState.size, s = e.frameState.extent, o = Vt(s);
    let a = s;
    if (t) {
      const d = r[0] * n, m = r[1] * n;
      a = [
        o[0] - d / 2,
        o[1] - m / 2,
        o[0] + d / 2,
        o[1] + m / 2
      ];
    }
    let l = 0, h = 0, u = this.latLabelPosition_ < 0.5;
    const c = this.projection_.getExtent(), f = _e(c);
    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !Bi(c, s)) {
      l = Math.floor((s[0] - c[0]) / f), h = Math.ceil((s[2] - c[2]) / f);
      const d = Math.abs(t) > Math.PI / 2;
      u = u !== d;
    }
    const g = dL(e);
    for (let d = l; d <= h; ++d) {
      let m = this.meridians_.length + this.parallels_.length, x, v, p, y;
      if (this.meridiansLabels_)
        for (v = 0, p = this.meridiansLabels_.length; v < p; ++v) {
          const E = this.meridians_[v];
          if (!t && d === 0)
            y = this.getMeridianPoint_(E, s, v);
          else {
            const b = E.clone();
            b.translate(d * f, 0), b.rotate(-t, o), y = this.getMeridianPoint_(b, a, v), y.rotate(t, o);
          }
          x = this.featurePool_[m++], x.setGeometry(y), x.set("graticule_label", this.meridiansLabels_[v].text), g.drawFeature(x, this.lonLabelStyle_(x));
        }
      if (this.parallelsLabels_ && (d === l && u || d === h && !u))
        for (v = 0, p = this.parallels_.length; v < p; ++v) {
          const E = this.parallels_[v];
          if (!t && d === 0)
            y = this.getParallelPoint_(E, s, v);
          else {
            const b = E.clone();
            b.translate(d * f, 0), b.rotate(-t, o), y = this.getParallelPoint_(b, a, v), y.rotate(t, o);
          }
          x = this.featurePool_[m++], x.setGeometry(y), x.set("graticule_label", this.parallelsLabels_[v].text), g.drawFeature(x, this.latLabelStyle_(x));
        }
    }
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} squaredTolerance Squared tolerance.
   * @private
   */
  createGraticule_(e, t, n, r) {
    const s = this.getInterval_(n);
    if (s == -1) {
      this.meridians_.length = 0, this.parallels_.length = 0, this.meridiansLabels_ && (this.meridiansLabels_.length = 0), this.parallelsLabels_ && (this.parallelsLabels_.length = 0);
      return;
    }
    let o = !1;
    const a = this.projection_.getExtent(), l = _e(a);
    this.getSource().getWrapX() && this.projection_.canWrapX() && !Bi(a, e) && (_e(e) >= l ? (e[0] = a[0], e[2] = a[2]) : o = !0);
    const h = [
      ve(t[0], this.minX_, this.maxX_),
      ve(t[1], this.minY_, this.maxY_)
    ], u = this.toLonLatTransform_(h);
    isNaN(u[1]) && (u[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_);
    let c = ve(u[0], this.minLon_, this.maxLon_), f = ve(u[1], this.minLat_, this.maxLat_);
    const g = this.maxLines_;
    let d, m, x, v, p = e;
    o || (p = [
      ve(e[0], this.minX_, this.maxX_),
      ve(e[1], this.minY_, this.maxY_),
      ve(e[2], this.minX_, this.maxX_),
      ve(e[3], this.minY_, this.maxY_)
    ]);
    const y = so(
      p,
      this.toLonLatTransform_,
      void 0,
      8
    );
    let E = y[3], b = y[2], T = y[1], R = y[0];
    if (o || (nn(p, this.bottomLeft_) && (R = this.minLon_, T = this.minLat_), nn(p, this.bottomRight_) && (b = this.maxLon_, T = this.minLat_), nn(p, this.topLeft_) && (R = this.minLon_, E = this.maxLat_), nn(p, this.topRight_) && (b = this.maxLon_, E = this.maxLat_), E = ve(E, f, this.maxLat_), b = ve(b, c, this.maxLon_), T = ve(T, this.minLat_, f), R = ve(R, this.minLon_, c)), c = Math.floor(c / s) * s, v = ve(c, this.minLon_, this.maxLon_), m = this.addMeridian_(v, T, E, r, e, 0), d = 0, o)
      for (; (v -= s) >= R && d++ < g; )
        m = this.addMeridian_(
          v,
          T,
          E,
          r,
          e,
          m
        );
    else
      for (; v != this.minLon_ && d++ < g; )
        v = Math.max(v - s, this.minLon_), m = this.addMeridian_(
          v,
          T,
          E,
          r,
          e,
          m
        );
    if (v = ve(c, this.minLon_, this.maxLon_), d = 0, o)
      for (; (v += s) <= b && d++ < g; )
        m = this.addMeridian_(
          v,
          T,
          E,
          r,
          e,
          m
        );
    else
      for (; v != this.maxLon_ && d++ < g; )
        v = Math.min(v + s, this.maxLon_), m = this.addMeridian_(
          v,
          T,
          E,
          r,
          e,
          m
        );
    for (this.meridians_.length = m, this.meridiansLabels_ && (this.meridiansLabels_.length = m), f = Math.floor(f / s) * s, x = ve(f, this.minLat_, this.maxLat_), m = this.addParallel_(x, R, b, r, e, 0), d = 0; x != this.minLat_ && d++ < g; )
      x = Math.max(x - s, this.minLat_), m = this.addParallel_(
        x,
        R,
        b,
        r,
        e,
        m
      );
    for (x = ve(f, this.minLat_, this.maxLat_), d = 0; x != this.maxLat_ && d++ < g; )
      x = Math.min(x + s, this.maxLat_), m = this.addParallel_(
        x,
        R,
        b,
        r,
        e,
        m
      );
    this.parallels_.length = m, this.parallelsLabels_ && (this.parallelsLabels_.length = m);
  }
  /**
   * @param {number} resolution Resolution.
   * @return {number} The interval in degrees.
   * @private
   */
  getInterval_(e) {
    const t = this.projectionCenterLonLat_[0], n = this.projectionCenterLonLat_[1];
    let r = -1;
    const s = Math.pow(this.targetSize_ * e, 2), o = [], a = [];
    for (let l = 0, h = this.intervals_.length; l < h; ++l) {
      const u = ve(this.intervals_[l] / 2, 0, 90), c = ve(n, -90 + u, 90 - u);
      if (o[0] = t - u, o[1] = c - u, a[0] = t + u, a[1] = c + u, this.fromLonLatTransform_(o, o), this.fromLonLatTransform_(a, a), Math.pow(a[0] - o[0], 2) + Math.pow(a[1] - o[1], 2) <= s)
        break;
      r = this.intervals_[l];
    }
    return r;
  }
  /**
   * @param {number} lon Longitude.
   * @param {number} minLat Minimal latitude.
   * @param {number} maxLat Maximal latitude.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} The meridian line string.
   * @param {number} index Index.
   * @private
   */
  getMeridian_(e, t, n, r, s) {
    const o = eL(
      e,
      t,
      n,
      this.projection_,
      r
    );
    let a = this.meridians_[s];
    return a ? (a.setFlatCoordinates("XY", o), a.changed()) : (a = new Wt(o, "XY"), this.meridians_[s] = a), a;
  }
  /**
   * @param {LineString} lineString Meridian
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} index Index.
   * @return {Point} Meridian point.
   * @private
   */
  getMeridianPoint_(e, t, n) {
    const r = e.getFlatCoordinates();
    let s = 1, o = r.length - 1;
    r[s] > r[o] && (s = o, o = 1);
    const a = Math.max(t[1], r[s]), l = Math.min(t[3], r[o]), h = ve(
      t[1] + Math.abs(t[1] - t[3]) * this.lonLabelPosition_,
      a,
      l
    ), c = [r[s - 1] + (r[o - 1] - r[s - 1]) * (h - r[s]) / (r[o] - r[s]), h], f = this.meridiansLabels_[n].geom;
    return f.setCoordinates(c), f;
  }
  /**
   * Get the list of meridians.  Meridians are lines of equal longitude.
   * @return {Array<LineString>} The meridians.
   * @api
   */
  getMeridians() {
    return this.meridians_;
  }
  /**
   * @param {number} lat Latitude.
   * @param {number} minLon Minimal longitude.
   * @param {number} maxLon Maximal longitude.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} The parallel line string.
   * @param {number} index Index.
   * @private
   */
  getParallel_(e, t, n, r, s) {
    const o = tL(
      e,
      t,
      n,
      this.projection_,
      r
    );
    let a = this.parallels_[s];
    return a ? (a.setFlatCoordinates("XY", o), a.changed()) : a = new Wt(o, "XY"), a;
  }
  /**
   * @param {LineString} lineString Parallels.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} index Index.
   * @return {Point} Parallel point.
   * @private
   */
  getParallelPoint_(e, t, n) {
    const r = e.getFlatCoordinates();
    let s = 0, o = r.length - 2;
    r[s] > r[o] && (s = o, o = 0);
    const a = Math.max(t[0], r[s]), l = Math.min(t[2], r[o]), h = ve(
      t[0] + Math.abs(t[0] - t[2]) * this.latLabelPosition_,
      a,
      l
    ), u = r[s + 1] + (r[o + 1] - r[s + 1]) * (h - r[s]) / (r[o] - r[s]), c = [h, u], f = this.parallelsLabels_[n].geom;
    return f.setCoordinates(c), f;
  }
  /**
   * Get the list of parallels.  Parallels are lines of equal latitude.
   * @return {Array<LineString>} The parallels.
   * @api
   */
  getParallels() {
    return this.parallels_;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @private
   */
  updateProjectionInfo_(e) {
    const t = ee("EPSG:4326"), n = e.getWorldExtent();
    this.maxLat_ = n[3], this.maxLon_ = n[2], this.minLat_ = n[1], this.minLon_ = n[0];
    const r = Vn(e, t);
    if (this.minLon_ < this.maxLon_)
      this.toLonLatTransform_ = r;
    else {
      const o = this.minLon_ + this.maxLon_ / 2;
      this.maxLon_ += 360, this.toLonLatTransform_ = function(a, l, h) {
        h = h || 2;
        const u = r(
          a,
          l,
          h
        );
        for (let c = 0, f = u.length; c < f; c += h)
          u[c] < o && (u[c] += 360);
        return u;
      };
    }
    this.fromLonLatTransform_ = Vn(t, e);
    const s = so(
      [this.minLon_, this.minLat_, this.maxLon_, this.maxLat_],
      this.fromLonLatTransform_,
      void 0,
      8
    );
    this.minX_ = s[0], this.maxX_ = s[2], this.minY_ = s[1], this.maxY_ = s[3], this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]), this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]), this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]), this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]), this.projectionCenterLonLat_ = this.toLonLatTransform_(
      Vt(e.getExtent())
    ), isNaN(this.projectionCenterLonLat_[1]) && (this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_), this.projection_ = e;
  }
}
const X = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
function So() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function Mc(i, e) {
  return i[0] = e[0], i[1] = e[1], i[4] = e[2], i[5] = e[3], i[12] = e[4], i[13] = e[5], i;
}
function Hg(i, e, t, n, r, s, o) {
  o = o ?? So();
  const a = 1 / (i - e), l = 1 / (t - n), h = 1 / (r - s);
  return o[0] = -2 * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * l, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * h, o[11] = 0, o[12] = (i + e) * a, o[13] = (n + t) * l, o[14] = (s + r) * h, o[15] = 1, o;
}
function i1(i, e, t, n, r) {
  return r = r ?? So(), r[0] = i[0] * e, r[1] = i[1] * e, r[2] = i[2] * e, r[3] = i[3] * e, r[4] = i[4] * t, r[5] = i[5] * t, r[6] = i[6] * t, r[7] = i[7] * t, r[8] = i[8] * n, r[9] = i[9] * n, r[10] = i[10] * n, r[11] = i[11] * n, r[12] = i[12], r[13] = i[13], r[14] = i[14], r[15] = i[15], r;
}
function OF(i, e, t, n, r) {
  r = r ?? So();
  let s, o, a, l, h, u, c, f, g, d, m, x;
  return i === r ? (r[12] = i[0] * e + i[4] * t + i[8] * n + i[12], r[13] = i[1] * e + i[5] * t + i[9] * n + i[13], r[14] = i[2] * e + i[6] * t + i[10] * n + i[14], r[15] = i[3] * e + i[7] * t + i[11] * n + i[15]) : (s = i[0], o = i[1], a = i[2], l = i[3], h = i[4], u = i[5], c = i[6], f = i[7], g = i[8], d = i[9], m = i[10], x = i[11], r[0] = s, r[1] = o, r[2] = a, r[3] = l, r[4] = h, r[5] = u, r[6] = c, r[7] = f, r[8] = g, r[9] = d, r[10] = m, r[11] = x, r[12] = s * e + h * t + g * n + i[12], r[13] = o * e + u * t + d * n + i[13], r[14] = a * e + c * t + m * n + i[14], r[15] = l * e + f * t + x * n + i[15]), r;
}
function NF(i, e, t, n) {
  return n = n ?? So(), n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = i, n[13] = e, n[14] = t, n[15] = 1, n;
}
const fo = 34962, Dh = 34963, Zm = 35044, ha = 35048, DF = 5121, GF = 5123, kF = 5125, vw = 5126, n1 = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
function UF(i, e) {
  e = Object.assign(
    {
      preserveDrawingBuffer: !0,
      antialias: !hP
      // https://bugs.webkit.org/show_bug.cgi?id=237906
    },
    e
  );
  const t = n1.length;
  for (let n = 0; n < t; ++n)
    try {
      const r = i.getContext(n1[n], e);
      if (r)
        return (
          /** @type {!WebGLRenderingContext} */
          r
        );
    } catch {
    }
  return null;
}
const zF = {
  STATIC_DRAW: Zm
};
class xs {
  /**
   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
   * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
   * Default is `STATIC_DRAW`.
   */
  constructor(e, t) {
    this.array_ = null, this.type_ = e, Te(
      e === fo || e === Dh,
      "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`"
    ), this.usage_ = t !== void 0 ? t : zF.STATIC_DRAW;
  }
  /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {number} size Array size
   * @return {WebGLArrayBuffer} This
   */
  ofSize(e) {
    return this.array_ = new (xu(this.type_))(e), this;
  }
  /**
   * Populates the buffer with an array of the given size.
   * @param {Array<number>} array Numerical array
   * @return {WebGLArrayBuffer} This
   */
  fromArray(e) {
    return this.array_ = xu(this.type_).from(e), this;
  }
  /**
   * Populates the buffer with a raw binary array buffer.
   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
   * initialized for the same typed array class.
   * @return {WebGLArrayBuffer} This
   */
  fromArrayBuffer(e) {
    return this.array_ = new (xu(this.type_))(e), this;
  }
  /**
   * @return {number} Buffer type.
   */
  getType() {
    return this.type_;
  }
  /**
   * Will return null if the buffer was not initialized
   * @return {Float32Array|Uint32Array|null} Array.
   */
  getArray() {
    return this.array_;
  }
  /**
   * @param {Float32Array|Uint32Array} array Array.
   */
  setArray(e) {
    const t = xu(this.type_);
    if (!(e instanceof t))
      throw new Error(`Expected ${t}`);
    this.array_ = e;
  }
  /**
   * @return {number} Usage.
   */
  getUsage() {
    return this.usage_;
  }
  /**
   * Will return 0 if the buffer is not initialized
   * @return {number} Array size
   */
  getSize() {
    return this.array_ ? this.array_.length : 0;
  }
}
function xu(i) {
  switch (i) {
    case fo:
      return Float32Array;
    case Dh:
      return Uint32Array;
    default:
      return Float32Array;
  }
}
const Eu = {
  LOST: "webglcontextlost",
  RESTORED: "webglcontextrestored"
}, BF = `
  precision mediump float;

  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;

  uniform vec2 u_screenSize;

  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`, $F = `
  precision mediump float;

  uniform sampler2D u_image;
  uniform float u_opacity;

  varying vec2 v_texCoord;

  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;
class r1 {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.gl_ = e.webGlContext;
    const t = this.gl_;
    this.scaleRatio_ = e.scaleRatio || 1, this.renderTargetTexture_ = t.createTexture(), this.renderTargetTextureSize_ = null, this.frameBuffer_ = t.createFramebuffer(), this.depthBuffer_ = t.createRenderbuffer();
    const n = t.createShader(t.VERTEX_SHADER);
    t.shaderSource(
      n,
      e.vertexShader || BF
    ), t.compileShader(n);
    const r = t.createShader(t.FRAGMENT_SHADER);
    t.shaderSource(
      r,
      e.fragmentShader || $F
    ), t.compileShader(r), this.renderTargetProgram_ = t.createProgram(), t.attachShader(this.renderTargetProgram_, n), t.attachShader(this.renderTargetProgram_, r), t.linkProgram(this.renderTargetProgram_), this.renderTargetVerticesBuffer_ = t.createBuffer();
    const s = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    t.bindBuffer(t.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), t.bufferData(
      t.ARRAY_BUFFER,
      new Float32Array(s),
      t.STATIC_DRAW
    ), this.renderTargetAttribLocation_ = t.getAttribLocation(
      this.renderTargetProgram_,
      "a_position"
    ), this.renderTargetUniformLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_screenSize"
    ), this.renderTargetOpacityLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_opacity"
    ), this.renderTargetTextureLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_image"
    ), this.uniforms_ = [], e.uniforms && Object.keys(e.uniforms).forEach((o) => {
      this.uniforms_.push({
        value: e.uniforms[o],
        location: t.getUniformLocation(this.renderTargetProgram_, o)
      });
    });
  }
  getRenderTargetTexture() {
    return this.renderTargetTexture_;
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */
  getGL() {
    return this.gl_;
  }
  /**
   * Initialize the render target texture of the post process, make sure it is at the
   * right size and bind it as a render target for the next draw calls.
   * The last step to be initialized will be the one where the primitives are rendered.
   * @param {import("../Map.js").FrameState} frameState current frame state
   */
  init(e) {
    const t = this.getGL(), n = [
      t.drawingBufferWidth * this.scaleRatio_,
      t.drawingBufferHeight * this.scaleRatio_
    ];
    if (t.bindFramebuffer(t.FRAMEBUFFER, this.getFrameBuffer()), t.bindRenderbuffer(t.RENDERBUFFER, this.getDepthBuffer()), t.viewport(0, 0, n[0], n[1]), !this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== n[0] || this.renderTargetTextureSize_[1] !== n[1]) {
      this.renderTargetTextureSize_ = n;
      const r = 0, s = t.RGBA, o = 0, a = t.RGBA, l = t.UNSIGNED_BYTE, h = null;
      t.bindTexture(t.TEXTURE_2D, this.renderTargetTexture_), t.texImage2D(
        t.TEXTURE_2D,
        r,
        s,
        n[0],
        n[1],
        o,
        a,
        l,
        h
      ), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.framebufferTexture2D(
        t.FRAMEBUFFER,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        this.renderTargetTexture_,
        0
      ), t.renderbufferStorage(
        t.RENDERBUFFER,
        t.DEPTH_COMPONENT16,
        n[0],
        n[1]
      ), t.framebufferRenderbuffer(
        t.FRAMEBUFFER,
        t.DEPTH_ATTACHMENT,
        t.RENDERBUFFER,
        this.depthBuffer_
      );
    }
  }
  /**
   * Render to the next postprocessing pass (or to the canvas if final pass).
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */
  apply(e, t, n, r) {
    const s = this.getGL(), o = e.size;
    if (s.bindFramebuffer(
      s.FRAMEBUFFER,
      t ? t.getFrameBuffer() : null
    ), s.activeTexture(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D, this.renderTargetTexture_), !t) {
      const l = ie(s.canvas);
      if (!e.renderTargets[l]) {
        const h = s.getContextAttributes();
        h && h.preserveDrawingBuffer && (s.clearColor(0, 0, 0, 0), s.clearDepth(1), s.clear(s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT)), e.renderTargets[l] = !0;
      }
    }
    s.disable(s.DEPTH_TEST), s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA), s.viewport(0, 0, s.drawingBufferWidth, s.drawingBufferHeight), s.bindBuffer(s.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), s.useProgram(this.renderTargetProgram_), s.enableVertexAttribArray(this.renderTargetAttribLocation_), s.vertexAttribPointer(
      this.renderTargetAttribLocation_,
      2,
      s.FLOAT,
      !1,
      0,
      0
    ), s.uniform2f(this.renderTargetUniformLocation_, o[0], o[1]), s.uniform1i(this.renderTargetTextureLocation_, 0);
    const a = e.layerStatesArray[e.layerIndex].opacity;
    s.uniform1f(this.renderTargetOpacityLocation_, a), this.applyUniforms(e), n && n(s, e), s.drawArrays(s.TRIANGLES, 0, 6), r && r(s, e);
  }
  /**
   * @return {WebGLFramebuffer} Frame buffer
   */
  getFrameBuffer() {
    return this.frameBuffer_;
  }
  /**
   * @return {WebGLRenderbuffer} Depth buffer
   */
  getDepthBuffer() {
    return this.depthBuffer_;
  }
  /**
   * Sets the custom uniforms based on what was given in the constructor.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @private
   */
  applyUniforms(e) {
    const t = this.getGL();
    let n, r = 1;
    this.uniforms_.forEach(function(s) {
      if (n = typeof s.value == "function" ? s.value(e) : s.value, n instanceof HTMLCanvasElement || n instanceof ImageData)
        s.texture || (s.texture = t.createTexture()), t.activeTexture(t[`TEXTURE${r}`]), t.bindTexture(t.TEXTURE_2D, s.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n instanceof ImageData ? t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          n.width,
          n.height,
          0,
          t.UNSIGNED_BYTE,
          new Uint8Array(n.data)
        ) : t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          t.UNSIGNED_BYTE,
          n
        ), t.uniform1i(s.location, r++);
      else if (Array.isArray(n))
        switch (n.length) {
          case 2:
            t.uniform2f(s.location, n[0], n[1]);
            return;
          case 3:
            t.uniform3f(s.location, n[0], n[1], n[2]);
            return;
          case 4:
            t.uniform4f(
              s.location,
              n[0],
              n[1],
              n[2],
              n[3]
            );
            return;
          default:
            return;
        }
      else typeof n == "number" && t.uniform1f(s.location, n);
    });
  }
}
const rr = {
  PROJECTION_MATRIX: "u_projectionMatrix",
  SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix",
  TIME: "u_time",
  ZOOM: "u_zoom",
  RESOLUTION: "u_resolution",
  ROTATION: "u_rotation",
  VIEWPORT_SIZE_PX: "u_viewportSizePx",
  PIXEL_RATIO: "u_pixelRatio",
  HIT_DETECTION: "u_hitDetection"
}, Rt = {
  UNSIGNED_BYTE: DF,
  UNSIGNED_SHORT: GF,
  UNSIGNED_INT: kF,
  FLOAT: vw
}, Cc = {};
function s1(i) {
  return "shared/" + i;
}
let o1 = 0;
function jF() {
  const i = "unique/" + o1;
  return o1 += 1, i;
}
function XF(i) {
  let e = Cc[i];
  if (!e) {
    const t = document.createElement("canvas");
    t.width = 1, t.height = 1, t.style.position = "absolute", t.style.left = "0", e = { users: 0, context: UF(t) }, Cc[i] = e;
  }
  return e.users += 1, e.context;
}
function VF(i) {
  const e = Cc[i];
  if (!e || (e.users -= 1, e.users > 0))
    return;
  const t = e.context, n = t.getExtension("WEBGL_lose_context");
  n && n.loseContext();
  const r = t.canvas;
  r.width = 1, r.height = 1, delete Cc[i];
}
class WF extends Da {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this), this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this), this.canvasCacheKey_ = e.canvasCacheKey ? s1(e.canvasCacheKey) : jF(), this.gl_ = XF(this.canvasCacheKey_), this.bufferCache_ = {}, this.extensionCache_ = {}, this.currentProgram_ = null, this.needsToBeRecreated_ = !1;
    const t = this.gl_.canvas;
    t.addEventListener(
      Eu.LOST,
      this.boundHandleWebGLContextLost_
    ), t.addEventListener(
      Eu.RESTORED,
      this.boundHandleWebGLContextRestored_
    ), this.offsetRotateMatrix_ = st(), this.offsetScaleMatrix_ = st(), this.tmpMat4_ = So(), this.uniformLocationsByProgram_ = {}, this.attribLocationsByProgram_ = {}, this.uniforms_ = [], e.uniforms && this.setUniforms(e.uniforms), this.postProcessPasses_ = e.postProcesses ? e.postProcesses.map(
      (n) => new r1({
        webGlContext: this.gl_,
        scaleRatio: n.scaleRatio,
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        uniforms: n.uniforms
      })
    ) : [new r1({ webGlContext: this.gl_ })], this.shaderCompileErrors_ = null, this.startTime_ = Date.now(), this.maxAttributeCount_ = this.gl_.getParameter(
      this.gl_.MAX_VERTEX_ATTRIBS
    );
  }
  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */
  setUniforms(e) {
    this.uniforms_ = [], this.addUniforms(e);
  }
  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */
  addUniforms(e) {
    for (const t in e)
      this.uniforms_.push({
        name: t,
        value: e[t]
      });
  }
  /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */
  canvasCacheKeyMatches(e) {
    return this.canvasCacheKey_ === s1(e);
  }
  /**
   * Get a WebGL extension.  If the extension is not supported, null is returned.
   * Extensions are cached after they are enabled for the first time.
   * @param {string} name The extension name.
   * @return {Object|null} The extension or null if not supported.
   */
  getExtension(e) {
    if (e in this.extensionCache_)
      return this.extensionCache_[e];
    const t = this.gl_.getExtension(e);
    return this.extensionCache_[e] = t, t;
  }
  /**
   * Will throw if the extension is not available
   * @return {ANGLE_instanced_arrays} Extension
   */
  getInstancedRenderingExtension_() {
    const e = this.getExtension("ANGLE_instanced_arrays");
    return Te(
      !!e,
      "WebGL extension 'ANGLE_instanced_arrays' is required for vector rendering"
    ), e;
  }
  /**
   * Just bind the buffer if it's in the cache. Otherwise create
   * the WebGL buffer, bind it, populate it, and add an entry to
   * the cache.
   * @param {import("./Buffer").default} buffer Buffer.
   */
  bindBuffer(e) {
    const t = this.gl_, n = ie(e);
    let r = this.bufferCache_[n];
    if (!r) {
      const s = t.createBuffer();
      r = {
        buffer: e,
        webGlBuffer: s
      }, this.bufferCache_[n] = r;
    }
    t.bindBuffer(e.getType(), r.webGlBuffer);
  }
  /**
   * Update the data contained in the buffer array; this is required for the
   * new data to be rendered
   * @param {import("./Buffer").default} buffer Buffer.
   */
  flushBufferData(e) {
    const t = this.gl_;
    this.bindBuffer(e), t.bufferData(e.getType(), e.getArray(), e.getUsage());
  }
  /**
   * @param {import("./Buffer.js").default} buf Buffer.
   */
  deleteBuffer(e) {
    const t = ie(e);
    delete this.bufferCache_[t];
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    const e = this.gl_.canvas;
    e.removeEventListener(
      Eu.LOST,
      this.boundHandleWebGLContextLost_
    ), e.removeEventListener(
      Eu.RESTORED,
      this.boundHandleWebGLContextRestored_
    ), VF(this.canvasCacheKey_), delete this.gl_;
  }
  /**
   * Clear the buffer & set the viewport to draw.
   * Post process passes will be initialized here, the first one being bound as a render target for
   * subsequent draw calls.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   * @param {boolean} [enableDepth] If true, enables depth testing.
   */
  prepareDraw(e, t, n) {
    const r = this.gl_, s = this.getCanvas(), o = e.size, a = e.pixelRatio;
    (s.width !== o[0] * a || s.height !== o[1] * a) && (s.width = o[0] * a, s.height = o[1] * a, s.style.width = o[0] + "px", s.style.height = o[1] + "px");
    for (let l = this.postProcessPasses_.length - 1; l >= 0; l--)
      this.postProcessPasses_[l].init(e);
    r.bindTexture(r.TEXTURE_2D, null), r.clearColor(0, 0, 0, 0), r.depthRange(0, 1), r.clearDepth(1), r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT), r.enable(r.BLEND), r.blendFunc(r.ONE, t ? r.ZERO : r.ONE_MINUS_SRC_ALPHA), n ? (r.enable(r.DEPTH_TEST), r.depthFunc(r.LEQUAL)) : r.disable(r.DEPTH_TEST);
  }
  /**
   * @param {WebGLFramebuffer|null} frameBuffer The frame buffer.
   * @param {WebGLTexture} [texture] The texture.
   */
  bindFrameBuffer(e, t) {
    const n = this.getGL();
    n.bindFramebuffer(n.FRAMEBUFFER, e), t && n.framebufferTexture2D(
      n.FRAMEBUFFER,
      n.COLOR_ATTACHMENT0,
      n.TEXTURE_2D,
      t,
      0
    );
  }
  /**
   * Bind the frame buffer from the initial render.
   */
  bindInitialFrameBuffer() {
    const e = this.getGL(), t = this.postProcessPasses_[0].getFrameBuffer();
    e.bindFramebuffer(e.FRAMEBUFFER, t);
    const n = this.postProcessPasses_[0].getRenderTargetTexture();
    e.framebufferTexture2D(
      e.FRAMEBUFFER,
      e.COLOR_ATTACHMENT0,
      e.TEXTURE_2D,
      n,
      0
    );
  }
  /**
   * Prepare a program to use a texture.
   * @param {WebGLTexture} texture The texture.
   * @param {number} slot The texture slot.
   * @param {string} uniformName The corresponding uniform name.
   */
  bindTexture(e, t, n) {
    const r = this.gl_;
    r.activeTexture(r.TEXTURE0 + t), r.bindTexture(r.TEXTURE_2D, e), r.uniform1i(this.getUniformLocation(n), t);
  }
  /**
   * Set up an attribute array buffer for use in the vertex shader.
   * @param {import("./Buffer").default} buffer The buffer.
   * @param {string} attributeName The attribute name.
   * @param {number} size The number of components per attribute vertex.
   */
  bindAttribute(e, t, n) {
    const r = this.getGL();
    this.bindBuffer(e);
    const s = this.getAttributeLocation(t);
    r.enableVertexAttribArray(s), r.vertexAttribPointer(s, n, r.FLOAT, !1, 0, 0);
  }
  /**
   * Clear the render target & bind it for future draw operations.
   * This is similar to `prepareDraw`, only post processes will not be applied.
   * Note: the whole viewport will be drawn to the render target, regardless of its size.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   * @param {boolean} [enableDepth] If true, enables depth testing.
   */
  prepareDrawToRenderTarget(e, t, n, r) {
    const s = this.gl_, o = t.getSize();
    s.bindFramebuffer(s.FRAMEBUFFER, t.getFramebuffer()), s.bindRenderbuffer(s.RENDERBUFFER, t.getDepthbuffer()), s.viewport(0, 0, o[0], o[1]), s.bindTexture(s.TEXTURE_2D, t.getTexture()), s.clearColor(0, 0, 0, 0), s.depthRange(0, 1), s.clearDepth(1), s.clear(s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT), s.enable(s.BLEND), s.blendFunc(s.ONE, n ? s.ZERO : s.ONE_MINUS_SRC_ALPHA), r ? (s.enable(s.DEPTH_TEST), s.depthFunc(s.LEQUAL)) : s.disable(s.DEPTH_TEST);
  }
  /**
   * Execute a draw call based on the currently bound program, texture, buffers, attributes.
   * @param {number} start Start index.
   * @param {number} end End index.
   */
  drawElements(e, t) {
    const n = this.gl_;
    this.getExtension("OES_element_index_uint");
    const r = n.UNSIGNED_INT, s = 4, o = t - e, a = e * s;
    n.drawElements(n.TRIANGLES, o, r, a);
  }
  /**
   * Execute a draw call similar to `drawElements`, but using instanced rendering.
   * Will have no effect if `enableAttributesInstanced` was not called for this rendering pass.
   * @param {number} start Start index.
   * @param {number} end End index.
   * @param {number} instanceCount The number of instances to render
   */
  drawElementsInstanced(e, t, n) {
    const r = this.gl_;
    this.getExtension("OES_element_index_uint");
    const s = this.getInstancedRenderingExtension_(), o = r.UNSIGNED_INT, a = 4, l = t - e, h = e * a;
    s.drawElementsInstancedANGLE(
      r.TRIANGLES,
      l,
      o,
      h,
      n
    );
    for (let u = 0; u < this.maxAttributeCount_; u++)
      s.vertexAttribDivisorANGLE(u, 0);
  }
  /**
   * Apply the successive post process passes which will eventually render to the actual canvas.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */
  finalizeDraw(e, t, n) {
    for (let r = 0, s = this.postProcessPasses_.length; r < s; r++)
      r === s - 1 ? this.postProcessPasses_[r].apply(
        e,
        null,
        t,
        n
      ) : this.postProcessPasses_[r].apply(
        e,
        this.postProcessPasses_[r + 1]
      );
  }
  /**
   * @return {HTMLCanvasElement} Canvas.
   */
  getCanvas() {
    return (
      /** @type {HTMLCanvasElement} */
      this.gl_.canvas
    );
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */
  getGL() {
    return this.gl_;
  }
  /**
   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyFrameState(e) {
    const t = e.size, n = e.viewState.rotation, r = e.pixelRatio;
    this.setUniformFloatValue(
      rr.TIME,
      (Date.now() - this.startTime_) * 1e-3
    ), this.setUniformFloatValue(rr.ZOOM, e.viewState.zoom), this.setUniformFloatValue(
      rr.RESOLUTION,
      e.viewState.resolution
    ), this.setUniformFloatValue(rr.PIXEL_RATIO, r), this.setUniformFloatVec2(rr.VIEWPORT_SIZE_PX, [
      t[0],
      t[1]
    ]), this.setUniformFloatValue(rr.ROTATION, n);
  }
  /**
   * Sets the `u_hitDetection` uniform.
   * @param {boolean} enabled Whether to enable the hit detection code path
   */
  applyHitDetectionUniform(e) {
    const t = this.getUniformLocation(rr.HIT_DETECTION);
    this.getGL().uniform1i(t, e ? 1 : 0), e && this.setUniformFloatValue(rr.PIXEL_RATIO, 0.5);
  }
  /**
   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyUniforms(e) {
    const t = this.gl_;
    let n, r = 0;
    this.uniforms_.forEach((s) => {
      if (n = typeof s.value == "function" ? s.value(e) : s.value, n instanceof HTMLCanvasElement || n instanceof HTMLImageElement || n instanceof ImageData || n instanceof WebGLTexture) {
        n instanceof WebGLTexture && !s.texture ? (s.prevValue = void 0, s.texture = n) : s.texture || (s.prevValue = void 0, s.texture = t.createTexture()), this.bindTexture(s.texture, r, s.name), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
        const o = !(n instanceof HTMLImageElement) || /** @type {HTMLImageElement} */
        n.complete;
        !(n instanceof WebGLTexture) && o && s.prevValue !== n && (s.prevValue = n, t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          t.UNSIGNED_BYTE,
          n
        )), r++;
      } else if (Array.isArray(n) && n.length === 6)
        this.setUniformMatrixValue(
          s.name,
          Mc(this.tmpMat4_, n)
        );
      else if (Array.isArray(n) && n.length <= 4)
        switch (n.length) {
          case 2:
            t.uniform2f(
              this.getUniformLocation(s.name),
              n[0],
              n[1]
            );
            return;
          case 3:
            t.uniform3f(
              this.getUniformLocation(s.name),
              n[0],
              n[1],
              n[2]
            );
            return;
          case 4:
            t.uniform4f(
              this.getUniformLocation(s.name),
              n[0],
              n[1],
              n[2],
              n[3]
            );
            return;
          default:
            return;
        }
      else typeof n == "number" && t.uniform1f(this.getUniformLocation(s.name), n);
    });
  }
  /**
   * Set up a program for use. The program will be set as the current one. Then, the uniforms used
   * in the program will be set based on the current frame state and the helper configuration.
   * @param {WebGLProgram} program Program.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   */
  useProgram(e, t) {
    this.disableAllAttributes_(), this.gl_.useProgram(e), this.currentProgram_ = e, t && (this.applyFrameState(t), this.applyUniforms(t));
  }
  /**
   * Will attempt to compile a vertex or fragment shader based on source
   * On error, the shader will be returned but
   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
   * Use `gl.getShaderInfoLog(shader)` to have details
   * @param {string} source Shader source
   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
   * @return {WebGLShader} Shader object
   */
  compileShader(e, t) {
    const n = this.gl_, r = n.createShader(t);
    return n.shaderSource(r, e), n.compileShader(r), r;
  }
  /**
   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
   * @param {string} fragmentShaderSource Fragment shader source.
   * @param {string} vertexShaderSource Vertex shader source.
   * @return {WebGLProgram} Program
   */
  getProgram(e, t) {
    const n = this.gl_, r = this.compileShader(
      e,
      n.FRAGMENT_SHADER
    ), s = this.compileShader(
      t,
      n.VERTEX_SHADER
    ), o = n.createProgram();
    if (n.attachShader(o, r), n.attachShader(o, s), n.linkProgram(o), !n.getShaderParameter(r, n.COMPILE_STATUS)) {
      const a = `Fragment shader compilation failed: ${n.getShaderInfoLog(
        r
      )}`;
      throw new Error(a);
    }
    if (n.deleteShader(r), !n.getShaderParameter(s, n.COMPILE_STATUS)) {
      const a = `Vertex shader compilation failed: ${n.getShaderInfoLog(
        s
      )}`;
      throw new Error(a);
    }
    if (n.deleteShader(s), !n.getProgramParameter(o, n.LINK_STATUS)) {
      const a = `GL program linking failed: ${n.getProgramInfoLog(
        o
      )}`;
      throw new Error(a);
    }
    return o;
  }
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Uniform name
   * @return {WebGLUniformLocation} uniformLocation
   */
  getUniformLocation(e) {
    const t = ie(this.currentProgram_);
    return this.uniformLocationsByProgram_[t] === void 0 && (this.uniformLocationsByProgram_[t] = {}), this.uniformLocationsByProgram_[t][e] === void 0 && (this.uniformLocationsByProgram_[t][e] = this.gl_.getUniformLocation(this.currentProgram_, e)), this.uniformLocationsByProgram_[t][e];
  }
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Attribute name
   * @return {number} attribLocation
   */
  getAttributeLocation(e) {
    const t = ie(this.currentProgram_);
    return this.attribLocationsByProgram_[t] === void 0 && (this.attribLocationsByProgram_[t] = {}), this.attribLocationsByProgram_[t][e] === void 0 && (this.attribLocationsByProgram_[t][e] = this.gl_.getAttribLocation(this.currentProgram_, e)), this.attribLocationsByProgram_[t][e];
  }
  /**
   * Sets the given transform to apply the rotation/translation/scaling of the given frame state.
   * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../transform").Transform} transform Transform to update.
   * @return {import("../transform").Transform} The updated transform object.
   */
  makeProjectionTransform(e, t) {
    const n = e.size, r = e.viewState.rotation, s = e.viewState.resolution, o = e.viewState.center;
    return un(
      t,
      0,
      0,
      2 / (s * n[0]),
      2 / (s * n[1]),
      -r,
      -o[0],
      -o[1]
    ), t;
  }
  /**
   * Give a value for a standard float uniform
   * @param {string} uniform Uniform name
   * @param {number} value Value
   */
  setUniformFloatValue(e, t) {
    this.gl_.uniform1f(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a vec2 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec2(e, t) {
    this.gl_.uniform2fv(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a vec4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec4(e, t) {
    this.gl_.uniform4fv(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a standard matrix4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Matrix value
   */
  setUniformMatrixValue(e, t) {
    this.gl_.uniformMatrix4fv(this.getUniformLocation(e), !1, t);
  }
  /**
   * Disable all vertex attributes.
   * @private
   */
  disableAllAttributes_() {
    for (let e = 0; e < this.maxAttributeCount_; e++)
      this.gl_.disableVertexAttribArray(e);
  }
  /**
   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
   * internally.
   * @param {string} attribName Attribute name
   * @param {number} size Number of components per attributes
   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
   * @param {number} stride Stride in bytes (0 means attribs are packed)
   * @param {number} offset Offset in bytes
   * @param {boolean} instanced Whether the attribute is used for instanced rendering
   * @private
   */
  enableAttributeArray_(e, t, n, r, s, o) {
    const a = this.getAttributeLocation(e);
    a < 0 || (this.gl_.enableVertexAttribArray(a), this.gl_.vertexAttribPointer(a, t, n, !1, r, s), o && this.getInstancedRenderingExtension_().vertexAttribDivisorANGLE(
      a,
      1
    ));
  }
  /**
   * @private
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
   * @param {boolean} instanced Whether the attributes are instanced.
   */
  enableAttributes_(e, t) {
    const n = YF(e);
    let r = 0;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      o.name && this.enableAttributeArray_(
        o.name,
        o.size,
        o.type || vw,
        n,
        r,
        t
      ), r += o.size * ww(o.type);
    }
  }
  /**
   * Will enable the following attributes to be read from the currently bound buffer,
   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
   */
  enableAttributes(e) {
    this.enableAttributes_(e, !1);
  }
  /**
   * Will enable these attributes as instanced, meaning that they will only be read
   * once per instance instead of per vertex.
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
   */
  enableAttributesInstanced(e) {
    this.enableAttributes_(e, !0);
  }
  /**
   * WebGL context was lost
   * @param {WebGLContextEvent} event The context loss event.
   * @private
   */
  handleWebGLContextLost(e) {
    Ga(this.bufferCache_), this.currentProgram_ = null, e.preventDefault();
  }
  /**
   * WebGL context was restored
   * @private
   */
  handleWebGLContextRestored() {
    this.needsToBeRecreated_ = !0;
  }
  /**
   * Returns whether this helper needs to be recreated, as the context was lost and then restored.
   * @return {boolean} Whether this helper needs to be recreated.
   */
  needsToBeRecreated() {
    return this.needsToBeRecreated_;
  }
  /**
   * Will create or reuse a given webgl texture and apply the given size. If no image data
   * specified, the texture will be empty, otherwise image data will be used and the `size`
   * parameter will be ignored.  If a Uint8Array is provided for data, a size must also be provided.
   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
   * @param {Array<number>} size Expected size of the texture
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement|Uint8Array|null} data Image data/object to bind to the texture
   * @param {WebGLTexture} [texture] Existing texture to reuse
   * @param {boolean} [nearest] Use gl.NEAREST for min/mag filter.
   * @return {WebGLTexture} The generated texture
   */
  createTexture(e, t, n, r) {
    const s = this.gl_;
    n = n || s.createTexture();
    const o = r ? s.NEAREST : s.LINEAR;
    s.bindTexture(s.TEXTURE_2D, n), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, o), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, o), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE);
    const a = 0, l = s.RGBA, h = 0, u = s.RGBA, c = s.UNSIGNED_BYTE;
    return t instanceof Uint8Array ? s.texImage2D(
      s.TEXTURE_2D,
      a,
      l,
      e[0],
      e[1],
      h,
      u,
      c,
      t
    ) : t ? s.texImage2D(s.TEXTURE_2D, a, l, u, c, t) : s.texImage2D(
      s.TEXTURE_2D,
      a,
      l,
      e[0],
      e[1],
      h,
      u,
      c,
      null
    ), n;
  }
}
function YF(i) {
  let e = 0;
  for (let t = 0; t < i.length; t++) {
    const n = i[t];
    e += n.size * ww(n.type);
  }
  return e;
}
function ww(i) {
  switch (i) {
    case Rt.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case Rt.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case Rt.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case Rt.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}
class Za extends ka {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(e, t, n) {
    super(), n = n || {}, this.tileCoord = e, this.state = t, this.key = "", this.transition_ = n.transition === void 0 ? 250 : n.transition, this.transitionStarts_ = {}, this.interpolate = !!n.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(le.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.setState(X.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(e) {
    if (this.state !== X.EMPTY) {
      if (this.state !== X.ERROR && this.state > e)
        throw new Error("Tile load sequence violation");
      this.state = e, this.changed();
    }
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    de();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(e, t) {
    if (!this.transition_)
      return 1;
    let n = this.transitionStarts_[e];
    if (!n)
      n = t, this.transitionStarts_[e] = n;
    else if (n === -1)
      return 1;
    const r = t - n + 1e3 / 60;
    return r >= this.transition_ ? 1 : yw(r / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(e) {
    return this.transition_ ? this.transitionStarts_[e] !== -1 : !1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(e) {
    this.transition_ && (this.transitionStarts_[e] = -1);
  }
  /**
   * @override
   */
  disposeInternal() {
    this.release(), super.disposeInternal();
  }
}
function Ra(i) {
  return i instanceof Image || i instanceof HTMLCanvasElement || i instanceof HTMLVideoElement || i instanceof ImageBitmap ? i : null;
}
function Kg(i) {
  return i instanceof Uint8Array || i instanceof Uint8ClampedArray || i instanceof Float32Array || i instanceof DataView ? i : null;
}
const qF = new Error("disposed");
let Ao = null;
function ZF(i) {
  Ao || (Ao = ot(
    i.width,
    i.height,
    void 0,
    { willReadFrequently: !0 }
  ));
  const e = Ao.canvas, t = i.width;
  e.width !== t && (e.width = t);
  const n = i.height;
  return e.height !== n && (e.height = n), Ao.clearRect(0, 0, t, n), Ao.drawImage(i, 0, 0), Ao.getImageData(0, 0, t, n).data;
}
const HF = [256, 256];
class rh extends Za {
  /**
   * @param {Options} options Tile options.
   */
  constructor(e) {
    const t = X.IDLE;
    super(e.tileCoord, t, {
      transition: e.transition,
      interpolate: e.interpolate
    }), this.loader_ = e.loader, this.data_ = null, this.error_ = null, this.size_ = e.size || null, this.controller_ = e.controller || null;
  }
  /**
   * Get the tile size.
   * @return {import('./size.js').Size} Tile size.
   */
  getSize() {
    if (this.size_)
      return this.size_;
    const e = Ra(this.data_);
    return e ? [e.width, e.height] : HF;
  }
  /**
   * Get the data for the tile.
   * @return {Data} Tile data.
   * @api
   */
  getData() {
    return this.data_;
  }
  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @api
   */
  getError() {
    return this.error_;
  }
  /**
   * Load the tile data.
   * @api
   * @override
   */
  load() {
    if (this.state !== X.IDLE && this.state !== X.ERROR)
      return;
    this.state = X.LOADING, this.changed();
    const e = this;
    this.loader_().then(function(t) {
      e.data_ = t, e.state = X.LOADED, e.changed();
    }).catch(function(t) {
      e.error_ = t, e.state = X.ERROR, e.changed();
    });
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.controller_ && (this.controller_.abort(qF), this.controller_ = null), super.disposeInternal();
  }
}
class Gh extends Za {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, n, r, s, o) {
    super(e, t, o), this.crossOrigin_ = r, this.src_ = n, this.key = n, this.image_, di ? this.image_ = new OffscreenCanvas(1, 1) : (this.image_ = new Image(), r !== null && (this.image_.crossOrigin = r)), this.unlisten_ = null, this.tileLoadFunction_ = s;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, OffscreenCanvas, Image, or Video).
   * @return {HTMLCanvasElement|OffscreenCanvas|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|OffscreenCanvas|HTMLImageElement} element Element.
   */
  setImage(e) {
    this.image_ = e, this.state = X.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Get the cross origin of the ImageTile.
   * @return {string} Cross origin.
   */
  getCrossOrigin() {
    return this.crossOrigin_;
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = X.ERROR, this.unlistenImage_(), this.image_ = KF(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    if (di)
      this.state = X.LOADED;
    else {
      const e = (
        /** @type {HTMLImageElement} */
        this.image_
      );
      e.naturalWidth && e.naturalHeight ? this.state = X.LOADED : this.state = X.EMPTY;
    }
    this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   * @api
   * @override
   */
  load() {
    this.state == X.ERROR && (this.state = X.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == X.IDLE && (this.state = X.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = bP(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
  /**
   * @override
   */
  disposeInternal() {
    this.unlistenImage_(), this.image_ = null, super.disposeInternal();
  }
}
function KF() {
  const i = ot(1, 1);
  return i.fillStyle = "rgba(0,0,0,0)", i.fillRect(0, 0, 1, 1), i.canvas;
}
let zd;
const ua = [];
function a1(i, e, t, n, r) {
  i.beginPath(), i.moveTo(0, 0), i.lineTo(e, t), i.lineTo(n, r), i.closePath(), i.save(), i.clip(), i.fillRect(0, 0, Math.max(e, n) + 1, Math.max(t, r)), i.restore();
}
function Bd(i, e) {
  return Math.abs(i[e * 4] - 210) > 2 || Math.abs(i[e * 4 + 3] - 0.75 * 255) > 2;
}
function JF() {
  if (zd === void 0) {
    const i = ot(6, 6, ua);
    i.globalCompositeOperation = "lighter", i.fillStyle = "rgba(210, 0, 0, 0.75)", a1(i, 4, 5, 4, 0), a1(i, 4, 5, 0, 5);
    const e = i.getImageData(0, 0, 3, 3).data;
    zd = Bd(e, 0) || Bd(e, 4) || Bd(e, 8), Ih(i), ua.push(i.canvas);
  }
  return zd;
}
function Ac(i, e, t, n) {
  const r = Sh(t, e, i);
  let s = Cg(
    e,
    n,
    t
  );
  const o = e.getMetersPerUnit();
  o !== void 0 && (s *= o);
  const a = i.getMetersPerUnit();
  a !== void 0 && (s /= a);
  const l = i.getExtent();
  if (!l || nn(l, r)) {
    const h = Cg(i, s, r) / s;
    isFinite(h) && h > 0 && (s /= h);
  }
  return s;
}
function bw(i, e, t, n) {
  const r = Vt(t);
  let s = Ac(
    i,
    e,
    r,
    n
  );
  return (!isFinite(s) || s <= 0) && yE(t, function(o) {
    return s = Ac(
      i,
      e,
      o,
      n
    ), isFinite(s) && s > 0;
  }), s;
}
function Sw(i, e, t, n, r, s, o, a, l, h, u, c, f, g) {
  const d = ot(
    Math.round(t * i),
    Math.round(t * e),
    ua
  );
  if (c || (d.imageSmoothingEnabled = !1), l.length === 0)
    return d.canvas;
  d.scale(t, t);
  function m(b) {
    return Math.round(b * t) / t;
  }
  d.globalCompositeOperation = "lighter";
  const x = hi();
  l.forEach(function(b, T, R) {
    jp(x, b.extent);
  });
  let v;
  const p = t / n, y = (c ? 1 : 1 + Math.pow(2, -24)) / p;
  (!f || l.length !== 1 || h !== 0) && (v = ot(
    Math.round(_e(x) * p),
    Math.round(it(x) * p),
    ua
  ), c || (v.imageSmoothingEnabled = !1), l.forEach(function(b, T, R) {
    if (b.image.width > 0 && b.image.height > 0) {
      if (b.clipExtent) {
        v.save();
        const z = (b.clipExtent[0] - x[0]) * p, _ = -(b.clipExtent[3] - x[3]) * p, w = _e(b.clipExtent) * p, S = it(b.clipExtent) * p;
        v.rect(
          c ? z : Math.round(z),
          c ? _ : Math.round(_),
          c ? w : Math.round(z + w) - Math.round(z),
          c ? S : Math.round(_ + S) - Math.round(_)
        ), v.clip();
      }
      const M = (b.extent[0] - x[0]) * p, C = -(b.extent[3] - x[3]) * p, I = _e(b.extent) * p, O = it(b.extent) * p;
      v.drawImage(
        b.image,
        h,
        h,
        b.image.width - 2 * h,
        b.image.height - 2 * h,
        c ? M : Math.round(M),
        c ? C : Math.round(C),
        c ? I : Math.round(M + I) - Math.round(M),
        c ? O : Math.round(C + O) - Math.round(C)
      ), b.clipExtent && v.restore();
    }
  }));
  const E = Mn(o);
  return a.getTriangles().forEach(function(b, T, R) {
    const M = b.source, C = b.target;
    let I = M[0][0], O = M[0][1], z = M[1][0], _ = M[1][1], w = M[2][0], S = M[2][1];
    const P = m((C[0][0] - E[0]) / s), A = m(
      -(C[0][1] - E[1]) / s
    ), D = m((C[1][0] - E[0]) / s), k = m(
      -(C[1][1] - E[1]) / s
    ), U = m((C[2][0] - E[0]) / s), G = m(
      -(C[2][1] - E[1]) / s
    ), $ = I, H = O;
    I = 0, O = 0, z -= $, _ -= H, w -= $, S -= H;
    const ne = [
      [z, _, 0, 0, D - P],
      [w, S, 0, 0, U - P],
      [0, 0, z, _, k - A],
      [0, 0, w, S, G - A]
    ], te = OT(ne);
    if (!te)
      return;
    if (d.save(), d.beginPath(), JF() || !c) {
      d.moveTo(D, k);
      const ae = 4, Re = P - D, xe = A - k;
      for (let Ae = 0; Ae < ae; Ae++)
        d.lineTo(
          D + m((Ae + 1) * Re / ae),
          k + m(Ae * xe / (ae - 1))
        ), Ae != ae - 1 && d.lineTo(
          D + m((Ae + 1) * Re / ae),
          k + m((Ae + 1) * xe / (ae - 1))
        );
      d.lineTo(U, G);
    } else
      d.moveTo(D, k), d.lineTo(P, A), d.lineTo(U, G);
    d.clip(), d.transform(
      te[0],
      te[2],
      te[1],
      te[3],
      P,
      A
    ), d.translate(
      x[0] - $,
      x[3] - H
    );
    let re;
    if (v)
      re = v.canvas, d.scale(y, -y);
    else {
      const ae = l[0], Re = ae.extent;
      re = ae.image, d.scale(
        _e(Re) / re.width,
        -it(Re) / re.height
      );
    }
    d.drawImage(re, 0, 0), d.restore();
  }), v && (Ih(v), ua.push(v.canvas)), u && (d.save(), d.globalCompositeOperation = "source-over", d.strokeStyle = "black", d.lineWidth = 1, a.getTriangles().forEach(function(b, T, R) {
    const M = b.target, C = (M[0][0] - E[0]) / s, I = -(M[0][1] - E[1]) / s, O = (M[1][0] - E[0]) / s, z = -(M[1][1] - E[1]) / s, _ = (M[2][0] - E[0]) / s, w = -(M[2][1] - E[1]) / s;
    d.beginPath(), d.moveTo(O, z), d.lineTo(C, I), d.lineTo(_, w), d.closePath(), d.stroke();
  }), d.restore()), d.canvas;
}
const QF = 10, l1 = 0.25;
class Hm {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   * @param {import("../transform.js").Transform} [sourceMatrix] Source transform matrix.
   */
  constructor(e, t, n, r, s, o, a) {
    this.sourceProj_ = e, this.targetProj_ = t;
    let l = {};
    const h = a ? hc(
      (y) => rt(
        a,
        Sh(y, this.targetProj_, this.sourceProj_)
      )
    ) : Vn(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(y) {
      const E = y[0] + "/" + y[1];
      return l[E] || (l[E] = h(y)), l[E];
    }, this.maxSourceExtent_ = r, this.errorThresholdSquared_ = s * s, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!r && !!this.sourceProj_.getExtent() && _e(r) >= _e(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? _e(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? _e(this.targetProj_.getExtent()) : null;
    const u = Mn(n), c = wh(n), f = gf(n), g = vh(n), d = this.transformInv_(u), m = this.transformInv_(c), x = this.transformInv_(f), v = this.transformInv_(g), p = QF + (o ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          Zl(n) / (o * o * 256 * 256)
        )
      )
    ) : 0);
    if (this.addQuad_(
      u,
      c,
      f,
      g,
      d,
      m,
      x,
      v,
      p
    ), this.wrapsXInSource_) {
      let y = 1 / 0;
      this.triangles_.forEach(function(E, b, T) {
        y = Math.min(
          y,
          E.source[0][0],
          E.source[1][0],
          E.source[2][0]
        );
      }), this.triangles_.forEach((E) => {
        if (Math.max(
          E.source[0][0],
          E.source[1][0],
          E.source[2][0]
        ) - y > this.sourceWorldWidth_ / 2) {
          const b = [
            [E.source[0][0], E.source[0][1]],
            [E.source[1][0], E.source[1][1]],
            [E.source[2][0], E.source[2][1]]
          ];
          b[0][0] - y > this.sourceWorldWidth_ / 2 && (b[0][0] -= this.sourceWorldWidth_), b[1][0] - y > this.sourceWorldWidth_ / 2 && (b[1][0] -= this.sourceWorldWidth_), b[2][0] - y > this.sourceWorldWidth_ / 2 && (b[2][0] -= this.sourceWorldWidth_);
          const T = Math.min(
            b[0][0],
            b[1][0],
            b[2][0]
          );
          Math.max(
            b[0][0],
            b[1][0],
            b[2][0]
          ) - T < this.sourceWorldWidth_ / 2 && (E.source = b);
        }
      });
    }
    l = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(e, t, n, r, s, o) {
    this.triangles_.push({
      source: [r, s, o],
      target: [e, t, n]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(e, t, n, r, s, o, a, l, h) {
    const u = Ea([s, o, a, l]), c = this.sourceWorldWidth_ ? _e(u) / this.sourceWorldWidth_ : null, f = (
      /** @type {number} */
      this.sourceWorldWidth_
    ), g = this.sourceProj_.canWrapX() && c > 0.5 && c < 1;
    let d = !1;
    if (h > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const x = Ea([e, t, n, r]);
        d = _e(x) / this.targetWorldWidth_ > l1 || d;
      }
      !g && this.sourceProj_.isGlobal() && c && (d = c > l1 || d);
    }
    if (!d && this.maxSourceExtent_ && isFinite(u[0]) && isFinite(u[1]) && isFinite(u[2]) && isFinite(u[3]) && !ft(u, this.maxSourceExtent_))
      return;
    let m = 0;
    if (!d && (!isFinite(s[0]) || !isFinite(s[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(a[0]) || !isFinite(a[1]) || !isFinite(l[0]) || !isFinite(l[1]))) {
      if (h > 0)
        d = !0;
      else if (m = (!isFinite(s[0]) || !isFinite(s[1]) ? 8 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 4 : 0) + (!isFinite(a[0]) || !isFinite(a[1]) ? 2 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 1 : 0), m != 1 && m != 2 && m != 4 && m != 8)
        return;
    }
    if (h > 0) {
      if (!d) {
        const x = [(e[0] + n[0]) / 2, (e[1] + n[1]) / 2], v = this.transformInv_(x);
        let p;
        g ? p = ($n(s[0], f) + $n(a[0], f)) / 2 - $n(v[0], f) : p = (s[0] + a[0]) / 2 - v[0];
        const y = (s[1] + a[1]) / 2 - v[1];
        d = p * p + y * y > this.errorThresholdSquared_;
      }
      if (d) {
        if (Math.abs(e[0] - n[0]) <= Math.abs(e[1] - n[1])) {
          const x = [(t[0] + n[0]) / 2, (t[1] + n[1]) / 2], v = this.transformInv_(x), p = [(r[0] + e[0]) / 2, (r[1] + e[1]) / 2], y = this.transformInv_(p);
          this.addQuad_(
            e,
            t,
            x,
            p,
            s,
            o,
            v,
            y,
            h - 1
          ), this.addQuad_(
            p,
            x,
            n,
            r,
            y,
            v,
            a,
            l,
            h - 1
          );
        } else {
          const x = [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2], v = this.transformInv_(x), p = [(n[0] + r[0]) / 2, (n[1] + r[1]) / 2], y = this.transformInv_(p);
          this.addQuad_(
            e,
            x,
            p,
            r,
            s,
            v,
            y,
            l,
            h - 1
          ), this.addQuad_(
            x,
            t,
            n,
            p,
            v,
            o,
            a,
            y,
            h - 1
          );
        }
        return;
      }
    }
    if (g) {
      if (!this.canWrapXInSource_)
        return;
      this.wrapsXInSource_ = !0;
    }
    (m & 11) == 0 && this.addTriangle_(e, n, r, s, a, l), (m & 14) == 0 && this.addTriangle_(e, n, t, s, a, o), m && ((m & 13) == 0 && this.addTriangle_(t, r, e, o, l, s), (m & 7) == 0 && this.addTriangle_(t, r, n, o, l, a));
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const e = hi();
    return this.triangles_.forEach(function(t, n, r) {
      const s = t.source;
      Pl(e, s[0]), Pl(e, s[1]), Pl(e, s[2]);
    }), e;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}
const Km = 0.5;
class Jm extends Za {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, n, r, s, o, a, l, h, u, c, f) {
    super(s, X.IDLE, f), this.renderEdges_ = c !== void 0 ? c : !1, this.pixelRatio_ = a, this.gutter_ = l, this.canvas_ = null, this.sourceTileGrid_ = t, this.targetTileGrid_ = r, this.wrappedTileCoord_ = o || s, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0, this.clipExtent_ = e.canWrapX() ? e.getExtent() : void 0;
    const g = r.getTileCoordExtent(
      this.wrappedTileCoord_
    ), d = this.targetTileGrid_.getExtent();
    let m = this.sourceTileGrid_.getExtent();
    const x = d ? kt(g, d) : g;
    if (Zl(x) === 0) {
      this.state = X.EMPTY;
      return;
    }
    const v = e.getExtent();
    v && (m ? m = kt(m, v) : m = v);
    const p = r.getResolution(
      this.wrappedTileCoord_[0]
    ), y = bw(
      e,
      n,
      x,
      p
    );
    if (!isFinite(y) || y <= 0) {
      this.state = X.EMPTY;
      return;
    }
    const E = u !== void 0 ? u : Km;
    if (this.triangulation_ = new Hm(
      e,
      n,
      x,
      m,
      y * E,
      p
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = X.EMPTY;
      return;
    }
    this.sourceZ_ = t.getZForResolution(y);
    let b = this.triangulation_.calculateSourceExtent();
    if (m && (e.canWrapX() ? (b[1] = ve(
      b[1],
      m[1],
      m[3]
    ), b[3] = ve(
      b[3],
      m[1],
      m[3]
    )) : b = kt(b, m)), !Zl(b))
      this.state = X.EMPTY;
    else {
      let T = 0, R = 0;
      e.canWrapX() && (T = _e(v), R = Math.floor(
        (b[0] - v[0]) / T
      )), Wp(
        b.slice(),
        e,
        !0
      ).forEach((C) => {
        const I = t.getTileRangeForExtentAndZ(
          C,
          this.sourceZ_
        );
        for (let O = I.minX; O <= I.maxX; O++)
          for (let z = I.minY; z <= I.maxY; z++) {
            const _ = h(this.sourceZ_, O, z, a);
            if (_) {
              const w = R * T;
              this.sourceTiles_.push({ tile: _, offset: w });
            }
          }
        ++R;
      }), this.sourceTiles_.length === 0 && (this.state = X.EMPTY);
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement|OffscreenCanvas} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = [];
    if (this.sourceTiles_.forEach((t) => {
      const n = t.tile;
      if (n && n.getState() == X.LOADED) {
        const r = this.sourceTileGrid_.getTileCoordExtent(n.tileCoord);
        r[0] += t.offset, r[2] += t.offset;
        const s = this.clipExtent_?.slice();
        s && (s[0] += t.offset, s[2] += t.offset), e.push({
          extent: r,
          clipExtent: s,
          image: n.getImage()
        });
      }
    }), this.sourceTiles_.length = 0, e.length === 0)
      this.state = X.ERROR;
    else {
      const t = this.wrappedTileCoord_[0], n = this.targetTileGrid_.getTileSize(t), r = typeof n == "number" ? n : n[0], s = typeof n == "number" ? n : n[1], o = this.targetTileGrid_.getResolution(t), a = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      ), l = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = Sw(
        r,
        s,
        this.pixelRatio_,
        a,
        this.sourceTileGrid_.getExtent(),
        o,
        l,
        this.triangulation_,
        e,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      ), this.state = X.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state == X.IDLE) {
      this.state = X.LOADING, this.changed();
      let e = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: t }) => {
        const n = t.getState();
        if (n == X.IDLE || n == X.LOADING) {
          e++;
          const r = Ce(t, le.CHANGE, (s) => {
            const o = t.getState();
            (o == X.LOADED || o == X.ERROR || o == X.EMPTY) && (tt(r), e--, e === 0 && (this.unlistenSources_(), this.reproject_()));
          });
          this.sourcesListenerKeys_.push(r);
        }
      }), e === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: t }, n, r) {
        t.getState() == X.IDLE && t.load();
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(tt), this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   * @override
   */
  release() {
    this.canvas_ && (Ih(
      /** @type {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} */
      this.canvas_.getContext("2d")
    ), ua.push(this.canvas_), this.canvas_ = null), super.release();
  }
}
class eO extends ka {
  /**
   * @param {TileRepresentationOptions<TileType>} options The tile representation options.
   */
  constructor(e) {
    super(), this.tile, this.handleTileChange_ = this.handleTileChange_.bind(this), this.gutter = e.gutter || 0, this.helper = e.helper, this.loaded = !1, this.ready = !1;
  }
  /**
   * @param {TileType} tile Tile.
   */
  setTile(e) {
    if (e !== this.tile)
      if (this.tile && this.tile.removeEventListener(le.CHANGE, this.handleTileChange_), this.tile = e, this.loaded = e.getState() === X.LOADED, this.loaded)
        this.uploadTile();
      else {
        if (e instanceof Gh) {
          const t = e.getImage();
          t instanceof Image && !t.crossOrigin && (t.crossOrigin = "anonymous");
        }
        e.addEventListener(le.CHANGE, this.handleTileChange_);
      }
  }
  /**
   * @abstract
   * @protected
   */
  uploadTile() {
    de();
  }
  setReady() {
    this.ready = !0, this.dispatchEvent(le.CHANGE);
  }
  handleTileChange_() {
    this.tile.getState() === X.LOADED && (this.loaded = !0, this.uploadTile());
  }
  /**
   * @param {import("./Helper.js").default} helper The WebGL helper.
   */
  setHelper(e) {
    this.helper = e, this.helper && this.loaded && this.uploadTile();
  }
  /**
   * @override
   */
  disposeInternal() {
    this.setHelper(null), this.tile.removeEventListener(le.CHANGE, this.handleTileChange_);
  }
}
function Tw(i, e, t) {
  const n = t ? i.LINEAR : i.NEAREST;
  i.bindTexture(i.TEXTURE_2D, e), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, n), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, n);
}
function tO(i, e, t, n) {
  Tw(i, e, n), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, t);
}
function h1(i, e, t, n, r, s) {
  const o = i.getGL();
  let a, l;
  t instanceof Float32Array ? (a = o.FLOAT, i.getExtension("OES_texture_float"), l = i.getExtension("OES_texture_float_linear") !== null) : (a = o.UNSIGNED_BYTE, l = !0), Tw(o, e, s && l);
  const h = t.byteLength / n[1];
  let u = 1;
  h % 8 === 0 ? u = 8 : h % 4 === 0 ? u = 4 : h % 2 === 0 && (u = 2);
  let c;
  switch (r) {
    case 1: {
      c = o.LUMINANCE;
      break;
    }
    case 2: {
      c = o.LUMINANCE_ALPHA;
      break;
    }
    case 3: {
      c = o.RGB;
      break;
    }
    case 4: {
      c = o.RGBA;
      break;
    }
    default:
      throw new Error(`Unsupported number of bands: ${r}`);
  }
  const f = o.getParameter(o.UNPACK_ALIGNMENT);
  o.pixelStorei(o.UNPACK_ALIGNMENT, u), o.texImage2D(
    o.TEXTURE_2D,
    0,
    c,
    n[0],
    n[1],
    0,
    c,
    a,
    t
  ), o.pixelStorei(o.UNPACK_ALIGNMENT, f);
}
let $o = null;
function iO() {
  $o = ot(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class nO extends eO {
  /**
   * @param {import("./BaseTileRepresentation.js").TileRepresentationOptions<TileType>} options The tile texture options.
   */
  constructor(e) {
    super(e), this.textures = [], this.renderSize_ = dt(
      e.grid.getTileSize(e.tile.tileCoord[0])
    ), this.bandCount = NaN;
    const t = new xs(fo, Zm);
    t.fromArray([
      0,
      // P0
      1,
      1,
      // P1
      1,
      1,
      // P2
      0,
      0,
      // P3
      0
    ]), this.helper.flushBufferData(t), this.coords = t, this.setTile(e.tile);
  }
  /**
   * @override
   * @param {import("./Helper.js").default} helper The WebGL helper.
   */
  setHelper(e) {
    const t = this.helper?.getGL();
    if (t) {
      this.helper.deleteBuffer(this.coords);
      for (let n = 0; n < this.textures.length; ++n)
        t.deleteTexture(this.textures[n]);
    }
    super.setHelper(e), e && e.flushBufferData(this.coords);
  }
  /**
   * @override
   */
  uploadTile() {
    const e = this.helper, t = e.getGL(), n = this.tile;
    this.textures.length = 0;
    let r;
    n instanceof Gh || n instanceof Jm ? r = n.getImage() : r = n.getData();
    const s = Ra(r);
    if (s) {
      const p = t.createTexture();
      this.textures.push(p), this.bandCount = 4, tO(t, p, s, n.interpolate), this.setReady();
      return;
    }
    r = Kg(r);
    const o = (
      /** @type {DataTile} */
      n.getSize()
    ), a = [
      o[0] + 2 * this.gutter,
      o[1] + 2 * this.gutter
    ], l = r instanceof Float32Array, h = a[0] * a[1], u = l ? Float32Array : Uint8Array, c = u.BYTES_PER_ELEMENT, f = r.byteLength / a[1];
    this.bandCount = Math.floor(f / c / a[0]);
    const g = Math.ceil(this.bandCount / 4);
    if (g === 1) {
      const p = t.createTexture();
      this.textures.push(p), h1(
        e,
        p,
        r,
        a,
        this.bandCount,
        n.interpolate
      ), this.setReady();
      return;
    }
    const d = new Array(g);
    for (let p = 0; p < g; ++p) {
      const y = t.createTexture();
      this.textures.push(y);
      const E = p < g - 1 ? 4 : (this.bandCount - 1) % 4 + 1;
      d[p] = new u(h * E);
    }
    let m = 0, x = 0;
    const v = a[0] * this.bandCount;
    for (let p = 0; p < a[1]; ++p) {
      for (let y = 0; y < v; ++y) {
        const E = r[x + y], b = Math.floor(m / this.bandCount), T = y % this.bandCount, R = Math.floor(T / 4), M = d[R], C = M.length / h, I = T % 4;
        M[b * C + I] = E, ++m;
      }
      x += f / c;
    }
    for (let p = 0; p < g; ++p) {
      const y = this.textures[p], E = d[p], b = E.length / h;
      h1(
        e,
        y,
        E,
        a,
        b,
        n.interpolate
      );
    }
    this.setReady();
  }
  /**
   * @param {import("../DataTile.js").ImageLike} image The image.
   * @param {number} renderCol The column index (in rendered tile space).
   * @param {number} renderRow The row index (in rendered tile space).
   * @return {Uint8ClampedArray|null} The data.
   * @private
   */
  getImagePixelData_(e, t, n) {
    const r = this.gutter, s = this.renderSize_[0], o = this.renderSize_[1];
    $o || iO(), $o.clearRect(0, 0, 1, 1);
    const a = e.width, l = e.height, h = a - 2 * r, u = l - 2 * r, c = r + Math.floor(h * (t / s)), f = r + Math.floor(u * (n / o));
    let g;
    try {
      $o.drawImage(e, c, f, 1, 1, 0, 0, 1, 1), g = $o.getImageData(0, 0, 1, 1).data;
    } catch {
      return $o = null, null;
    }
    return g;
  }
  /**
   * @param {import("../DataTile.js").ArrayLike} data The data.
   * @param {import("../size.js").Size} sourceSize The size.
   * @param {number} renderCol The column index (in rendered tile space).
   * @param {number} renderRow The row index (in rendered tile space).
   * @return {import("../DataTile.js").ArrayLike|null} The data.
   * @private
   */
  getArrayPixelData_(e, t, n, r) {
    const s = this.gutter, o = this.renderSize_[0], a = this.renderSize_[1], l = t[0], h = t[1], u = l + 2 * s, c = h + 2 * s, f = s + Math.floor(l * (n / o)), g = s + Math.floor(h * (r / a));
    if (e instanceof DataView) {
      const m = e.byteLength / (u * c), x = m * (g * u + f), v = e.buffer.slice(x, x + m);
      return new DataView(v);
    }
    const d = this.bandCount * (g * u + f);
    return e.slice(d, d + this.bandCount);
  }
  /**
   * Get data for a pixel.  If the tile is not loaded, null is returned.
   * @param {number} renderCol The column index (in rendered tile space).
   * @param {number} renderRow The row index (in rendered tile space).
   * @return {import("../DataTile.js").ArrayLike|null} The data.
   */
  getPixelData(e, t) {
    if (!this.loaded)
      return null;
    if (this.tile instanceof rh) {
      const n = this.tile.getData(), r = Kg(n);
      if (r) {
        const s = this.tile.getSize();
        return this.getArrayPixelData_(
          r,
          s,
          e,
          t
        );
      }
      return this.getImagePixelData_(Ra(n), e, t);
    }
    return this.getImagePixelData_(this.tile.getImage(), e, t);
  }
}
class Uf {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(e, t, n, r) {
    this.minX = e, this.maxX = t, this.minY = n, this.maxY = r;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(e) {
    return this.containsXY(e[1], e[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(e) {
    return this.minX <= e.minX && e.maxX <= this.maxX && this.minY <= e.minY && e.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(e, t) {
    return this.minX <= e && e <= this.maxX && this.minY <= t && t <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(e) {
    return this.minX == e.minX && this.minY == e.minY && this.maxX == e.maxX && this.maxY == e.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(e) {
    e.minX < this.minX && (this.minX = e.minX), e.maxX > this.maxX && (this.maxX = e.maxX), e.minY < this.minY && (this.minY = e.minY), e.maxY > this.maxY && (this.maxY = e.maxY);
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(e) {
    return this.minX <= e.maxX && this.maxX >= e.minX && this.minY <= e.maxY && this.maxY >= e.minY;
  }
}
function Io(i, e, t, n, r) {
  return r !== void 0 ? (r.minX = i, r.maxX = e, r.minY = t, r.maxY = n, r) : new Uf(i, e, t, n);
}
class Ic {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(e) {
    this.highWaterMark = e !== void 0 ? e : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  deleteOldest() {
    const e = this.pop();
    e instanceof Da && e.dispose();
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
   * the entry will be disposed.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(e) {
    for (; this.canExpireCache(); )
      this.deleteOldest();
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    for (; this.oldest_; )
      this.deleteOldest();
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(e) {
    return this.entries_.hasOwnProperty(e);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(e) {
    let t = this.oldest_;
    for (; t; )
      e(t.value_, t.key_, this), t = t.newer;
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(e, t) {
    const n = this.entries_[e];
    return Te(
      n !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), n === this.newest_ || (n === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    this.oldest_.newer, this.oldest_.older = null) : (n.newer.older = n.older, n.older.newer = n.newer), n.newer = null, n.older = this.newest_, this.newest_.newer = n, this.newest_ = n), n.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(e) {
    const t = this.entries_[e];
    return Te(
      t !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), t === this.newest_ ? (this.newest_ = /** @type {Entry} */
    t.older, this.newest_ && (this.newest_.newer = null)) : t === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    t.newer, this.oldest_ && (this.oldest_.older = null)) : (t.newer.older = t.older, t.older.newer = t.newer), delete this.entries_[e], --this.count_, t.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const e = new Array(this.count_);
    let t = 0, n;
    for (n = this.newest_; n; n = n.older)
      e[t++] = n.key_;
    return e;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const e = new Array(this.count_);
    let t = 0, n;
    for (n = this.newest_; n; n = n.older)
      e[t++] = n.value_;
    return e;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(e) {
    return this.entries_[e]?.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const e = this.oldest_;
    return delete this.entries_[e.key_], e.newer && (e.newer.older = null), this.oldest_ = /** @type {Entry} */
    e.newer, this.oldest_ || (this.newest_ = null), --this.count_, e.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(e, t) {
    this.get(e), this.entries_[e].value_ = t;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(e, t) {
    Te(
      !(e in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const n = {
      key_: e,
      newer: null,
      older: this.newest_,
      value_: t
    };
    this.newest_ ? this.newest_.newer = n : this.oldest_ = n, this.newest_ = n, this.entries_[e] = n, ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(e) {
    this.highWaterMark = e;
  }
}
function go(i, e, t, n) {
  return n !== void 0 ? (n[0] = i, n[1] = e, n[2] = t, n) : [i, e, t];
}
function Qm(i, e, t) {
  return i + "/" + e + "/" + t;
}
function jo(i) {
  return Qm(i[0], i[1], i[2]);
}
function Ol(i, e, t, n, r) {
  return `${ie(i)},${e},${Qm(t, n, r)}`;
}
function e0(i) {
  return Rw(i[0], i[1], i[2]);
}
function Rw(i, e, t) {
  return (e << i) + t;
}
function rO(i, e) {
  const t = i[0], n = i[1], r = i[2];
  if (e.getMinZoom() > t || t > e.getMaxZoom())
    return !1;
  const s = e.getFullTileRange(t);
  return s ? s.containsXY(n, r) : !0;
}
class kh extends uw {
  /**
   * @param {LayerType} layer Layer.
   * @param {Options} [options] Options.
   */
  constructor(e, t) {
    super(e), t = t || {}, this.inversePixelTransform_ = st(), this.postProcesses_ = t.postProcesses, this.uniforms_ = t.uniforms, this.helper, this.onMapChanged_ = () => {
      this.clearCache(), this.removeHelper();
    }, e.addChangeListener(je.MAP, this.onMapChanged_), this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this), this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPreComposeEvent(e, t) {
    const n = this.getLayer();
    if (n.hasListener(Ht.PRECOMPOSE)) {
      const r = new Fl(
        Ht.PRECOMPOSE,
        void 0,
        t,
        e
      );
      n.dispatchEvent(r);
    }
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPostComposeEvent(e, t) {
    const n = this.getLayer();
    if (n.hasListener(Ht.POSTCOMPOSE)) {
      const r = new Fl(
        Ht.POSTCOMPOSE,
        void 0,
        t,
        e
      );
      n.dispatchEvent(r);
    }
  }
  /**
   * Reset options (only handles uniforms).
   * @param {Options} options Options.
   */
  reset(e) {
    this.uniforms_ = e.uniforms, this.helper && this.helper.setUniforms(this.uniforms_);
  }
  /**
   * @protected
   */
  removeHelper() {
    this.helper && (this.helper.dispose(), delete this.helper);
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(e) {
    if (this.getLayer().getRenderSource()) {
      let t = !0, n = -1, r;
      for (let o = 0, a = e.layerStatesArray.length; o < a; o++) {
        const l = e.layerStatesArray[o].layer, h = l.getRenderer();
        if (!(h instanceof kh)) {
          t = !0;
          continue;
        }
        const u = l.getClassName();
        if ((t || u !== r) && (n += 1, t = !1), r = u, h === this)
          break;
      }
      const s = "map/" + e.mapId + "/group/" + n;
      (!this.helper || !this.helper.canvasCacheKeyMatches(s) || this.helper.needsToBeRecreated()) && (this.removeHelper(), this.helper = new WF({
        postProcesses: this.postProcesses_,
        uniforms: this.uniforms_,
        canvasCacheKey: s
      }), r && (this.helper.getCanvas().className = r), this.afterHelperCreated());
    }
    return this.prepareFrameInternal(e);
  }
  /**
   * @protected
   */
  afterHelperCreated() {
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @protected
   */
  prepareFrameInternal(e) {
    return !0;
  }
  /**
   * @protected
   */
  clearCache() {
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.clearCache(), this.removeHelper(), this.getLayer()?.removeChangeListener(
      je.MAP,
      this.onMapChanged_
    ), super.disposeInternal();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, n) {
    const r = this.getLayer();
    if (r.hasListener(e)) {
      un(
        this.inversePixelTransform_,
        0,
        0,
        n.pixelRatio,
        -n.pixelRatio,
        0,
        0,
        -n.size[1]
      );
      const s = new Fl(
        e,
        this.inversePixelTransform_,
        n,
        t
      );
      r.dispatchEvent(s);
    }
  }
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.dispatchRenderEvent_(Ht.PRERENDER, e, t);
  }
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    this.dispatchRenderEvent_(Ht.POSTRENDER, e, t);
  }
}
const sO = {
  TILE_TRANSFORM: "u_tileTransform",
  TRANSITION_ALPHA: "u_transitionAlpha",
  DEPTH: "u_depth",
  RENDER_EXTENT: "u_renderExtent",
  // intersection of layer, source, and view extent
  PATTERN_ORIGIN: "u_patternOrigin",
  RESOLUTION: "u_resolution",
  ZOOM: "u_zoom",
  GLOBAL_ALPHA: "u_globalAlpha",
  PROJECTION_MATRIX: "u_projectionMatrix",
  SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix"
};
function u1(i) {
  return 1 / (i + 2);
}
function oO() {
  return { tileIds: /* @__PURE__ */ new Set(), representationsByZ: {} };
}
function c1(i, e) {
  return i.tileIds.has(ie(e));
}
function f1(i, e, t) {
  const n = i.representationsByZ;
  t in n || (n[t] = /* @__PURE__ */ new Set()), n[t].add(e), i.tileIds.add(ie(e.tile));
}
function $d(i, e) {
  const t = i.layerStatesArray[i.layerIndex];
  t.extent && (e = kt(
    e,
    xn(t.extent, i.viewState.projection)
  ));
  const n = (
    /** @type {import("../../source/Tile.js").default} */
    t.layer.getRenderSource()
  );
  if (!n.getWrapX()) {
    const r = n.getTileGridForProjection(i.viewState.projection).getExtent();
    r && (e = kt(e, r));
  }
  return e;
}
function Jg(i, e) {
  return `${ie(i)},${i.getKey()},${i.getRevision()},${jo(e)}`;
}
class aO extends kh {
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} options Options.
   */
  constructor(e, t) {
    super(e, {
      uniforms: t.uniforms,
      postProcesses: t.postProcesses
    }), this.renderComplete = !1, this.tileTransform_ = st(), this.tempMat4 = So(), this.tempTileRange_ = new Uf(0, 0, 0, 0), this.tempTileCoord_ = go(0, 0, 0), this.tempSize_ = [0, 0];
    const n = t.cacheSize !== void 0 ? t.cacheSize : 512;
    this.tileRepresentationCache = new Ic(n), this.frameState = null, this.renderedProjection_ = void 0;
  }
  /**
   * @param {Options} options Options.
   * @override
   */
  reset(e) {
    super.reset({
      uniforms: e.uniforms
    });
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrameInternal(e) {
    this.renderedProjection_ ? e.viewState.projection !== this.renderedProjection_ && (this.clearCache(), this.renderedProjection_ = e.viewState.projection) : this.renderedProjection_ = e.viewState.projection;
    const n = this.getLayer().getRenderSource();
    return !n || qn($d(e, e.extent)) ? !1 : n.getState() === "ready";
  }
  /**
   * @abstract
   * @param {import("../../webgl/BaseTileRepresentation.js").TileRepresentationOptions<TileType>} options tile representation options
   * @return {TileRepresentation} A new tile representation
   * @protected
   */
  createTileRepresentation(e) {
    return de();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent The extent to be rendered.
   * @param {number} initialZ The zoom level.
   * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.
   * @param {number} preload Number of additional levels to load.
   */
  enqueueTiles(e, t, n, r, s) {
    const o = e.viewState, a = this.getLayer(), l = a.getRenderSource(), h = l.getTileGridForProjection(o.projection), u = l.getGutterForProjection(o.projection), c = ie(l);
    c in e.wantedTiles || (e.wantedTiles[c] = {});
    const f = e.wantedTiles[c], g = this.tileRepresentationCache, d = a.getMapInternal(), m = Math.max(
      n - s,
      h.getMinZoom(),
      h.getZForResolution(
        Math.min(
          a.getMaxResolution(),
          d ? d.getView().getResolutionForZoom(Math.max(a.getMinZoom(), 0)) : h.getResolution(0)
        ),
        l.zDirection
      )
    ), x = o.rotation, v = x ? Xp(
      o.center,
      o.resolution,
      x,
      e.size
    ) : void 0;
    for (let p = n; p >= m; --p) {
      const y = h.getTileRangeForExtentAndZ(
        t,
        p,
        this.tempTileRange_
      ), E = h.getResolution(p);
      for (let b = y.minX; b <= y.maxX; ++b)
        for (let T = y.minY; T <= y.maxY; ++T) {
          if (x && !h.tileCoordIntersectsViewport([p, b, T], v))
            continue;
          const R = go(p, b, T, this.tempTileCoord_), M = Jg(l, R);
          let C, I;
          if (g.containsKey(M) && (C = g.get(M), I = C.tile), (!C || C.tile.key !== l.getKey()) && (I = l.getTile(
            p,
            b,
            T,
            e.pixelRatio,
            o.projection
          ), !I) || c1(r, I))
            continue;
          C ? C.setTile(I) : (C = this.createTileRepresentation({
            tile: I,
            grid: h,
            helper: this.helper,
            gutter: u
          }), g.set(M, C)), f1(
            r,
            C,
            p
          );
          const O = I.getKey();
          f[O] = !0, I.getState() === X.IDLE && (e.tileQueue.isKeyQueued(O) || e.tileQueue.enqueue([
            I,
            c,
            h.getTileCoordCenter(R),
            E
          ]));
        }
    }
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha
   * @protected
   */
  beforeTilesRender(e, t) {
    this.helper.prepareDraw(this.frameState, !t, !0);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} If returns false, tile mask rendering will be skipped
   * @protected
   */
  beforeTilesMaskRender(e) {
    return !1;
  }
  /**
   * @param {TileRepresentation} tileRepresentation Tile representation
   * @param {import("../../transform.js").Transform} tileTransform Tile transform
   * @param {import("../../Map.js").FrameState} frameState Frame state
   * @param {import("../../extent.js").Extent} renderExtent Render extent
   * @param {number} tileResolution Tile resolution
   * @param {import("../../size.js").Size} tileSize Tile size
   * @param {import("../../coordinate.js").Coordinate} tileOrigin Tile origin
   * @param {import("../../extent.js").Extent} tileExtent tile Extent
   * @param {number} depth Depth
   * @param {number} gutter Gutter
   * @param {number} alpha Alpha
   * @protected
   */
  renderTile(e, t, n, r, s, o, a, l, h, u, c) {
  }
  /**
   * @param {TileRepresentation} tileRepresentation Tile representation
   * @param {number} tileZ Tile Z
   * @param {import("../../extent.js").Extent} extent Render extent
   * @param {number} depth Depth
   * @protected
   */
  renderTileMask(e, t, n, r) {
  }
  drawTile_(e, t, n, r, s, o, a) {
    if (!t.ready)
      return;
    const h = t.tile.tileCoord, u = jo(h), c = u in o ? o[u] : 1, f = a.getResolution(n), g = dt(a.getTileSize(n), this.tempSize_), d = a.getOrigin(n), m = a.getTileCoordExtent(h), x = c < 1 ? -1 : u1(n);
    c < 1 && (e.animate = !0);
    const v = e.viewState, p = v.center[0], y = v.center[1], E = g[0] + 2 * r, b = g[1] + 2 * r, T = E / b, R = (p - d[0]) / (g[0] * f), M = (d[1] - y) / (g[1] * f), C = v.resolution / f, I = h[1], O = h[2];
    Lg(this.tileTransform_), Ml(
      this.tileTransform_,
      2 / (e.size[0] * C / E),
      -2 / (e.size[1] * C / E)
    ), g2(this.tileTransform_, v.rotation), Ml(this.tileTransform_, 1, 1 / T), xf(
      this.tileTransform_,
      (g[0] * (I - R) - r) / E,
      (g[1] * (O - M) - r) / b
    ), this.renderTile(
      /** @type {TileRepresentation} */
      t,
      this.tileTransform_,
      e,
      s,
      f,
      g,
      d,
      m,
      x,
      r,
      c
    );
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(e) {
    this.frameState = e, this.renderComplete = !0;
    const t = this.helper.getGL();
    this.preRender(t, e);
    const n = e.viewState, r = this.getLayer(), s = r.getRenderSource(), o = s.getTileGridForProjection(n.projection), a = s.getGutterForProjection(n.projection), l = $d(e, e.extent), h = o.getZForResolution(
      n.resolution,
      s.zDirection
    ), u = oO(), c = r.getPreload();
    if (e.nextExtent) {
      const y = o.getZForResolution(
        n.nextResolution,
        s.zDirection
      ), E = $d(e, e.nextExtent);
      this.enqueueTiles(
        e,
        E,
        y,
        u,
        c
      );
    }
    this.enqueueTiles(e, l, h, u, 0), c > 0 && setTimeout(() => {
      this.enqueueTiles(
        e,
        l,
        h - 1,
        u,
        c - 1
      );
    }, 0);
    const f = {};
    let g = !1;
    const d = u.representationsByZ;
    if (h in d) {
      const y = ie(this), E = e.time;
      for (const b of d[h]) {
        const T = b.tile;
        if (T.getState() === X.EMPTY)
          continue;
        const R = T.tileCoord;
        if (b.ready) {
          const I = T.getAlpha(y, E);
          if (I === 1) {
            T.endTransition(y);
            continue;
          }
          g = !0;
          const O = jo(R);
          f[O] = I;
        }
        if (this.renderComplete = !1, this.findAltTiles_(
          o,
          R,
          h + 1,
          u
        ))
          continue;
        const C = o.getMinZoom();
        for (let I = h - 1; I >= C && !this.findAltTiles_(
          o,
          R,
          I,
          u
        ); --I)
          ;
      }
    }
    const m = Object.keys(d).map(Number).sort(dE);
    if (this.beforeTilesMaskRender(e))
      for (let y = 0, E = m.length; y < E; ++y) {
        const b = m[y];
        for (const T of d[b]) {
          const R = T.tile.tileCoord;
          if (jo(R) in f)
            continue;
          const C = o.getTileCoordExtent(R);
          this.renderTileMask(
            /** @type {TileRepresentation} */
            T,
            b,
            C,
            u1(b)
          );
        }
      }
    this.beforeTilesRender(e, g);
    for (let y = 0, E = m.length; y < E; ++y) {
      const b = m[y];
      for (const T of d[b]) {
        const R = T.tile.tileCoord;
        jo(R) in f || this.drawTile_(
          e,
          T,
          b,
          a,
          l,
          f,
          o
        );
      }
    }
    if (h in d)
      for (const y of d[h]) {
        const E = y.tile.tileCoord;
        jo(E) in f && this.drawTile_(
          e,
          y,
          h,
          a,
          l,
          f,
          o
        );
      }
    this.beforeFinalize(e), this.helper.finalizeDraw(
      e,
      this.dispatchPreComposeEvent,
      this.dispatchPostComposeEvent
    );
    const v = this.helper.getCanvas();
    return this.tileRepresentationCache.expireCache(), this.postRender(t, e), v;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  beforeFinalize(e) {
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile representation lookup.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {number} altZ The alternate zoom level.
   * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of
   * tile representations by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findAltTiles_(e, t, n, r) {
    const s = e.getTileRangeForTileCoordAndZ(
      t,
      n,
      this.tempTileRange_
    );
    if (!s)
      return !1;
    let o = !0;
    const a = this.tileRepresentationCache, l = this.getLayer().getRenderSource();
    for (let h = s.minX; h <= s.maxX; ++h)
      for (let u = s.minY; u <= s.maxY; ++u) {
        const c = Jg(l, [n, h, u]);
        let f = !1;
        if (a.containsKey(c)) {
          const g = a.get(c);
          g.ready && !c1(r, g.tile) && (f1(
            r,
            g,
            n
          ), f = !0);
        }
        f || (o = !1);
      }
    return o;
  }
  /**
   * @override
   */
  clearCache() {
    super.clearCache();
    const e = this.tileRepresentationCache;
    e.forEach(
      (t) => t.dispose()
    ), e.clear();
  }
  /**
   * @override
   */
  afterHelperCreated() {
    super.afterHelperCreated(), this.tileRepresentationCache.forEach(
      (e) => e.setHelper(this.helper)
    );
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    super.disposeInternal(), delete this.frameState;
  }
}
const Pe = {
  ...sO,
  TILE_TEXTURE_ARRAY: "u_tileTextures",
  TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth",
  TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight",
  TEXTURE_RESOLUTION: "u_textureResolution",
  // map units per texture pixel
  TEXTURE_ORIGIN_X: "u_textureOriginX",
  // map x coordinate of left edge of texture
  TEXTURE_ORIGIN_Y: "u_textureOriginY"
  // map y coordinate of top edge of texture
}, Xu = {
  TEXTURE_COORD: "a_textureCoord"
}, lO = [
  {
    name: Xu.TEXTURE_COORD,
    size: 2,
    type: Rt.FLOAT
  }
];
class hO extends aO {
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} options Options.
   */
  constructor(e, t) {
    super(e, t), this.program_, this.vertexShader_ = t.vertexShader, this.fragmentShader_ = t.fragmentShader, this.indices_ = new xs(Dh, Zm), this.indices_.fromArray([0, 1, 3, 1, 2, 3]), this.paletteTextures_ = t.paletteTextures || [];
  }
  /**
   * @param {Options} options Options.
   * @override
   */
  reset(e) {
    if (super.reset(e), this.helper) {
      const t = this.helper.getGL();
      for (const n of this.paletteTextures_)
        n.delete(t);
    }
    if (this.vertexShader_ = e.vertexShader, this.fragmentShader_ = e.fragmentShader, this.paletteTextures_ = e.paletteTextures || [], this.helper) {
      this.program_ = this.helper.getProgram(
        this.fragmentShader_,
        this.vertexShader_
      );
      const t = this.helper.getGL();
      for (const n of this.paletteTextures_)
        n.getTexture(t);
    }
  }
  /**
   * @override
   */
  afterHelperCreated() {
    super.afterHelperCreated();
    const e = this.helper.getGL();
    for (const t of this.paletteTextures_)
      t.getTexture(e);
    this.program_ = this.helper.getProgram(
      this.fragmentShader_,
      this.vertexShader_
    ), this.helper.flushBufferData(this.indices_);
  }
  /**
   * @override
   */
  removeHelper() {
    if (this.helper) {
      const e = this.helper.getGL();
      for (const t of this.paletteTextures_)
        t.delete(e);
    }
    super.removeHelper();
  }
  /**
   * @override
   */
  createTileRepresentation(e) {
    return new nO(e);
  }
  /**
   * @override
   */
  beforeTilesRender(e, t) {
    super.beforeTilesRender(e, t), this.helper.useProgram(this.program_, e);
  }
  /**
   * @override
   */
  renderTile(e, t, n, r, s, o, a, l, h, u, c) {
    const f = this.helper.getGL();
    this.helper.bindBuffer(e.coords), this.helper.bindBuffer(this.indices_), this.helper.enableAttributes(lO);
    let g = 0;
    for (; g < e.textures.length; ) {
      const T = `${Pe.TILE_TEXTURE_ARRAY}[${g}]`;
      this.helper.bindTexture(
        e.textures[g],
        g,
        T
      ), ++g;
    }
    for (let T = 0; T < this.paletteTextures_.length; ++T) {
      const R = this.paletteTextures_[T], M = R.getTexture(f);
      this.helper.bindTexture(M, g, R.name), ++g;
    }
    const d = n.viewState, m = o[0] + 2 * u, x = o[1] + 2 * u, p = e.tile.tileCoord, y = p[1], E = p[2];
    this.helper.setUniformMatrixValue(
      Pe.TILE_TRANSFORM,
      Mc(this.tempMat4, t)
    ), this.helper.setUniformFloatValue(Pe.TRANSITION_ALPHA, c), this.helper.setUniformFloatValue(Pe.DEPTH, h);
    let b = r;
    u > 0 && (b = l, kt(b, r, b)), this.helper.setUniformFloatVec4(Pe.RENDER_EXTENT, b), this.helper.setUniformFloatValue(Pe.RESOLUTION, d.resolution), this.helper.setUniformFloatValue(Pe.ZOOM, d.zoom), this.helper.setUniformFloatValue(
      Pe.TEXTURE_PIXEL_WIDTH,
      m
    ), this.helper.setUniformFloatValue(
      Pe.TEXTURE_PIXEL_HEIGHT,
      x
    ), this.helper.setUniformFloatValue(
      Pe.TEXTURE_RESOLUTION,
      s
    ), this.helper.setUniformFloatValue(
      Pe.TEXTURE_ORIGIN_X,
      a[0] + y * o[0] * s - u * s
    ), this.helper.setUniformFloatValue(
      Pe.TEXTURE_ORIGIN_Y,
      a[1] - E * o[1] * s + u * s
    ), this.helper.drawElements(0, this.indices_.getSize());
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.
   * @override
   */
  getData(e) {
    if (!this.helper.getGL())
      return null;
    const n = this.frameState;
    if (!n)
      return null;
    const r = this.getLayer(), s = rt(
      n.pixelToCoordinateTransform,
      e.slice()
    ), o = n.viewState, a = r.getExtent();
    if (a && !nn(
      xn(a, o.projection),
      s
    ))
      return null;
    const l = r.getSources(
      Ea([s]),
      o.resolution
    );
    let h, u, c;
    for (h = l.length - 1; h >= 0; --h)
      if (u = l[h], u.getState() === "ready") {
        if (c = u.getTileGridForProjection(o.projection), u.getWrapX())
          break;
        const g = c.getExtent();
        if (!g || nn(g, s))
          break;
      }
    if (h < 0)
      return null;
    const f = this.tileRepresentationCache;
    for (let g = c.getZForResolution(o.resolution); g >= c.getMinZoom(); --g) {
      const d = c.getTileCoordForCoordAndZ(s, g), m = Jg(u, d);
      if (!f.containsKey(m))
        continue;
      const x = f.get(m);
      if (x.tile.getState() === X.EMPTY)
        return null;
      if (!x.loaded)
        continue;
      const p = c.getOrigin(g), y = dt(c.getTileSize(g)), E = c.getResolution(g), b = (s[0] - p[0]) / E - d[1] * y[0], T = (p[1] - s[1]) / E - d[2] * y[1];
      return x.getPixelData(b, T);
    }
    return null;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    const e = this.helper;
    if (e) {
      const t = e.getGL();
      for (const n of this.paletteTextures_)
        n.delete(t);
      this.paletteTextures_.length = 0, t.deleteProgram(this.program_), delete this.program_, e.deleteBuffer(this.indices_);
    }
    super.disposeInternal(), delete this.indices_;
  }
}
class uO {
  /**
   * @param {string} name The name of the texture.
   * @param {Uint8Array} data The texture data.
   */
  constructor(e, t) {
    this.name = e, this.data = t, this.texture_ = null;
  }
  /**
   * @param {WebGLRenderingContext} gl Rendering context.
   * @return {WebGLTexture} The texture.
   */
  getTexture(e) {
    if (!this.texture_) {
      const t = e.createTexture();
      e.bindTexture(e.TEXTURE_2D, t), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texImage2D(
        e.TEXTURE_2D,
        0,
        e.RGBA,
        this.data.length / 4,
        1,
        0,
        e.RGBA,
        e.UNSIGNED_BYTE,
        this.data
      ), this.texture_ = t;
    }
    return this.texture_;
  }
  /**
   * @param {WebGLRenderingContext} gl Rendering context.
   */
  delete(e) {
    this.texture_ && e.deleteTexture(this.texture_), this.texture_ = null;
  }
}
function cO(i, e) {
  return `operator_${i}_${Object.keys(e.functions).length}`;
}
function Es(i) {
  const e = i.toString();
  return e.includes(".") ? e : e + ".0";
}
function t0(i) {
  if (i.length < 2 || i.length > 4)
    throw new Error(
      "`formatArray` can only output `vec2`, `vec3` or `vec4` arrays."
    );
  return `vec${i.length}(${i.map(Es).join(", ")})`;
}
function Vu(i) {
  const e = An(i), t = e.length > 3 ? e[3] : 1;
  return t0([e[0] / 255, e[1] / 255, e[2] / 255, t]);
}
function fO(i) {
  const e = dt(i);
  return t0(e);
}
const jd = {};
let dO = 0;
function Pa(i) {
  return i in jd || (jd[i] = dO++), jd[i];
}
function Cr(i) {
  return Es(Pa(i));
}
function zf(i) {
  return "u_var_" + i;
}
function i0() {
  return {
    variables: {},
    properties: {},
    functions: {},
    bandCount: 0,
    featureId: !1,
    geometryType: !1
  };
}
const Xd = "getBandValue", Pw = "u_paletteTextures", Mw = "featureId", Cw = "geometryType", Qg = -9999999;
function gO(i, e, t, n) {
  const r = oi(i, e, t);
  return n0(r, e, n);
}
function $e(i) {
  return (e, t, n) => {
    const r = t.args.length, s = new Array(r);
    for (let o = 0; o < r; ++o)
      s[o] = n0(t.args[o], n, e);
    return i(s, e);
  };
}
const pO = {
  [B.Get]: (i, e) => {
    const n = (
      /** @type {string} */
      /** @type {LiteralExpression} */
      e.args[0].value
    );
    n in i.properties || (i.properties[n] = {
      name: n,
      type: e.type
    });
    let s = "a_prop_" + n;
    return nr(e.type, jt) && (s = `(${s} > 0.0)`), s;
  },
  [B.Id]: (i) => (i.featureId = !0, "a_" + Mw),
  [B.GeometryType]: (i) => (i.geometryType = !0, "a_" + Cw),
  [B.LineMetric]: () => "currentLineMetric",
  // this variable is assumed to always be present in shaders, default is 0.
  [B.Var]: (i, e) => {
    const n = (
      /** @type {string} */
      /** @type {LiteralExpression} */
      e.args[0].value
    );
    n in i.variables || (i.variables[n] = {
      name: n,
      type: e.type
    });
    let s = zf(n);
    return nr(e.type, jt) && (s = `(${s} > 0.0)`), s;
  },
  [B.Has]: (i, e) => {
    const n = (
      /** @type {string} */
      /** @type {LiteralExpression} */
      e.args[0].value
    );
    return n in i.properties || (i.properties[n] = {
      name: n,
      type: e.type
    }), `(a_prop_${n} != ${Es(Qg)})`;
  },
  [B.Resolution]: () => "u_resolution",
  [B.Zoom]: () => "u_zoom",
  [B.Time]: () => "u_time",
  [B.Any]: $e((i) => `(${i.join(" || ")})`),
  [B.All]: $e((i) => `(${i.join(" && ")})`),
  [B.Not]: $e(([i]) => `(!${i})`),
  [B.Equal]: $e(
    ([i, e]) => `(${i} == ${e})`
  ),
  [B.NotEqual]: $e(
    ([i, e]) => `(${i} != ${e})`
  ),
  [B.GreaterThan]: $e(
    ([i, e]) => `(${i} > ${e})`
  ),
  [B.GreaterThanOrEqualTo]: $e(
    ([i, e]) => `(${i} >= ${e})`
  ),
  [B.LessThan]: $e(
    ([i, e]) => `(${i} < ${e})`
  ),
  [B.LessThanOrEqualTo]: $e(
    ([i, e]) => `(${i} <= ${e})`
  ),
  [B.Multiply]: $e(
    (i) => `(${i.join(" * ")})`
  ),
  [B.Divide]: $e(
    ([i, e]) => `(${i} / ${e})`
  ),
  [B.Add]: $e((i) => `(${i.join(" + ")})`),
  [B.Subtract]: $e(
    ([i, e]) => `(${i} - ${e})`
  ),
  [B.Clamp]: $e(
    ([i, e, t]) => `clamp(${i}, ${e}, ${t})`
  ),
  [B.Mod]: $e(([i, e]) => `mod(${i}, ${e})`),
  [B.Pow]: $e(([i, e]) => `pow(${i}, ${e})`),
  [B.Abs]: $e(([i]) => `abs(${i})`),
  [B.Floor]: $e(([i]) => `floor(${i})`),
  [B.Ceil]: $e(([i]) => `ceil(${i})`),
  [B.Round]: $e(([i]) => `floor(${i} + 0.5)`),
  [B.Sin]: $e(([i]) => `sin(${i})`),
  [B.Cos]: $e(([i]) => `cos(${i})`),
  [B.Atan]: $e(([i, e]) => e !== void 0 ? `atan(${i}, ${e})` : `atan(${i})`),
  [B.Sqrt]: $e(([i]) => `sqrt(${i})`),
  [B.Match]: $e((i) => {
    const e = i[0], t = i[i.length - 1];
    let n = null;
    for (let r = i.length - 3; r >= 1; r -= 2) {
      const s = i[r], o = i[r + 1];
      n = `(${e} == ${s} ? ${o} : ${n || t})`;
    }
    return n;
  }),
  [B.Between]: $e(
    ([i, e, t]) => `(${i} >= ${e} && ${i} <= ${t})`
  ),
  [B.Interpolate]: $e(([i, e, ...t]) => {
    let n = "";
    for (let r = 0; r < t.length - 2; r += 2) {
      const s = t[r], o = n || t[r + 1], a = t[r + 2], l = t[r + 3];
      let h;
      i === Es(1) ? h = `(${e} - ${s}) / (${a} - ${s})` : h = `(pow(${i}, (${e} - ${s})) - 1.0) / (pow(${i}, (${a} - ${s})) - 1.0)`, n = `mix(${o}, ${l}, clamp(${h}, 0.0, 1.0))`;
    }
    return n;
  }),
  [B.Case]: $e((i) => {
    const e = i[i.length - 1];
    let t = null;
    for (let n = i.length - 3; n >= 0; n -= 2) {
      const r = i[n], s = i[n + 1];
      t = `(${r} ? ${s} : ${t || e})`;
    }
    return t;
  }),
  [B.In]: $e(([i, ...e], t) => {
    const n = cO("in", t), r = [];
    for (let s = 0; s < e.length; s += 1)
      r.push(`  if (inputValue == ${e[s]}) { return true; }`);
    return t.functions[n] = `bool ${n}(float inputValue) {
${r.join(`
`)}
  return false;
}`, `${n}(${i})`;
  }),
  [B.Array]: $e(
    (i) => `vec${i.length}(${i.join(", ")})`
  ),
  [B.Color]: $e((i) => {
    if (i.length === 1)
      return `vec4(vec3(${i[0]} / 255.0), 1.0)`;
    if (i.length === 2)
      return `vec4(vec3(${i[0]} / 255.0), ${i[1]})`;
    const e = i.slice(0, 3).map((n) => `${n} / 255.0`);
    if (i.length === 3)
      return `vec4(${e.join(", ")}, 1.0)`;
    const t = i[3];
    return `vec4(${e.join(", ")}, ${t})`;
  }),
  [B.Band]: $e(([i, e, t], n) => {
    if (!(Xd in n.functions)) {
      let r = "";
      const s = n.bandCount || 1;
      for (let o = 0; o < s; o++) {
        const a = Math.floor(o / 4);
        let l = o % 4;
        o === s - 1 && l === 1 && (l = 3);
        const h = `${Pe.TILE_TEXTURE_ARRAY}[${a}]`;
        r += `  if (band == ${o + 1}.0) {
    return texture2D(${h}, v_textureCoord + vec2(dx, dy))[${l}];
  }
`;
      }
      n.functions[Xd] = `float getBandValue(float band, float xOffset, float yOffset) {
  float dx = xOffset / ${Pe.TEXTURE_PIXEL_WIDTH};
  float dy = yOffset / ${Pe.TEXTURE_PIXEL_HEIGHT};
${r}
}`;
    }
    return `${Xd}(${i}, ${e ?? "0.0"}, ${t ?? "0.0"})`;
  }),
  [B.Palette]: (i, e) => {
    const [t, ...n] = e.args, r = n.length, s = new Uint8Array(r * 4);
    for (let h = 0; h < n.length; h++) {
      const u = (
        /** @type {string | Array<number>} */
        /** @type {LiteralExpression} */
        n[h].value
      ), c = An(u), f = h * 4;
      s[f] = c[0], s[f + 1] = c[1], s[f + 2] = c[2], s[f + 3] = c[3] * 255;
    }
    i.paletteTextures || (i.paletteTextures = []);
    const o = `${Pw}[${i.paletteTextures.length}]`, a = new uO(o, s);
    i.paletteTextures.push(a);
    const l = n0(t, oe, i);
    return `texture2D(${o}, vec2((${l} + 0.5) / ${r}.0, 0.5))`;
  }
  // TODO: unimplemented
  // Ops.Number
  // Ops.String
  // Ops.Coalesce
  // Ops.Concat
  // Ops.ToString
};
function n0(i, e, t) {
  if (i instanceof fw) {
    const n = pO[i.operator];
    if (n === void 0)
      throw new Error(
        `No compiler defined for this operator: ${JSON.stringify(
          i.operator
        )}`
      );
    return n(t, i, e);
  }
  if ((i.type & oe) > 0)
    return Es(
      /** @type {number} */
      i.value
    );
  if ((i.type & jt) > 0)
    return i.value.toString();
  if ((i.type & Kt) > 0)
    return Cr(i.value.toString());
  if ((i.type & mt) > 0)
    return Vu(
      /** @type {Array<number> | string} */
      i.value
    );
  if ((i.type & Wi) > 0)
    return t0(
      /** @type {Array<number>} */
      i.value
    );
  if ((i.type & bn) > 0)
    return fO(
      /** @type {number|import('../size.js').Size} */
      i.value
    );
  throw new Error(
    `Unexpected expression ${i.value} (expected type ${Ko(
      e
    )})`
  );
}
function mO() {
  return {
    "fill-color": "rgba(255,255,255,0.4)",
    "stroke-color": "#3399CC",
    "stroke-width": 1.25,
    "circle-radius": 5,
    "circle-fill-color": "rgba(255,255,255,0.4)",
    "circle-stroke-width": 1.25,
    "circle-stroke-color": "#3399CC"
  };
}
const d1 = 0.985;
function me(i, e, t) {
  const n = $m();
  return gO(
    e,
    t,
    n,
    i
  );
}
function _O(i) {
  const e = An(i), t = e[0] * 256, n = e[1], r = e[2] * 256, s = Math.round(e[3] * 255);
  return [t + n, r + s];
}
const yO = `vec4 unpackColor(vec2 packedColor) {
  return vec4(
    min(floor(packedColor[0] / 256.0) / 255.0, 1.0),
    min(mod(packedColor[0], 256.0) / 255.0, 1.0),
    min(floor(packedColor[1] / 256.0) / 255.0, 1.0),
    min(mod(packedColor[1], 256.0) / 255.0, 1.0)
  );
}`;
function r0(i) {
  return i === mt || i === bn ? 2 : i === Wi ? 4 : 1;
}
function ep(i) {
  const e = r0(i);
  return e > 1 ? (
    /** @type {'vec2'|'vec3'|'vec4'} */
    `vec${e}`
  ) : "float";
}
function Aw(i, e) {
  for (const t in e.variables) {
    const n = e.variables[t], r = zf(n.name);
    let s = ep(n.type);
    n.type === mt && (s = "vec4"), i.addUniform(r, s);
  }
  for (const t in e.properties) {
    const n = e.properties[t], r = ep(n.type), s = `a_prop_${n.name}`;
    n.type === mt ? i.addAttribute(
      s,
      r,
      `unpackColor(${s})`,
      "vec4"
    ) : i.addAttribute(s, r);
  }
  for (const t in e.functions)
    i.addVertexShaderFunction(e.functions[t]), i.addFragmentShaderFunction(e.functions[t]);
}
function Iw(i, e) {
  const t = {};
  for (const n in i.variables) {
    const r = i.variables[n], s = zf(r.name);
    t[s] = () => {
      const o = e[r.name];
      if (typeof o == "number")
        return o;
      if (typeof o == "boolean")
        return o ? 1 : 0;
      if (r.type === mt) {
        const a = [...An(o || "#eee")];
        return a[0] /= 255, a[1] /= 255, a[2] /= 255, a[3] ??= 1, a;
      }
      return typeof o == "string" ? Pa(o) : o;
    };
  }
  return t;
}
function Lw(i) {
  const e = {};
  for (const t in i.properties) {
    const n = i.properties[t], r = (s) => {
      const o = s.get(n.name);
      return n.type === mt ? _O([...An(o || "#eee")]) : typeof o == "string" ? Pa(o) : typeof o == "boolean" ? o ? 1 : 0 : o;
    };
    e[`prop_${n.name}`] = {
      size: r0(n.type),
      callback: r
    };
  }
  return e;
}
const Lo = `#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform mat4 u_projectionMatrix;
uniform mat4 u_screenToWorldMatrix;
uniform vec2 u_viewportSizePx;
uniform float u_pixelRatio;
uniform float u_globalAlpha;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
uniform float u_rotation;
uniform vec4 u_renderExtent;
uniform vec2 u_patternOrigin;
uniform float u_depth;
uniform mediump int u_hitDetection;

const float PI = 3.141592653589793238;
const float TWO_PI = 2.0 * PI;
float currentLineMetric = 0.; // an actual value will be used in the stroke shaders

${yO}
`, Fo = mO();
class Fw {
  constructor() {
    this.uniforms_ = [], this.attributes_ = [], this.hasSymbol_ = !1, this.symbolSizeExpression_ = `vec2(${Es(
      Fo["circle-radius"]
    )} + ${Es(Fo["circle-stroke-width"] * 0.5)})`, this.symbolRotationExpression_ = "0.0", this.symbolOffsetExpression_ = "vec2(0.0)", this.symbolColorExpression_ = Vu(
      /** @type {string} */
      Fo["circle-fill-color"]
    ), this.texCoordExpression_ = "vec4(0.0, 0.0, 1.0, 1.0)", this.discardExpression_ = "false", this.symbolRotateWithView_ = !1, this.hasStroke_ = !1, this.strokeWidthExpression_ = Es(Fo["stroke-width"]), this.strokeColorExpression_ = Vu(
      /** @type {string} */
      Fo["stroke-color"]
    ), this.strokeOffsetExpression_ = "0.", this.strokeCapExpression_ = Cr("round"), this.strokeJoinExpression_ = Cr("round"), this.strokeMiterLimitExpression_ = "10.", this.strokeDistanceFieldExpression_ = "-1000.", this.strokePatternLengthExpression_ = null, this.hasFill_ = !1, this.fillColorExpression_ = Vu(
      /** @type {string} */
      Fo["fill-color"]
    ), this.vertexShaderFunctions_ = [], this.fragmentShaderFunctions_ = [];
  }
  /**
   * Adds a uniform accessible in both fragment and vertex shaders.
   * The given name should include a type, such as `sampler2D u_texture`.
   * @param {string} name Uniform name, including the `u_` prefix
   * @param {'float'|'vec2'|'vec3'|'vec4'|'sampler2D'} type GLSL type
   * @return {ShaderBuilder} the builder object
   */
  addUniform(e, t) {
    return this.uniforms_.push({
      name: e,
      type: t
    }), this;
  }
  /**
   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.
   * The given name should include a type, such as `vec2 a_position`.
   * Attributes will also be made available under the same name in fragment shaders.
   * @param {string} name Attribute name, including the `a_` prefix
   * @param {'float'|'vec2'|'vec3'|'vec4'} type GLSL type
   * @param {string} [varyingExpression] Expression which will be assigned to the varying in the vertex shader, and
   * passed on to the fragment shader.
   * @param {'float'|'vec2'|'vec3'|'vec4'} [varyingType] Type of the attribute after transformation;
   * e.g. `vec4` after unpacking color components
   * @return {ShaderBuilder} the builder object
   */
  addAttribute(e, t, n, r) {
    return this.attributes_.push({
      name: e,
      type: t,
      varyingName: e.replace(/^a_/, "v_"),
      varyingType: r ?? t,
      varyingExpression: n ?? e
    }), this;
  }
  /**
   * Sets an expression to compute the size of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolSizeExpression(e) {
    return this.hasSymbol_ = !0, this.symbolSizeExpression_ = e, this;
  }
  /**
   * @return {string} The current symbol size expression
   */
  getSymbolSizeExpression() {
    return this.symbolSizeExpression_;
  }
  /**
   * Sets an expression to compute the rotation of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `float` value in radians.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolRotationExpression(e) {
    return this.symbolRotationExpression_ = e, this;
  }
  /**
   * Sets an expression to compute the offset of the symbol from the point center.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * @param {string} expression Offset expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolOffsetExpression(e) {
    return this.symbolOffsetExpression_ = e, this;
  }
  /**
   * @return {string} The current symbol offset expression
   */
  getSymbolOffsetExpression() {
    return this.symbolOffsetExpression_;
  }
  /**
   * Sets an expression to compute the color of the shape.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `vec4` value.
   * @param {string} expression Color expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolColorExpression(e) {
    return this.hasSymbol_ = !0, this.symbolColorExpression_ = e, this;
  }
  /**
   * @return {string} The current symbol color expression
   */
  getSymbolColorExpression() {
    return this.symbolColorExpression_;
  }
  /**
   * Sets an expression to compute the texture coordinates of the vertices.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec4` value.
   * @param {string} expression Texture coordinate expression
   * @return {ShaderBuilder} the builder object
   */
  setTextureCoordinateExpression(e) {
    return this.texCoordExpression_ = e, this;
  }
  /**
   * Sets an expression to determine whether a fragment (pixel) should be discarded,
   * i.e. not drawn at all.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `bool` value (it will be
   * used in an `if` statement)
   * @param {string} expression Fragment discard expression
   * @return {ShaderBuilder} the builder object
   */
  setFragmentDiscardExpression(e) {
    return this.discardExpression_ = e, this;
  }
  /**
   * @return {string} The current fragment discard expression
   */
  getFragmentDiscardExpression() {
    return this.discardExpression_;
  }
  /**
   * Sets whether the symbols should rotate with the view or stay aligned with the map.
   * Note: will only be used for point geometry shaders.
   * @param {boolean} rotateWithView Rotate with view
   * @return {ShaderBuilder} the builder object
   */
  setSymbolRotateWithView(e) {
    return this.symbolRotateWithView_ = e, this;
  }
  /**
   * @param {string} expression Stroke width expression, returning value in pixels
   * @return {ShaderBuilder} the builder object
   */
  setStrokeWidthExpression(e) {
    return this.hasStroke_ = !0, this.strokeWidthExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke color expression, evaluate to `vec4`: can rely on currentLengthPx and currentRadiusPx
   * @return {ShaderBuilder} the builder object
   */
  setStrokeColorExpression(e) {
    return this.hasStroke_ = !0, this.strokeColorExpression_ = e, this;
  }
  /**
   * @return {string} The current stroke color expression
   */
  getStrokeColorExpression() {
    return this.strokeColorExpression_;
  }
  /**
   * @param {string} expression Stroke color expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeOffsetExpression(e) {
    return this.strokeOffsetExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke line cap expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeCapExpression(e) {
    return this.strokeCapExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke line join expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeJoinExpression(e) {
    return this.strokeJoinExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke miter limit expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeMiterLimitExpression(e) {
    return this.strokeMiterLimitExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke distance field expression, evaluate to `float`
   * This can override the default distance field; can rely on currentLengthPx and currentRadiusPx
   * @return {ShaderBuilder} the builder object
   */
  setStrokeDistanceFieldExpression(e) {
    return this.strokeDistanceFieldExpression_ = e, this;
  }
  /**
   * Defining a pattern length for a stroke lets us avoid having visual artifacts when
   * a linestring is very long and thus has very high "distance" attributes on its vertices.
   * If we apply a pattern or dash array to a stroke we know for certain that the full distance value
   * is not necessary and can be trimmed down using `mod(currentDistance, patternLength)`.
   * @param {string} expression Stroke expression that evaluates to a`float; value is expected to be
   * in pixels.
   * @return {ShaderBuilder} the builder object
   */
  setStrokePatternLengthExpression(e) {
    return this.strokePatternLengthExpression_ = e, this;
  }
  /**
   * @return {string} The current stroke pattern length expression.
   */
  getStrokePatternLengthExpression() {
    return this.strokePatternLengthExpression_;
  }
  /**
   * @param {string} expression Fill color expression, evaluate to `vec4`
   * @return {ShaderBuilder} the builder object
   */
  setFillColorExpression(e) {
    return this.hasFill_ = !0, this.fillColorExpression_ = e, this;
  }
  /**
   * @return {string} The current fill color expression
   */
  getFillColorExpression() {
    return this.fillColorExpression_;
  }
  addVertexShaderFunction(e) {
    return this.vertexShaderFunctions_.includes(e) ? this : (this.vertexShaderFunctions_.push(e), this);
  }
  addFragmentShaderFunction(e) {
    return this.fragmentShaderFunctions_.includes(e) ? this : (this.fragmentShaderFunctions_.push(e), this);
  }
  /**
   * Generates a symbol vertex shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getSymbolVertexShader() {
    return this.hasSymbol_ ? `${Lo}
${this.uniforms_.map((e) => `uniform ${e.type} ${e.name};`).join(`
`)}
attribute vec2 a_position;
attribute vec2 a_localPosition;
attribute vec2 a_hitColor;

varying vec2 v_texCoord;
varying vec2 v_quadCoord;
varying vec4 v_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;

${this.attributes_.map(
      (e) => `attribute ${e.type} ${e.name};
varying ${e.varyingType} ${e.varyingName};`
    ).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 pxToScreen(vec2 coordPx) {
  vec2 scaled = coordPx / u_viewportSizePx / 0.5;
  return scaled;
}

vec2 screenToPx(vec2 coordScreen) {
  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;
}

void main(void) {
  v_quadSizePx = ${this.symbolSizeExpression_};
  vec2 halfSizePx = v_quadSizePx * 0.5;
  vec2 centerOffsetPx = ${this.symbolOffsetExpression_};
  vec2 offsetPx = centerOffsetPx + a_localPosition * halfSizePx * vec2(1., -1.);
  float angle = ${this.symbolRotationExpression_}${this.symbolRotateWithView_ ? " + u_rotation" : ""};
  float c = cos(-angle);
  float s = sin(-angle);
  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);
  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);
  gl_Position = center + vec4(pxToScreen(offsetPx), u_depth, 0.);
  vec4 texCoord = ${this.texCoordExpression_};
  float u = mix(texCoord.s, texCoord.p, a_localPosition.x * 0.5 + 0.5);
  float v = mix(texCoord.t, texCoord.q, a_localPosition.y * 0.5 + 0.5);
  v_texCoord = vec2(u, v);
  v_hitColor = unpackColor(a_hitColor);
  v_angle = angle;
  c = cos(-v_angle);
  s = sin(-v_angle);
  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y);
  v_centerPx = screenToPx(center.xy) + centerOffsetPx;
${this.attributes_.map(
      (e) => `  ${e.varyingName} = ${e.varyingExpression};`
    ).join(`
`)}
}` : null;
  }
  /**
   * Generates a symbol fragment shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getSymbolFragmentShader() {
    return this.hasSymbol_ ? `${Lo}
${this.uniforms_.map((e) => `uniform ${e.type} ${e.name};`).join(`
`)}
varying vec2 v_texCoord;
varying vec4 v_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.attributes_.map(
      (e) => `varying ${e.varyingType} ${e.varyingName};`
    ).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

void main(void) {
${this.attributes_.map(
      (e) => `  ${e.varyingType} ${e.name} = ${e.varyingName}; // assign to original attribute name`
    ).join(`
`)}
  if (${this.discardExpression_}) { discard; }
  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center
  float c = cos(v_angle);
  float s = sin(v_angle);
  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);
  gl_FragColor = ${this.symbolColorExpression_};
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.05) { discard; };
    gl_FragColor = v_hitColor;
  }
}` : null;
  }
  /**
   * Generates a stroke vertex shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getStrokeVertexShader() {
    return this.hasStroke_ ? `${Lo}
${this.uniforms_.map((e) => `uniform ${e.type} ${e.name};`).join(`
`)}
attribute vec2 a_segmentStart;
attribute vec2 a_segmentEnd;
attribute vec2 a_localPosition;
attribute float a_measureStart;
attribute float a_measureEnd;
attribute float a_angleTangentSum;
attribute float a_distanceLow;
attribute float a_distanceHigh;
attribute vec2 a_joinAngles;
attribute vec2 a_hitColor;

varying vec2 v_segmentStartPx;
varying vec2 v_segmentEndPx;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_hitColor;
varying float v_distancePx;
varying float v_measureStart;
varying float v_measureEnd;

${this.attributes_.map(
      (e) => `attribute ${e.type} ${e.name};
varying ${e.varyingType} ${e.varyingName};`
    ).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

vec4 pxToScreen(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return vec4(screenPos, u_depth, 1.0);
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

vec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {
  float halfAngle = joinAngle / 2.0;
  float c = cos(halfAngle);
  float s = sin(halfAngle);
  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);
  float length = 1.0 / s;
  return angleBisectorNormal * length;
}

vec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {
  // if on a cap or the join angle is too high, offset the line along the segment normal
  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {
    return point - normal * offsetPx;
  }
  // offset is applied along the inverted normal (positive offset goes "right" relative to line direction)
  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;
}

void main(void) {
  v_angleStart = a_joinAngles.x;
  v_angleEnd = a_joinAngles.y;
  float startEndRatio = a_localPosition.x * 0.5 + 0.5;
  currentLineMetric = mix(a_measureStart, a_measureEnd, startEndRatio);
  // we're reading the fractional part while keeping the sign (so -4.12 gives -0.12, 3.45 gives 0.45)

  float lineWidth = ${this.strokeWidthExpression_};
  float lineOffsetPx = ${this.strokeOffsetExpression_};

  // compute segment start/end in px with offset
  vec2 segmentStartPx = worldToPx(a_segmentStart);
  vec2 segmentEndPx = worldToPx(a_segmentEnd);
  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);
  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);
  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),
  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);

  // compute current vertex position
  float normalDir = -1. * a_localPosition.y;
  float tangentDir = -1. * a_localPosition.x;
  float angle = mix(v_angleStart, v_angleEnd, startEndRatio);
  vec2 joinDirection;
  vec2 positionPx = mix(segmentStartPx, segmentEndPx, startEndRatio);
  // if angle is too high, do not make a proper join
  if (cos(angle) > ${d1} || isCap(angle)) {
    joinDirection = normalPx * normalDir - tangentPx * tangentDir;
  } else {
    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);
  }
  positionPx = positionPx + joinDirection * (lineWidth * 0.5 + 1.); // adding 1 pixel for antialiasing
  gl_Position = pxToScreen(positionPx);

  v_segmentStartPx = segmentStartPx;
  v_segmentEndPx = segmentEndPx;
  v_width = lineWidth;
  v_hitColor = unpackColor(a_hitColor);

  v_distancePx = a_distanceLow / u_resolution - (lineOffsetPx * a_angleTangentSum);
  float distanceHighPx = a_distanceHigh / u_resolution;
  ${this.strokePatternLengthExpression_ !== null ? `v_distancePx = mod(v_distancePx, ${this.strokePatternLengthExpression_});
  distanceHighPx = mod(distanceHighPx, ${this.strokePatternLengthExpression_});
  ` : ""}v_distancePx += distanceHighPx;

  v_measureStart = a_measureStart;
  v_measureEnd = a_measureEnd;
${this.attributes_.map(
      (e) => `  ${e.varyingName} = ${e.varyingExpression};`
    ).join(`
`)}
}` : null;
  }
  /**
   * Generates a stroke fragment shader from the builder parameters
   *
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getStrokeFragmentShader() {
    return this.hasStroke_ ? `${Lo}
${this.uniforms_.map((e) => `uniform ${e.type} ${e.name};`).join(`
`)}
varying vec2 v_segmentStartPx;
varying vec2 v_segmentEndPx;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_hitColor;
varying float v_distancePx;
varying float v_measureStart;
varying float v_measureEnd;
${this.attributes_.map(
      (e) => `varying ${e.varyingType} ${e.varyingName};`
    ).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

float segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  vec2 tangent = normalize(end - start);
  vec2 normal = vec2(-tangent.y, tangent.x);
  vec2 startToPoint = point - start;
  return abs(dot(startToPoint, normal)) - width * 0.5;
}

float buttCapDistanceField(vec2 point, vec2 start, vec2 end) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  return dot(startToPoint, -tangent);
}

float squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return buttCapDistanceField(point, start, end) - width * 0.5;
}

float roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment
  return length(point - start) - width * 0.5 - onSegment;
}

float roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return roundCapDistanceField(point, start, end, width);
}

float bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  float c = cos(joinAngle * 0.5);
  float s = sin(joinAngle * 0.5);
  float direction = -sign(sin(joinAngle));
  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);
  float radius = width * 0.5 * s;
  return dot(startToPoint, bisector * direction) - radius;
}

float miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  if (cos(joinAngle) > ${d1}) { // avoid risking a division by zero
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  float miterLength = 1. / sin(joinAngle * 0.5);
  float miterLimit = ${this.strokeMiterLimitExpression_};
  if (miterLength > miterLimit) {
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  return -1000.;
}

float capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {
   if (capType == ${Cr("butt")}) {
    return buttCapDistanceField(point, start, end);
  } else if (capType == ${Cr("square")}) {
    return squareCapDistanceField(point, start, end, width);
  }
  return roundCapDistanceField(point, start, end, width);
}

float joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {
  if (joinType == ${Cr("bevel")}) {
    return bevelJoinField(point, start, end, width, joinAngle);
  } else if (joinType == ${Cr("miter")}) {
    return miterJoinDistanceField(point, start, end, width, joinAngle);
  }
  return roundJoinDistanceField(point, start, end, width);
}

float computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {
  if (isCap(joinAngle)) {
    return capDistanceField(point, start, end, width, capType);
  }
  return joinDistanceField(point, start, end, width, joinAngle, joinType);
}

float distanceFromSegment(vec2 point, vec2 start, vec2 end) {
  vec2 tangent = end - start;
  vec2 startToPoint = point - start;
  // inspire by capsule fn in https://iquilezles.org/articles/distfunctions/
  float h = clamp(dot(startToPoint, tangent) / dot(tangent, tangent), 0.0, 1.0);
  return length(startToPoint - tangent * h);
}

void main(void) {
${this.attributes_.map(
      (e) => `  ${e.varyingType} ${e.name} = ${e.varyingName}; // assign to original attribute name`
    ).join(`
`)}

  vec2 currentPointPx = gl_FragCoord.xy / u_pixelRatio;
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(currentPointPx);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif

  float segmentLengthPx = length(v_segmentEndPx - v_segmentStartPx);
  segmentLengthPx = max(segmentLengthPx, 1.17549429e-38); // avoid divide by zero
  vec2 segmentTangent = (v_segmentEndPx - v_segmentStartPx) / segmentLengthPx;
  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);
  vec2 startToPointPx = currentPointPx - v_segmentStartPx;
  float lengthToPointPx = max(0., min(dot(segmentTangent, startToPointPx), segmentLengthPx));
  float currentLengthPx = lengthToPointPx + v_distancePx;
  float currentRadiusPx = distanceFromSegment(currentPointPx, v_segmentStartPx, v_segmentEndPx);
  float currentRadiusRatio = dot(segmentNormal, startToPointPx) * 2. / v_width;
  currentLineMetric = mix(v_measureStart, v_measureEnd, lengthToPointPx / segmentLengthPx);

  if (${this.discardExpression_}) { discard; }

  float capType = ${this.strokeCapExpression_};
  float joinType = ${this.strokeJoinExpression_};
  float segmentStartDistance = computeSegmentPointDistance(currentPointPx, v_segmentStartPx, v_segmentEndPx, v_width, v_angleStart, capType, joinType);
  float segmentEndDistance = computeSegmentPointDistance(currentPointPx, v_segmentEndPx, v_segmentStartPx, v_width, v_angleEnd, capType, joinType);
  float distanceField = max(
    segmentDistanceField(currentPointPx, v_segmentStartPx, v_segmentEndPx, v_width),
    max(segmentStartDistance, segmentEndDistance)
  );
  distanceField = max(distanceField, ${this.strokeDistanceFieldExpression_});

  vec4 color = ${this.strokeColorExpression_};
  color.a *= smoothstep(0.5, -0.5, distanceField);
  gl_FragColor = color;
  gl_FragColor.a *= u_globalAlpha;
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_hitColor;
  }
}` : null;
  }
  /**
   * Generates a fill vertex shader from the builder parameters
   *
   * @return {string|null} The full shader as a string; null if no color specified
   */
  getFillVertexShader() {
    return this.hasFill_ ? `${Lo}
${this.uniforms_.map((e) => `uniform ${e.type} ${e.name};`).join(`
`)}
attribute vec2 a_position;
attribute vec2 a_hitColor;

varying vec4 v_hitColor;

${this.attributes_.map(
      (e) => `attribute ${e.type} ${e.name};
varying ${e.varyingType} ${e.varyingName};`
    ).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
void main(void) {
  gl_Position = u_projectionMatrix * vec4(a_position, u_depth, 1.0);
  v_hitColor = unpackColor(a_hitColor);
${this.attributes_.map(
      (e) => `  ${e.varyingName} = ${e.varyingExpression};`
    ).join(`
`)}
}` : null;
  }
  /**
   * Generates a fill fragment shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no color specified
   */
  getFillFragmentShader() {
    return this.hasFill_ ? `${Lo}
${this.uniforms_.map((e) => `uniform ${e.type} ${e.name};`).join(`
`)}
varying vec4 v_hitColor;
${this.attributes_.map(
      (e) => `varying ${e.varyingType} ${e.varyingName};`
    ).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}
vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

void main(void) {
${this.attributes_.map(
      (e) => `  ${e.varyingType} ${e.name} = ${e.varyingName}; // assign to original attribute name`
    ).join(`
`)}
  vec2 pxPos = gl_FragCoord.xy / u_pixelRatio;
  vec2 pxOrigin = worldToPx(u_patternOrigin);
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(pxPos);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif
  if (${this.discardExpression_}) { discard; }
  gl_FragColor = ${this.fillColorExpression_};
  gl_FragColor.a *= u_globalAlpha;
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_hitColor;
  }
}` : null;
  }
}
class Lc {
  constructor() {
    this.globalCounter_ = 0, this.refToFeature_ = /* @__PURE__ */ new Map(), this.uidToRef_ = /* @__PURE__ */ new Map(), this.freeGlobalRef_ = [], this.polygonBatch = {
      entries: {},
      geometriesCount: 0,
      verticesCount: 0,
      ringsCount: 0
    }, this.pointBatch = {
      entries: {},
      geometriesCount: 0
    }, this.lineStringBatch = {
      entries: {},
      geometriesCount: 0,
      verticesCount: 0
    };
  }
  /**
   * @param {Array<Feature|RenderFeature>} features Array of features to add to the batch
   * @param {import("../../proj.js").TransformFunction} [projectionTransform] Projection transform.
   */
  addFeatures(e, t) {
    for (let n = 0; n < e.length; n++)
      this.addFeature(e[n], t);
  }
  /**
   * @param {Feature|RenderFeature} feature Feature to add to the batch
   * @param {import("../../proj.js").TransformFunction} [projectionTransform] Projection transform.
   */
  addFeature(e, t) {
    let n = e.getGeometry();
    n && (t && (n = n.clone(), n.applyTransform(t)), this.addGeometry_(n, e));
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   * @return {GeometryBatchItem|void} the cleared entry
   * @private
   */
  clearFeatureEntryInPointBatch_(e) {
    const t = ie(e), n = this.pointBatch.entries[t];
    if (n)
      return this.pointBatch.geometriesCount -= n.flatCoordss.length, delete this.pointBatch.entries[t], n;
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   * @return {GeometryBatchItem|void} the cleared entry
   * @private
   */
  clearFeatureEntryInLineStringBatch_(e) {
    const t = ie(e), n = this.lineStringBatch.entries[t];
    if (n)
      return this.lineStringBatch.verticesCount -= n.verticesCount, this.lineStringBatch.geometriesCount -= n.flatCoordss.length, delete this.lineStringBatch.entries[t], n;
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   * @return {GeometryBatchItem|void} the cleared entry
   * @private
   */
  clearFeatureEntryInPolygonBatch_(e) {
    const t = ie(e), n = this.polygonBatch.entries[t];
    if (n)
      return this.polygonBatch.verticesCount -= n.verticesCount, this.polygonBatch.ringsCount -= n.ringsCount, this.polygonBatch.geometriesCount -= n.flatCoordss.length, delete this.polygonBatch.entries[t], n;
  }
  /**
   * @param {import("../../geom.js").Geometry|RenderFeature} geometry Geometry
   * @param {Feature|RenderFeature} feature Feature
   * @private
   */
  addGeometry_(e, t) {
    const n = e.getType();
    switch (n) {
      case "GeometryCollection": {
        const r = (
          /** @type {import("../../geom.js").GeometryCollection} */
          e.getGeometriesArray()
        );
        for (const s of r)
          this.addGeometry_(s, t);
        break;
      }
      case "MultiPolygon": {
        const r = (
          /** @type {import("../../geom.js").MultiPolygon} */
          e
        );
        this.addCoordinates_(
          n,
          r.getFlatCoordinates(),
          r.getEndss(),
          t,
          ie(t),
          r.getStride()
        );
        break;
      }
      case "MultiLineString": {
        const r = (
          /** @type {import("../../geom.js").MultiLineString|RenderFeature} */
          e
        );
        this.addCoordinates_(
          n,
          r.getFlatCoordinates(),
          r.getEnds(),
          t,
          ie(t),
          r.getStride()
        );
        break;
      }
      case "MultiPoint": {
        const r = (
          /** @type {import("../../geom.js").MultiPoint|RenderFeature} */
          e
        );
        this.addCoordinates_(
          n,
          r.getFlatCoordinates(),
          null,
          t,
          ie(t),
          r.getStride()
        );
        break;
      }
      case "Polygon": {
        const r = (
          /** @type {import("../../geom.js").Polygon|RenderFeature} */
          e
        );
        this.addCoordinates_(
          n,
          r.getFlatCoordinates(),
          r.getEnds(),
          t,
          ie(t),
          r.getStride()
        );
        break;
      }
      case "Point": {
        const r = (
          /** @type {import("../../geom.js").Point} */
          e
        );
        this.addCoordinates_(
          n,
          r.getFlatCoordinates(),
          null,
          t,
          ie(t),
          r.getStride()
        );
        break;
      }
      case "LineString":
      case "LinearRing": {
        const r = (
          /** @type {import("../../geom.js").LineString} */
          e
        ), s = r.getStride();
        this.addCoordinates_(
          n,
          r.getFlatCoordinates(),
          null,
          t,
          ie(t),
          s,
          r.getLayout?.()
        );
        break;
      }
    }
  }
  /**
   * @param {GeometryType} type Geometry type
   * @param {Array<number>} flatCoords Flat coordinates
   * @param {Array<number> | Array<Array<number>> | null} ends Coordinate ends
   * @param {Feature|RenderFeature} feature Feature
   * @param {string} featureUid Feature uid
   * @param {number} stride Stride
   * @param {import('../../geom/Geometry.js').GeometryLayout} [layout] Layout
   * @private
   */
  addCoordinates_(e, t, n, r, s, o, a) {
    let l;
    switch (e) {
      case "MultiPolygon": {
        const h = (
          /** @type {Array<Array<number>>} */
          n
        );
        for (let u = 0, c = h.length; u < c; u++) {
          let f = h[u];
          const g = u > 0 ? h[u - 1] : null, d = g ? g[g.length - 1] : 0, m = f[f.length - 1];
          f = d > 0 ? f.map((x) => x - d) : f, this.addCoordinates_(
            "Polygon",
            t.slice(d, m),
            f,
            r,
            s,
            o,
            a
          );
        }
        break;
      }
      case "MultiLineString": {
        const h = (
          /** @type {Array<number>} */
          n
        );
        for (let u = 0, c = h.length; u < c; u++) {
          const f = u > 0 ? h[u - 1] : 0;
          this.addCoordinates_(
            "LineString",
            t.slice(f, h[u]),
            null,
            r,
            s,
            o,
            a
          );
        }
        break;
      }
      case "MultiPoint":
        for (let h = 0, u = t.length; h < u; h += o)
          this.addCoordinates_(
            "Point",
            t.slice(h, h + 2),
            null,
            r,
            s,
            null,
            null
          );
        break;
      case "Polygon": {
        const h = (
          /** @type {Array<number>} */
          n
        );
        if (r instanceof fi) {
          const f = cm(t, h);
          if (f.length > 1) {
            this.addCoordinates_(
              "MultiPolygon",
              t,
              f,
              r,
              s,
              o,
              a
            );
            return;
          }
        }
        this.polygonBatch.entries[s] || (this.polygonBatch.entries[s] = this.addRefToEntry_(
          s,
          {
            feature: r,
            flatCoordss: [],
            verticesCount: 0,
            ringsCount: 0,
            ringsVerticesCounts: []
          }
        )), l = t.length / o;
        const u = n.length, c = n.map(
          (f, g, d) => g > 0 ? (f - d[g - 1]) / o : f / o
        );
        this.polygonBatch.verticesCount += l, this.polygonBatch.ringsCount += u, this.polygonBatch.geometriesCount++, this.polygonBatch.entries[s].flatCoordss.push(
          xO(t, o)
        ), this.polygonBatch.entries[s].ringsVerticesCounts.push(
          c
        ), this.polygonBatch.entries[s].verticesCount += l, this.polygonBatch.entries[s].ringsCount += u;
        for (let f = 0, g = h.length; f < g; f++) {
          const d = f > 0 ? h[f - 1] : 0;
          this.addCoordinates_(
            "LinearRing",
            t.slice(d, h[f]),
            null,
            r,
            s,
            o,
            a
          );
        }
        break;
      }
      case "Point":
        this.pointBatch.entries[s] || (this.pointBatch.entries[s] = this.addRefToEntry_(
          s,
          {
            feature: r,
            flatCoordss: []
          }
        )), this.pointBatch.geometriesCount++, this.pointBatch.entries[s].flatCoordss.push(t);
        break;
      case "LineString":
      case "LinearRing":
        this.lineStringBatch.entries[s] || (this.lineStringBatch.entries[s] = this.addRefToEntry_(
          s,
          {
            feature: r,
            flatCoordss: [],
            verticesCount: 0
          }
        )), l = t.length / o, this.lineStringBatch.verticesCount += l, this.lineStringBatch.geometriesCount++, this.lineStringBatch.entries[s].flatCoordss.push(
          EO(t, o, a)
        ), this.lineStringBatch.entries[s].verticesCount += l;
        break;
    }
  }
  /**
   * @param {string} featureUid Feature uid
   * @param {GeometryBatchItem} entry The entry to add
   * @return {GeometryBatchItem} the added entry
   * @private
   */
  addRefToEntry_(e, t) {
    const n = this.uidToRef_.get(e), r = n || this.freeGlobalRef_.pop() || ++this.globalCounter_;
    return t.ref = r, n || (this.refToFeature_.set(r, t.feature), this.uidToRef_.set(e, r)), t;
  }
  /**
   * Return a ref to the pool of available refs.
   * @param {number} ref the ref to return
   * @param {string} featureUid the feature uid
   * @private
   */
  removeRef_(e, t) {
    if (!e)
      throw new Error("This feature has no ref: " + t);
    this.refToFeature_.delete(e), this.uidToRef_.delete(t), this.freeGlobalRef_.push(e);
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   * @param {import("../../proj.js").TransformFunction} [projectionTransform] Projection transform.
   */
  changeFeature(e, t) {
    if (!this.uidToRef_.get(ie(e)))
      return;
    this.removeFeature(e);
    let n = e.getGeometry();
    n && (t && (n = n.clone(), n.applyTransform(t)), this.addGeometry_(n, e));
  }
  /**
   * @param {Feature|RenderFeature} feature Feature
   */
  removeFeature(e) {
    let t = this.clearFeatureEntryInPointBatch_(e);
    t = this.clearFeatureEntryInPolygonBatch_(e) || t, t = this.clearFeatureEntryInLineStringBatch_(e) || t, t && this.removeRef_(t.ref, ie(t.feature));
  }
  clear() {
    this.polygonBatch.entries = {}, this.polygonBatch.geometriesCount = 0, this.polygonBatch.verticesCount = 0, this.polygonBatch.ringsCount = 0, this.lineStringBatch.entries = {}, this.lineStringBatch.geometriesCount = 0, this.lineStringBatch.verticesCount = 0, this.pointBatch.entries = {}, this.pointBatch.geometriesCount = 0, this.globalCounter_ = 0, this.freeGlobalRef_ = [], this.refToFeature_.clear(), this.uidToRef_.clear();
  }
  /**
   * Resolve the feature associated to a ref.
   * @param {number} ref Hit detected ref
   * @return {Feature|RenderFeature} feature
   */
  getFeatureFromRef(e) {
    return this.refToFeature_.get(e);
  }
  isEmpty() {
    return this.globalCounter_ === 0;
  }
  /**
   * Will return a new instance of this class that only contains the features
   * for which the provided callback returned true
   * @param {function((Feature|RenderFeature)): boolean} featureFilter Feature filter callback
   * @return {MixedGeometryBatch} Filtered geometry batch
   */
  filter(e) {
    const t = new Lc();
    t.globalCounter_ = this.globalCounter_, t.uidToRef_ = this.uidToRef_, t.refToFeature_ = this.refToFeature_;
    let n = !0;
    for (const r of this.refToFeature_.values())
      e(r) && (t.addFeature(r), n = !1);
    return n ? new Lc() : t;
  }
}
function xO(i, e) {
  return e === 2 ? i : i.filter((t, n) => n % e < 2);
}
function EO(i, e, t) {
  return e === 3 && t === "XYM" ? i : e === 4 ? i.filter((n, r) => r % e !== 2) : e === 3 ? i.map((n, r) => r % e !== 2 ? n : 0) : new Array(i.length * 1.5).fill(0).map((n, r) => r % 3 === 2 ? 0 : i[Math.round(r / 1.5)]);
}
function Ow() {
  const i = 'function t(t,n,x=2){const o=n&&n.length,i=o?n[0]*x:t.length;let f=e(t,0,i,x,!0);const l=[];if(!f||f.next===f.prev)return l;let c,y,h;if(o&&(f=function(t,n,r,x){const o=[];for(let r=0,i=n.length;r<i;r++){const f=e(t,n[r]*x,r<i-1?n[r+1]*x:t.length,x,!1);f===f.next&&(f.steiner=!0),o.push(a(f))}o.sort(u);for(let t=0;t<o.length;t++)r=s(o[t],r);return r}(t,n,f,x)),t.length>80*x){c=t[0],y=t[1];let e=c,n=y;for(let r=x;r<i;r+=x){const x=t[r],o=t[r+1];x<c&&(c=x),o<y&&(y=o),x>e&&(e=x),o>n&&(n=o)}h=Math.max(e-c,n-y),h=0!==h?32767/h:0}return r(f,l,x,c,y,h,0),l}function e(t,e,n,r,x){let o;if(x===function(t,e,n,r){let x=0;for(let o=e,i=n-r;o<n;o+=r)x+=(t[i]-t[o])*(t[o+1]+t[i+1]),i=o;return x}(t,e,n,r)>0)for(let x=e;x<n;x+=r)o=d(x/r|0,t[x],t[x+1],o);else for(let x=n-r;x>=e;x-=r)o=d(x/r|0,t[x],t[x+1],o);return o&&b(o,o.next)&&(w(o),o=o.next),o}function n(t,e){if(!t)return t;e||(e=t);let n,r=t;do{if(n=!1,r.steiner||!b(r,r.next)&&0!==v(r.prev,r,r.next))r=r.next;else{if(w(r),r=e=r.prev,r===r.next)break;n=!0}}while(n||r!==e);return e}function r(t,e,u,s,l,a,y){if(!t)return;!y&&a&&function(t,e,n,r){let x=t;do{0===x.z&&(x.z=c(x.x,x.y,e,n,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next}while(x!==t);x.prevZ.nextZ=null,x.prevZ=null,function(t){let e,n=1;do{let r,x=t;t=null;let o=null;for(e=0;x;){e++;let i=x,f=0;for(let t=0;t<n&&(f++,i=i.nextZ,i);t++);let u=n;for(;f>0||u>0&&i;)0!==f&&(0===u||!i||x.z<=i.z)?(r=x,x=x.nextZ,f--):(r=i,i=i.nextZ,u--),o?o.nextZ=r:t=r,r.prevZ=o,o=r;x=i}o.nextZ=null,n*=2}while(e>1)}(x)}(t,s,l,a);let h=t;for(;t.prev!==t.next;){const c=t.prev,p=t.next;if(a?o(t,s,l,a):x(t))e.push(c.i,t.i,p.i),w(t),t=p.next,h=p.next;else if((t=p)===h){y?1===y?r(t=i(n(t),e),e,u,s,l,a,2):2===y&&f(t,e,u,s,l,a):r(n(t),e,u,s,l,a,1);break}}}function x(t){const e=t.prev,n=t,r=t.next;if(v(e,n,r)>=0)return!1;const x=e.x,o=n.x,i=r.x,f=e.y,u=n.y,s=r.y,l=Math.min(x,o,i),c=Math.min(f,u,s),a=Math.max(x,o,i),y=Math.max(f,u,s);let p=r.next;for(;p!==e;){if(p.x>=l&&p.x<=a&&p.y>=c&&p.y<=y&&h(x,f,o,u,i,s,p.x,p.y)&&v(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function o(t,e,n,r){const x=t.prev,o=t,i=t.next;if(v(x,o,i)>=0)return!1;const f=x.x,u=o.x,s=i.x,l=x.y,a=o.y,y=i.y,p=Math.min(f,u,s),b=Math.min(l,a,y),M=Math.max(f,u,s),m=Math.max(l,a,y),A=c(p,b,e,n,r),g=c(M,m,e,n,r);let Z=t.prevZ,d=t.nextZ;for(;Z&&Z.z>=A&&d&&d.z<=g;){if(Z.x>=p&&Z.x<=M&&Z.y>=b&&Z.y<=m&&Z!==x&&Z!==i&&h(f,l,u,a,s,y,Z.x,Z.y)&&v(Z.prev,Z,Z.next)>=0)return!1;if(Z=Z.prevZ,d.x>=p&&d.x<=M&&d.y>=b&&d.y<=m&&d!==x&&d!==i&&h(f,l,u,a,s,y,d.x,d.y)&&v(d.prev,d,d.next)>=0)return!1;d=d.nextZ}for(;Z&&Z.z>=A;){if(Z.x>=p&&Z.x<=M&&Z.y>=b&&Z.y<=m&&Z!==x&&Z!==i&&h(f,l,u,a,s,y,Z.x,Z.y)&&v(Z.prev,Z,Z.next)>=0)return!1;Z=Z.prevZ}for(;d&&d.z<=g;){if(d.x>=p&&d.x<=M&&d.y>=b&&d.y<=m&&d!==x&&d!==i&&h(f,l,u,a,s,y,d.x,d.y)&&v(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function i(t,e){let r=t;do{const n=r.prev,x=r.next.next;!b(n,x)&&M(n,r,r.next,x)&&g(n,x)&&g(x,n)&&(e.push(n.i,r.i,x.i),w(r),w(r.next),r=t=x),r=r.next}while(r!==t);return n(r)}function f(t,e,x,o,i,f){let u=t;do{let t=u.next.next;for(;t!==u.prev;){if(u.i!==t.i&&p(u,t)){let s=Z(u,t);return u=n(u,u.next),s=n(s,s.next),r(u,e,x,o,i,f,0),void r(s,e,x,o,i,f,0)}t=t.next}u=u.next}while(u!==t)}function u(t,e){let n=t.x-e.x;if(0===n&&(n=t.y-e.y,0===n)){n=(t.next.y-t.y)/(t.next.x-t.x)-(e.next.y-e.y)/(e.next.x-e.x)}return n}function s(t,e){const r=function(t,e){let n=e;const r=t.x,x=t.y;let o,i=-1/0;if(b(t,n))return n;do{if(b(t,n.next))return n.next;if(x<=n.y&&x>=n.next.y&&n.next.y!==n.y){const t=n.x+(x-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=r&&t>i&&(i=t,o=n.x<n.next.x?n:n.next,t===r))return o}n=n.next}while(n!==e);if(!o)return null;const f=o,u=o.x,s=o.y;let c=1/0;n=o;do{if(r>=n.x&&n.x>=u&&r!==n.x&&y(x<s?r:i,x,u,s,x<s?i:r,x,n.x,n.y)){const e=Math.abs(x-n.y)/(r-n.x);g(n,t)&&(e<c||e===c&&(n.x>o.x||n.x===o.x&&l(o,n)))&&(o=n,c=e)}n=n.next}while(n!==f);return o}(t,e);if(!r)return e;const x=Z(r,t);return n(x,x.next),n(r,r.next)}function l(t,e){return v(t.prev,t,e.prev)<0&&v(e.next,t,t.next)<0}function c(t,e,n,r,x){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*x|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-r)*x|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function a(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function y(t,e,n,r,x,o,i,f){return(x-i)*(e-f)>=(t-i)*(o-f)&&(t-i)*(r-f)>=(n-i)*(e-f)&&(n-i)*(o-f)>=(x-i)*(r-f)}function h(t,e,n,r,x,o,i,f){return!(t===i&&e===f)&&y(t,e,n,r,x,o,i,f)}function p(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&M(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(g(t,e)&&g(e,t)&&function(t,e){let n=t,r=!1;const x=(t.x+e.x)/2,o=(t.y+e.y)/2;do{n.y>o!=n.next.y>o&&n.next.y!==n.y&&x<(n.next.x-n.x)*(o-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==t);return r}(t,e)&&(v(t.prev,t,e.prev)||v(t,e.prev,e))||b(t,e)&&v(t.prev,t,t.next)>0&&v(e.prev,e,e.next)>0)}function v(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function b(t,e){return t.x===e.x&&t.y===e.y}function M(t,e,n,r){const x=A(v(t,e,n)),o=A(v(t,e,r)),i=A(v(n,r,t)),f=A(v(n,r,e));return x!==o&&i!==f||(!(0!==x||!m(t,n,e))||(!(0!==o||!m(t,r,e))||(!(0!==i||!m(n,t,r))||!(0!==f||!m(n,e,r)))))}function m(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function A(t){return t>0?1:t<0?-1:0}function g(t,e){return v(t.prev,t,t.next)<0?v(t,e,t.next)>=0&&v(t,t.prev,e)>=0:v(t,e,t.prev)<0||v(t,t.next,e)<0}function Z(t,e){const n=F(t.i,t.x,t.y),r=F(e.i,e.x,e.y),x=t.next,o=e.prev;return t.next=e,e.prev=t,n.next=x,x.prev=n,r.next=n,n.prev=r,o.next=r,r.prev=o,r}function d(t,e,n,r){const x=F(t,e,n);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function w(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function F(t,e,n){return{i:t,x:e,y:n,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function E(t,e){const n=e[0],r=e[1];return e[0]=t[0]*n+t[2]*r+t[4],e[1]=t[1]*n+t[3]*r+t[5],e}function I(t,e){const n=(r=e)[0]*r[3]-r[1]*r[2];var r;!function(t,e){if(!t)throw new Error(e)}(0!==n,"Transformation matrix cannot be inverted");const x=e[0],o=e[1],i=e[2],f=e[3],u=e[4],s=e[5];return t[0]=f/n,t[1]=-o/n,t[2]=-i/n,t[3]=x/n,t[4]=(i*s-f*u)/n,t[5]=-(x*s-o*u)/n,t}new Array(6);const z=[],B={vertexAttributesPosition:0,instanceAttributesPosition:0,indicesPosition:0};function P(t,e,n,r,x){const o=t[e++],i=t[e++],f=z;f.length=r;for(let n=0;n<f.length;n++)f[n]=t[e+n];let u=x?x.instanceAttributesPosition:0;return n[u++]=o,n[u++]=i,f.length&&(n.set(f,u),u+=f.length),B.instanceAttributesPosition=u,B}function N(t,e,n,r,x,o,i,f,u,s){const l=[t[e],t[e+1]],c=[t[n],t[n+1]],a=t[e+2],y=t[n+2],h=E(f,[...l]),p=E(f,[...c]);function v(t,e,n){const r=Math.sqrt((e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])),x=[(e[0]-t[0])/r,(e[1]-t[1])/r],o=[-x[1],x[0]],i=Math.sqrt((n[0]-t[0])*(n[0]-t[0])+(n[1]-t[1])*(n[1]-t[1])),f=[(n[0]-t[0])/i,(n[1]-t[1])/i];let u=0===r||0===i?0:Math.acos((s=f[0]*x[0]+f[1]*x[1],l=-1,c=1,Math.min(Math.max(s,l),c)));var s,l,c;u=Math.max(u,1e-5);return f[0]*o[0]+f[1]*o[1]>0?u:2*Math.PI-u}let b=-1,M=-1,m=s;const A=null!==x;if(null!==r){b=v(h,p,E(f,[...[t[r],t[r+1]]])),Math.cos(b)<=.985&&(m+=Math.tan((b-Math.PI)/2))}if(A){M=v(p,h,E(f,[...[t[x],t[x+1]]])),Math.cos(M)<=.985&&(m+=Math.tan((Math.PI-M)/2))}const g=Math.pow(2,24),Z=u%g,d=Math.floor(u/g)*g;return o.push(l[0],l[1],a,c[0],c[1],y,b,M,Z,d,s),o.push(...i),{length:u+Math.sqrt((p[0]-h[0])*(p[0]-h[0])+(p[1]-h[1])*(p[1]-h[1])),angle:m}}function R(e,n,r,x,o){const i=2+o;let f=n;const u=e.slice(f,f+o);f+=o;const s=e[f++];let l=0;const c=new Array(s-1);for(let t=0;t<s;t++)l+=e[f++],t<s-1&&(c[t]=l);const a=e.slice(f,f+2*l),y=t(a,c,2);for(let t=0;t<y.length;t++)x.push(y[t]+r.length/i);for(let t=0;t<a.length;t+=2)r.push(a[t],a[t+1],...u);return f+2*l}const S="GENERATE_POLYGON_BUFFERS",T="GENERATE_POINT_BUFFERS",_="GENERATE_LINE_STRING_BUFFERS",O=self;O.onmessage=t=>{const e=t.data;switch(e.type){case T:{const t=2,n=2,r=e.customAttributesSize,x=n+r,o=new Float32Array(e.renderInstructions),i=o.length/x*(t+r),f=Uint32Array.from([0,1,3,1,2,3]),u=Float32Array.from([-1,-1,1,-1,1,1,-1,1]),s=new Float32Array(i);let l;for(let t=0;t<o.length;t+=x)l=P(o,t,s,r,l);const c=Object.assign({indicesBuffer:f.buffer,vertexAttributesBuffer:u.buffer,instanceAttributesBuffer:s.buffer,renderInstructions:o.buffer},e);O.postMessage(c,[u.buffer,s.buffer,f.buffer,o.buffer]);break}case _:{const t=[],n=e.customAttributesSize,r=3,x=new Float32Array(e.renderInstructions);let o=0;const i=[1,0,0,1,0,0];let f,u;for(I(i,e.renderInstructionsTransform);o<x.length;){u=Array.from(x.slice(o,o+n)),o+=n,f=x[o++];const e=o,s=o+(f-1)*r,l=x[e]===x[s]&&x[e+1]===x[s+1];let c=0,a=0;for(let n=0;n<f-1;n++){let y=null;n>0?y=o+(n-1)*r:l&&(y=s-r);let h=null;n<f-2?h=o+(n+2)*r:l&&(h=e+r);const p=N(x,o+n*r,o+(n+1)*r,y,h,t,u,i,c,a);c=p.length,a=p.angle}o+=f*r}const s=Uint32Array.from([0,1,3,1,2,3]),l=Float32Array.from([-1,-1,1,-1,1,1,-1,1]),c=Float32Array.from(t),a=Object.assign({indicesBuffer:s.buffer,vertexAttributesBuffer:l.buffer,instanceAttributesBuffer:c.buffer,renderInstructions:x.buffer},e);O.postMessage(a,[l.buffer,c.buffer,s.buffer,x.buffer]);break}case S:{const t=[],n=[],r=e.customAttributesSize,x=new Float32Array(e.renderInstructions);let o=0;for(;o<x.length;)o=R(x,o,t,n,r);const i=Uint32Array.from(n),f=Float32Array.from(t),u=Float32Array.from([]),s=Object.assign({indicesBuffer:i.buffer,vertexAttributesBuffer:f.buffer,instanceAttributesBuffer:u.buffer,renderInstructions:x.buffer},e);O.postMessage(s,[f.buffer,u.buffer,i.buffer,x.buffer]);break}}};';
  return new Worker(typeof Blob > "u" ? "data:application/javascript;base64," + Buffer.from(i, "binary").toString("base64") : URL.createObjectURL(new Blob([i], { type: "application/javascript" })));
}
const Nl = {
  GENERATE_POLYGON_BUFFERS: "GENERATE_POLYGON_BUFFERS",
  GENERATE_POINT_BUFFERS: "GENERATE_POINT_BUFFERS",
  GENERATE_LINE_STRING_BUFFERS: "GENERATE_LINE_STRING_BUFFERS"
};
function Nw(i, e) {
  e = e || [];
  const t = 256, n = t - 1, r = Math.floor(i / t / t / t) / n, s = Math.floor(i / t / t) % t / n, o = Math.floor(i / t) % t / n, a = i % t / n;
  return e[0] = r * 256 * 255 + s * 255, e[1] = o * 256 * 255 + a * 255, e;
}
function Dw(i) {
  let e = 0;
  const t = 256, n = t - 1;
  return e += Math.round(i[0] * t * t * t * n), e += Math.round(i[1] * t * t * n), e += Math.round(i[2] * t * n), e += Math.round(i[3] * n), e;
}
function s0(i, e, t, n) {
  let r = 0;
  for (const s in e) {
    const o = e[s], a = o.callback.call(t, t.feature);
    let l = a?.[0] ?? a;
    l === Qg && console.warn('The "has" operator might return false positives.'), l === void 0 ? l = Qg : l === null && (l = 0), i[n + r++] = l, !(!o.size || o.size === 1) && (i[n + r++] = a[1], !(o.size < 3) && (i[n + r++] = a[2], !(o.size < 4) && (i[n + r++] = a[3])));
  }
  return r;
}
function Bf(i) {
  return Object.keys(i).reduce(
    (e, t) => e + (i[t].size || 1),
    0
  );
}
function vO(i, e, t, n) {
  const r = (2 + Bf(t)) * i.geometriesCount;
  (!e || e.length !== r) && (e = new Float32Array(r));
  const s = [];
  let o = 0;
  for (const a in i.entries) {
    const l = i.entries[a];
    for (let h = 0, u = l.flatCoordss.length; h < u; h++)
      s[0] = l.flatCoordss[h][0], s[1] = l.flatCoordss[h][1], rt(n, s), e[o++] = s[0], e[o++] = s[1], o += s0(
        e,
        t,
        l,
        o
      );
  }
  return e;
}
function wO(i, e, t, n) {
  const r = 3 * i.verticesCount + (1 + Bf(t)) * i.geometriesCount;
  (!e || e.length !== r) && (e = new Float32Array(r));
  const s = [];
  let o = 0;
  for (const a in i.entries) {
    const l = i.entries[a];
    for (let h = 0, u = l.flatCoordss.length; h < u; h++) {
      s.length = l.flatCoordss[h].length, hr(
        l.flatCoordss[h],
        0,
        s.length,
        3,
        n,
        s,
        3
      ), o += s0(
        e,
        t,
        l,
        o
      ), e[o++] = s.length / 3;
      for (let c = 0, f = s.length; c < f; c += 3)
        e[o++] = s[c], e[o++] = s[c + 1], e[o++] = s[c + 2];
    }
  }
  return e;
}
function bO(i, e, t, n) {
  const r = 2 * i.verticesCount + (1 + Bf(t)) * i.geometriesCount + i.ringsCount;
  (!e || e.length !== r) && (e = new Float32Array(r));
  const s = [];
  let o = 0;
  for (const a in i.entries) {
    const l = i.entries[a];
    for (let h = 0, u = l.flatCoordss.length; h < u; h++) {
      s.length = l.flatCoordss[h].length, hr(
        l.flatCoordss[h],
        0,
        s.length,
        2,
        n,
        s
      ), o += s0(
        e,
        t,
        l,
        o
      ), e[o++] = l.ringsVerticesCounts[h].length;
      for (let c = 0, f = l.ringsVerticesCounts[h].length; c < f; c++)
        e[o++] = l.ringsVerticesCounts[h][c];
      for (let c = 0, f = s.length; c < f; c += 2)
        e[o++] = s[c], e[o++] = s[c + 1];
    }
  }
  return e;
}
function Fc(i) {
  return (JSON.stringify(i).split("").reduce((t, n) => (t << 5) - t + n.charCodeAt(0), 0) >>> 0).toString();
}
function o0(i, e, t, n) {
  if (`${n}radius` in i && n !== "icon-") {
    let r = me(
      t,
      i[`${n}radius`],
      oe
    );
    if (`${n}radius2` in i) {
      const s = me(
        t,
        i[`${n}radius2`],
        oe
      );
      r = `max(${r}, ${s})`;
    }
    `${n}stroke-width` in i && (r = `(${r} + ${me(
      t,
      i[`${n}stroke-width`],
      oe
    )} * 0.5)`), e.setSymbolSizeExpression(`vec2(${r} * 2. + 0.5)`);
  }
  if (`${n}scale` in i) {
    const r = me(
      t,
      i[`${n}scale`],
      bn
    );
    e.setSymbolSizeExpression(
      `${e.getSymbolSizeExpression()} * ${r}`
    );
  }
  `${n}displacement` in i && e.setSymbolOffsetExpression(
    me(
      t,
      i[`${n}displacement`],
      Wi
    )
  ), `${n}rotation` in i && e.setSymbolRotationExpression(
    me(t, i[`${n}rotation`], oe)
  ), `${n}rotate-with-view` in i && e.setSymbolRotateWithView(!!i[`${n}rotate-with-view`]);
}
function Gw(i, e, t, n, r) {
  let s = "vec4(0.)";
  if (e !== null && (s = e), t !== null && n !== null) {
    const l = `smoothstep(-${n} + 0.63, -${n} - 0.58, ${i})`;
    s = `mix(${t}, ${s}, ${l})`;
  }
  const o = `(1.0 - smoothstep(-0.63, 0.58, ${i}))`;
  let a = `${s} * vec4(1.0, 1.0, 1.0, ${o})`;
  return r !== null && (a = `${a} * vec4(1.0, 1.0, 1.0, ${r})`), a;
}
function a0(i, e, t, n, r) {
  const s = new Image();
  s.crossOrigin = i[`${n}cross-origin`] === void 0 ? "anonymous" : i[`${n}cross-origin`], Te(
    typeof i[`${n}src`] == "string",
    `WebGL layers do not support expressions for the ${n}src style property`
  ), s.src = /** @type {string} */
  i[`${n}src`], t[`u_texture${r}_size`] = () => s.complete ? [s.width, s.height] : [0, 0], e.addUniform(`u_texture${r}_size`, "vec2");
  const o = `u_texture${r}_size`;
  return t[`u_texture${r}`] = s, e.addUniform(`u_texture${r}`, "sampler2D"), o;
}
function l0(i, e, t, n, r) {
  let s = me(
    t,
    i[`${e}offset`],
    bn
  );
  if (`${e}offset-origin` in i)
    switch (i[`${e}offset-origin`]) {
      case "top-right":
        s = `vec2(${n}.x, 0.) + ${r} * vec2(-1., 0.) + ${s} * vec2(-1., 1.)`;
        break;
      case "bottom-left":
        s = `vec2(0., ${n}.y) + ${r} * vec2(0., -1.) + ${s} * vec2(1., -1.)`;
        break;
      case "bottom-right":
        s = `${n} - ${r} - ${s}`;
        break;
    }
  return s;
}
function SO(i, e, t, n) {
  n.functions.circleDistanceField = `float circleDistanceField(vec2 point, float radius) {
  return length(point) - radius;
}`, o0(i, e, n, "circle-");
  let r = null;
  "circle-opacity" in i && (r = me(n, i["circle-opacity"], oe));
  let s = "coordsPx";
  "circle-scale" in i && (s = `coordsPx / ${me(n, i["circle-scale"], bn)}`);
  let o = null;
  "circle-fill-color" in i && (o = me(
    n,
    i["circle-fill-color"],
    mt
  ));
  let a = null;
  "circle-stroke-color" in i && (a = me(
    n,
    i["circle-stroke-color"],
    mt
  ));
  let l = me(n, i["circle-radius"], oe), h = null;
  "circle-stroke-width" in i && (h = me(
    n,
    i["circle-stroke-width"],
    oe
  ), l = `(${l} + ${h} * 0.5)`);
  const u = `circleDistanceField(${s}, ${l})`, c = Gw(
    u,
    o,
    a,
    h,
    r
  );
  e.setSymbolColorExpression(c);
}
function TO(i, e, t, n) {
  n.functions.round = `float round(float v) {
  return sign(v) * floor(abs(v) + 0.5);
}`, n.functions.starDistanceField = `float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round(beta / alpha) * alpha; // angle in sector
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  vec2 tipToPoint = inSector + vec2(-radius, 0.);
  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);
  return dot(normalize(edgeNormal), tipToPoint);
}`, n.functions.regularDistanceField = `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float radiusIn = radius * cos(PI / numPoints);
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  return inSector.x - radiusIn;
}`, o0(i, e, n, "shape-");
  let r = null;
  "shape-opacity" in i && (r = me(n, i["shape-opacity"], oe));
  let s = "coordsPx";
  "shape-scale" in i && (s = `coordsPx / ${me(n, i["shape-scale"], bn)}`);
  let o = null;
  "shape-fill-color" in i && (o = me(n, i["shape-fill-color"], mt));
  let a = null;
  "shape-stroke-color" in i && (a = me(
    n,
    i["shape-stroke-color"],
    mt
  ));
  let l = null;
  "shape-stroke-width" in i && (l = me(
    n,
    i["shape-stroke-width"],
    oe
  ));
  const h = me(
    n,
    i["shape-points"],
    oe
  );
  let u = "0.";
  "shape-angle" in i && (u = me(n, i["shape-angle"], oe));
  let c, f = me(n, i["shape-radius"], oe);
  if (l !== null && (f = `${f} + ${l} * 0.5`), "shape-radius2" in i) {
    let d = me(n, i["shape-radius2"], oe);
    l !== null && (d = `${d} + ${l} * 0.5`), c = `starDistanceField(${s}, ${h}, ${f}, ${d}, ${u})`;
  } else
    c = `regularDistanceField(${s}, ${h}, ${f}, ${u})`;
  const g = Gw(
    c,
    o,
    a,
    l,
    r
  );
  e.setSymbolColorExpression(g);
}
function RO(i, e, t, n) {
  let r = "vec4(1.0)";
  "icon-color" in i && (r = me(n, i["icon-color"], mt)), "icon-opacity" in i && (r = `${r} * vec4(1.0, 1.0, 1.0, ${me(
    n,
    i["icon-opacity"],
    oe
  )})`);
  const s = Fc(i["icon-src"]), o = a0(
    i,
    e,
    t,
    "icon-",
    s
  );
  if (e.setSymbolColorExpression(
    `${r} * texture2D(u_texture${s}, v_texCoord)`
  ).setSymbolSizeExpression(o), "icon-width" in i && "icon-height" in i && e.setSymbolSizeExpression(
    `vec2(${me(
      n,
      i["icon-width"],
      oe
    )}, ${me(n, i["icon-height"], oe)})`
  ), "icon-offset" in i && "icon-size" in i) {
    const a = me(
      n,
      i["icon-size"],
      Wi
    ), l = e.getSymbolSizeExpression();
    e.setSymbolSizeExpression(a);
    const h = l0(
      i,
      "icon-",
      n,
      "v_quadSizePx",
      a
    );
    e.setTextureCoordinateExpression(
      `(vec4((${h}).xyxy) + vec4(0., 0., ${a})) / (${l}).xyxy`
    );
  }
  if (o0(i, e, n, "icon-"), "icon-anchor" in i) {
    const a = me(
      n,
      i["icon-anchor"],
      Wi
    );
    let l = "1.0";
    "icon-scale" in i && (l = me(n, i["icon-scale"], bn));
    let h;
    i["icon-anchor-x-units"] === "pixels" && i["icon-anchor-y-units"] === "pixels" ? h = `${a} * ${l}` : i["icon-anchor-x-units"] === "pixels" ? h = `${a} * vec2(vec2(${l}).x, v_quadSizePx.y)` : i["icon-anchor-y-units"] === "pixels" ? h = `${a} * vec2(v_quadSizePx.x, vec2(${l}).x)` : h = `${a} * v_quadSizePx`;
    let u = `v_quadSizePx * vec2(0.5, -0.5) + ${h} * vec2(-1., 1.)`;
    if ("icon-anchor-origin" in i)
      switch (i["icon-anchor-origin"]) {
        case "top-right":
          u = `v_quadSizePx * -0.5 + ${h}`;
          break;
        case "bottom-left":
          u = `v_quadSizePx * 0.5 - ${h}`;
          break;
        case "bottom-right":
          u = `v_quadSizePx * vec2(-0.5, 0.5) + ${h} * vec2(1., -1.)`;
          break;
      }
    e.setSymbolOffsetExpression(
      `${e.getSymbolOffsetExpression()} + ${u}`
    );
  }
}
function PO(i, e, t, n) {
  if ("stroke-color" in i && e.setStrokeColorExpression(
    me(n, i["stroke-color"], mt)
  ), "stroke-pattern-src" in i) {
    const r = Fc(i["stroke-pattern-src"]), s = a0(
      i,
      e,
      t,
      "stroke-pattern-",
      r
    );
    let o = s, a = "vec2(0.)";
    "stroke-pattern-offset" in i && "stroke-pattern-size" in i && (o = me(
      n,
      i["stroke-pattern-size"],
      Wi
    ), a = l0(
      i,
      "stroke-pattern-",
      n,
      s,
      o
    ));
    let l = "0.";
    "stroke-pattern-spacing" in i && (l = me(
      n,
      i["stroke-pattern-spacing"],
      oe
    ));
    let h = "0.";
    "stroke-pattern-start-offset" in i && (h = me(
      n,
      i["stroke-pattern-start-offset"],
      oe
    )), n.functions.sampleStrokePattern = `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float startOffsetPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {
  float currentLengthScaled = (currentLengthPx - startOffsetPx) * sampleSize.y / lineWidth;
  float spacingScaled = spacingPx * sampleSize.y / lineWidth;
  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));
  float isInsideOfPattern = step(uCoordPx, sampleSize.x);
  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;
  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels
  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);
  vCoordPx = clamp(vCoordPx, 0.5, sampleSize.y - 0.5);
  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;
  return texture2D(texture, texCoord) * vec4(1.0, 1.0, 1.0, isInsideOfPattern);
}`;
    const u = `u_texture${r}`;
    let c = "1.";
    "stroke-color" in i && (c = e.getStrokeColorExpression()), e.setStrokeColorExpression(
      `${c} * sampleStrokePattern(${u}, ${s}, ${a}, ${o}, ${l}, ${h}, currentLengthPx, currentRadiusRatio, v_width)`
    ), n.functions.computeStrokePatternLength = `float computeStrokePatternLength(vec2 sampleSize, float spacingPx, float lineWidth) {
  float patternLengthPx = sampleSize.x / sampleSize.y * lineWidth;
  return patternLengthPx + spacingPx;
}`, e.setStrokePatternLengthExpression(
      `computeStrokePatternLength(${o}, ${l}, v_width)`
    );
  }
  if ("stroke-width" in i && e.setStrokeWidthExpression(
    me(n, i["stroke-width"], oe)
  ), "stroke-offset" in i && e.setStrokeOffsetExpression(
    me(n, i["stroke-offset"], oe)
  ), "stroke-line-cap" in i && e.setStrokeCapExpression(
    me(n, i["stroke-line-cap"], Kt)
  ), "stroke-line-join" in i && e.setStrokeJoinExpression(
    me(n, i["stroke-line-join"], Kt)
  ), "stroke-miter-limit" in i && e.setStrokeMiterLimitExpression(
    me(n, i["stroke-miter-limit"], oe)
  ), "stroke-line-dash" in i) {
    n.functions.getSingleDashDistance = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType, float lineWidth) {
  float localDistance = mod(distance, dashLengthTotal);
  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;
  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);
  if (capType == ${Cr("square")}) {
    distanceSegment -= lineWidth * 0.5;
  } else if (capType == ${Cr("round")}) {
    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - lineWidth * 0.5);
  }
  return distanceSegment;
}`;
    let r = i["stroke-line-dash"].map(
      (d) => me(n, d, oe)
    );
    r.length % 2 === 1 && (r = [...r, ...r]);
    let s = "0.";
    "stroke-line-dash-offset" in i && (s = me(
      n,
      i["stroke-line-dash-offset"],
      oe
    ));
    const a = `dashDistanceField_${Fc(i["stroke-line-dash"])}`, l = r.map((d, m) => `float dashLength${m}`).join(", "), h = r.map((d, m) => `dashLength${m}`).join(" + ");
    let u = "0.", c = `getSingleDashDistance(distance, radius, ${u}, dashLength0, totalDashLength, capType, lineWidth)`;
    for (let d = 2; d < r.length; d += 2)
      u = `${u} + dashLength${d - 2} + dashLength${d - 1}`, c = `min(${c}, getSingleDashDistance(distance, radius, ${u}, dashLength${d}, totalDashLength, capType, lineWidth))`;
    n.functions[a] = `float ${a}(float distance, float radius, float capType, float lineWidth, ${l}) {
  float totalDashLength = ${h};
  return ${c};
}`;
    const f = r.map((d, m) => `${d}`).join(", ");
    e.setStrokeDistanceFieldExpression(
      `${a}(currentLengthPx + ${s}, currentRadiusPx, capType, v_width, ${f})`
    );
    let g = r.join(" + ");
    e.getStrokePatternLengthExpression() && (n.functions.combinePatternLengths = `float combinePatternLengths(float patternLength1, float patternLength2) {
  return patternLength1 * patternLength2;
}`, g = `combinePatternLengths(${e.getStrokePatternLengthExpression()}, ${g})`), e.setStrokePatternLengthExpression(g);
  }
}
function MO(i, e, t, n) {
  if ("fill-color" in i && e.setFillColorExpression(
    me(n, i["fill-color"], mt)
  ), "fill-pattern-src" in i) {
    const r = Fc(i["fill-pattern-src"]), s = a0(
      i,
      e,
      t,
      "fill-pattern-",
      r
    );
    let o = s, a = "vec2(0.)";
    "fill-pattern-offset" in i && "fill-pattern-size" in i && (o = me(
      n,
      i["fill-pattern-size"],
      Wi
    ), a = l0(
      i,
      "fill-pattern-",
      n,
      s,
      o
    )), n.functions.sampleFillPattern = `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {
  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);
  vec2 pxRelativePos = pxPosition - pxOrigin;
  // rotate the relative position from origin by the current view rotation
  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));
  // sample position is computed according to the sample offset & size
  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);
  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels
  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));
  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright
  return texture2D(texture, (samplePos + textureOffset) / textureSize);
}`;
    const l = `u_texture${r}`;
    let h = "1.";
    "fill-color" in i && (h = e.getFillColorExpression()), e.setFillColorExpression(
      `${h} * sampleFillPattern(${l}, ${s}, ${a}, ${o}, pxOrigin, pxPos)`
    );
  }
}
function tp(i, e, t) {
  const n = i0(), r = new Fw(), s = {};
  if ("icon-src" in i ? RO(i, r, s, n) : "shape-points" in i ? TO(i, r, s, n) : "circle-radius" in i && SO(i, r, s, n), PO(i, r, s, n), MO(i, r, s, n), t) {
    const l = me(n, t, jt);
    r.setFragmentDiscardExpression(`!${l}`);
  }
  const o = {};
  function a(l, h, u, c) {
    if (!n[l])
      return;
    const f = ep(u), g = r0(u);
    r.addAttribute(`a_${h}`, f), o[h] = {
      size: g,
      callback: c
    };
  }
  return a(
    "geometryType",
    Cw,
    Kt,
    (l) => Pa(jm(l.getGeometry()))
  ), a(
    "featureId",
    Mw,
    Kt | oe,
    (l) => {
      const h = l.getId() ?? null;
      return typeof h == "string" ? Pa(h) : h;
    }
  ), Aw(r, n), {
    builder: r,
    attributes: { ...o, ...Lw(n) },
    uniforms: {
      ...s,
      ...Iw(n, e)
    }
  };
}
const CO = [];
let Vd;
function AO() {
  return Vd || (Vd = Ow()), Vd;
}
let IO = 0;
const gn = {
  POSITION: "a_position",
  LOCAL_POSITION: "a_localPosition",
  SEGMENT_START: "a_segmentStart",
  SEGMENT_END: "a_segmentEnd",
  MEASURE_START: "a_measureStart",
  MEASURE_END: "a_measureEnd",
  ANGLE_TANGENT_SUM: "a_angleTangentSum",
  JOIN_ANGLES: "a_joinAngles",
  DISTANCE_LOW: "a_distanceLow",
  DISTANCE_HIGH: "a_distanceHigh"
};
class LO {
  /**
   * @param {FlatStyleLike|StyleShaders|Array<StyleShaders>} styles Vector styles expressed as flat styles, flat style rules or style shaders
   * @param {import('../../style/flat.js').StyleVariables} variables Style variables
   * @param {import('../../webgl/Helper.js').default} helper Helper
   * @param {boolean} [enableHitDetection] Whether to enable the hit detection (needs compatible shader)
   */
  constructor(e, t, n, r) {
    this.helper_, this.hitDetectionEnabled_ = !!r, this.styleShaders = FO(e, t), this.customAttributes_ = {}, this.uniforms_ = {}, this.hitDetectionEnabled_ && (this.customAttributes_.hitColor = {
      callback() {
        return Nw(this.ref, CO);
      },
      size: 2
    });
    for (const s of this.styleShaders) {
      for (const o in s.attributes)
        o in this.customAttributes_ || (this.customAttributes_[o] = s.attributes[o]);
      for (const o in s.uniforms)
        o in this.uniforms_ || (this.uniforms_[o] = s.uniforms[o]);
    }
    this.renderPasses_ = this.styleShaders.map((s) => {
      const o = {}, a = Object.entries(this.customAttributes_).map(
        ([l, h]) => ({
          name: l in s.attributes || l === "hitColor" ? `a_${l}` : null,
          // giving a null name means this is only used for "spacing" in between attributes
          size: h.size || 1,
          type: Rt.FLOAT
        })
      );
      return s.builder.getFillVertexShader() && (o.fillRenderPass = {
        vertexShader: s.builder.getFillVertexShader(),
        fragmentShader: s.builder.getFillFragmentShader(),
        attributesDesc: [
          {
            name: gn.POSITION,
            size: 2,
            type: Rt.FLOAT
          },
          ...a
        ],
        instancedAttributesDesc: [],
        // no instanced rendering for polygons
        instancePrimitiveVertexCount: 3
      }), s.builder.getStrokeVertexShader() && (o.strokeRenderPass = {
        vertexShader: s.builder.getStrokeVertexShader(),
        fragmentShader: s.builder.getStrokeFragmentShader(),
        attributesDesc: [
          {
            name: gn.LOCAL_POSITION,
            size: 2,
            type: Rt.FLOAT
          }
        ],
        instancedAttributesDesc: [
          {
            name: gn.SEGMENT_START,
            size: 2,
            type: Rt.FLOAT
          },
          {
            name: gn.MEASURE_START,
            size: 1,
            type: Rt.FLOAT
          },
          {
            name: gn.SEGMENT_END,
            size: 2,
            type: Rt.FLOAT
          },
          {
            name: gn.MEASURE_END,
            size: 1,
            type: Rt.FLOAT
          },
          {
            name: gn.JOIN_ANGLES,
            size: 2,
            type: Rt.FLOAT
          },
          {
            name: gn.DISTANCE_LOW,
            size: 1,
            type: Rt.FLOAT
          },
          {
            name: gn.DISTANCE_HIGH,
            size: 1,
            type: Rt.FLOAT
          },
          {
            name: gn.ANGLE_TANGENT_SUM,
            size: 1,
            type: Rt.FLOAT
          },
          ...a
        ],
        instancePrimitiveVertexCount: 6
      }), s.builder.getSymbolVertexShader() && (o.symbolRenderPass = {
        vertexShader: s.builder.getSymbolVertexShader(),
        fragmentShader: s.builder.getSymbolFragmentShader(),
        attributesDesc: [
          {
            name: gn.LOCAL_POSITION,
            size: 2,
            type: Rt.FLOAT
          }
        ],
        instancedAttributesDesc: [
          {
            name: gn.POSITION,
            size: 2,
            type: Rt.FLOAT
          },
          ...a
        ],
        instancePrimitiveVertexCount: 6
      }), o;
    }), this.hasFill_ = this.renderPasses_.some((s) => s.fillRenderPass), this.hasStroke_ = this.renderPasses_.some((s) => s.strokeRenderPass), this.hasSymbol_ = this.renderPasses_.some((s) => s.symbolRenderPass), this.setHelper(n);
  }
  /**
   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch
   * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
   * @return {Promise<WebGLBuffers|null>} A promise resolving to WebGL buffers; returns null if buffers are empty
   */
  async generateBuffers(e, t) {
    if (e.isEmpty())
      return null;
    const n = this.generateRenderInstructions_(
      e,
      t
    ), [r, s, o] = await Promise.all(
      [
        this.generateBuffersForType_(
          n.polygonInstructions,
          "Polygon",
          t
        ),
        this.generateBuffersForType_(
          n.lineStringInstructions,
          "LineString",
          t
        ),
        this.generateBuffersForType_(
          n.pointInstructions,
          "Point",
          t
        )
      ]
    ), a = lo(
      st(),
      t
    );
    return {
      polygonBuffers: r,
      lineStringBuffers: s,
      pointBuffers: o,
      invertVerticesTransform: a
    };
  }
  /**
   * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch
   * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
   * @return {RenderInstructions} Render instructions
   * @private
   */
  generateRenderInstructions_(e, t) {
    const n = this.hasFill_ ? bO(
      e.polygonBatch,
      new Float32Array(0),
      this.customAttributes_,
      t
    ) : null, r = this.hasStroke_ ? wO(
      e.lineStringBatch,
      new Float32Array(0),
      this.customAttributes_,
      t
    ) : null, s = this.hasSymbol_ ? vO(
      e.pointBatch,
      new Float32Array(0),
      this.customAttributes_,
      t
    ) : null;
    return {
      polygonInstructions: n,
      lineStringInstructions: r,
      pointInstructions: s
    };
  }
  /**
   * @param {Float32Array|null} renderInstructions Render instructions
   * @param {import("../../geom/Geometry.js").Type} geometryType Geometry type
   * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
   * @return {Promise<WebGLArrayBufferSet>|null} Indices buffer and vertices buffer; null if nothing to render
   * @private
   */
  generateBuffersForType_(e, t, n) {
    if (e === null)
      return null;
    const r = IO++;
    let s;
    switch (t) {
      case "Polygon":
        s = Nl.GENERATE_POLYGON_BUFFERS;
        break;
      case "LineString":
        s = Nl.GENERATE_LINE_STRING_BUFFERS;
        break;
      case "Point":
        s = Nl.GENERATE_POINT_BUFFERS;
        break;
    }
    const o = {
      id: r,
      type: s,
      renderInstructions: e.buffer,
      renderInstructionsTransform: n,
      customAttributesSize: Bf(this.customAttributes_)
    }, a = AO();
    return a.postMessage(o, [e.buffer]), e = null, new Promise((l) => {
      const h = (u) => {
        const c = u.data;
        if (c.id !== r || (a.removeEventListener("message", h), !this.helper_.getGL()))
          return;
        const f = new xs(
          Dh,
          ha
        ).fromArrayBuffer(c.indicesBuffer), g = new xs(
          fo,
          ha
        ).fromArrayBuffer(c.vertexAttributesBuffer), d = new xs(
          fo,
          ha
        ).fromArrayBuffer(c.instanceAttributesBuffer);
        this.helper_.flushBufferData(f), this.helper_.flushBufferData(g), this.helper_.flushBufferData(d), l([
          f,
          g,
          d
        ]);
      };
      a.addEventListener("message", h);
    });
  }
  /**
   * Render the geometries in the given buffers.
   * @param {WebGLBuffers} buffers WebGL Buffers to draw
   * @param {import("../../Map.js").FrameState} frameState Frame state
   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms
   */
  render(e, t, n) {
    for (const r of this.renderPasses_)
      r.fillRenderPass && this.renderInternal_(
        e.polygonBuffers[0],
        e.polygonBuffers[1],
        e.polygonBuffers[2],
        r.fillRenderPass,
        t,
        n
      ), r.strokeRenderPass && this.renderInternal_(
        e.lineStringBuffers[0],
        e.lineStringBuffers[1],
        e.lineStringBuffers[2],
        r.strokeRenderPass,
        t,
        n
      ), r.symbolRenderPass && this.renderInternal_(
        e.pointBuffers[0],
        e.pointBuffers[1],
        e.pointBuffers[2],
        r.symbolRenderPass,
        t,
        n
      );
  }
  /**
   * @param {WebGLArrayBuffer} indicesBuffer Indices buffer
   * @param {WebGLArrayBuffer} vertexAttributesBuffer Vertex attributes buffer
   * @param {WebGLArrayBuffer} instanceAttributesBuffer Instance attributes buffer
   * @param {SubRenderPass} subRenderPass Render pass (program, attributes, etc.) specific to one geometry type
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms
   * @private
   */
  renderInternal_(e, t, n, r, s, o) {
    const a = e.getSize();
    if (a === 0)
      return;
    const l = r.instancedAttributesDesc.length;
    if (this.helper_.useProgram(r.program, s), this.helper_.bindBuffer(t), this.helper_.bindBuffer(e), this.helper_.enableAttributes(r.attributesDesc), this.helper_.bindBuffer(n), this.helper_.enableAttributesInstanced(
      r.instancedAttributesDesc
    ), o(), l) {
      const h = r.instancedAttributesDesc.reduce(
        (c, f) => c + (f.size || 1),
        0
      ), u = n.getSize() / h;
      this.helper_.drawElementsInstanced(0, a, u);
    } else
      this.helper_.drawElements(0, a);
  }
  /**
   * @param {import('../../webgl/Helper.js').default} helper Helper
   * @param {WebGLBuffers} buffers WebGL Buffers to reload if any
   */
  setHelper(e, t = null) {
    this.helper_ = e;
    for (const n of this.renderPasses_)
      n.fillRenderPass && (n.fillRenderPass.program = this.helper_.getProgram(
        n.fillRenderPass.fragmentShader,
        n.fillRenderPass.vertexShader
      )), n.strokeRenderPass && (n.strokeRenderPass.program = this.helper_.getProgram(
        n.strokeRenderPass.fragmentShader,
        n.strokeRenderPass.vertexShader
      )), n.symbolRenderPass && (n.symbolRenderPass.program = this.helper_.getProgram(
        n.symbolRenderPass.fragmentShader,
        n.symbolRenderPass.vertexShader
      ));
    this.helper_.addUniforms(this.uniforms_), t && (t.polygonBuffers && (this.helper_.flushBufferData(t.polygonBuffers[0]), this.helper_.flushBufferData(t.polygonBuffers[1]), this.helper_.flushBufferData(t.polygonBuffers[2])), t.lineStringBuffers && (this.helper_.flushBufferData(t.lineStringBuffers[0]), this.helper_.flushBufferData(t.lineStringBuffers[1]), this.helper_.flushBufferData(t.lineStringBuffers[2])), t.pointBuffers && (this.helper_.flushBufferData(t.pointBuffers[0]), this.helper_.flushBufferData(t.pointBuffers[1]), this.helper_.flushBufferData(t.pointBuffers[2])));
  }
}
function FO(i, e) {
  const t = Array.isArray(i) ? i : [i];
  if ("style" in t[0]) {
    const n = [], r = (
      /** @type {Array<FlatStyleRule>} */
      t
    ), s = [];
    for (const o of r) {
      const a = Array.isArray(o.style) ? o.style : [o.style];
      let l = o.filter;
      o.else && s.length && (l = [
        "all",
        ...s.map((u) => ["!", u])
      ], o.filter && l.push(o.filter), l.length < 3 && (l = l[1])), o.filter && s.push(o.filter);
      const h = a.map(
        (u) => tp(u, e, l)
      );
      n.push(...h);
    }
    return n;
  }
  return "builder" in t[0] ? (
    /** @type {Array<StyleShaders>} */
    t
  ) : (
    /** @type {Array<FlatStyle>} */
    t.map(
      (n) => tp(n, e, null)
    )
  );
}
const Qn = new Uint8Array(4);
class kw {
  /**
   * @param {import("./Helper.js").default} helper WebGL helper; mandatory.
   * @param {Array<number>} [size] Expected size of the render target texture; note: this can be changed later on.
   */
  constructor(e, t) {
    this.helper_ = e;
    const n = e.getGL();
    this.texture_ = n.createTexture(), this.framebuffer_ = n.createFramebuffer(), this.depthbuffer_ = n.createRenderbuffer(), this.size_ = t || [1, 1], this.data_ = new Uint8Array(0), this.dataCacheDirty_ = !0, this.updateSize_();
  }
  /**
   * Changes the size of the render target texture. Note: will do nothing if the size
   * is already the same.
   * @param {Array<number>} size Expected size of the render target texture
   */
  setSize(e) {
    Xr(e, this.size_) || (this.size_[0] = e[0], this.size_[1] = e[1], this.updateSize_());
  }
  /**
   * Returns the size of the render target texture
   * @return {Array<number>} Size of the render target texture
   */
  getSize() {
    return this.size_;
  }
  /**
   * This will cause following calls to `#readAll` or `#readPixel` to download the content of the
   * render target into memory, which is an expensive operation.
   * This content will be kept in cache but should be cleared after each new render.
   */
  clearCachedData() {
    this.dataCacheDirty_ = !0;
  }
  /**
   * Returns the full content of the frame buffer as a series of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * @return {Uint8Array} Integer array of color values
   */
  readAll() {
    if (this.dataCacheDirty_) {
      const e = this.size_, t = this.helper_.getGL();
      t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer_), t.readPixels(
        0,
        0,
        e[0],
        e[1],
        t.RGBA,
        t.UNSIGNED_BYTE,
        this.data_
      ), this.dataCacheDirty_ = !1;
    }
    return this.data_;
  }
  /**
   * Reads one pixel of the frame buffer as an array of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * If x and/or y are outside of existing data, an array filled with 0 is returned.
   * @param {number} x Pixel coordinate
   * @param {number} y Pixel coordinate
   * @return {Uint8Array} Integer array with one color value (4 components)
   */
  readPixel(e, t) {
    if (e < 0 || t < 0 || e > this.size_[0] || t >= this.size_[1])
      return Qn[0] = 0, Qn[1] = 0, Qn[2] = 0, Qn[3] = 0, Qn;
    this.readAll();
    const n = Math.floor(e) + (this.size_[1] - Math.floor(t) - 1) * this.size_[0];
    return Qn[0] = this.data_[n * 4], Qn[1] = this.data_[n * 4 + 1], Qn[2] = this.data_[n * 4 + 2], Qn[3] = this.data_[n * 4 + 3], Qn;
  }
  /**
   * @return {WebGLTexture} Texture to render to
   */
  getTexture() {
    return this.texture_;
  }
  /**
   * @return {WebGLFramebuffer} Frame buffer of the render target
   */
  getFramebuffer() {
    return this.framebuffer_;
  }
  /**
   * @return {WebGLRenderbuffer} Depth buffer of the render target
   */
  getDepthbuffer() {
    return this.depthbuffer_;
  }
  /**
   * @private
   */
  updateSize_() {
    const e = this.size_, t = this.helper_.getGL();
    this.texture_ = this.helper_.createTexture(e, null, this.texture_), t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer_), t.viewport(0, 0, e[0], e[1]), t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0,
      t.TEXTURE_2D,
      this.texture_,
      0
    ), t.bindRenderbuffer(t.RENDERBUFFER, this.depthbuffer_), t.renderbufferStorage(
      t.RENDERBUFFER,
      t.DEPTH_COMPONENT16,
      e[0],
      e[1]
    ), t.framebufferRenderbuffer(
      t.FRAMEBUFFER,
      t.DEPTH_ATTACHMENT,
      t.RENDERBUFFER,
      this.depthbuffer_
    ), this.data_ = new Uint8Array(e[0] * e[1] * 4);
  }
}
function Uw(i, e) {
  const t = i.viewState.projection, r = e.getSource().getWrapX() && t.canWrapX(), s = t.getExtent(), o = i.extent, a = r ? _e(s) : null, l = r ? Math.ceil((o[2] - s[2]) / a) + 1 : 1;
  return [r ? Math.floor((o[0] - s[0]) / a) : 0, l, a];
}
const Oo = {
  ...rr,
  RENDER_EXTENT: "u_renderExtent",
  // intersection of layer, source, and view extent
  PATTERN_ORIGIN: "u_patternOrigin",
  GLOBAL_ALPHA: "u_globalAlpha"
};
class zw extends kh {
  /**
   * @param {import("../../layer/Layer.js").default} layer Layer.
   * @param {Options} options Options.
   */
  constructor(e, t) {
    const n = {
      [Oo.RENDER_EXTENT]: [0, 0, 0, 0],
      [Oo.PATTERN_ORIGIN]: [0, 0],
      [Oo.GLOBAL_ALPHA]: 1
    };
    super(e, {
      uniforms: n,
      postProcesses: t.postProcesses
    }), this.hitDetectionEnabled_ = !t.disableHitDetection, this.hitRenderTarget_, this.sourceRevision_ = -1, this.previousExtent_ = hi(), this.currentTransform_ = st(), this.tmpCoords_ = [0, 0], this.tmpTransform_ = st(), this.tmpMat4_ = So(), this.currentFrameStateTransform_ = st(), this.styleVariables_ = {}, this.style_ = [], this.styleRenderer_ = null, this.buffers_ = null, this.applyOptions_(t), this.batch_ = new Lc(), this.initialFeaturesAdded_ = !1, this.sourceListenKeys_ = null;
  }
  /**
   * @private
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  addInitialFeatures_(e) {
    const t = this.getLayer().getSource();
    let n;
    this.batch_.addFeatures(t.getFeatures(), n), this.sourceListenKeys_ = [
      Ce(
        t,
        Bt.ADDFEATURE,
        this.handleSourceFeatureAdded_.bind(this, n)
      ),
      Ce(
        t,
        Bt.CHANGEFEATURE,
        this.handleSourceFeatureChanged_.bind(this, n),
        this
      ),
      Ce(
        t,
        Bt.REMOVEFEATURE,
        this.handleSourceFeatureDelete_,
        this
      ),
      Ce(
        t,
        Bt.CLEAR,
        this.handleSourceFeatureClear_,
        this
      )
    ];
  }
  /**
   * @param {Options} options Options.
   * @private
   */
  applyOptions_(e) {
    this.styleVariables_ = e.variables, this.style_ = e.style;
  }
  /**
   * @private
   */
  createRenderers_() {
    this.buffers_ = null, this.styleRenderer_ = new LO(
      this.style_,
      this.styleVariables_,
      this.helper,
      this.hitDetectionEnabled_
    );
  }
  /**
   * @override
   */
  reset(e) {
    this.applyOptions_(e), this.helper && this.createRenderers_(), super.reset(e);
  }
  /**
   * @override
   */
  afterHelperCreated() {
    this.styleRenderer_ ? this.styleRenderer_.setHelper(this.helper, this.buffers_) : this.createRenderers_(), this.hitDetectionEnabled_ && (this.hitRenderTarget_ = new kw(this.helper));
  }
  /**
   * @param {import("../../proj.js").TransformFunction} projectionTransform Transform function.
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureAdded_(e, t) {
    const n = t.feature;
    this.batch_.addFeature(n, e);
  }
  /**
   * @param {import("../../proj.js").TransformFunction} projectionTransform Transform function.
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureChanged_(e, t) {
    const n = t.feature;
    this.batch_.changeFeature(n, e);
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureDelete_(e) {
    const t = e.feature;
    this.batch_.removeFeature(t);
  }
  /**
   * @private
   */
  handleSourceFeatureClear_() {
    this.batch_.clear();
  }
  /**
   * @param {import("../../transform.js").Transform} batchInvertTransform Inverse of the transformation in which geometries are expressed
   * @private
   */
  applyUniforms_(e) {
    IE(this.tmpTransform_, this.currentFrameStateTransform_), zr(this.tmpTransform_, e), this.helper.setUniformMatrixValue(
      Oo.PROJECTION_MATRIX,
      Mc(this.tmpMat4_, this.tmpTransform_)
    ), lo(this.tmpTransform_, this.tmpTransform_), this.helper.setUniformMatrixValue(
      Oo.SCREEN_TO_WORLD_MATRIX,
      Mc(this.tmpMat4_, this.tmpTransform_)
    ), this.tmpCoords_[0] = 0, this.tmpCoords_[1] = 0, lo(this.tmpTransform_, e), rt(this.tmpTransform_, this.tmpCoords_), this.helper.setUniformFloatVec2(Oo.PATTERN_ORIGIN, this.tmpCoords_);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(e) {
    const t = this.helper.getGL();
    this.preRender(t, e);
    const [n, r, s] = Uw(
      e,
      this.getLayer()
    );
    this.helper.prepareDraw(e), this.renderWorlds(e, !1, n, r, s), this.helper.finalizeDraw(
      e,
      this.dispatchPreComposeEvent,
      this.dispatchPostComposeEvent
    );
    const o = this.helper.getCanvas();
    return this.hitDetectionEnabled_ && (this.renderWorlds(e, !0, n, r, s), this.hitRenderTarget_.clearCachedData()), this.postRender(t, e), o;
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrameInternal(e) {
    this.initialFeaturesAdded_ || (this.addInitialFeatures_(e), this.initialFeaturesAdded_ = !0);
    const t = this.getLayer(), n = t.getSource(), r = e.viewState, s = !e.viewHints[Xe.ANIMATING] && !e.viewHints[Xe.INTERACTING], o = !Pn(this.previousExtent_, e.extent), a = this.sourceRevision_ < n.getRevision();
    if (a && (this.sourceRevision_ = n.getRevision()), s && (o || a)) {
      const l = r.projection, h = r.resolution, u = t instanceof bo ? t.getRenderBuffer() : 0, c = ln(e.extent, u * h);
      n.loadFeatures(c, h, l), this.ready = !1;
      const f = this.helper.makeProjectionTransform(
        e,
        st()
      );
      this.styleRenderer_.generateBuffers(this.batch_, f).then((g) => {
        this.buffers_ && this.disposeBuffers(this.buffers_), this.buffers_ = g, this.ready = !0, this.getLayer().changed();
      }), this.previousExtent_ = e.extent.slice();
    }
    return !0;
  }
  /**
   * Render the world, either to the main framebuffer or to the hit framebuffer
   * @param {import("../../Map.js").FrameState} frameState current frame state
   * @param {boolean} forHitDetection whether the rendering is for hit detection
   * @param {number} startWorld the world to render in the first iteration
   * @param {number} endWorld the last world to render
   * @param {number} worldWidth the width of the worlds being rendered
   */
  renderWorlds(e, t, n, r, s) {
    let o = n;
    t && (this.hitRenderTarget_.setSize([
      Math.floor(e.size[0] / 2),
      Math.floor(e.size[1] / 2)
    ]), this.helper.prepareDrawToRenderTarget(
      e,
      this.hitRenderTarget_,
      !0
    ));
    do
      this.helper.makeProjectionTransform(
        e,
        this.currentFrameStateTransform_
      ), xf(
        this.currentFrameStateTransform_,
        o * s,
        0
      ), this.buffers_ && this.styleRenderer_.render(this.buffers_, e, () => {
        this.applyUniforms_(this.buffers_.invertVerticesTransform), this.helper.applyHitDetectionUniform(t);
      });
    while (++o < r);
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   * @override
   */
  forEachFeatureAtCoordinate(e, t, n, r, s) {
    if (Te(
      this.hitDetectionEnabled_,
      "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."
    ), !this.styleRenderer_ || !this.hitDetectionEnabled_)
      return;
    const o = rt(
      t.coordinateToPixelTransform,
      e.slice()
    ), a = this.hitRenderTarget_.readPixel(o[0] / 2, o[1] / 2), l = [a[0] / 255, a[1] / 255, a[2] / 255, a[3] / 255], h = Dw(l), u = this.batch_.getFeatureFromRef(h);
    if (u)
      return r(u, this.getLayer(), null);
  }
  /**
   * Will release a set of Webgl buffers
   * @param {import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers} buffers Buffers
   */
  disposeBuffers(e) {
    const t = (n) => {
      for (const r of n)
        r && this.helper.deleteBuffer(r);
    };
    e.pointBuffers && t(e.pointBuffers), e.lineStringBuffers && t(e.lineStringBuffers), e.polygonBuffers && t(e.polygonBuffers);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.buffers_ && this.disposeBuffers(this.buffers_), this.sourceListenKeys_ && (this.sourceListenKeys_.forEach(function(e) {
      tt(e);
    }), this.sourceListenKeys_ = null), super.disposeInternal();
  }
  renderDeclutter() {
  }
}
const Rr = {
  BLUR: "blur",
  GRADIENT: "gradient",
  RADIUS: "radius"
}, OO = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
class NO extends bo {
  /**
   * @param {Options<FeatureType, VectorSourceType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.gradient, delete t.radius, delete t.blur, delete t.weight, super(t), this.filter_ = e.filter ?? !0, this.styleVariables_ = e.variables || {}, this.gradient_ = null, this.addChangeListener(Rr.GRADIENT, this.handleGradientChanged_), this.setGradient(e.gradient ? e.gradient : OO), this.setBlur(e.blur !== void 0 ? e.blur : 15), this.setRadius(e.radius !== void 0 ? e.radius : 8);
    const n = e.weight ? e.weight : "weight";
    this.weight_ = n, this.setRenderOrder(null);
  }
  /**
   * Return the blur size in pixels.
   * @return {import("../style/flat.js").NumberExpression} Blur size in pixels.
   * @api
   * @observable
   */
  getBlur() {
    return (
      /** @type {import("../style/flat.js").NumberExpression} */
      this.get(Rr.BLUR)
    );
  }
  /**
   * Return the gradient colors as array of strings.
   * @return {Array<string>} Colors.
   * @api
   * @observable
   */
  getGradient() {
    return (
      /** @type {Array<string>} */
      this.get(Rr.GRADIENT)
    );
  }
  /**
   * Return the size of the radius in pixels.
   * @return {import("../style/flat.js").NumberExpression} Radius size in pixel.
   * @api
   * @observable
   */
  getRadius() {
    return (
      /** @type {import("../style/flat.js").NumberExpression} */
      this.get(Rr.RADIUS)
    );
  }
  /**
   * @private
   */
  handleGradientChanged_() {
    this.gradient_ = DO(this.getGradient());
  }
  /**
   * Set the blur size in pixels.
   * @param {import("../style/flat.js").NumberExpression} blur Blur size in pixels (supports expressions).
   * @api
   * @observable
   */
  setBlur(e) {
    const t = this.get(Rr.BLUR);
    if (this.set(Rr.BLUR, e), typeof e == "number" && typeof t == "number") {
      this.changed();
      return;
    }
    this.clearRenderer();
  }
  /**
   * Set the gradient colors as array of strings.
   * @param {Array<string>} colors Gradient.
   * @api
   * @observable
   */
  setGradient(e) {
    this.set(Rr.GRADIENT, e);
  }
  /**
   * Set the size of the radius in pixels.
   * @param {import("../style/flat.js").NumberExpression} radius Radius size in pixel (supports expressions).
   * @api
   * @observable
   */
  setRadius(e) {
    const t = this.get(Rr.RADIUS);
    if (this.set(Rr.RADIUS, e), typeof e == "number" && typeof t == "number") {
      this.changed();
      return;
    }
    this.clearRenderer();
  }
  /**
   * Set the filter expression
   * @param {import("../style/flat.js").BooleanExpression} filter Filter expression
   * @api
   */
  setFilter(e) {
    this.filter_ = e, this.changed(), this.clearRenderer();
  }
  /**
   * Set the weight expression
   * @param {WeightExpression} weight Weight expression
   * @api
   */
  setWeight(e) {
    this.weight_ = e, this.changed(), this.clearRenderer();
  }
  /**
   * @override
   */
  createRenderer() {
    const e = new Fw(), t = i0(), n = me(t, this.filter_, jt);
    let r = me(
      t,
      this.getRadius(),
      oe
    ), s = me(t, this.getBlur(), oe);
    const o = {};
    typeof this.getBlur() == "number" && (s = "a_blur", o.a_blur = () => this.getBlur(), e.addUniform("a_blur", "float")), typeof this.getRadius() == "number" && (r = "a_radius", o.a_radius = () => this.getRadius(), e.addUniform("a_radius", "float"));
    const a = {};
    let l = null;
    if (typeof this.weight_ == "string" || typeof this.weight_ == "function") {
      const c = typeof this.weight_ == "string" ? (f) => f.get(this.weight_) : this.weight_;
      a.prop_weight = {
        size: 1,
        callback: (f) => {
          const g = c(f);
          return g !== void 0 ? ve(g, 0, 1) : 1;
        }
      }, l = "a_prop_weight", e.addAttribute("a_prop_weight", "float");
    } else {
      const c = ["clamp", this.weight_, 0, 1];
      l = me(t, c, oe);
    }
    e.addFragmentShaderFunction(
      `float getBlurSlope() {
  float blur = max(1., ${s});
  float radius = ${r};
  return radius / blur;
}`
    ).setSymbolSizeExpression(`vec2(${r} + ${s}) * 2.`).setSymbolColorExpression(
      `vec4(smoothstep(0., 1., (1. - length(coordsPx * 2. / v_quadSizePx)) * getBlurSlope()) * ${l})`
    ).setStrokeColorExpression(
      `vec4(smoothstep(0., 1., (1. - length(currentRadiusPx * 2. / v_width)) * getBlurSlope()) * ${l})`
    ).setStrokeWidthExpression(`(${r} + ${s}) * 2.`).setFillColorExpression(`vec4(${l})`).setFragmentDiscardExpression(`!${n}`), Aw(e, t);
    const h = Lw(t), u = Iw(t, this.styleVariables_);
    return new zw(this, {
      className: this.getClassName(),
      variables: this.styleVariables_,
      style: {
        builder: e,
        attributes: {
          ...h,
          ...a
        },
        uniforms: {
          ...u,
          ...o
        }
      },
      disableHitDetection: !1,
      postProcesses: [
        {
          fragmentShader: `
            precision mediump float;

            uniform sampler2D u_image;
            uniform sampler2D u_gradientTexture;
            uniform float u_opacity;

            varying vec2 v_texCoord;

            void main() {
              vec4 color = texture2D(u_image, v_texCoord);
              gl_FragColor.a = color.a * u_opacity;
              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;
              gl_FragColor.rgb *= gl_FragColor.a;
            }`,
          uniforms: {
            u_gradientTexture: () => this.gradient_,
            u_opacity: () => this.getOpacity()
          }
        }
      ]
    });
  }
  /**
   * Update any variables used by the layer style and trigger a re-render.
   * @param {import('../style/flat.js').StyleVariables} variables Variables to update.
   */
  updateStyleVariables(e) {
    Object.assign(this.styleVariables_, e), this.changed();
  }
  /**
   * @override
   */
  renderDeclutter() {
  }
}
function DO(i) {
  const n = ot(1, 256), r = n.createLinearGradient(0, 0, 1, 256), s = 1 / (i.length - 1);
  for (let o = 0, a = i.length; o < a; ++o)
    r.addColorStop(o * s, i[o]);
  return n.fillStyle = r, n.fillRect(0, 0, 1, 256), n.canvas;
}
class h0 extends Rf {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {HTMLCanvasElement|OffscreenCanvas} canvas Canvas.
   * @param {Loader} [loader] Optional loader function to
   *     support asynchronous canvas drawing.
   */
  constructor(e, t, n, r, s) {
    const o = s !== void 0 ? se.IDLE : se.LOADED;
    super(e, t, n, o), this.loader_ = s !== void 0 ? s : null, this.canvas_ = r, this.error_ = null;
  }
  /**
   * Get any error associated with asynchronous rendering.
   * @return {?Error} Any error that occurred during rendering.
   */
  getError() {
    return this.error_;
  }
  /**
   * Handle async drawing complete.
   * @param {Error} [err] Any error during drawing.
   * @private
   */
  handleLoad_(e) {
    e ? (this.error_ = e, this.state = se.ERROR) : this.state = se.LOADED, this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    this.state == se.IDLE && (this.state = se.LOADING, this.changed(), this.loader_(this.handleLoad_.bind(this)));
  }
  /**
   * @return {HTMLCanvasElement|OffscreenCanvas} Canvas element.
   * @override
   */
  getImage() {
    return this.canvas_;
  }
}
function Oc(i) {
  return Array.isArray(i) ? Math.min(...i) : i;
}
class Bw extends zm {
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */
  constructor(e) {
    super(e), this.image = null;
  }
  /**
   * @return {import('../../DataTile.js').ImageLike} Image.
   */
  getImage() {
    return this.image ? this.image.getImage() : null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(e) {
    const t = e.layerStatesArray[e.layerIndex], n = e.pixelRatio, r = e.viewState, s = r.resolution, o = this.getLayer().getSource(), a = e.viewHints;
    let l = e.extent;
    if (t.extent !== void 0 && (l = kt(
      l,
      xn(t.extent, r.projection)
    )), !a[Xe.ANIMATING] && !a[Xe.INTERACTING] && !qn(l))
      if (o) {
        const h = r.projection, u = o.getImage(
          l,
          s,
          n,
          h
        );
        u && (this.loadImage(u) ? this.image = u : u.getState() === se.EMPTY && (this.image = null));
      } else
        this.image = null;
    return !!this.image;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   * @override
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const n = this.getLayer(), r = rt(
      t.pixelToCoordinateTransform,
      e.slice()
    ), s = n.getExtent();
    if (s && !nn(s, r))
      return null;
    const o = this.image.getExtent(), a = this.image.getImage(), l = _e(o), h = Math.floor(
      a.width * ((r[0] - o[0]) / l)
    );
    if (h < 0 || h >= a.width)
      return null;
    const u = it(o), c = Math.floor(
      a.height * ((o[3] - r[1]) / u)
    );
    return c < 0 || c >= a.height ? null : this.getImageData(a, h, c);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(e, t) {
    const n = this.image, r = n.getExtent(), s = n.getResolution(), [o, a] = Array.isArray(s) ? s : [s, s], l = n.getPixelRatio(), h = e.layerStatesArray[e.layerIndex], u = e.pixelRatio, c = e.viewState, f = c.center, g = c.resolution, d = u * o / (g * l), m = u * a / (g * l);
    this.prepareContainer(e, t);
    const x = this.context.canvas.width, v = this.context.canvas.height, p = this.getRenderContext(e);
    let y = !1, E = !0;
    if (h.extent) {
      const C = xn(
        h.extent,
        c.projection
      );
      E = ft(C, e.extent), y = E && !Bi(C, e.extent), y && this.clipUnrotated(p, e, C);
    }
    const b = n.getImage(), T = un(
      this.tempTransform,
      x / 2,
      v / 2,
      d,
      m,
      0,
      l * (r[0] - f[0]) / o,
      l * (f[1] - r[3]) / a
    );
    this.renderedResolution = a * u / l;
    const R = b.width * T[0], M = b.height * T[3];
    if (this.getLayer().getSource().getInterpolate() || (p.imageSmoothingEnabled = !1), this.preRender(p, e), E && R >= 0.5 && M >= 0.5) {
      const C = T[4], I = T[5], O = h.opacity;
      O !== 1 && (p.save(), p.globalAlpha = O), p.drawImage(b, 0, 0, +b.width, +b.height, C, I, R, M), O !== 1 && p.restore();
    }
    return this.postRender(this.context, e), y && p.restore(), p.imageSmoothingEnabled = !0, this.container;
  }
}
class GO extends Bw {
  /**
   * @param {import("../../layer/VectorImage.js").default} layer Vector image layer.
   */
  constructor(e) {
    super(e), this.vectorRenderer_ = new cw(e), this.layerImageRatio_ = e.getImageRatio(), this.coordinateToVectorPixelTransform_ = st(), this.renderedPixelToCoordinateTransform_ = null;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.vectorRenderer_.dispose(), super.disposeInternal();
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   * @override
   */
  getFeatures(e) {
    if (!this.vectorRenderer_)
      return Promise.resolve([]);
    const t = rt(
      this.coordinateToVectorPixelTransform_,
      rt(this.renderedPixelToCoordinateTransform_, e.slice())
    );
    return this.vectorRenderer_.getFeatures(t);
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @override
   */
  handleFontsChanged() {
    this.vectorRenderer_.handleFontsChanged();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(e) {
    const t = e.pixelRatio, n = e.viewState, r = n.resolution, s = e.viewHints, o = this.vectorRenderer_;
    let a = e.extent;
    this.layerImageRatio_ !== 1 && (a = a.slice(0), xE(a, this.layerImageRatio_));
    const l = _e(a) / r, h = it(a) / r;
    if (!s[Xe.ANIMATING] && !s[Xe.INTERACTING] && !qn(a)) {
      o.useContainer(null, null);
      const u = o.context, c = e.layerStatesArray[e.layerIndex], f = Object.assign({}, c, { opacity: 1 }), g = (
        /** @type {import("../../Map.js").FrameState} */
        Object.assign({}, e, {
          extent: a,
          size: [l, h],
          viewState: (
            /** @type {import("../../View.js").State} */
            Object.assign({}, e.viewState, {
              rotation: 0
            })
          ),
          layerStatesArray: [f],
          layerIndex: 0,
          declutter: null
        })
      ), d = this.getLayer().getDeclutter();
      d && (g.declutter = {
        [d]: new km(9)
      });
      const m = new h0(
        a,
        r,
        t,
        u.canvas,
        function(x) {
          o.prepareFrame(g) && o.replayGroupChanged && (o.clipping = !1, o.renderFrame(g, null), o.renderDeclutter(g), o.renderDeferred(g), x());
        }
      );
      m.addEventListener(le.CHANGE, () => {
        if (m.getState() !== se.LOADED)
          return;
        this.image = m;
        const x = m.getPixelRatio(), v = Oc(m.getResolution()) * t / x;
        this.renderedResolution = v, this.coordinateToVectorPixelTransform_ = un(
          this.coordinateToVectorPixelTransform_,
          l / 2,
          h / 2,
          1 / v,
          -1 / v,
          0,
          -n.center[0],
          -n.center[1]
        );
      }), m.load();
    }
    return this.image && (this.renderedPixelToCoordinateTransform_ = e.pixelToCoordinateTransform.slice()), !this.getLayer().getSource()?.loading && !!this.image;
  }
  /**
   * @override
   */
  preRender() {
  }
  /**
   * @override
   */
  postRender() {
  }
  /**
   */
  renderDeclutter() {
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   * @override
   */
  forEachFeatureAtCoordinate(e, t, n, r, s) {
    return this.vectorRenderer_ ? this.vectorRenderer_.forEachFeatureAtCoordinate(
      e,
      t,
      n,
      r,
      s
    ) : super.forEachFeatureAtCoordinate(
      e,
      t,
      n,
      r,
      s
    );
  }
}
class kO extends bo {
  /**
   * @param {Options<VectorSourceType, FeatureType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.imageRatio, super(t), this.imageRatio_ = e.imageRatio !== void 0 ? e.imageRatio : 1;
  }
  /**
   * @return {number} Ratio between rendered extent size and viewport extent size.
   */
  getImageRatio() {
    return this.imageRatio_;
  }
  /**
   * @override
   */
  createRenderer() {
    return new GO(this);
  }
}
class UO extends kh {
  /**
   * @param {import("../../layer/Layer.js").default} layer Layer.
   * @param {Options} options Options.
   */
  constructor(e, t) {
    const n = t.uniforms || {}, r = st();
    n[rr.PROJECTION_MATRIX] = r, super(e, {
      uniforms: n,
      postProcesses: t.postProcesses
    }), this.sourceRevision_ = -1, this.verticesBuffer_ = new xs(fo, ha), this.instanceAttributesBuffer_ = new xs(
      fo,
      ha
    ), this.indicesBuffer_ = new xs(
      Dh,
      ha
    ), this.vertexShader_ = t.vertexShader, this.fragmentShader_ = t.fragmentShader, this.program_, this.hitDetectionEnabled_ = t.hitDetectionEnabled ?? !0;
    const s = t.attributes ? t.attributes.map(function(a) {
      return {
        name: "a_" + a.name,
        size: 1,
        type: Rt.FLOAT
      };
    }) : [];
    this.attributes = [
      {
        name: "a_localPosition",
        size: 2,
        type: Rt.FLOAT
      }
    ], this.instanceAttributes = [
      {
        name: "a_position",
        size: 2,
        type: Rt.FLOAT
      }
    ], this.hitDetectionEnabled_ && (this.instanceAttributes.push({
      name: "a_hitColor",
      size: 2,
      type: Rt.FLOAT
    }), this.instanceAttributes.push({
      name: "a_featureUid",
      size: 1,
      type: Rt.FLOAT
    })), this.instanceAttributes.push(...s), this.customAttributes = t.attributes ? t.attributes : [], this.previousExtent_ = hi(), this.currentTransform_ = r, this.renderTransform_ = st(), this.invertRenderTransform_ = st(), this.renderInstructions_ = new Float32Array(0), this.hitRenderTarget_, this.lastSentId = 0, this.worker_ = Ow(), this.worker_.addEventListener(
      "message",
      /**
       * @param {*} event Event.
       */
      (a) => {
        const l = a.data;
        if (l.type === Nl.GENERATE_POINT_BUFFERS) {
          const h = l.projectionTransform;
          this.verticesBuffer_.fromArrayBuffer(l.vertexAttributesBuffer), this.instanceAttributesBuffer_.fromArrayBuffer(
            l.instanceAttributesBuffer
          ), this.helper.flushBufferData(this.verticesBuffer_), this.helper.flushBufferData(this.instanceAttributesBuffer_), this.indicesBuffer_.fromArrayBuffer(l.indicesBuffer), this.helper.flushBufferData(this.indicesBuffer_), this.renderTransform_ = h, lo(
            this.invertRenderTransform_,
            this.renderTransform_
          ), this.renderInstructions_ = new Float32Array(
            a.data.renderInstructions
          ), l.id === this.lastSentId && (this.ready = !0), this.getLayer().changed();
        }
      }
    ), this.featureCache_ = {}, this.featureCount_ = 0;
    const o = (
      /** @type {import("../../source/Vector.js").default} */
      this.getLayer().getSource()
    );
    this.sourceListenKeys_ = [
      Ce(
        o,
        Bt.ADDFEATURE,
        this.handleSourceFeatureAdded_,
        this
      ),
      Ce(
        o,
        Bt.CHANGEFEATURE,
        this.handleSourceFeatureChanged_,
        this
      ),
      Ce(
        o,
        Bt.REMOVEFEATURE,
        this.handleSourceFeatureDelete_,
        this
      ),
      Ce(
        o,
        Bt.CLEAR,
        this.handleSourceFeatureClear_,
        this
      )
    ], o.forEachFeature((a) => {
      const l = a.getGeometry();
      l && l.getType() === "Point" && (this.featureCache_[ie(a)] = {
        feature: (
          /** @type {PointFeature} */
          a
        ),
        properties: a.getProperties(),
        flatCoordinates: (
          /** @type {Point} */
          l.getFlatCoordinates()
        )
      }, this.featureCount_++);
    });
  }
  /**
   * @override
   */
  afterHelperCreated() {
    this.program_ = this.helper.getProgram(
      this.fragmentShader_,
      this.vertexShader_
    ), this.hitDetectionEnabled_ && (this.hitRenderTarget_ = new kw(this.helper)), this.verticesBuffer_.getArray() && this.helper.flushBufferData(this.verticesBuffer_), this.indicesBuffer_.getArray() && this.helper.flushBufferData(this.indicesBuffer_);
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureAdded_(e) {
    const t = e.feature, n = t.getGeometry();
    n && n.getType() === "Point" && (this.featureCache_[ie(t)] = {
      feature: (
        /** @type {PointFeature} */
        t
      ),
      properties: t.getProperties(),
      flatCoordinates: (
        /** @type {Point} */
        n.getFlatCoordinates()
      )
    }, this.featureCount_++);
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureChanged_(e) {
    const t = e.feature, n = ie(t), r = this.featureCache_[n], s = t.getGeometry();
    r ? s && s.getType() === "Point" ? (r.properties = t.getProperties(), r.flatCoordinates = /** @type {Point} */
    s.getFlatCoordinates()) : (delete this.featureCache_[n], this.featureCount_--) : s && s.getType() === "Point" && (this.featureCache_[n] = {
      feature: (
        /** @type {PointFeature} */
        t
      ),
      properties: t.getProperties(),
      flatCoordinates: (
        /** @type {Point} */
        s.getFlatCoordinates()
      )
    }, this.featureCount_++);
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureDelete_(e) {
    const t = e.feature, n = ie(t);
    n in this.featureCache_ && (delete this.featureCache_[n], this.featureCount_--);
  }
  /**
   * @private
   */
  handleSourceFeatureClear_() {
    this.featureCache_ = {}, this.featureCount_ = 0;
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(e) {
    const t = this.helper.getGL();
    this.preRender(t, e);
    const [n, r, s] = Uw(
      e,
      this.getLayer()
    );
    return this.renderWorlds(e, !1, n, r, s), this.helper.finalizeDraw(
      e,
      this.dispatchPreComposeEvent,
      this.dispatchPostComposeEvent
    ), this.hitDetectionEnabled_ && (this.renderWorlds(e, !0, n, r, s), this.hitRenderTarget_.clearCachedData()), this.postRender(t, e), this.helper.getCanvas();
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrameInternal(e) {
    const t = this.getLayer(), n = t.getSource(), r = e.viewState, s = !e.viewHints[Xe.ANIMATING] && !e.viewHints[Xe.INTERACTING], o = !Pn(this.previousExtent_, e.extent), a = this.sourceRevision_ < n.getRevision();
    if (a && (this.sourceRevision_ = n.getRevision()), s && (o || a)) {
      const l = r.projection, h = r.resolution, u = t instanceof bo ? t.getRenderBuffer() : 0, c = ln(e.extent, u * h);
      n.loadFeatures(c, h, l), this.rebuildBuffers_(e), this.previousExtent_ = e.extent.slice();
    }
    return this.helper.useProgram(this.program_, e), this.helper.prepareDraw(e), !0;
  }
  /**
   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  rebuildBuffers_(e) {
    const t = st();
    this.helper.makeProjectionTransform(e, t);
    const r = (this.hitDetectionEnabled_ ? 5 : 2) + this.customAttributes.length, s = r * this.featureCount_, o = this.renderInstructions_ && this.renderInstructions_.length === s ? this.renderInstructions_ : new Float32Array(s);
    this.renderInstructions_ = null;
    let a = [];
    const l = [];
    let h = -1;
    e.viewState.projection;
    for (const c in this.featureCache_) {
      const f = this.featureCache_[c];
      if (a[0] = f.flatCoordinates[0], a[1] = f.flatCoordinates[1], rt(t, a), o[++h] = a[0], o[++h] = a[1], this.hitDetectionEnabled_) {
        const g = Nw(h + 3, l);
        o[++h] = g[0], o[++h] = g[1], o[++h] = Number(c);
      }
      for (let g = 0; g < this.customAttributes.length; g++) {
        const d = this.customAttributes[g].callback(
          f.feature,
          f.properties
        );
        o[++h] = d;
      }
    }
    const u = {
      id: ++this.lastSentId,
      type: Nl.GENERATE_POINT_BUFFERS,
      renderInstructions: o.buffer,
      customAttributesSize: r - 2
    };
    u.projectionTransform = t, this.ready = !1, this.worker_.postMessage(u, [o.buffer]);
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   * @override
   */
  forEachFeatureAtCoordinate(e, t, n, r, s) {
    if (Te(
      this.hitDetectionEnabled_,
      "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."
    ), !this.renderInstructions_ || !this.hitDetectionEnabled_)
      return;
    const o = rt(
      t.coordinateToPixelTransform,
      e.slice()
    ), a = this.hitRenderTarget_.readPixel(o[0] / 2, o[1] / 2), l = [a[0] / 255, a[1] / 255, a[2] / 255, a[3] / 255], h = Dw(l), u = this.renderInstructions_[h], c = Math.floor(u).toString(), g = this.getLayer().getSource().getFeatureByUid(c);
    if (g)
      return r(g, this.getLayer(), null);
  }
  /**
   * Render the world, either to the main framebuffer or to the hit framebuffer
   * @param {import("../../Map.js").FrameState} frameState current frame state
   * @param {boolean} forHitDetection whether the rendering is for hit detection
   * @param {number} startWorld the world to render in the first iteration
   * @param {number} endWorld the last world to render
   * @param {number} worldWidth the width of the worlds being rendered
   */
  renderWorlds(e, t, n, r, s) {
    let o = n;
    this.helper.useProgram(this.program_, e), t && (this.hitRenderTarget_.setSize([
      Math.floor(e.size[0] / 2),
      Math.floor(e.size[1] / 2)
    ]), this.helper.prepareDrawToRenderTarget(
      e,
      this.hitRenderTarget_,
      !0
    ));
    const a = this.instanceAttributes.reduce(
      (h, u) => h + (u.size || 1),
      0
    ), l = this.instanceAttributesBuffer_.getSize() / a;
    do {
      this.helper.bindBuffer(this.indicesBuffer_), this.helper.bindBuffer(this.verticesBuffer_), this.helper.enableAttributes(this.attributes), this.helper.bindBuffer(this.instanceAttributesBuffer_), this.helper.enableAttributesInstanced(this.instanceAttributes), this.helper.makeProjectionTransform(e, this.currentTransform_), xf(this.currentTransform_, o * s, 0), zr(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(e), this.helper.applyHitDetectionUniform(t);
      const h = this.indicesBuffer_.getSize();
      this.helper.drawElementsInstanced(0, h, l);
    } while (++o < r);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.worker_.terminate(), this.sourceListenKeys_.forEach(function(e) {
      tt(e);
    }), this.sourceListenKeys_ = null, super.disposeInternal();
  }
  renderDeclutter() {
  }
}
class zO extends Yr {
  /**
   * @param {Options<VectorSourceType>} options Options.
   */
  constructor(e) {
    const t = Object.assign({}, e);
    super(t), this.styleVariables_ = e.variables || {}, this.parseResult_ = tp(
      e.style,
      this.styleVariables_,
      e.filter
    ), this.hitDetectionDisabled_ = !!e.disableHitDetection;
  }
  /**
   * @override
   */
  createRenderer() {
    const e = Object.keys(this.parseResult_.attributes).map(
      (t) => ({
        name: t,
        ...this.parseResult_.attributes[t]
      })
    );
    return new UO(this, {
      vertexShader: this.parseResult_.builder.getSymbolVertexShader(),
      fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),
      hitDetectionEnabled: !this.hitDetectionDisabled_,
      uniforms: this.parseResult_.uniforms,
      attributes: (
        /** @type {Array<import('../renderer/webgl/PointsLayer.js').CustomAttribute>} */
        e
      )
    });
  }
  /**
   * Update any variables used by the layer style and trigger a re-render.
   * @param {Object<string, number>} variables Variables to update.
   */
  updateStyleVariables(e) {
    Object.assign(this.styleVariables_, e), this.changed();
  }
}
const gs = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class $w extends Yr {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e), n = e.cacheSize;
    delete e.cacheSize, delete t.preload, delete t.useInterimTilesOnError, super(t), this.on, this.once, this.un, this.cacheSize_ = n, this.setPreload(e.preload !== void 0 ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    );
  }
  /**
   * @return {number|undefined} The suggested cache size
   * @protected
   */
  getCacheSize() {
    return this.cacheSize_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(gs.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set(gs.PRELOAD, e);
  }
  /**
   * Deprecated.  Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(gs.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Deprecated.  Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set(gs.USE_INTERIM_TILES_ON_ERROR, e);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   * @override
   */
  getData(e) {
    return super.getData(e);
  }
}
function g1(i, e) {
  const t = `
    attribute vec2 ${Xu.TEXTURE_COORD};
    uniform mat4 ${Pe.TILE_TRANSFORM};
    uniform float ${Pe.TEXTURE_PIXEL_WIDTH};
    uniform float ${Pe.TEXTURE_PIXEL_HEIGHT};
    uniform float ${Pe.TEXTURE_RESOLUTION};
    uniform float ${Pe.TEXTURE_ORIGIN_X};
    uniform float ${Pe.TEXTURE_ORIGIN_Y};
    uniform float ${Pe.DEPTH};

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;

    void main() {
      v_textureCoord = ${Xu.TEXTURE_COORD};
      v_mapCoord = vec2(
        ${Pe.TEXTURE_ORIGIN_X} + ${Pe.TEXTURE_RESOLUTION} * ${Pe.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],
        ${Pe.TEXTURE_ORIGIN_Y} - ${Pe.TEXTURE_RESOLUTION} * ${Pe.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]
      );
      gl_Position = ${Pe.TILE_TRANSFORM} * vec4(${Xu.TEXTURE_COORD}, ${Pe.DEPTH}, 1.0);
    }
  `, n = {
    ...i0(),
    bandCount: e
  }, r = [];
  if (i.color !== void 0) {
    const c = me(n, i.color, mt);
    r.push(`color = ${c};`);
  }
  if (i.contrast !== void 0) {
    const c = me(n, i.contrast, oe);
    r.push(
      `color.rgb = clamp((${c} + 1.0) * color.rgb - (${c} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`
    );
  }
  if (i.exposure !== void 0) {
    const c = me(n, i.exposure, oe);
    r.push(
      `color.rgb = clamp((${c} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`
    );
  }
  if (i.saturation !== void 0) {
    const c = me(n, i.saturation, oe);
    r.push(`
      float saturation = ${c} + 1.0;
      float sr = (1.0 - saturation) * 0.2126;
      float sg = (1.0 - saturation) * 0.7152;
      float sb = (1.0 - saturation) * 0.0722;
      mat3 saturationMatrix = mat3(
        sr + saturation, sr, sr,
        sg, sg + saturation, sg,
        sb, sb, sb + saturation
      );
      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
    `);
  }
  if (i.gamma !== void 0) {
    const c = me(n, i.gamma, oe);
    r.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${c}));`);
  }
  if (i.brightness !== void 0) {
    const c = me(n, i.brightness, oe);
    r.push(
      `color.rgb = clamp(color.rgb + ${c}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`
    );
  }
  const s = {}, o = Object.keys(n.variables).length;
  if (o > 1 && !i.variables)
    throw new Error(
      `Missing variables in style (expected ${n.variables})`
    );
  for (let c = 0; c < o; ++c) {
    const f = n.variables[Object.keys(n.variables)[c]];
    if (!(f.name in i.variables))
      throw new Error(`Missing '${f.name}' in style variables`);
    const g = zf(f.name);
    s[g] = function() {
      let d = i.variables[f.name];
      return typeof d == "string" && (d = Pa(d)), d !== void 0 ? d : -9999999;
    };
  }
  const a = Object.keys(s).map(function(c) {
    return `uniform float ${c};`;
  }), l = Math.ceil(e / 4);
  a.push(
    `uniform sampler2D ${Pe.TILE_TEXTURE_ARRAY}[${l}];`
  ), n.paletteTextures && a.push(
    `uniform sampler2D ${Pw}[${n.paletteTextures.length}];`
  );
  const h = Object.keys(n.functions).map(
    function(c) {
      return n.functions[c];
    }
  ), u = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;
    uniform vec4 ${Pe.RENDER_EXTENT};
    uniform float ${Pe.TRANSITION_ALPHA};
    uniform float ${Pe.TEXTURE_PIXEL_WIDTH};
    uniform float ${Pe.TEXTURE_PIXEL_HEIGHT};
    uniform float ${Pe.RESOLUTION};
    uniform float ${Pe.ZOOM};

    ${a.join(`
`)}

    ${h.join(`
`)}

    void main() {
      if (
        v_mapCoord[0] < ${Pe.RENDER_EXTENT}[0] ||
        v_mapCoord[1] < ${Pe.RENDER_EXTENT}[1] ||
        v_mapCoord[0] > ${Pe.RENDER_EXTENT}[2] ||
        v_mapCoord[1] > ${Pe.RENDER_EXTENT}[3]
      ) {
        discard;
      }

      vec4 color = texture2D(${Pe.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);

      ${r.join(`
`)}

      gl_FragColor = color;
      gl_FragColor.rgb *= gl_FragColor.a;
      gl_FragColor *= ${Pe.TRANSITION_ALPHA};
    }`;
  return {
    vertexShader: t,
    fragmentShader: u,
    uniforms: s,
    paletteTextures: n.paletteTextures
  };
}
class Nc extends $w {
  /**
   * @param {Options} [options] Tile layer options.
   */
  constructor(e) {
    e = e ? Object.assign({}, e) : {};
    const t = e.style || {};
    delete e.style, super(e), this.sources_ = e.sources, this.renderedSource_ = null, this.renderedResolution_ = NaN, this.style_ = t, this.styleVariables_ = this.style_.variables || {}, this.handleSourceUpdate_(), this.addChangeListener(je.SOURCE, this.handleSourceUpdate_);
  }
  /**
   * Gets the sources for this layer, for a given extent and resolution.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @return {Array<SourceType>} Sources.
   */
  getSources(e, t) {
    const n = this.getSource();
    return this.sources_ ? typeof this.sources_ == "function" ? this.sources_(e, t) : this.sources_ : n ? [n] : [];
  }
  /**
   * @return {SourceType} The source being rendered.
   * @override
   */
  getRenderSource() {
    return this.renderedSource_ || this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    const e = this.getRenderSource();
    return e ? e.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceUpdate_() {
    this.hasRenderer() && this.getRenderer().clearCache();
    const e = this.getSource();
    if (e)
      if (e.getState() === "loading") {
        const t = () => {
          e.getState() === "ready" && (e.removeEventListener("change", t), this.setStyle(this.style_));
        };
        e.addEventListener("change", t);
      } else
        this.setStyle(this.style_);
  }
  /**
   * @private
   * @return {number} The number of source bands.
   */
  getSourceBandCount_() {
    const e = Number.MAX_SAFE_INTEGER, t = this.getSources([-e, -e, e, e], e);
    return t && t.length && "bandCount" in t[0] ? t[0].bandCount : 4;
  }
  /**
   * @override
   */
  createRenderer() {
    const e = g1(this.style_, this.getSourceBandCount_());
    return new hO(this, {
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader,
      uniforms: e.uniforms,
      cacheSize: this.getCacheSize(),
      paletteTextures: e.paletteTextures
    });
  }
  /**
   * @param {import("../Map").FrameState} frameState Frame state.
   * @param {Array<SourceType>} sources Sources.
   * @return {HTMLElement} Canvas.
   */
  renderSources(e, t) {
    const n = this.getRenderer();
    let r;
    for (let s = 0, o = t.length; s < o; ++s)
      this.renderedSource_ = t[s], n.prepareFrame(e) && (r = n.renderFrame(e));
    return r;
  }
  /**
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  render(e, t) {
    this.rendered = !0;
    const n = e.viewState, r = this.getSources(e.extent, n.resolution);
    let s = !0;
    for (let a = 0, l = r.length; a < l; ++a) {
      const h = r[a], u = h.getState();
      if (u == "loading") {
        const c = () => {
          h.getState() == "ready" && (h.removeEventListener("change", c), this.changed());
        };
        h.addEventListener("change", c);
      }
      s = s && u == "ready";
    }
    const o = this.renderSources(e, r);
    if (this.getRenderer().renderComplete && s)
      return this.renderedResolution_ = n.resolution, o;
    if (this.renderedResolution_ > 0.5 * n.resolution) {
      const a = this.getSources(
        e.extent,
        this.renderedResolution_
      ).filter((l) => !r.includes(l));
      if (a.length > 0)
        return this.renderSources(e, a);
    }
    return o;
  }
  /**
   * Update the layer style.  The `updateStyleVariables` function is a more efficient
   * way to update layer rendering.  In cases where the whole style needs to be updated,
   * this method may be called instead.  Note that calling this method will also replace
   * any previously set variables, so the new style also needs to include new variables,
   * if needed.
   * @param {Style} style The new style.
   */
  setStyle(e) {
    if (this.styleVariables_ = e.variables || {}, this.style_ = e, this.hasRenderer()) {
      const t = g1(this.style_, this.getSourceBandCount_());
      this.getRenderer().reset({
        vertexShader: t.vertexShader,
        fragmentShader: t.fragmentShader,
        uniforms: t.uniforms,
        paletteTextures: t.paletteTextures
      }), this.changed();
    }
  }
  /**
   * Update any variables used by the layer style and trigger a re-render.
   * @param {Object<string, number>} variables Variables to update.
   * @api
   */
  updateStyleVariables(e) {
    Object.assign(this.styleVariables_, e), this.changed();
  }
}
Nc.prototype.dispose;
class BO extends Yr {
  /**
   * @param {Options<VectorSourceType, FeatureType>} [options] Options.
   */
  constructor(e) {
    const t = Object.assign({}, e);
    super(t), this.styleVariables_ = e.variables || {}, this.style_ = e.style, this.hitDetectionDisabled_ = !!e.disableHitDetection;
  }
  /**
   * @override
   */
  createRenderer() {
    return new zw(this, {
      style: this.style_,
      variables: this.styleVariables_,
      disableHitDetection: this.hitDetectionDisabled_
    });
  }
  /**
   * Update any variables used by the layer style and trigger a re-render.
   * @param {import('../style/flat.js').StyleVariables} variables Variables to update.
   */
  updateStyleVariables(e) {
    Object.assign(this.styleVariables_, e), this.changed();
  }
  /**
   * Set the layer style.
   * @param {import('../style/flat.js').FlatStyleLike} style Layer style.
   */
  setStyle(e) {
    this.style_ = e, this.clearRenderer(), this.changed();
  }
}
var en = Uint8Array, Jo = Uint16Array, $O = Int32Array, jw = new en([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Xw = new en([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), jO = new en([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Vw = function(i, e) {
  for (var t = new Jo(31), n = 0; n < 31; ++n)
    t[n] = e += 1 << i[n - 1];
  for (var r = new $O(t[30]), n = 1; n < 30; ++n)
    for (var s = t[n]; s < t[n + 1]; ++s)
      r[s] = s - t[n] << 5 | n;
  return { b: t, r };
}, Ww = Vw(jw, 2), Yw = Ww.b, XO = Ww.r;
Yw[28] = 258, XO[258] = 28;
var VO = Vw(Xw, 0), WO = VO.b, ip = new Jo(32768);
for (var _t = 0; _t < 32768; ++_t) {
  var es = (_t & 43690) >> 1 | (_t & 21845) << 1;
  es = (es & 52428) >> 2 | (es & 13107) << 2, es = (es & 61680) >> 4 | (es & 3855) << 4, ip[_t] = ((es & 65280) >> 8 | (es & 255) << 8) >> 1;
}
var Dl = (function(i, e, t) {
  for (var n = i.length, r = 0, s = new Jo(e); r < n; ++r)
    i[r] && ++s[i[r] - 1];
  var o = new Jo(e);
  for (r = 1; r < e; ++r)
    o[r] = o[r - 1] + s[r - 1] << 1;
  var a;
  if (t) {
    a = new Jo(1 << e);
    var l = 15 - e;
    for (r = 0; r < n; ++r)
      if (i[r])
        for (var h = r << 4 | i[r], u = e - i[r], c = o[i[r] - 1]++ << u, f = c | (1 << u) - 1; c <= f; ++c)
          a[ip[c] >> l] = h;
  } else
    for (a = new Jo(n), r = 0; r < n; ++r)
      i[r] && (a[r] = ip[o[i[r] - 1]++] >> 15 - i[r]);
  return a;
}), Uh = new en(288);
for (var _t = 0; _t < 144; ++_t)
  Uh[_t] = 8;
for (var _t = 144; _t < 256; ++_t)
  Uh[_t] = 9;
for (var _t = 256; _t < 280; ++_t)
  Uh[_t] = 7;
for (var _t = 280; _t < 288; ++_t)
  Uh[_t] = 8;
var qw = new en(32);
for (var _t = 0; _t < 32; ++_t)
  qw[_t] = 5;
var YO = /* @__PURE__ */ Dl(Uh, 9, 1), qO = /* @__PURE__ */ Dl(qw, 5, 1), Wd = function(i) {
  for (var e = i[0], t = 1; t < i.length; ++t)
    i[t] > e && (e = i[t]);
  return e;
}, On = function(i, e, t) {
  var n = e / 8 | 0;
  return (i[n] | i[n + 1] << 8) >> (e & 7) & t;
}, Yd = function(i, e) {
  var t = e / 8 | 0;
  return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) >> (e & 7);
}, ZO = function(i) {
  return (i + 7) / 8 | 0;
}, HO = function(i, e, t) {
  return (t == null || t > i.length) && (t = i.length), new en(i.subarray(e, t));
}, KO = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], Ki = function(i, e, t) {
  var n = new Error(e || KO[i]);
  if (n.code = i, Error.captureStackTrace && Error.captureStackTrace(n, Ki), !t)
    throw n;
  return n;
}, u0 = function(i, e, t, n) {
  var r = i.length, s = 0;
  if (!r || e.f && !e.l)
    return t || new en(0);
  var o = !t, a = o || e.i != 2, l = e.i;
  o && (t = new en(r * 3));
  var h = function(Z) {
    var at = t.length;
    if (Z > at) {
      var ut = new en(Math.max(at * 2, Z));
      ut.set(t), t = ut;
    }
  }, u = e.f || 0, c = e.p || 0, f = e.b || 0, g = e.l, d = e.d, m = e.m, x = e.n, v = r * 8;
  do {
    if (!g) {
      u = On(i, c, 1);
      var p = On(i, c + 1, 3);
      if (c += 3, p)
        if (p == 1)
          g = YO, d = qO, m = 9, x = 5;
        else if (p == 2) {
          var T = On(i, c, 31) + 257, R = On(i, c + 10, 15) + 4, M = T + On(i, c + 5, 31) + 1;
          c += 14;
          for (var C = new en(M), I = new en(19), O = 0; O < R; ++O)
            I[jO[O]] = On(i, c + O * 3, 7);
          c += R * 3;
          for (var z = Wd(I), _ = (1 << z) - 1, w = Dl(I, z, 1), O = 0; O < M; ) {
            var S = w[On(i, c, _)];
            c += S & 15;
            var y = S >> 4;
            if (y < 16)
              C[O++] = y;
            else {
              var P = 0, A = 0;
              for (y == 16 ? (A = 3 + On(i, c, 3), c += 2, P = C[O - 1]) : y == 17 ? (A = 3 + On(i, c, 7), c += 3) : y == 18 && (A = 11 + On(i, c, 127), c += 7); A--; )
                C[O++] = P;
            }
          }
          var D = C.subarray(0, T), k = C.subarray(T);
          m = Wd(D), x = Wd(k), g = Dl(D, m, 1), d = Dl(k, x, 1);
        } else
          Ki(1);
      else {
        var y = ZO(c) + 4, E = i[y - 4] | i[y - 3] << 8, b = y + E;
        if (b > r) {
          l && Ki(0);
          break;
        }
        a && h(f + E), t.set(i.subarray(y, b), f), e.b = f += E, e.p = c = b * 8, e.f = u;
        continue;
      }
      if (c > v) {
        l && Ki(0);
        break;
      }
    }
    a && h(f + 131072);
    for (var U = (1 << m) - 1, G = (1 << x) - 1, $ = c; ; $ = c) {
      var P = g[Yd(i, c) & U], H = P >> 4;
      if (c += P & 15, c > v) {
        l && Ki(0);
        break;
      }
      if (P || Ki(2), H < 256)
        t[f++] = H;
      else if (H == 256) {
        $ = c, g = null;
        break;
      } else {
        var ne = H - 254;
        if (H > 264) {
          var O = H - 257, te = jw[O];
          ne = On(i, c, (1 << te) - 1) + Yw[O], c += te;
        }
        var re = d[Yd(i, c) & G], ae = re >> 4;
        re || Ki(3), c += re & 15;
        var k = WO[ae];
        if (ae > 3) {
          var te = Xw[ae];
          k += Yd(i, c) & (1 << te) - 1, c += te;
        }
        if (c > v) {
          l && Ki(0);
          break;
        }
        a && h(f + 131072);
        var Re = f + ne;
        if (f < k) {
          var xe = s - k, Ae = Math.min(k, Re);
          for (xe + f < 0 && Ki(3); f < Ae; ++f)
            t[f] = n[xe + f];
        }
        for (; f < Re; ++f)
          t[f] = t[f - k];
      }
    }
    e.l = g, e.p = $, e.b = f, e.f = u, g && (u = 1, e.m = m, e.d = d, e.n = x);
  } while (!u);
  return f != t.length && o ? HO(t, 0, f) : t.subarray(0, f);
}, JO = /* @__PURE__ */ new en(0), QO = function(i) {
  (i[0] != 31 || i[1] != 139 || i[2] != 8) && Ki(6, "invalid gzip data");
  var e = i[3], t = 10;
  e & 4 && (t += (i[10] | i[11] << 8) + 2);
  for (var n = (e >> 3 & 1) + (e >> 4 & 1); n > 0; n -= !i[t++])
    ;
  return t + (e & 2);
}, e4 = function(i) {
  var e = i.length;
  return (i[e - 4] | i[e - 3] << 8 | i[e - 2] << 16 | i[e - 1] << 24) >>> 0;
}, t4 = function(i, e) {
  return ((i[0] & 15) != 8 || i[0] >> 4 > 7 || (i[0] << 8 | i[1]) % 31) && Ki(6, "invalid zlib data"), (i[1] >> 5 & 1) == 1 && Ki(6, "invalid zlib data: " + (i[1] & 32 ? "need" : "unexpected") + " dictionary"), (i[1] >> 3 & 4) + 2;
};
function i4(i, e) {
  return u0(i, { i: 2 }, e, e);
}
function n4(i, e) {
  var t = QO(i);
  return t + 8 > i.length && Ki(6, "invalid gzip data"), u0(i.subarray(t, -8), { i: 2 }, new en(e4(i)), e);
}
function r4(i, e) {
  return u0(i.subarray(t4(i), -4), { i: 2 }, e, e);
}
function s4(i, e) {
  return i[0] == 31 && i[1] == 139 && i[2] == 8 ? n4(i, e) : (i[0] & 15) != 8 || i[0] >> 4 > 7 || (i[0] << 8 | i[1]) % 31 ? i4(i, e) : r4(i, e);
}
var o4 = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), a4 = 0;
try {
  o4.decode(JO, { stream: !0 }), a4 = 1;
} catch {
}
var l4 = Object.defineProperty, Gl = Math.pow, ht = (i, e) => l4(i, "name", { value: e, configurable: !0 }), si = (i, e, t) => new Promise((n, r) => {
  var s = (l) => {
    try {
      a(t.next(l));
    } catch (h) {
      r(h);
    }
  }, o = (l) => {
    try {
      a(t.throw(l));
    } catch (h) {
      r(h);
    }
  }, a = (l) => l.done ? n(l.value) : Promise.resolve(l.value).then(s, o);
  a((t = t.apply(i, e)).next());
});
ht((i, e) => {
  let t = !1, n = "", r = L.GridLayer.extend({ createTile: ht((s, o) => {
    let a = document.createElement("img"), l = new AbortController(), h = l.signal;
    return a.cancel = () => {
      l.abort();
    }, t || (i.getHeader().then((u) => {
      u.tileType === 1 ? console.error("Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.") : u.tileType === 2 ? n = "image/png" : u.tileType === 3 ? n = "image/jpeg" : u.tileType === 4 ? n = "image/webp" : u.tileType === 5 && (n = "image/avif");
    }), t = !0), i.getZxy(s.z, s.x, s.y, h).then((u) => {
      if (u) {
        let c = new Blob([u.data], { type: n }), f = window.URL.createObjectURL(c);
        a.src = f, a.cancel = void 0, o(void 0, a);
      }
    }).catch((u) => {
      if (u.name !== "AbortError") throw u;
    }), a;
  }, "createTile"), _removeTile: ht(function(s) {
    let o = this._tiles[s];
    o && (o.el.cancel && o.el.cancel(), o.el.width = 0, o.el.height = 0, o.el.deleted = !0, L.DomUtil.remove(o.el), delete this._tiles[s], this.fire("tileunload", { tile: o.el, coords: this._keyToTileCoords(s) }));
  }, "_removeTile") });
  return new r(e);
}, "leafletRasterLayer");
var h4 = ht((i) => (e, t) => {
  if (t instanceof AbortController) return i(e, t);
  let n = new AbortController();
  return i(e, n).then((r) => t(void 0, r.data, r.cacheControl || "", r.expires || ""), (r) => t(r)).catch((r) => t(r)), { cancel: ht(() => n.abort(), "cancel") };
}, "v3compat"), u4 = class {
  constructor(e) {
    this.tilev4 = ht((t, n) => si(this, null, function* () {
      if (t.type === "json") {
        let g = t.url.substr(10), d = this.tiles.get(g);
        if (d || (d = new sh(g), this.tiles.set(g, d)), this.metadata) return { data: yield d.getTileJson(t.url) };
        let m = yield d.getHeader();
        return (m.minLon >= m.maxLon || m.minLat >= m.maxLat) && console.error(`Bounds of PMTiles archive ${m.minLon},${m.minLat},${m.maxLon},${m.maxLat} are not valid.`), { data: { tiles: [`${t.url}/{z}/{x}/{y}`], minzoom: m.minZoom, maxzoom: m.maxZoom, bounds: [m.minLon, m.minLat, m.maxLon, m.maxLat] } };
      }
      let r = new RegExp(/pmtiles:\/\/(.+)\/(\d+)\/(\d+)\/(\d+)/), s = t.url.match(r);
      if (!s) throw new Error("Invalid PMTiles protocol URL");
      let o = s[1], a = this.tiles.get(o);
      a || (a = new sh(o), this.tiles.set(o, a));
      let l = s[2], h = s[3], u = s[4], c = yield a.getHeader(), f = yield a?.getZxy(+l, +h, +u, n.signal);
      if (f) return { data: new Uint8Array(f.data), cacheControl: f.cacheControl, expires: f.expires };
      if (c.tileType === 1) {
        if (this.errorOnMissingTile) throw new Error("Tile not found.");
        return { data: new Uint8Array() };
      }
      return { data: null };
    }), "tilev4"), this.tile = h4(this.tilev4), this.tiles = /* @__PURE__ */ new Map(), this.metadata = e?.metadata || !1, this.errorOnMissingTile = e?.errorOnMissingTile || !1;
  }
  add(e) {
    this.tiles.set(e.source.getKey(), e);
  }
  get(e) {
    return this.tiles.get(e);
  }
};
ht(u4, "Protocol");
function Zw(i, e) {
  return (e >>> 0) * 4294967296 + (i >>> 0);
}
ht(Zw, "toNum");
function Hw(i, e) {
  let t = e.buf, n = t[e.pos++], r = (n & 112) >> 4;
  if (n < 128 || (n = t[e.pos++], r |= (n & 127) << 3, n < 128) || (n = t[e.pos++], r |= (n & 127) << 10, n < 128) || (n = t[e.pos++], r |= (n & 127) << 17, n < 128) || (n = t[e.pos++], r |= (n & 127) << 24, n < 128) || (n = t[e.pos++], r |= (n & 1) << 31, n < 128)) return Zw(i, r);
  throw new Error("Expected varint not more than 10 bytes");
}
ht(Hw, "readVarintRemainder");
function Xo(i) {
  let e = i.buf, t = e[i.pos++], n = t & 127;
  return t < 128 || (t = e[i.pos++], n |= (t & 127) << 7, t < 128) || (t = e[i.pos++], n |= (t & 127) << 14, t < 128) || (t = e[i.pos++], n |= (t & 127) << 21, t < 128) ? n : (t = e[i.pos], n |= (t & 15) << 28, Hw(n, i));
}
ht(Xo, "readVarint");
function c0(i, e, t, n) {
  if (n === 0) {
    t === 1 && (e[0] = i - 1 - e[0], e[1] = i - 1 - e[1]);
    let r = e[0];
    e[0] = e[1], e[1] = r;
  }
}
ht(c0, "rotate");
function Kw(i, e) {
  let t = Gl(2, i), n = e, r = e, s = e, o = [0, 0], a = 1;
  for (; a < t; ) n = 1 & s / 2, r = 1 & (s ^ n), c0(a, o, n, r), o[0] += a * n, o[1] += a * r, s = s / 4, a *= 2;
  return [i, o[0], o[1]];
}
ht(Kw, "idOnLevel");
var c4 = [0, 1, 5, 21, 85, 341, 1365, 5461, 21845, 87381, 349525, 1398101, 5592405, 22369621, 89478485, 357913941, 1431655765, 5726623061, 22906492245, 91625968981, 366503875925, 1466015503701, 5864062014805, 23456248059221, 93824992236885, 375299968947541, 1501199875790165];
function Jw(i, e, t) {
  if (i > 26) throw new Error("Tile zoom level exceeds max safe number limit (26)");
  if (e > Gl(2, i) - 1 || t > Gl(2, i) - 1) throw new Error("tile x/y outside zoom level bounds");
  let n = c4[i], r = Gl(2, i), s = 0, o = 0, a = 0, l = [e, t], h = r / 2;
  for (; h > 0; ) s = (l[0] & h) > 0 ? 1 : 0, o = (l[1] & h) > 0 ? 1 : 0, a += h * h * (3 * s ^ o), c0(h, l, s, o), h = h / 2;
  return n + a;
}
ht(Jw, "zxyToTileId");
function f4(i) {
  let e = 0;
  for (let t = 0; t < 27; t++) {
    let n = (1 << t) * (1 << t);
    if (e + n > i) return Kw(t, i - e);
    e += n;
  }
  throw new Error("Tile zoom level exceeds max safe number limit (26)");
}
ht(f4, "tileIdToZxy");
var d4 = ((i) => (i[i.Unknown = 0] = "Unknown", i[i.None = 1] = "None", i[i.Gzip = 2] = "Gzip", i[i.Brotli = 3] = "Brotli", i[i.Zstd = 4] = "Zstd", i))(d4 || {});
function $f(i, e) {
  return si(this, null, function* () {
    if (e === 1 || e === 0) return i;
    if (e === 2) {
      if (typeof globalThis.DecompressionStream > "u") return s4(new Uint8Array(i));
      let t = new Response(i).body;
      if (!t) throw new Error("Failed to read response stream");
      let n = t.pipeThrough(new globalThis.DecompressionStream("gzip"));
      return new Response(n).arrayBuffer();
    }
    throw new Error("Compression method not supported");
  });
}
ht($f, "defaultDecompress");
var Vo = ((i) => (i[i.Unknown = 0] = "Unknown", i[i.Mvt = 1] = "Mvt", i[i.Png = 2] = "Png", i[i.Jpeg = 3] = "Jpeg", i[i.Webp = 4] = "Webp", i[i.Avif = 5] = "Avif", i))(Vo || {});
function Qw(i) {
  return i === 1 ? ".mvt" : i === 2 ? ".png" : i === 3 ? ".jpg" : i === 4 ? ".webp" : i === 5 ? ".avif" : "";
}
ht(Qw, "tileTypeExt");
var g4 = 127;
function eb(i, e) {
  let t = 0, n = i.length - 1;
  for (; t <= n; ) {
    let r = n + t >> 1, s = e - i[r].tileId;
    if (s > 0) t = r + 1;
    else if (s < 0) n = r - 1;
    else return i[r];
  }
  return n >= 0 && (i[n].runLength === 0 || e - i[n].tileId < i[n].runLength) ? i[n] : null;
}
ht(eb, "findTile");
var p4 = class {
  constructor(e) {
    this.file = e;
  }
  getKey() {
    return this.file.name;
  }
  getBytes(e, t) {
    return si(this, null, function* () {
      return { data: yield this.file.slice(e, e + t).arrayBuffer() };
    });
  }
};
ht(p4, "FileSource");
var tb = class {
  constructor(e, t = new Headers()) {
    this.url = e, this.customHeaders = t, this.mustReload = !1;
    let n = "";
    "navigator" in globalThis && (n = globalThis.navigator.userAgent || "");
    let r = n.indexOf("Windows") > -1, s = /Chrome|Chromium|Edg|OPR|Brave/.test(n);
    this.chromeWindowsNoCache = !1, r && s && (this.chromeWindowsNoCache = !0);
  }
  getKey() {
    return this.url;
  }
  setHeaders(e) {
    this.customHeaders = e;
  }
  getBytes(e, t, n, r) {
    return si(this, null, function* () {
      let s, o;
      n ? o = n : (s = new AbortController(), o = s.signal);
      let a = new Headers(this.customHeaders);
      a.set("range", `bytes=${e}-${e + t - 1}`);
      let l;
      this.mustReload ? l = "reload" : this.chromeWindowsNoCache && (l = "no-store");
      let h = yield fetch(this.url, { signal: o, cache: l, headers: a });
      if (e === 0 && h.status === 416) {
        let f = h.headers.get("Content-Range");
        if (!f || !f.startsWith("bytes */")) throw new Error("Missing content-length on 416 response");
        let g = +f.substr(8);
        h = yield fetch(this.url, { signal: o, cache: "reload", headers: { range: `bytes=0-${g - 1}` } });
      }
      let u = h.headers.get("Etag");
      if (u != null && u.startsWith("W/") && (u = null), h.status === 416 || r && u && u !== r) throw this.mustReload = !0, new np(`Server returned non-matching ETag ${r} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`);
      if (h.status >= 300) throw new Error(`Bad response code: ${h.status}`);
      let c = h.headers.get("Content-Length");
      if (h.status === 200 && (!c || +c > t)) throw s && s.abort(), new Error("Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.");
      return { data: yield h.arrayBuffer(), etag: u || void 0, cacheControl: h.headers.get("Cache-Control") || void 0, expires: h.headers.get("Expires") || void 0 };
    });
  }
};
ht(tb, "FetchSource");
var m4 = tb;
function pn(i, e) {
  let t = i.getUint32(e + 4, !0), n = i.getUint32(e + 0, !0);
  return t * Gl(2, 32) + n;
}
ht(pn, "getUint64");
function ib(i, e) {
  let t = new DataView(i), n = t.getUint8(7);
  if (n > 3) throw new Error(`Archive is spec version ${n} but this library supports up to spec version 3`);
  return { specVersion: n, rootDirectoryOffset: pn(t, 8), rootDirectoryLength: pn(t, 16), jsonMetadataOffset: pn(t, 24), jsonMetadataLength: pn(t, 32), leafDirectoryOffset: pn(t, 40), leafDirectoryLength: pn(t, 48), tileDataOffset: pn(t, 56), tileDataLength: pn(t, 64), numAddressedTiles: pn(t, 72), numTileEntries: pn(t, 80), numTileContents: pn(t, 88), clustered: t.getUint8(96) === 1, internalCompression: t.getUint8(97), tileCompression: t.getUint8(98), tileType: t.getUint8(99), minZoom: t.getUint8(100), maxZoom: t.getUint8(101), minLon: t.getInt32(102, !0) / 1e7, minLat: t.getInt32(106, !0) / 1e7, maxLon: t.getInt32(110, !0) / 1e7, maxLat: t.getInt32(114, !0) / 1e7, centerZoom: t.getUint8(118), centerLon: t.getInt32(119, !0) / 1e7, centerLat: t.getInt32(123, !0) / 1e7, etag: e };
}
ht(ib, "bytesToHeader");
function f0(i) {
  let e = { buf: new Uint8Array(i), pos: 0 }, t = Xo(e), n = [], r = 0;
  for (let s = 0; s < t; s++) {
    let o = Xo(e);
    n.push({ tileId: r + o, offset: 0, length: 0, runLength: 1 }), r += o;
  }
  for (let s = 0; s < t; s++) n[s].runLength = Xo(e);
  for (let s = 0; s < t; s++) n[s].length = Xo(e);
  for (let s = 0; s < t; s++) {
    let o = Xo(e);
    o === 0 && s > 0 ? n[s].offset = n[s - 1].offset + n[s - 1].length : n[s].offset = o - 1;
  }
  return n;
}
ht(f0, "deserializeIndex");
var nb = class extends Error {
};
ht(nb, "EtagMismatch");
var np = nb;
function d0(i, e) {
  return si(this, null, function* () {
    let t = yield i.getBytes(0, 16384);
    if (new DataView(t.data).getUint16(0, !0) !== 19792) throw new Error("Wrong magic number for PMTiles archive");
    let n = t.data.slice(0, g4), r = ib(n, t.etag), s = t.data.slice(r.rootDirectoryOffset, r.rootDirectoryOffset + r.rootDirectoryLength), o = `${i.getKey()}|${r.etag || ""}|${r.rootDirectoryOffset}|${r.rootDirectoryLength}`, a = f0(yield e(s, r.internalCompression));
    return [r, [o, a.length, a]];
  });
}
ht(d0, "getHeaderAndRoot");
function g0(i, e, t, n, r) {
  return si(this, null, function* () {
    let s = yield i.getBytes(t, n, void 0, r.etag), o = yield e(s.data, r.internalCompression), a = f0(o);
    if (a.length === 0) throw new Error("Empty directory is invalid");
    return a;
  });
}
ht(g0, "getDirectory");
var _4 = class {
  constructor(e = 100, t = !0, n = $f) {
    this.cache = /* @__PURE__ */ new Map(), this.maxCacheEntries = e, this.counter = 1, this.decompress = n;
  }
  getHeader(e) {
    return si(this, null, function* () {
      let t = e.getKey(), n = this.cache.get(t);
      if (n) return n.lastUsed = this.counter++, n.data;
      let r = yield d0(e, this.decompress);
      return r[1] && this.cache.set(r[1][0], { lastUsed: this.counter++, data: r[1][2] }), this.cache.set(t, { lastUsed: this.counter++, data: r[0] }), this.prune(), r[0];
    });
  }
  getDirectory(e, t, n, r) {
    return si(this, null, function* () {
      let s = `${e.getKey()}|${r.etag || ""}|${t}|${n}`, o = this.cache.get(s);
      if (o) return o.lastUsed = this.counter++, o.data;
      let a = yield g0(e, this.decompress, t, n, r);
      return this.cache.set(s, { lastUsed: this.counter++, data: a }), this.prune(), a;
    });
  }
  prune() {
    if (this.cache.size > this.maxCacheEntries) {
      let e = 1 / 0, t;
      this.cache.forEach((n, r) => {
        n.lastUsed < e && (e = n.lastUsed, t = r);
      }), t && this.cache.delete(t);
    }
  }
  invalidate(e) {
    return si(this, null, function* () {
      this.cache.delete(e.getKey());
    });
  }
};
ht(_4, "ResolvedValueCache");
var rb = class {
  constructor(e = 100, t = !0, n = $f) {
    this.cache = /* @__PURE__ */ new Map(), this.invalidations = /* @__PURE__ */ new Map(), this.maxCacheEntries = e, this.counter = 1, this.decompress = n;
  }
  getHeader(e) {
    return si(this, null, function* () {
      let t = e.getKey(), n = this.cache.get(t);
      if (n) return n.lastUsed = this.counter++, yield n.data;
      let r = new Promise((s, o) => {
        d0(e, this.decompress).then((a) => {
          a[1] && this.cache.set(a[1][0], { lastUsed: this.counter++, data: Promise.resolve(a[1][2]) }), s(a[0]), this.prune();
        }).catch((a) => {
          o(a);
        });
      });
      return this.cache.set(t, { lastUsed: this.counter++, data: r }), r;
    });
  }
  getDirectory(e, t, n, r) {
    return si(this, null, function* () {
      let s = `${e.getKey()}|${r.etag || ""}|${t}|${n}`, o = this.cache.get(s);
      if (o) return o.lastUsed = this.counter++, yield o.data;
      let a = new Promise((l, h) => {
        g0(e, this.decompress, t, n, r).then((u) => {
          l(u), this.prune();
        }).catch((u) => {
          h(u);
        });
      });
      return this.cache.set(s, { lastUsed: this.counter++, data: a }), a;
    });
  }
  prune() {
    if (this.cache.size >= this.maxCacheEntries) {
      let e = 1 / 0, t;
      this.cache.forEach((n, r) => {
        n.lastUsed < e && (e = n.lastUsed, t = r);
      }), t && this.cache.delete(t);
    }
  }
  invalidate(e) {
    return si(this, null, function* () {
      let t = e.getKey();
      if (this.invalidations.get(t)) return yield this.invalidations.get(t);
      this.cache.delete(e.getKey());
      let n = new Promise((r, s) => {
        this.getHeader(e).then((o) => {
          r(), this.invalidations.delete(t);
        }).catch((o) => {
          s(o);
        });
      });
      this.invalidations.set(t, n);
    });
  }
};
ht(rb, "SharedPromiseCache");
var y4 = rb, sb = class {
  constructor(e, t, n) {
    typeof e == "string" ? this.source = new m4(e) : this.source = e, n ? this.decompress = n : this.decompress = $f, t ? this.cache = t : this.cache = new y4();
  }
  getHeader() {
    return si(this, null, function* () {
      return yield this.cache.getHeader(this.source);
    });
  }
  getZxyAttempt(e, t, n, r) {
    return si(this, null, function* () {
      let s = Jw(e, t, n), o = yield this.cache.getHeader(this.source);
      if (e < o.minZoom || e > o.maxZoom) return;
      let a = o.rootDirectoryOffset, l = o.rootDirectoryLength;
      for (let h = 0; h <= 3; h++) {
        let u = yield this.cache.getDirectory(this.source, a, l, o), c = eb(u, s);
        if (c) {
          if (c.runLength > 0) {
            let f = yield this.source.getBytes(o.tileDataOffset + c.offset, c.length, r, o.etag);
            return { data: yield this.decompress(f.data, o.tileCompression), cacheControl: f.cacheControl, expires: f.expires };
          }
          a = o.leafDirectoryOffset + c.offset, l = c.length;
        } else return;
      }
      throw new Error("Maximum directory depth exceeded");
    });
  }
  getZxy(e, t, n, r) {
    return si(this, null, function* () {
      try {
        return yield this.getZxyAttempt(e, t, n, r);
      } catch (s) {
        if (s instanceof np) return this.cache.invalidate(this.source), yield this.getZxyAttempt(e, t, n, r);
        throw s;
      }
    });
  }
  getMetadataAttempt() {
    return si(this, null, function* () {
      let e = yield this.cache.getHeader(this.source), t = yield this.source.getBytes(e.jsonMetadataOffset, e.jsonMetadataLength, void 0, e.etag), n = yield this.decompress(t.data, e.internalCompression), r = new TextDecoder("utf-8");
      return JSON.parse(r.decode(n));
    });
  }
  getMetadata() {
    return si(this, null, function* () {
      try {
        return yield this.getMetadataAttempt();
      } catch (e) {
        if (e instanceof np) return this.cache.invalidate(this.source), yield this.getMetadataAttempt();
        throw e;
      }
    });
  }
  getTileJson(e) {
    return si(this, null, function* () {
      let t = yield this.getHeader(), n = yield this.getMetadata(), r = Qw(t.tileType);
      return { tilejson: "3.0.0", scheme: "xyz", tiles: [`${e}/{z}/{x}/{y}${r}`], vector_layers: n.vector_layers, attribution: n.attribution, description: n.description, name: n.name, version: n.version, bounds: [t.minLon, t.minLat, t.maxLon, t.maxLat], center: [t.centerLon, t.centerLat, t.centerZoom], minzoom: t.minZoom, maxzoom: t.maxZoom };
    });
  }
};
ht(sb, "PMTiles");
var sh = sb;
class x4 extends In {
  /**
   * @param {Error} error error object.
   * @api
   */
  constructor(e) {
    super(le.ERROR), this.error = e;
  }
}
class Dc extends gm {
  /**
   * @param {Options<FeatureType>} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(), this.dataProjection = ee(
      e.dataProjection ? e.dataProjection : "EPSG:4326"
    ), e.featureProjection && (this.defaultFeatureProjection = ee(e.featureProjection)), e.featureClass && (this.featureClass = e.featureClass), this.geometryName_ = e.geometryName, this.extractGeometryName_ = e.extractGeometryName, this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {FeatureType|Array<FeatureType>} Feature.
   * @override
   */
  readFeatureFromObject(e, t) {
    let n = null;
    e.type === "Feature" ? n = /** @type {GeoJSONFeature} */
    e : n = {
      type: "Feature",
      geometry: (
        /** @type {GeoJSONGeometry} */
        e
      ),
      properties: null
    };
    const r = p0(n.geometry);
    if (this.featureClass === fi)
      return (
        /** @type {FeatureType|Array<FeatureType>} */
        XE(
          {
            geometry: r,
            id: n.id,
            properties: n.properties
          },
          t
        )
      );
    const s = new li();
    return this.geometryName_ ? s.setGeometryName(this.geometryName_) : this.extractGeometryName_ && n.geometry_name && s.setGeometryName(n.geometry_name), s.setGeometry(dm(r, t)), "id" in n && s.setId(n.id), n.properties && s.setProperties(n.properties, !0), /** @type {FeatureType|Array<FeatureType>} */
    s;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<FeatureType>} Features.
   * @override
   */
  readFeaturesFromObject(e, t) {
    const n = (
      /** @type {GeoJSONObject} */
      e
    );
    let r = null;
    if (n.type === "FeatureCollection") {
      const s = (
        /** @type {GeoJSONFeatureCollection} */
        e
      );
      r = [];
      const o = s.features;
      for (let a = 0, l = o.length; a < l; ++a) {
        const h = this.readFeatureFromObject(
          o[a],
          t
        );
        h && r.push(h);
      }
    } else
      r = [this.readFeatureFromObject(e, t)];
    return (
      /** @type {Array<FeatureType>} */
      r.flat()
    );
  }
  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @override
   */
  readGeometryFromObject(e, t) {
    return E4(e, t);
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   * @override
   */
  readProjectionFromObject(e) {
    const t = e.crs;
    let n;
    if (t)
      if (t.type == "name")
        n = ee(t.properties.name);
      else if (t.type === "EPSG")
        n = ee("EPSG:" + t.properties.code);
      else
        throw new Error("Unknown SRS type");
    else
      n = this.dataProjection;
    return (
      /** @type {import("../proj/Projection.js").default} */
      n
    );
  }
  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   * @override
   */
  writeFeatureObject(e, t) {
    t = this.adaptOptions(t);
    const n = {
      type: "Feature",
      geometry: null,
      properties: null
    }, r = e.getId();
    if (r !== void 0 && (n.id = r), !e.hasProperties())
      return n;
    const s = e.getProperties(), o = e.getGeometry();
    return o && (n.geometry = rp(o, t), delete s[e.getGeometryName()]), Ur(s) || (n.properties = s), n;
  }
  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   * @override
   */
  writeFeaturesObject(e, t) {
    t = this.adaptOptions(t);
    const n = [];
    for (let r = 0, s = e.length; r < s; ++r)
      n.push(this.writeFeatureObject(e[r], t));
    return {
      type: "FeatureCollection",
      features: n
    };
  }
  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   * @override
   */
  writeGeometryObject(e, t) {
    return rp(e, this.adaptOptions(t));
  }
}
function p0(i, e) {
  if (!i)
    return null;
  let t;
  switch (i.type) {
    case "Point": {
      t = w4(
        /** @type {GeoJSONPoint} */
        i
      );
      break;
    }
    case "LineString": {
      t = b4(
        /** @type {GeoJSONLineString} */
        i
      );
      break;
    }
    case "Polygon": {
      t = P4(
        /** @type {GeoJSONPolygon} */
        i
      );
      break;
    }
    case "MultiPoint": {
      t = T4(
        /** @type {GeoJSONMultiPoint} */
        i
      );
      break;
    }
    case "MultiLineString": {
      t = S4(
        /** @type {GeoJSONMultiLineString} */
        i
      );
      break;
    }
    case "MultiPolygon": {
      t = R4(
        /** @type {GeoJSONMultiPolygon} */
        i
      );
      break;
    }
    case "GeometryCollection": {
      t = v4(
        /** @type {GeoJSONGeometryCollection} */
        i
      );
      break;
    }
    default:
      throw new Error("Unsupported GeoJSON type: " + i.type);
  }
  return t;
}
function E4(i, e) {
  const t = p0(i);
  return dm(t, e);
}
function v4(i, e) {
  return i.geometries.map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("./Feature.js").GeometryObject} geometry Geometry.
     */
    function(n) {
      return p0(n);
    }
  );
}
function w4(i) {
  const e = i.coordinates;
  return {
    type: "Point",
    flatCoordinates: e,
    layout: Eo(e.length)
  };
}
function b4(i) {
  const e = i.coordinates, t = e.flat();
  return {
    type: "LineString",
    flatCoordinates: t,
    ends: [t.length],
    layout: Eo(e[0]?.length || 2)
  };
}
function S4(i) {
  const e = i.coordinates, t = e[0]?.[0]?.length || 2, n = [], r = Rh(n, 0, e, t);
  return {
    type: "MultiLineString",
    flatCoordinates: n,
    ends: r,
    layout: Eo(t)
  };
}
function T4(i) {
  const e = i.coordinates;
  return {
    type: "MultiPoint",
    flatCoordinates: e.flat(),
    layout: Eo(e[0]?.length || 2)
  };
}
function R4(i) {
  const e = i.coordinates, t = [], n = e[0]?.[0]?.[0].length || 2, r = FE(
    t,
    0,
    e,
    n
  );
  return {
    type: "MultiPolygon",
    flatCoordinates: t,
    ends: r,
    layout: Eo(n)
  };
}
function P4(i) {
  const e = i.coordinates, t = [], n = e[0]?.[0]?.length, r = Rh(t, 0, e, n);
  return {
    type: "Polygon",
    flatCoordinates: t,
    ends: r,
    layout: Eo(n)
  };
}
function rp(i, e) {
  i = xt(i, !0, e);
  const t = i.getType();
  let n;
  switch (t) {
    case "Point": {
      n = F4(
        /** @type {import("../geom/Point.js").default} */
        i
      );
      break;
    }
    case "LineString": {
      n = C4(
        /** @type {import("../geom/LineString.js").default} */
        i
      );
      break;
    }
    case "Polygon": {
      n = O4(
        /** @type {import("../geom/Polygon.js").default} */
        i,
        e
      );
      break;
    }
    case "MultiPoint": {
      n = I4(
        /** @type {import("../geom/MultiPoint.js").default} */
        i
      );
      break;
    }
    case "MultiLineString": {
      n = A4(
        /** @type {import("../geom/MultiLineString.js").default} */
        i
      );
      break;
    }
    case "MultiPolygon": {
      n = L4(
        /** @type {import("../geom/MultiPolygon.js").default} */
        i,
        e
      );
      break;
    }
    case "GeometryCollection": {
      n = M4(
        /** @type {import("../geom/GeometryCollection.js").default} */
        i,
        e
      );
      break;
    }
    case "Circle": {
      n = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + t);
  }
  return n;
}
function M4(i, e) {
  return e = Object.assign({}, e), delete e.featureProjection, {
    type: "GeometryCollection",
    geometries: i.getGeometriesArray().map(function(n) {
      return rp(n, e);
    })
  };
}
function C4(i, e) {
  return {
    type: "LineString",
    coordinates: i.getCoordinates()
  };
}
function A4(i, e) {
  return {
    type: "MultiLineString",
    coordinates: i.getCoordinates()
  };
}
function I4(i, e) {
  return {
    type: "MultiPoint",
    coordinates: i.getCoordinates()
  };
}
function L4(i, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "MultiPolygon",
    coordinates: i.getCoordinates(t)
  };
}
function F4(i, e) {
  return {
    type: "Point",
    coordinates: i.getCoordinates()
  };
}
function O4(i, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "Polygon",
    coordinates: i.getCoordinates(t)
  };
}
function pi(i) {
  return (e, ...t) => N4(i, e, t);
}
function Ha(i, e) {
  return pi(
    ob(
      i,
      e
    ).get
  );
}
const {
  apply: N4,
  getOwnPropertyDescriptor: ob,
  getPrototypeOf: m0,
  ownKeys: D4
} = Reflect, {
  iterator: zh,
  toStringTag: G4
} = Symbol, k4 = Object, {
  create: _0,
  defineProperty: U4
} = k4, z4 = Array, B4 = z4.prototype, ab = B4[zh], $4 = pi(ab), lb = ArrayBuffer, j4 = lb.prototype;
Ha(j4, "byteLength");
const p1 = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : null;
p1 && Ha(p1.prototype, "byteLength");
const hb = m0(Uint8Array);
hb.from;
const Ci = hb.prototype;
Ci[zh];
pi(Ci.keys);
pi(
  Ci.values
);
pi(
  Ci.entries
);
pi(Ci.set);
pi(
  Ci.reverse
);
pi(Ci.fill);
pi(
  Ci.copyWithin
);
pi(Ci.sort);
pi(Ci.slice);
pi(
  Ci.subarray
);
Ha(
  Ci,
  "buffer"
);
Ha(
  Ci,
  "byteOffset"
);
Ha(
  Ci,
  "length"
);
Ha(
  Ci,
  G4
);
const X4 = Uint8Array, ub = Uint16Array, y0 = Uint32Array, V4 = Float32Array, oh = m0([][zh]()), cb = pi(oh.next), W4 = pi((function* () {
})().next), Y4 = m0(oh), q4 = DataView.prototype, Z4 = pi(
  q4.getUint16
), x0 = WeakMap, fb = x0.prototype, db = pi(fb.get), H4 = pi(fb.set), gb = new x0(), K4 = _0(null, {
  next: {
    value: function() {
      const e = db(gb, this);
      return cb(e);
    }
  },
  [zh]: {
    value: function() {
      return this;
    }
  }
});
function J4(i) {
  if (i[zh] === ab && oh.next === cb)
    return i;
  const e = _0(K4);
  return H4(gb, e, $4(i)), e;
}
const Q4 = new x0(), e3 = _0(Y4, {
  next: {
    value: function() {
      const e = db(Q4, this);
      return W4(e);
    },
    writable: !0,
    configurable: !0
  }
});
for (const i of D4(oh))
  i !== "next" && U4(e3, i, ob(oh, i));
const pb = new lb(4), t3 = new V4(pb), i3 = new y0(pb), er = new ub(512), tr = new X4(512);
for (let i = 0; i < 256; ++i) {
  const e = i - 127;
  e < -24 ? (er[i] = 0, er[i | 256] = 32768, tr[i] = 24, tr[i | 256] = 24) : e < -14 ? (er[i] = 1024 >> -e - 14, er[i | 256] = 1024 >> -e - 14 | 32768, tr[i] = -e - 1, tr[i | 256] = -e - 1) : e <= 15 ? (er[i] = e + 15 << 10, er[i | 256] = e + 15 << 10 | 32768, tr[i] = 13, tr[i | 256] = 13) : e < 128 ? (er[i] = 31744, er[i | 256] = 64512, tr[i] = 24, tr[i | 256] = 24) : (er[i] = 31744, er[i | 256] = 64512, tr[i] = 13, tr[i | 256] = 13);
}
const E0 = new y0(2048);
for (let i = 1; i < 1024; ++i) {
  let e = i << 13, t = 0;
  for (; (e & 8388608) === 0; )
    e <<= 1, t -= 8388608;
  e &= -8388609, t += 947912704, E0[i] = e | t;
}
for (let i = 1024; i < 2048; ++i)
  E0[i] = 939524096 + (i - 1024 << 13);
const Ka = new y0(64);
for (let i = 1; i < 31; ++i)
  Ka[i] = i << 23;
Ka[31] = 1199570944;
Ka[32] = 2147483648;
for (let i = 33; i < 63; ++i)
  Ka[i] = 2147483648 + (i - 32 << 23);
Ka[63] = 3347054592;
const mb = new ub(64);
for (let i = 1; i < 64; ++i)
  i !== 32 && (mb[i] = 1024);
function n3(i) {
  const e = i >> 10;
  return i3[0] = E0[mb[e] + (i & 1023)] + Ka[e], t3[0];
}
function _b(i, e, ...t) {
  return n3(
    Z4(i, e, ...J4(t))
  );
}
var m1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function jf(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var vu = { exports: {} }, _1;
function r3() {
  if (_1) return vu.exports;
  _1 = 1;
  function i(e, t, n) {
    const r = n && n.debug || !1;
    r && console.log("[xml-utils] getting " + t + " in " + e);
    const s = typeof e == "object" ? e.outer : e, o = s.slice(0, s.indexOf(">") + 1), a = ['"', "'"];
    for (let l = 0; l < a.length; l++) {
      const h = a[l], u = t + "\\=" + h + "([^" + h + "]*)" + h;
      r && console.log("[xml-utils] pattern:", u);
      const f = new RegExp(u).exec(o);
      if (r && console.log("[xml-utils] match:", f), f) return f[1];
    }
  }
  return vu.exports = i, vu.exports.default = i, vu.exports;
}
var s3 = r3();
const qd = /* @__PURE__ */ jf(s3);
var wu = { exports: {} }, bu = { exports: {} }, Su = { exports: {} }, y1;
function o3() {
  if (y1) return Su.exports;
  y1 = 1;
  function i(e, t, n) {
    const s = new RegExp(t).exec(e.slice(n));
    return s ? n + s.index : -1;
  }
  return Su.exports = i, Su.exports.default = i, Su.exports;
}
var Tu = { exports: {} }, x1;
function a3() {
  if (x1) return Tu.exports;
  x1 = 1;
  function i(e, t, n) {
    const s = new RegExp(t).exec(e.slice(n));
    return s ? n + s.index + s[0].length - 1 : -1;
  }
  return Tu.exports = i, Tu.exports.default = i, Tu.exports;
}
var Ru = { exports: {} }, E1;
function l3() {
  if (E1) return Ru.exports;
  E1 = 1;
  function i(e, t) {
    const n = new RegExp(t, "g"), r = e.match(n);
    return r ? r.length : 0;
  }
  return Ru.exports = i, Ru.exports.default = i, Ru.exports;
}
var v1;
function h3() {
  if (v1) return bu.exports;
  v1 = 1;
  const i = o3(), e = a3(), t = l3();
  function n(r, s, o) {
    const a = o && o.debug || !1, l = !(o && typeof o.nested === !1), h = o && o.startIndex || 0;
    a && console.log("[xml-utils] starting findTagByName with", s, " and ", o);
    const u = i(r, `<${s}[ 
>/]`, h);
    if (a && console.log("[xml-utils] start:", u), u === -1) return;
    const c = r.slice(u + s.length);
    let f = e(c, "^[^<]*[ /]>", 0);
    const g = f !== -1 && c[f - 1] === "/";
    if (a && console.log("[xml-utils] selfClosing:", g), g === !1)
      if (l) {
        let v = 0, p = 1, y = 0;
        for (; (f = e(c, "[ /]" + s + ">", v)) !== -1; ) {
          const E = c.substring(v, f + 1);
          if (p += t(E, "<" + s + `[ 
	>]`), y += t(E, "</" + s + ">"), y >= p) break;
          v = f;
        }
      } else
        f = e(c, "[ /]" + s + ">", 0);
    const d = u + s.length + f + 1;
    if (a && console.log("[xml-utils] end:", d), d === -1) return;
    const m = r.slice(u, d);
    let x;
    return g ? x = null : x = m.slice(m.indexOf(">") + 1, m.lastIndexOf("<")), { inner: x, outer: m, start: u, end: d };
  }
  return bu.exports = n, bu.exports.default = n, bu.exports;
}
var w1;
function u3() {
  if (w1) return wu.exports;
  w1 = 1;
  const i = h3();
  function e(t, n, r) {
    const s = [], o = r && r.debug || !1, a = r && typeof r.nested == "boolean" ? r.nested : !0;
    let l = r && r.startIndex || 0, h;
    for (; h = i(t, n, { debug: o, startIndex: l }); )
      a ? l = h.start + 1 + n.length : l = h.end, s.push(h);
    return o && console.log("findTagsByName found", s.length, "tags"), s;
  }
  return wu.exports = e, wu.exports.default = e, wu.exports;
}
var c3 = u3();
const f3 = /* @__PURE__ */ jf(c3), kl = {
  // TIFF Baseline
  315: "Artist",
  258: "BitsPerSample",
  265: "CellLength",
  264: "CellWidth",
  320: "ColorMap",
  259: "Compression",
  33432: "Copyright",
  306: "DateTime",
  338: "ExtraSamples",
  266: "FillOrder",
  289: "FreeByteCounts",
  288: "FreeOffsets",
  291: "GrayResponseCurve",
  290: "GrayResponseUnit",
  316: "HostComputer",
  270: "ImageDescription",
  257: "ImageLength",
  256: "ImageWidth",
  271: "Make",
  281: "MaxSampleValue",
  280: "MinSampleValue",
  272: "Model",
  254: "NewSubfileType",
  274: "Orientation",
  262: "PhotometricInterpretation",
  284: "PlanarConfiguration",
  296: "ResolutionUnit",
  278: "RowsPerStrip",
  277: "SamplesPerPixel",
  305: "Software",
  279: "StripByteCounts",
  273: "StripOffsets",
  255: "SubfileType",
  263: "Threshholding",
  282: "XResolution",
  283: "YResolution",
  // TIFF Extended
  326: "BadFaxLines",
  327: "CleanFaxData",
  343: "ClipPath",
  328: "ConsecutiveBadFaxLines",
  433: "Decode",
  434: "DefaultImageColor",
  269: "DocumentName",
  336: "DotRange",
  321: "HalftoneHints",
  346: "Indexed",
  347: "JPEGTables",
  285: "PageName",
  297: "PageNumber",
  317: "Predictor",
  319: "PrimaryChromaticities",
  532: "ReferenceBlackWhite",
  339: "SampleFormat",
  340: "SMinSampleValue",
  341: "SMaxSampleValue",
  559: "StripRowCounts",
  330: "SubIFDs",
  292: "T4Options",
  293: "T6Options",
  325: "TileByteCounts",
  323: "TileLength",
  324: "TileOffsets",
  322: "TileWidth",
  301: "TransferFunction",
  318: "WhitePoint",
  344: "XClipPathUnits",
  286: "XPosition",
  529: "YCbCrCoefficients",
  531: "YCbCrPositioning",
  530: "YCbCrSubSampling",
  345: "YClipPathUnits",
  287: "YPosition",
  // EXIF
  37378: "ApertureValue",
  40961: "ColorSpace",
  36868: "DateTimeDigitized",
  36867: "DateTimeOriginal",
  34665: "Exif IFD",
  36864: "ExifVersion",
  33434: "ExposureTime",
  41728: "FileSource",
  37385: "Flash",
  40960: "FlashpixVersion",
  33437: "FNumber",
  42016: "ImageUniqueID",
  37384: "LightSource",
  37500: "MakerNote",
  37377: "ShutterSpeedValue",
  37510: "UserComment",
  // IPTC
  33723: "IPTC",
  // ICC
  34675: "ICC Profile",
  // XMP
  700: "XMP",
  // GDAL
  42112: "GDAL_METADATA",
  42113: "GDAL_NODATA",
  // Photoshop
  34377: "Photoshop",
  // GeoTiff
  33550: "ModelPixelScale",
  33922: "ModelTiepoint",
  34264: "ModelTransformation",
  34735: "GeoKeyDirectory",
  34736: "GeoDoubleParams",
  34737: "GeoAsciiParams",
  // LERC
  50674: "LercParameters"
}, ir = {};
for (const i in kl)
  kl.hasOwnProperty(i) && (ir[kl[i]] = parseInt(i, 10));
const d3 = [
  ir.BitsPerSample,
  ir.ExtraSamples,
  ir.SampleFormat,
  ir.StripByteCounts,
  ir.StripOffsets,
  ir.StripRowCounts,
  ir.TileByteCounts,
  ir.TileOffsets,
  ir.SubIFDs
], Zd = {
  1: "BYTE",
  2: "ASCII",
  3: "SHORT",
  4: "LONG",
  5: "RATIONAL",
  6: "SBYTE",
  7: "UNDEFINED",
  8: "SSHORT",
  9: "SLONG",
  10: "SRATIONAL",
  11: "FLOAT",
  12: "DOUBLE",
  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html
  13: "IFD",
  // introduced by BigTIFF
  16: "LONG8",
  17: "SLONG8",
  18: "IFD8"
}, Fe = {};
for (const i in Zd)
  Zd.hasOwnProperty(i) && (Fe[Zd[i]] = parseInt(i, 10));
const Fi = {
  WhiteIsZero: 0,
  BlackIsZero: 1,
  RGB: 2,
  Palette: 3,
  CMYK: 5,
  YCbCr: 6,
  CIELab: 8,
  ICCLab: 9
}, g3 = {
  Unspecified: 0
}, x$ = {
  AddCompression: 1
}, E$ = {
  None: 0,
  Deflate: 1,
  Zstandard: 2
}, p3 = {
  1024: "GTModelTypeGeoKey",
  1025: "GTRasterTypeGeoKey",
  1026: "GTCitationGeoKey",
  2048: "GeographicTypeGeoKey",
  2049: "GeogCitationGeoKey",
  2050: "GeogGeodeticDatumGeoKey",
  2051: "GeogPrimeMeridianGeoKey",
  2052: "GeogLinearUnitsGeoKey",
  2053: "GeogLinearUnitSizeGeoKey",
  2054: "GeogAngularUnitsGeoKey",
  2055: "GeogAngularUnitSizeGeoKey",
  2056: "GeogEllipsoidGeoKey",
  2057: "GeogSemiMajorAxisGeoKey",
  2058: "GeogSemiMinorAxisGeoKey",
  2059: "GeogInvFlatteningGeoKey",
  2060: "GeogAzimuthUnitsGeoKey",
  2061: "GeogPrimeMeridianLongGeoKey",
  2062: "GeogTOWGS84GeoKey",
  3072: "ProjectedCSTypeGeoKey",
  3073: "PCSCitationGeoKey",
  3074: "ProjectionGeoKey",
  3075: "ProjCoordTransGeoKey",
  3076: "ProjLinearUnitsGeoKey",
  3077: "ProjLinearUnitSizeGeoKey",
  3078: "ProjStdParallel1GeoKey",
  3079: "ProjStdParallel2GeoKey",
  3080: "ProjNatOriginLongGeoKey",
  3081: "ProjNatOriginLatGeoKey",
  3082: "ProjFalseEastingGeoKey",
  3083: "ProjFalseNorthingGeoKey",
  3084: "ProjFalseOriginLongGeoKey",
  3085: "ProjFalseOriginLatGeoKey",
  3086: "ProjFalseOriginEastingGeoKey",
  3087: "ProjFalseOriginNorthingGeoKey",
  3088: "ProjCenterLongGeoKey",
  3089: "ProjCenterLatGeoKey",
  3090: "ProjCenterEastingGeoKey",
  3091: "ProjCenterNorthingGeoKey",
  3092: "ProjScaleAtNatOriginGeoKey",
  3093: "ProjScaleAtCenterGeoKey",
  3094: "ProjAzimuthAngleGeoKey",
  3095: "ProjStraightVertPoleLongGeoKey",
  3096: "ProjRectifiedGridAngleGeoKey",
  4096: "VerticalCSTypeGeoKey",
  4097: "VerticalCitationGeoKey",
  4098: "VerticalDatumGeoKey",
  4099: "VerticalUnitsGeoKey"
};
function m3(i, e) {
  const { width: t, height: n } = i, r = new Uint8Array(t * n * 3);
  let s;
  for (let o = 0, a = 0; o < i.length; ++o, a += 3)
    s = 256 - i[o] / e * 256, r[a] = s, r[a + 1] = s, r[a + 2] = s;
  return r;
}
function _3(i, e) {
  const { width: t, height: n } = i, r = new Uint8Array(t * n * 3);
  let s;
  for (let o = 0, a = 0; o < i.length; ++o, a += 3)
    s = i[o] / e * 256, r[a] = s, r[a + 1] = s, r[a + 2] = s;
  return r;
}
function y3(i, e) {
  const { width: t, height: n } = i, r = new Uint8Array(t * n * 3), s = e.length / 3, o = e.length / 3 * 2;
  for (let a = 0, l = 0; a < i.length; ++a, l += 3) {
    const h = i[a];
    r[l] = e[h] / 65536 * 256, r[l + 1] = e[h + s] / 65536 * 256, r[l + 2] = e[h + o] / 65536 * 256;
  }
  return r;
}
function x3(i) {
  const { width: e, height: t } = i, n = new Uint8Array(e * t * 3);
  for (let r = 0, s = 0; r < i.length; r += 4, s += 3) {
    const o = i[r], a = i[r + 1], l = i[r + 2], h = i[r + 3];
    n[s] = 255 * ((255 - o) / 256) * ((255 - h) / 256), n[s + 1] = 255 * ((255 - a) / 256) * ((255 - h) / 256), n[s + 2] = 255 * ((255 - l) / 256) * ((255 - h) / 256);
  }
  return n;
}
function E3(i) {
  const { width: e, height: t } = i, n = new Uint8ClampedArray(e * t * 3);
  for (let r = 0, s = 0; r < i.length; r += 3, s += 3) {
    const o = i[r], a = i[r + 1], l = i[r + 2];
    n[s] = o + 1.402 * (l - 128), n[s + 1] = o - 0.34414 * (a - 128) - 0.71414 * (l - 128), n[s + 2] = o + 1.772 * (a - 128);
  }
  return n;
}
const v3 = 0.95047, w3 = 1, b3 = 1.08883;
function S3(i) {
  const { width: e, height: t } = i, n = new Uint8Array(e * t * 3);
  for (let r = 0, s = 0; r < i.length; r += 3, s += 3) {
    const o = i[r + 0], a = i[r + 1] << 24 >> 24, l = i[r + 2] << 24 >> 24;
    let h = (o + 16) / 116, u = a / 500 + h, c = h - l / 200, f, g, d;
    u = v3 * (u * u * u > 8856e-6 ? u * u * u : (u - 16 / 116) / 7.787), h = w3 * (h * h * h > 8856e-6 ? h * h * h : (h - 16 / 116) / 7.787), c = b3 * (c * c * c > 8856e-6 ? c * c * c : (c - 16 / 116) / 7.787), f = u * 3.2406 + h * -1.5372 + c * -0.4986, g = u * -0.9689 + h * 1.8758 + c * 0.0415, d = u * 0.0557 + h * -0.204 + c * 1.057, f = f > 31308e-7 ? 1.055 * f ** (1 / 2.4) - 0.055 : 12.92 * f, g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : 12.92 * g, d = d > 31308e-7 ? 1.055 * d ** (1 / 2.4) - 0.055 : 12.92 * d, n[s] = Math.max(0, Math.min(1, f)) * 255, n[s + 1] = Math.max(0, Math.min(1, g)) * 255, n[s + 2] = Math.max(0, Math.min(1, d)) * 255;
  }
  return n;
}
const yb = /* @__PURE__ */ new Map();
function Is(i, e) {
  Array.isArray(i) || (i = [i]), i.forEach((t) => yb.set(t, e));
}
async function xb(i) {
  const e = yb.get(i.Compression);
  if (!e)
    throw new Error(`Unknown compression method identifier: ${i.Compression}`);
  const t = await e();
  return new t(i);
}
Is([void 0, 1], () => import("./raw-CaSL8pVO.js").then((i) => i.default));
Is(5, () => import("./lzw-DQ6ibF74.js").then((i) => i.default));
Is(6, () => {
  throw new Error("old style JPEG compression is not supported.");
});
Is(7, () => import("./jpeg-CqPRbuRp.js").then((i) => i.default));
Is([8, 32946], () => import("./deflate-DbhbvOaP.js").then((i) => i.default));
Is(32773, () => import("./packbits-BuzK6gM3.js").then((i) => i.default));
Is(
  34887,
  () => import("./lerc-EBF7t3uN.js").then(async (i) => (await i.zstd.init(), i)).then((i) => i.default)
);
Is(50001, () => import("./webimage--SJddlky.js").then((i) => i.default));
function Xf(i, e, t, n = 1) {
  return new (Object.getPrototypeOf(i)).constructor(e * t * n);
}
function T3(i, e, t, n, r) {
  const s = e / n, o = t / r;
  return i.map((a) => {
    const l = Xf(a, n, r);
    for (let h = 0; h < r; ++h) {
      const u = Math.min(Math.round(o * h), t - 1);
      for (let c = 0; c < n; ++c) {
        const f = Math.min(Math.round(s * c), e - 1), g = a[u * e + f];
        l[h * n + c] = g;
      }
    }
    return l;
  });
}
function ca(i, e, t) {
  return (1 - t) * i + t * e;
}
function R3(i, e, t, n, r) {
  const s = e / n, o = t / r;
  return i.map((a) => {
    const l = Xf(a, n, r);
    for (let h = 0; h < r; ++h) {
      const u = o * h, c = Math.floor(u), f = Math.min(Math.ceil(u), t - 1);
      for (let g = 0; g < n; ++g) {
        const d = s * g, m = d % 1, x = Math.floor(d), v = Math.min(Math.ceil(d), e - 1), p = a[c * e + x], y = a[c * e + v], E = a[f * e + x], b = a[f * e + v], T = ca(
          ca(p, y, m),
          ca(E, b, m),
          u % 1
        );
        l[h * n + g] = T;
      }
    }
    return l;
  });
}
function P3(i, e, t, n, r, s = "nearest") {
  switch (s.toLowerCase()) {
    case "nearest":
      return T3(i, e, t, n, r);
    case "bilinear":
    case "linear":
      return R3(i, e, t, n, r);
    default:
      throw new Error(`Unsupported resampling method: '${s}'`);
  }
}
function M3(i, e, t, n, r, s) {
  const o = e / n, a = t / r, l = Xf(i, n, r, s);
  for (let h = 0; h < r; ++h) {
    const u = Math.min(Math.round(a * h), t - 1);
    for (let c = 0; c < n; ++c) {
      const f = Math.min(Math.round(o * c), e - 1);
      for (let g = 0; g < s; ++g) {
        const d = i[u * e * s + f * s + g];
        l[h * n * s + c * s + g] = d;
      }
    }
  }
  return l;
}
function C3(i, e, t, n, r, s) {
  const o = e / n, a = t / r, l = Xf(i, n, r, s);
  for (let h = 0; h < r; ++h) {
    const u = a * h, c = Math.floor(u), f = Math.min(Math.ceil(u), t - 1);
    for (let g = 0; g < n; ++g) {
      const d = o * g, m = d % 1, x = Math.floor(d), v = Math.min(Math.ceil(d), e - 1);
      for (let p = 0; p < s; ++p) {
        const y = i[c * e * s + x * s + p], E = i[c * e * s + v * s + p], b = i[f * e * s + x * s + p], T = i[f * e * s + v * s + p], R = ca(
          ca(y, E, m),
          ca(b, T, m),
          u % 1
        );
        l[h * n * s + g * s + p] = R;
      }
    }
  }
  return l;
}
function A3(i, e, t, n, r, s, o = "nearest") {
  switch (o.toLowerCase()) {
    case "nearest":
      return M3(
        i,
        e,
        t,
        n,
        r,
        s
      );
    case "bilinear":
    case "linear":
      return C3(
        i,
        e,
        t,
        n,
        r,
        s
      );
    default:
      throw new Error(`Unsupported resampling method: '${o}'`);
  }
}
function I3(i, e, t) {
  let n = 0;
  for (let r = e; r < t; ++r)
    n += i[r];
  return n;
}
function sp(i, e, t) {
  switch (i) {
    case 1:
      if (e <= 8)
        return new Uint8Array(t);
      if (e <= 16)
        return new Uint16Array(t);
      if (e <= 32)
        return new Uint32Array(t);
      break;
    case 2:
      if (e === 8)
        return new Int8Array(t);
      if (e === 16)
        return new Int16Array(t);
      if (e === 32)
        return new Int32Array(t);
      break;
    case 3:
      switch (e) {
        case 16:
        case 32:
          return new Float32Array(t);
        case 64:
          return new Float64Array(t);
      }
      break;
  }
  throw Error("Unsupported data format/bitsPerSample");
}
function L3(i, e) {
  return (i === 1 || i === 2) && e <= 32 && e % 8 === 0 ? !1 : !(i === 3 && (e === 16 || e === 32 || e === 64));
}
function F3(i, e, t, n, r, s, o) {
  const a = new DataView(i), l = t === 2 ? o * s : o * s * n, h = t === 2 ? 1 : n, u = sp(e, r, l), c = parseInt("1".repeat(r), 2);
  if (e === 1) {
    let f;
    t === 1 ? f = n * r : f = r;
    let g = s * f;
    (g & 7) !== 0 && (g = g + 7 & -8);
    for (let d = 0; d < o; ++d) {
      const m = d * g;
      for (let x = 0; x < s; ++x) {
        const v = m + x * h * r;
        for (let p = 0; p < h; ++p) {
          const y = v + p * r, E = (d * s + x) * h + p, b = Math.floor(y / 8), T = y % 8;
          if (T + r <= 8)
            u[E] = a.getUint8(b) >> 8 - r - T & c;
          else if (T + r <= 16)
            u[E] = a.getUint16(b) >> 16 - r - T & c;
          else if (T + r <= 24) {
            const R = a.getUint16(b) << 8 | a.getUint8(b + 2);
            u[E] = R >> 24 - r - T & c;
          } else
            u[E] = a.getUint32(b) >> 32 - r - T & c;
        }
      }
    }
  }
  return u.buffer;
}
class Eb {
  /**
   * @constructor
   * @param {Object} fileDirectory The parsed file directory
   * @param {Object} geoKeys The parsed geo-keys
   * @param {DataView} dataView The DataView for the underlying file.
   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian
   * @param {Boolean} cache Whether or not decoded tiles shall be cached
   * @param {import('./source/basesource').BaseSource} source The datasource to read from
   */
  constructor(e, t, n, r, s, o) {
    this.fileDirectory = e, this.geoKeys = t, this.dataView = n, this.littleEndian = r, this.tiles = s ? {} : null, this.isTiled = !e.StripOffsets;
    const a = e.PlanarConfiguration;
    if (this.planarConfiguration = typeof a > "u" ? 1 : a, this.planarConfiguration !== 1 && this.planarConfiguration !== 2)
      throw new Error("Invalid planar configuration.");
    this.source = o;
  }
  /**
   * Returns the associated parsed file directory.
   * @returns {Object} the parsed file directory
   */
  getFileDirectory() {
    return this.fileDirectory;
  }
  /**
   * Returns the associated parsed geo keys.
   * @returns {Object} the parsed geo keys
   */
  getGeoKeys() {
    return this.geoKeys;
  }
  /**
   * Returns the width of the image.
   * @returns {Number} the width of the image
   */
  getWidth() {
    return this.fileDirectory.ImageWidth;
  }
  /**
   * Returns the height of the image.
   * @returns {Number} the height of the image
   */
  getHeight() {
    return this.fileDirectory.ImageLength;
  }
  /**
   * Returns the number of samples per pixel.
   * @returns {Number} the number of samples per pixel
   */
  getSamplesPerPixel() {
    return typeof this.fileDirectory.SamplesPerPixel < "u" ? this.fileDirectory.SamplesPerPixel : 1;
  }
  /**
   * Returns the width of each tile.
   * @returns {Number} the width of each tile
   */
  getTileWidth() {
    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();
  }
  /**
   * Returns the height of each tile.
   * @returns {Number} the height of each tile
   */
  getTileHeight() {
    return this.isTiled ? this.fileDirectory.TileLength : typeof this.fileDirectory.RowsPerStrip < "u" ? Math.min(this.fileDirectory.RowsPerStrip, this.getHeight()) : this.getHeight();
  }
  getBlockWidth() {
    return this.getTileWidth();
  }
  getBlockHeight(e) {
    return this.isTiled || (e + 1) * this.getTileHeight() <= this.getHeight() ? this.getTileHeight() : this.getHeight() - e * this.getTileHeight();
  }
  /**
   * Calculates the number of bytes for each pixel across all samples. Only full
   * bytes are supported, an exception is thrown when this is not the case.
   * @returns {Number} the bytes per pixel
   */
  getBytesPerPixel() {
    let e = 0;
    for (let t = 0; t < this.fileDirectory.BitsPerSample.length; ++t)
      e += this.getSampleByteSize(t);
    return e;
  }
  getSampleByteSize(e) {
    if (e >= this.fileDirectory.BitsPerSample.length)
      throw new RangeError(`Sample index ${e} is out of range.`);
    return Math.ceil(this.fileDirectory.BitsPerSample[e] / 8);
  }
  getReaderForSample(e) {
    const t = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[e] : 1, n = this.fileDirectory.BitsPerSample[e];
    switch (t) {
      case 1:
        if (n <= 8)
          return DataView.prototype.getUint8;
        if (n <= 16)
          return DataView.prototype.getUint16;
        if (n <= 32)
          return DataView.prototype.getUint32;
        break;
      case 2:
        if (n <= 8)
          return DataView.prototype.getInt8;
        if (n <= 16)
          return DataView.prototype.getInt16;
        if (n <= 32)
          return DataView.prototype.getInt32;
        break;
      case 3:
        switch (n) {
          case 16:
            return function(r, s) {
              return _b(this, r, s);
            };
          case 32:
            return DataView.prototype.getFloat32;
          case 64:
            return DataView.prototype.getFloat64;
        }
        break;
    }
    throw Error("Unsupported data format/bitsPerSample");
  }
  getSampleFormat(e = 0) {
    return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[e] : 1;
  }
  getBitsPerSample(e = 0) {
    return this.fileDirectory.BitsPerSample[e];
  }
  getArrayForSample(e, t) {
    const n = this.getSampleFormat(e), r = this.getBitsPerSample(e);
    return sp(n, r, t);
  }
  /**
   * Returns the decoded strip or tile.
   * @param {Number} x the strip or tile x-offset
   * @param {Number} y the tile y-offset (0 for stripped images)
   * @param {Number} sample the sample to get for separated samples
   * @param {import("./geotiff").Pool|import("./geotiff").BaseDecoder} poolOrDecoder the decoder or decoder pool
   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
   *                               to be aborted
   * @returns {Promise.<ArrayBuffer>}
   */
  async getTileOrStrip(e, t, n, r, s) {
    const o = Math.ceil(this.getWidth() / this.getTileWidth()), a = Math.ceil(this.getHeight() / this.getTileHeight());
    let l;
    const { tiles: h } = this;
    this.planarConfiguration === 1 ? l = t * o + e : this.planarConfiguration === 2 && (l = n * o * a + t * o + e);
    let u, c;
    this.isTiled ? (u = this.fileDirectory.TileOffsets[l], c = this.fileDirectory.TileByteCounts[l]) : (u = this.fileDirectory.StripOffsets[l], c = this.fileDirectory.StripByteCounts[l]);
    const f = (await this.source.fetch([{ offset: u, length: c }], s))[0];
    let g;
    return h === null || !h[l] ? (g = (async () => {
      let d = await r.decode(this.fileDirectory, f);
      const m = this.getSampleFormat(), x = this.getBitsPerSample();
      return L3(m, x) && (d = F3(
        d,
        m,
        this.planarConfiguration,
        this.getSamplesPerPixel(),
        x,
        this.getTileWidth(),
        this.getBlockHeight(t)
      )), d;
    })(), h !== null && (h[l] = g)) : g = h[l], { x: e, y: t, sample: n, data: await g };
  }
  /**
   * Internal read function.
   * @private
   * @param {Array} imageWindow The image window in pixel coordinates
   * @param {Array} samples The selected samples (0-based indices)
   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into
   * @param {Boolean} interleave Whether or not to write in an interleaved manner
   * @param {import("./geotiff").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool
   * @param {number} width the width of window to be read into
   * @param {number} height the height of window to be read into
   * @param {number} resampleMethod the resampling method to be used when interpolating
   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
   *                               to be aborted
   * @returns {Promise<ReadRasterResult>}
   */
  async _readRaster(e, t, n, r, s, o, a, l, h) {
    const u = this.getTileWidth(), c = this.getTileHeight(), f = this.getWidth(), g = this.getHeight(), d = Math.max(Math.floor(e[0] / u), 0), m = Math.min(
      Math.ceil(e[2] / u),
      Math.ceil(f / u)
    ), x = Math.max(Math.floor(e[1] / c), 0), v = Math.min(
      Math.ceil(e[3] / c),
      Math.ceil(g / c)
    ), p = e[2] - e[0];
    let y = this.getBytesPerPixel();
    const E = [], b = [];
    for (let M = 0; M < t.length; ++M)
      this.planarConfiguration === 1 ? E.push(I3(this.fileDirectory.BitsPerSample, 0, t[M]) / 8) : E.push(0), b.push(this.getReaderForSample(t[M]));
    const T = [], { littleEndian: R } = this;
    for (let M = x; M < v; ++M)
      for (let C = d; C < m; ++C) {
        let I;
        this.planarConfiguration === 1 && (I = this.getTileOrStrip(C, M, 0, s, h));
        for (let O = 0; O < t.length; ++O) {
          const z = O, _ = t[O];
          this.planarConfiguration === 2 && (y = this.getSampleByteSize(_), I = this.getTileOrStrip(C, M, _, s, h));
          const w = I.then((S) => {
            const P = S.data, A = new DataView(P), D = this.getBlockHeight(S.y), k = S.y * c, U = S.x * u, G = k + D, $ = (S.x + 1) * u, H = b[z], ne = Math.min(D, D - (G - e[3]), g - k), te = Math.min(u, u - ($ - e[2]), f - U);
            for (let re = Math.max(0, e[1] - k); re < ne; ++re)
              for (let ae = Math.max(0, e[0] - U); ae < te; ++ae) {
                const Re = (re * u + ae) * y, xe = H.call(
                  A,
                  Re + E[z],
                  R
                );
                let Ae;
                r ? (Ae = (re + k - e[1]) * p * t.length + (ae + U - e[0]) * t.length + z, n[Ae] = xe) : (Ae = (re + k - e[1]) * p + ae + U - e[0], n[z][Ae] = xe);
              }
          });
          T.push(w);
        }
      }
    if (await Promise.all(T), o && e[2] - e[0] !== o || a && e[3] - e[1] !== a) {
      let M;
      return r ? M = A3(
        n,
        e[2] - e[0],
        e[3] - e[1],
        o,
        a,
        t.length,
        l
      ) : M = P3(
        n,
        e[2] - e[0],
        e[3] - e[1],
        o,
        a,
        l
      ), M.width = o, M.height = a, M;
    }
    return n.width = o || e[2] - e[0], n.height = a || e[3] - e[1], n;
  }
  /**
   * Reads raster data from the image. This function reads all selected samples
   * into separate arrays of the correct type for that sample or into a single
   * combined array when `interleave` is set. When provided, only a subset
   * of the raster is read for each sample.
   *
   * @param {ReadRasterOptions} [options={}] optional parameters
   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise
   */
  async readRasters({
    window: e,
    samples: t = [],
    interleave: n,
    pool: r = null,
    width: s,
    height: o,
    resampleMethod: a,
    fillValue: l,
    signal: h
  } = {}) {
    const u = e || [0, 0, this.getWidth(), this.getHeight()];
    if (u[0] > u[2] || u[1] > u[3])
      throw new Error("Invalid subsets");
    const c = u[2] - u[0], f = u[3] - u[1], g = c * f, d = this.getSamplesPerPixel();
    if (!t || !t.length)
      for (let p = 0; p < d; ++p)
        t.push(p);
    else
      for (let p = 0; p < t.length; ++p)
        if (t[p] >= d)
          return Promise.reject(new RangeError(`Invalid sample index '${t[p]}'.`));
    let m;
    if (n) {
      const p = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1, y = Math.max.apply(null, this.fileDirectory.BitsPerSample);
      m = sp(p, y, g * t.length), l && m.fill(l);
    } else {
      m = [];
      for (let p = 0; p < t.length; ++p) {
        const y = this.getArrayForSample(t[p], g);
        Array.isArray(l) && p < l.length ? y.fill(l[p]) : l && !Array.isArray(l) && y.fill(l), m.push(y);
      }
    }
    const x = r || await xb(this.fileDirectory);
    return await this._readRaster(
      u,
      t,
      m,
      n,
      x,
      s,
      o,
      a,
      h
    );
  }
  /**
   * Reads raster data from the image as RGB. The result is always an
   * interleaved typed array.
   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.
   * When no other method is applicable, the first sample is used to produce a
   * grayscale image.
   * When provided, only a subset of the raster is read for each sample.
   *
   * @param {Object} [options] optional parameters
   * @param {Array<number>} [options.window] the subset to read data from in pixels.
   * @param {boolean} [options.interleave=true] whether the data shall be read
   *                                             in one single array or separate
   *                                             arrays.
   * @param {import("./geotiff").Pool} [options.pool=null] The optional decoder pool to use.
   * @param {number} [options.width] The desired width of the output. When the width is no the
   *                                 same as the images, resampling will be performed.
   * @param {number} [options.height] The desired height of the output. When the width is no the
   *                                  same as the images, resampling will be performed.
   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.
   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.
   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is
   *                                       to be aborted
   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise
   */
  async readRGB({
    window: e,
    interleave: t = !0,
    pool: n = null,
    width: r,
    height: s,
    resampleMethod: o,
    enableAlpha: a = !1,
    signal: l
  } = {}) {
    const h = e || [0, 0, this.getWidth(), this.getHeight()];
    if (h[0] > h[2] || h[1] > h[3])
      throw new Error("Invalid subsets");
    const u = this.fileDirectory.PhotometricInterpretation;
    if (u === Fi.RGB) {
      let v = [0, 1, 2];
      if (this.fileDirectory.ExtraSamples !== g3.Unspecified && a) {
        v = [];
        for (let p = 0; p < this.fileDirectory.BitsPerSample.length; p += 1)
          v.push(p);
      }
      return this.readRasters({
        window: e,
        interleave: t,
        samples: v,
        pool: n,
        width: r,
        height: s,
        resampleMethod: o,
        signal: l
      });
    }
    let c;
    switch (u) {
      case Fi.WhiteIsZero:
      case Fi.BlackIsZero:
      case Fi.Palette:
        c = [0];
        break;
      case Fi.CMYK:
        c = [0, 1, 2, 3];
        break;
      case Fi.YCbCr:
      case Fi.CIELab:
        c = [0, 1, 2];
        break;
      default:
        throw new Error("Invalid or unsupported photometric interpretation.");
    }
    const f = {
      window: h,
      interleave: !0,
      samples: c,
      pool: n,
      width: r,
      height: s,
      resampleMethod: o,
      signal: l
    }, { fileDirectory: g } = this, d = await this.readRasters(f), m = 2 ** this.fileDirectory.BitsPerSample[0];
    let x;
    switch (u) {
      case Fi.WhiteIsZero:
        x = m3(d, m);
        break;
      case Fi.BlackIsZero:
        x = _3(d, m);
        break;
      case Fi.Palette:
        x = y3(d, g.ColorMap);
        break;
      case Fi.CMYK:
        x = x3(d);
        break;
      case Fi.YCbCr:
        x = E3(d);
        break;
      case Fi.CIELab:
        x = S3(d);
        break;
      default:
        throw new Error("Unsupported photometric interpretation.");
    }
    if (!t) {
      const v = new Uint8Array(x.length / 3), p = new Uint8Array(x.length / 3), y = new Uint8Array(x.length / 3);
      for (let E = 0, b = 0; E < x.length; E += 3, ++b)
        v[b] = x[E], p[b] = x[E + 1], y[b] = x[E + 2];
      x = [v, p, y];
    }
    return x.width = d.width, x.height = d.height, x;
  }
  /**
   * Returns an array of tiepoints.
   * @returns {Object[]}
   */
  getTiePoints() {
    if (!this.fileDirectory.ModelTiepoint)
      return [];
    const e = [];
    for (let t = 0; t < this.fileDirectory.ModelTiepoint.length; t += 6)
      e.push({
        i: this.fileDirectory.ModelTiepoint[t],
        j: this.fileDirectory.ModelTiepoint[t + 1],
        k: this.fileDirectory.ModelTiepoint[t + 2],
        x: this.fileDirectory.ModelTiepoint[t + 3],
        y: this.fileDirectory.ModelTiepoint[t + 4],
        z: this.fileDirectory.ModelTiepoint[t + 5]
      });
    return e;
  }
  /**
   * Returns the parsed GDAL metadata items.
   *
   * If sample is passed to null, dataset-level metadata will be returned.
   * Otherwise only metadata specific to the provided sample will be returned.
   *
   * @param {number} [sample=null] The sample index.
   * @returns {Object}
   */
  getGDALMetadata(e = null) {
    const t = {};
    if (!this.fileDirectory.GDAL_METADATA)
      return null;
    const n = this.fileDirectory.GDAL_METADATA;
    let r = f3(n, "Item");
    e === null ? r = r.filter((s) => qd(s, "sample") === void 0) : r = r.filter((s) => Number(qd(s, "sample")) === e);
    for (let s = 0; s < r.length; ++s) {
      const o = r[s];
      t[qd(o, "name")] = o.inner;
    }
    return t;
  }
  /**
   * Returns the GDAL nodata value
   * @returns {number|null}
   */
  getGDALNoData() {
    if (!this.fileDirectory.GDAL_NODATA)
      return null;
    const e = this.fileDirectory.GDAL_NODATA;
    return Number(e.substring(0, e.length - 1));
  }
  /**
   * Returns the image origin as a XYZ-vector. When the image has no affine
   * transformation, then an exception is thrown.
   * @returns {Array<number>} The origin as a vector
   */
  getOrigin() {
    const e = this.fileDirectory.ModelTiepoint, t = this.fileDirectory.ModelTransformation;
    if (e && e.length === 6)
      return [
        e[3],
        e[4],
        e[5]
      ];
    if (t)
      return [
        t[3],
        t[7],
        t[11]
      ];
    throw new Error("The image does not have an affine transformation.");
  }
  /**
   * Returns the image resolution as a XYZ-vector. When the image has no affine
   * transformation, then an exception is thrown.
   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from
   *                                             in cases when the current image does not have the
   *                                             required tags on its own.
   * @returns {Array<number>} The resolution as a vector
   */
  getResolution(e = null) {
    const t = this.fileDirectory.ModelPixelScale, n = this.fileDirectory.ModelTransformation;
    if (t)
      return [
        t[0],
        -t[1],
        t[2]
      ];
    if (n)
      return n[1] === 0 && n[4] === 0 ? [
        n[0],
        -n[5],
        n[10]
      ] : [
        Math.sqrt(n[0] * n[0] + n[4] * n[4]),
        -Math.sqrt(n[1] * n[1] + n[5] * n[5]),
        n[10]
      ];
    if (e) {
      const [r, s, o] = e.getResolution();
      return [
        r * e.getWidth() / this.getWidth(),
        s * e.getHeight() / this.getHeight(),
        o * e.getWidth() / this.getWidth()
      ];
    }
    throw new Error("The image does not have an affine transformation.");
  }
  /**
   * Returns whether or not the pixels of the image depict an area (or point).
   * @returns {Boolean} Whether the pixels are a point
   */
  pixelIsArea() {
    return this.geoKeys.GTRasterTypeGeoKey === 1;
  }
  /**
   * Returns the image bounding box as an array of 4 values: min-x, min-y,
   * max-x and max-y. When the image has no affine transformation, then an
   * exception is thrown.
   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid
   *                                   without adjustment for ModelTransformation.
   * @returns {Array<number>} The bounding box
   */
  getBoundingBox(e = !1) {
    const t = this.getHeight(), n = this.getWidth();
    if (this.fileDirectory.ModelTransformation && !e) {
      const [r, s, o, a, l, h, u, c] = this.fileDirectory.ModelTransformation, g = [
        [0, 0],
        [0, t],
        [n, 0],
        [n, t]
      ].map(([x, v]) => [
        a + r * x + s * v,
        c + l * x + h * v
      ]), d = g.map((x) => x[0]), m = g.map((x) => x[1]);
      return [
        Math.min(...d),
        Math.min(...m),
        Math.max(...d),
        Math.max(...m)
      ];
    } else {
      const r = this.getOrigin(), s = this.getResolution(), o = r[0], a = r[1], l = o + s[0] * n, h = a + s[1] * t;
      return [
        Math.min(o, l),
        Math.min(a, h),
        Math.max(o, l),
        Math.max(a, h)
      ];
    }
  }
}
class O3 {
  constructor(e) {
    this._dataView = new DataView(e);
  }
  get buffer() {
    return this._dataView.buffer;
  }
  getUint64(e, t) {
    const n = this.getUint32(e, t), r = this.getUint32(e + 4, t);
    let s;
    if (t) {
      if (s = n + 2 ** 32 * r, !Number.isSafeInteger(s))
        throw new Error(
          `${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`
        );
      return s;
    }
    if (s = 2 ** 32 * n + r, !Number.isSafeInteger(s))
      throw new Error(
        `${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`
      );
    return s;
  }
  // adapted from https://stackoverflow.com/a/55338384/8060591
  getInt64(e, t) {
    let n = 0;
    const r = (this._dataView.getUint8(e + (t ? 7 : 0)) & 128) > 0;
    let s = !0;
    for (let o = 0; o < 8; o++) {
      let a = this._dataView.getUint8(e + (t ? o : 7 - o));
      r && (s ? a !== 0 && (a = ~(a - 1) & 255, s = !1) : a = ~a & 255), n += a * 256 ** o;
    }
    return r && (n = -n), n;
  }
  getUint8(e, t) {
    return this._dataView.getUint8(e, t);
  }
  getInt8(e, t) {
    return this._dataView.getInt8(e, t);
  }
  getUint16(e, t) {
    return this._dataView.getUint16(e, t);
  }
  getInt16(e, t) {
    return this._dataView.getInt16(e, t);
  }
  getUint32(e, t) {
    return this._dataView.getUint32(e, t);
  }
  getInt32(e, t) {
    return this._dataView.getInt32(e, t);
  }
  getFloat16(e, t) {
    return _b(this._dataView, e, t);
  }
  getFloat32(e, t) {
    return this._dataView.getFloat32(e, t);
  }
  getFloat64(e, t) {
    return this._dataView.getFloat64(e, t);
  }
}
class N3 {
  constructor(e, t, n, r) {
    this._dataView = new DataView(e), this._sliceOffset = t, this._littleEndian = n, this._bigTiff = r;
  }
  get sliceOffset() {
    return this._sliceOffset;
  }
  get sliceTop() {
    return this._sliceOffset + this.buffer.byteLength;
  }
  get littleEndian() {
    return this._littleEndian;
  }
  get bigTiff() {
    return this._bigTiff;
  }
  get buffer() {
    return this._dataView.buffer;
  }
  covers(e, t) {
    return this.sliceOffset <= e && this.sliceTop >= e + t;
  }
  readUint8(e) {
    return this._dataView.getUint8(
      e - this._sliceOffset,
      this._littleEndian
    );
  }
  readInt8(e) {
    return this._dataView.getInt8(
      e - this._sliceOffset,
      this._littleEndian
    );
  }
  readUint16(e) {
    return this._dataView.getUint16(
      e - this._sliceOffset,
      this._littleEndian
    );
  }
  readInt16(e) {
    return this._dataView.getInt16(
      e - this._sliceOffset,
      this._littleEndian
    );
  }
  readUint32(e) {
    return this._dataView.getUint32(
      e - this._sliceOffset,
      this._littleEndian
    );
  }
  readInt32(e) {
    return this._dataView.getInt32(
      e - this._sliceOffset,
      this._littleEndian
    );
  }
  readFloat32(e) {
    return this._dataView.getFloat32(
      e - this._sliceOffset,
      this._littleEndian
    );
  }
  readFloat64(e) {
    return this._dataView.getFloat64(
      e - this._sliceOffset,
      this._littleEndian
    );
  }
  readUint64(e) {
    const t = this.readUint32(e), n = this.readUint32(e + 4);
    let r;
    if (this._littleEndian) {
      if (r = t + 2 ** 32 * n, !Number.isSafeInteger(r))
        throw new Error(
          `${r} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`
        );
      return r;
    }
    if (r = 2 ** 32 * t + n, !Number.isSafeInteger(r))
      throw new Error(
        `${r} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`
      );
    return r;
  }
  // adapted from https://stackoverflow.com/a/55338384/8060591
  readInt64(e) {
    let t = 0;
    const n = (this._dataView.getUint8(e + (this._littleEndian ? 7 : 0)) & 128) > 0;
    let r = !0;
    for (let s = 0; s < 8; s++) {
      let o = this._dataView.getUint8(
        e + (this._littleEndian ? s : 7 - s)
      );
      n && (r ? o !== 0 && (o = ~(o - 1) & 255, r = !1) : o = ~o & 255), t += o * 256 ** s;
    }
    return n && (t = -t), t;
  }
  readOffset(e) {
    return this._bigTiff ? this.readUint64(e) : this.readUint32(e);
  }
}
const D3 = typeof navigator < "u" && navigator.hardwareConcurrency || 2;
class G3 {
  /**
   * @constructor
   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs
   *                      available. When this parameter is `null` or 0, then the
   *                      decoding will be done in the main thread.
   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.
   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`
   * function is expected to return a `Worker` compatible with Web Workers. For code that
   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.
   *
   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:
   * ```js
   * import { addDecoder, getDecoder } from 'geotiff';
   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));
   * self.addEventListener('message', async (e) => {
   *   const { id, fileDirectory, buffer } = e.data;
   *   const decoder = await getDecoder(fileDirectory);
   *   const decoded = await decoder.decode(fileDirectory, buffer);
   *   self.postMessage({ decoded, id }, [decoded]);
   * });
   * ```
   * The way the above code is built into a worker by the `createWorker()` function
   * depends on the used bundler. For most bundlers, something like this will work:
   * ```js
   * function createWorker() {
   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));
   * }
   * ```
   */
  constructor(e = D3, t) {
    this.workers = null, this._awaitingDecoder = null, this.size = e, this.messageId = 0, e && (this._awaitingDecoder = t ? Promise.resolve(t) : new Promise((n) => {
      import("./decoder-DJlmx386.js").then((r) => {
        n(r.create);
      });
    }), this._awaitingDecoder.then((n) => {
      this._awaitingDecoder = null, this.workers = [];
      for (let r = 0; r < e; r++)
        this.workers.push({ worker: n(), idle: !0 });
    }));
  }
  /**
   * Decode the given block of bytes with the set compression method.
   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.
   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`
   */
  async decode(e, t) {
    return this._awaitingDecoder && await this._awaitingDecoder, this.size === 0 ? xb(e).then((n) => n.decode(e, t)) : new Promise((n) => {
      const r = this.workers.find((a) => a.idle) || this.workers[Math.floor(Math.random() * this.size)];
      r.idle = !1;
      const s = this.messageId++, o = (a) => {
        a.data.id === s && (r.idle = !0, n(a.data.decoded), r.worker.removeEventListener("message", o));
      };
      r.worker.addEventListener("message", o), r.worker.postMessage({ fileDirectory: e, buffer: t, id: s }, [t]);
    });
  }
  destroy() {
    this.workers && (this.workers.forEach((e) => {
      e.worker.terminate();
    }), this.workers = null);
  }
}
const b1 = `\r
\r
`;
function vb(i) {
  if (typeof Object.fromEntries < "u")
    return Object.fromEntries(i);
  const e = {};
  for (const [t, n] of i)
    e[t.toLowerCase()] = n;
  return e;
}
function k3(i) {
  const e = i.split(`\r
`).map((t) => {
    const n = t.split(":").map((r) => r.trim());
    return n[0] = n[0].toLowerCase(), n;
  });
  return vb(e);
}
function U3(i) {
  const [e, ...t] = i.split(";").map((r) => r.trim()), n = t.map((r) => r.split("="));
  return { type: e, params: vb(n) };
}
function op(i) {
  let e, t, n;
  return i && ([, e, t, n] = i.match(/bytes (\d+)-(\d+)\/(\d+)/), e = parseInt(e, 10), t = parseInt(t, 10), n = parseInt(n, 10)), { start: e, end: t, total: n };
}
function z3(i, e) {
  let t = null;
  const n = new TextDecoder("ascii"), r = [], s = `--${e}`, o = `${s}--`;
  for (let a = 0; a < 10; ++a)
    n.decode(
      new Uint8Array(i, a, s.length)
    ) === s && (t = a);
  if (t === null)
    throw new Error("Could not find initial boundary");
  for (; t < i.byteLength; ) {
    const a = n.decode(
      new Uint8Array(
        i,
        t,
        Math.min(s.length + 1024, i.byteLength - t)
      )
    );
    if (a.length === 0 || a.startsWith(o))
      break;
    if (!a.startsWith(s))
      throw new Error("Part does not start with boundary");
    const l = a.substr(s.length + 2);
    if (l.length === 0)
      break;
    const h = l.indexOf(b1), u = k3(l.substr(0, h)), { start: c, end: f, total: g } = op(u["content-range"]), d = t + s.length + h + b1.length, m = parseInt(f, 10) + 1 - parseInt(c, 10);
    r.push({
      headers: u,
      data: i.slice(d, d + m),
      offset: c,
      length: m,
      fileSize: g
    }), t = d + m + 4;
  }
  return r;
}
class v0 {
  /**
   *
   * @param {Slice[]} slices
   * @returns {ArrayBuffer[]}
   */
  async fetch(e, t = void 0) {
    return Promise.all(
      e.map((n) => this.fetchSlice(n, t))
    );
  }
  /**
   *
   * @param {Slice} slice
   * @returns {ArrayBuffer}
   */
  async fetchSlice(e) {
    throw new Error(`fetching of slice ${e} not possible, not implemented`);
  }
  /**
   * Returns the filesize if already determined and null otherwise
   */
  get fileSize() {
    return null;
  }
  async close() {
  }
}
class B3 extends Map {
  constructor(e = {}) {
    if (super(), !(e.maxSize && e.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    if (typeof e.maxAge == "number" && e.maxAge === 0)
      throw new TypeError("`maxAge` must be a number greater than 0");
    this.maxSize = e.maxSize, this.maxAge = e.maxAge || Number.POSITIVE_INFINITY, this.onEviction = e.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  // TODO: Use private class methods when targeting Node.js 16.
  _emitEvictions(e) {
    if (typeof this.onEviction == "function")
      for (const [t, n] of e)
        this.onEviction(t, n.value);
  }
  _deleteIfExpired(e, t) {
    return typeof t.expiry == "number" && t.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e, t.value), this.delete(e)) : !1;
  }
  _getOrDeleteIfExpired(e, t) {
    if (this._deleteIfExpired(e, t) === !1)
      return t.value;
  }
  _getItemValue(e, t) {
    return t.expiry ? this._getOrDeleteIfExpired(e, t) : t.value;
  }
  _peek(e, t) {
    const n = t.get(e);
    return this._getItemValue(e, n);
  }
  _set(e, t) {
    this.cache.set(e, t), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
  }
  _moveToRecent(e, t) {
    this.oldCache.delete(e), this._set(e, t);
  }
  *_entriesAscending() {
    for (const e of this.oldCache) {
      const [t, n] = e;
      this.cache.has(t) || this._deleteIfExpired(t, n) === !1 && (yield e);
    }
    for (const e of this.cache) {
      const [t, n] = e;
      this._deleteIfExpired(t, n) === !1 && (yield e);
    }
  }
  get(e) {
    if (this.cache.has(e)) {
      const t = this.cache.get(e);
      return this._getItemValue(e, t);
    }
    if (this.oldCache.has(e)) {
      const t = this.oldCache.get(e);
      if (this._deleteIfExpired(e, t) === !1)
        return this._moveToRecent(e, t), t.value;
    }
  }
  set(e, t, { maxAge: n = this.maxAge } = {}) {
    const r = typeof n == "number" && n !== Number.POSITIVE_INFINITY ? Date.now() + n : void 0;
    return this.cache.has(e) ? this.cache.set(e, {
      value: t,
      expiry: r
    }) : this._set(e, { value: t, expiry: r }), this;
  }
  has(e) {
    return this.cache.has(e) ? !this._deleteIfExpired(e, this.cache.get(e)) : this.oldCache.has(e) ? !this._deleteIfExpired(e, this.oldCache.get(e)) : !1;
  }
  peek(e) {
    if (this.cache.has(e))
      return this._peek(e, this.cache);
    if (this.oldCache.has(e))
      return this._peek(e, this.oldCache);
  }
  delete(e) {
    const t = this.cache.delete(e);
    return t && this._size--, this.oldCache.delete(e) || t;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  resize(e) {
    if (!(e && e > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    const t = [...this._entriesAscending()], n = t.length - e;
    n < 0 ? (this.cache = new Map(t), this.oldCache = /* @__PURE__ */ new Map(), this._size = t.length) : (n > 0 && this._emitEvictions(t.slice(0, n)), this.oldCache = new Map(t.slice(n)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = e;
  }
  *keys() {
    for (const [e] of this)
      yield e;
  }
  *values() {
    for (const [, e] of this)
      yield e;
  }
  *[Symbol.iterator]() {
    for (const e of this.cache) {
      const [t, n] = e;
      this._deleteIfExpired(t, n) === !1 && (yield [t, n.value]);
    }
    for (const e of this.oldCache) {
      const [t, n] = e;
      this.cache.has(t) || this._deleteIfExpired(t, n) === !1 && (yield [t, n.value]);
    }
  }
  *entriesDescending() {
    let e = [...this.cache];
    for (let t = e.length - 1; t >= 0; --t) {
      const n = e[t], [r, s] = n;
      this._deleteIfExpired(r, s) === !1 && (yield [r, s.value]);
    }
    e = [...this.oldCache];
    for (let t = e.length - 1; t >= 0; --t) {
      const n = e[t], [r, s] = n;
      this.cache.has(r) || this._deleteIfExpired(r, s) === !1 && (yield [r, s.value]);
    }
  }
  *entriesAscending() {
    for (const [e, t] of this._entriesAscending())
      yield [e, t.value];
  }
  get size() {
    if (!this._size)
      return this.oldCache.size;
    let e = 0;
    for (const t of this.oldCache.keys())
      this.cache.has(t) || e++;
    return Math.min(this._size + e, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(e, t = this) {
    for (const [n, r] of this.entriesAscending())
      e.call(t, r, n, this);
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
}
async function $3(i) {
  return new Promise((e) => setTimeout(e, i));
}
function j3(i, e) {
  const t = Array.isArray(i) ? i : Array.from(i), n = Array.isArray(e) ? e : Array.from(e);
  return t.map((r, s) => [r, n[s]]);
}
class Ma extends Error {
  constructor(e) {
    super(e), Error.captureStackTrace && Error.captureStackTrace(this, Ma), this.name = "AbortError";
  }
}
class X3 extends Error {
  constructor(e, t) {
    super(t), this.errors = e, this.message = t, this.name = "AggregateError";
  }
}
const V3 = X3;
class W3 {
  /**
   *
   * @param {number} offset
   * @param {number} length
   * @param {ArrayBuffer} [data]
   */
  constructor(e, t, n = null) {
    this.offset = e, this.length = t, this.data = n;
  }
  /**
   * @returns {number} the top byte border
   */
  get top() {
    return this.offset + this.length;
  }
}
class S1 {
  /**
   *
   * @param {number} offset
   * @param {number} length
   * @param {number[]} blockIds
   */
  constructor(e, t, n) {
    this.offset = e, this.length = t, this.blockIds = n;
  }
}
class Y3 extends v0 {
  /**
   *
   * @param {BaseSource} source The underlying source that shall be blocked and cached
   * @param {object} options
   * @param {number} [options.blockSize]
   * @param {number} [options.cacheSize]
   */
  constructor(e, { blockSize: t = 65536, cacheSize: n = 100 } = {}) {
    super(), this.source = e, this.blockSize = t, this.blockCache = new B3({
      maxSize: n,
      onEviction: (r, s) => {
        this.evictedBlocks.set(r, s);
      }
    }), this.evictedBlocks = /* @__PURE__ */ new Map(), this.blockRequests = /* @__PURE__ */ new Map(), this.blockIdsToFetch = /* @__PURE__ */ new Set(), this.abortedBlockIds = /* @__PURE__ */ new Set();
  }
  get fileSize() {
    return this.source.fileSize;
  }
  /**
   *
   * @param {import("./basesource").Slice[]} slices
   */
  async fetch(e, t) {
    const n = [], r = [], s = [];
    this.evictedBlocks.clear();
    for (const { offset: f, length: g } of e) {
      let d = f + g;
      const { fileSize: m } = this;
      m !== null && (d = Math.min(d, m));
      const x = Math.floor(f / this.blockSize) * this.blockSize;
      for (let v = x; v < d; v += this.blockSize) {
        const p = Math.floor(v / this.blockSize);
        !this.blockCache.has(p) && !this.blockRequests.has(p) && (this.blockIdsToFetch.add(p), r.push(p)), this.blockRequests.has(p) && n.push(this.blockRequests.get(p)), s.push(p);
      }
    }
    await $3(), this.fetchBlocks(t);
    const o = [];
    for (const f of r)
      this.blockRequests.has(f) && o.push(this.blockRequests.get(f));
    await Promise.allSettled(n), await Promise.allSettled(o);
    const a = [], l = s.filter((f) => this.abortedBlockIds.has(f) || !this.blockCache.has(f));
    if (l.forEach((f) => this.blockIdsToFetch.add(f)), l.length > 0 && t && !t.aborted) {
      this.fetchBlocks(null);
      for (const f of l) {
        const g = this.blockRequests.get(f);
        if (!g)
          throw new Error(`Block ${f} is not in the block requests`);
        a.push(g);
      }
      await Promise.allSettled(a);
    }
    if (t && t.aborted)
      throw new Ma("Request was aborted");
    const h = s.map((f) => this.blockCache.get(f) || this.evictedBlocks.get(f)), u = h.filter((f) => !f);
    if (u.length)
      throw new V3(u, "Request failed");
    const c = new Map(j3(s, h));
    return this.readSliceData(e, c);
  }
  /**
   *
   * @param {AbortSignal} signal
   */
  fetchBlocks(e) {
    if (this.blockIdsToFetch.size > 0) {
      const t = this.groupBlocks(this.blockIdsToFetch), n = this.source.fetch(t, e);
      for (let r = 0; r < t.length; ++r) {
        const s = t[r];
        for (const o of s.blockIds)
          this.blockRequests.set(o, (async () => {
            try {
              const a = (await n)[r], l = o * this.blockSize, h = l - a.offset, u = Math.min(h + this.blockSize, a.data.byteLength), c = a.data.slice(h, u), f = new W3(
                l,
                c.byteLength,
                c,
                o
              );
              this.blockCache.set(o, f), this.abortedBlockIds.delete(o);
            } catch (a) {
              if (a.name === "AbortError")
                a.signal = e, this.blockCache.delete(o), this.abortedBlockIds.add(o);
              else
                throw a;
            } finally {
              this.blockRequests.delete(o);
            }
          })());
      }
      this.blockIdsToFetch.clear();
    }
  }
  /**
   *
   * @param {Set} blockIds
   * @returns {BlockGroup[]}
   */
  groupBlocks(e) {
    const t = Array.from(e).sort((o, a) => o - a);
    if (t.length === 0)
      return [];
    let n = [], r = null;
    const s = [];
    for (const o of t)
      r === null || r + 1 === o ? (n.push(o), r = o) : (s.push(new S1(
        n[0] * this.blockSize,
        n.length * this.blockSize,
        n
      )), n = [o], r = o);
    return s.push(new S1(
      n[0] * this.blockSize,
      n.length * this.blockSize,
      n
    )), s;
  }
  /**
   *
   * @param {import("./basesource").Slice[]} slices
   * @param {Map} blocks
   */
  readSliceData(e, t) {
    return e.map((n) => {
      let r = n.offset + n.length;
      this.fileSize !== null && (r = Math.min(this.fileSize, r));
      const s = Math.floor(n.offset / this.blockSize), o = Math.floor(r / this.blockSize), a = new ArrayBuffer(n.length), l = new Uint8Array(a);
      for (let h = s; h <= o; ++h) {
        const u = t.get(h), c = u.offset - n.offset, f = u.top - r;
        let g = 0, d = 0, m;
        c < 0 ? g = -c : c > 0 && (d = c), f < 0 ? m = u.length - g : m = r - u.offset - g;
        const x = new Uint8Array(u.data, g, m);
        l.set(x, d);
      }
      return a;
    });
  }
}
class w0 {
  /**
   * Returns whether the response has an ok'ish status code
   */
  get ok() {
    return this.status >= 200 && this.status <= 299;
  }
  /**
   * Returns the status code of the response
   */
  get status() {
    throw new Error("not implemented");
  }
  /**
   * Returns the value of the specified header
   * @param {string} headerName the header name
   * @returns {string} the header value
   */
  getHeader(e) {
    throw new Error("not implemented");
  }
  /**
   * @returns {ArrayBuffer} the response data of the request
   */
  async getData() {
    throw new Error("not implemented");
  }
}
class b0 {
  constructor(e) {
    this.url = e;
  }
  /**
   * Send a request with the options
   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]
   * @returns {Promise<BaseResponse>}
   */
  async request({ headers: e, signal: t } = {}) {
    throw new Error("request is not implemented");
  }
}
class q3 extends w0 {
  /**
   * BaseResponse facade for fetch API Response
   * @param {Response} response
   */
  constructor(e) {
    super(), this.response = e;
  }
  get status() {
    return this.response.status;
  }
  getHeader(e) {
    return this.response.headers.get(e);
  }
  async getData() {
    return this.response.arrayBuffer ? await this.response.arrayBuffer() : (await this.response.buffer()).buffer;
  }
}
class Z3 extends b0 {
  constructor(e, t) {
    super(e), this.credentials = t;
  }
  /**
   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]
   * @returns {Promise<FetchResponse>}
   */
  async request({ headers: e, signal: t } = {}) {
    const n = await fetch(this.url, {
      headers: e,
      credentials: this.credentials,
      signal: t
    });
    return new q3(n);
  }
}
class H3 extends w0 {
  /**
   * BaseResponse facade for XMLHttpRequest
   * @param {XMLHttpRequest} xhr
   * @param {ArrayBuffer} data
   */
  constructor(e, t) {
    super(), this.xhr = e, this.data = t;
  }
  get status() {
    return this.xhr.status;
  }
  getHeader(e) {
    return this.xhr.getResponseHeader(e);
  }
  async getData() {
    return this.data;
  }
}
class K3 extends b0 {
  constructRequest(e, t) {
    return new Promise((n, r) => {
      const s = new XMLHttpRequest();
      s.open("GET", this.url), s.responseType = "arraybuffer";
      for (const [o, a] of Object.entries(e))
        s.setRequestHeader(o, a);
      s.onload = () => {
        const o = s.response;
        n(new H3(s, o));
      }, s.onerror = r, s.onabort = () => r(new Ma("Request aborted")), s.send(), t && (t.aborted && s.abort(), t.addEventListener("abort", () => s.abort()));
    });
  }
  async request({ headers: e, signal: t } = {}) {
    return await this.constructRequest(e, t);
  }
}
const Hd = {};
class J3 extends w0 {
  /**
   * BaseResponse facade for node HTTP/HTTPS API Response
   * @param {http.ServerResponse} response
   */
  constructor(e, t) {
    super(), this.response = e, this.dataPromise = t;
  }
  get status() {
    return this.response.statusCode;
  }
  getHeader(e) {
    return this.response.headers[e];
  }
  async getData() {
    return await this.dataPromise;
  }
}
class Q3 extends b0 {
  constructor(e) {
    super(e), this.parsedUrl = Hd.parse(this.url), this.httpApi = (this.parsedUrl.protocol === "http:", Hd);
  }
  constructRequest(e, t) {
    return new Promise((n, r) => {
      const s = this.httpApi.get(
        {
          ...this.parsedUrl,
          headers: e
        },
        (o) => {
          const a = new Promise((l) => {
            const h = [];
            o.on("data", (u) => {
              h.push(u);
            }), o.on("end", () => {
              const u = Buffer.concat(h).buffer;
              l(u);
            }), o.on("error", r);
          });
          n(new J3(o, a));
        }
      );
      s.on("error", r), t && (t.aborted && s.destroy(new Ma("Request aborted")), t.addEventListener("abort", () => s.destroy(new Ma("Request aborted"))));
    });
  }
  async request({ headers: e, signal: t } = {}) {
    return await this.constructRequest(e, t);
  }
}
class S0 extends v0 {
  /**
   *
   * @param {BaseClient} client
   * @param {object} headers
   * @param {numbers} maxRanges
   * @param {boolean} allowFullFile
   */
  constructor(e, t, n, r) {
    super(), this.client = e, this.headers = t, this.maxRanges = n, this.allowFullFile = r, this._fileSize = null;
  }
  /**
   *
   * @param {Slice[]} slices
   */
  async fetch(e, t) {
    return this.maxRanges >= e.length ? this.fetchSlices(e, t) : (this.maxRanges > 0 && e.length > 1, Promise.all(
      e.map((n) => this.fetchSlice(n, t))
    ));
  }
  async fetchSlices(e, t) {
    const n = await this.client.request({
      headers: {
        ...this.headers,
        Range: `bytes=${e.map(({ offset: r, length: s }) => `${r}-${r + s}`).join(",")}`
      },
      signal: t
    });
    if (n.ok)
      if (n.status === 206) {
        const { type: r, params: s } = U3(n.getHeader("content-type"));
        if (r === "multipart/byteranges") {
          const c = z3(await n.getData(), s.boundary);
          return this._fileSize = c[0].fileSize || null, c;
        }
        const o = await n.getData(), { start: a, end: l, total: h } = op(n.getHeader("content-range"));
        this._fileSize = h || null;
        const u = [{
          data: o,
          offset: a,
          length: l - a
        }];
        if (e.length > 1) {
          const c = await Promise.all(e.slice(1).map((f) => this.fetchSlice(f, t)));
          return u.concat(c);
        }
        return u;
      } else {
        if (!this.allowFullFile)
          throw new Error("Server responded with full file");
        const r = await n.getData();
        return this._fileSize = r.byteLength, [{
          data: r,
          offset: 0,
          length: r.byteLength
        }];
      }
    else throw new Error("Error fetching data.");
  }
  async fetchSlice(e, t) {
    const { offset: n, length: r } = e, s = await this.client.request({
      headers: {
        ...this.headers,
        Range: `bytes=${n}-${n + r}`
      },
      signal: t
    });
    if (s.ok)
      if (s.status === 206) {
        const o = await s.getData(), { total: a } = op(s.getHeader("content-range"));
        return this._fileSize = a || null, {
          data: o,
          offset: n,
          length: r
        };
      } else {
        if (!this.allowFullFile)
          throw new Error("Server responded with full file");
        const o = await s.getData();
        return this._fileSize = o.byteLength, {
          data: o,
          offset: 0,
          length: o.byteLength
        };
      }
    else throw new Error("Error fetching data.");
  }
  get fileSize() {
    return this._fileSize;
  }
}
function T0(i, { blockSize: e, cacheSize: t }) {
  return e === null ? i : new Y3(i, { blockSize: e, cacheSize: t });
}
function eN(i, { headers: e = {}, credentials: t, maxRanges: n = 0, allowFullFile: r = !1, ...s } = {}) {
  const o = new Z3(i, t), a = new S0(o, e, n, r);
  return T0(a, s);
}
function tN(i, { headers: e = {}, maxRanges: t = 0, allowFullFile: n = !1, ...r } = {}) {
  const s = new K3(i), o = new S0(s, e, t, n);
  return T0(o, r);
}
function iN(i, { headers: e = {}, maxRanges: t = 0, allowFullFile: n = !1, ...r } = {}) {
  const s = new Q3(i), o = new S0(s, e, t, n);
  return T0(o, r);
}
function ap(i, { forceXHR: e = !1, ...t } = {}) {
  return typeof fetch == "function" && !e ? eN(i, t) : typeof XMLHttpRequest < "u" ? tN(i, t) : iN(i, t);
}
class nN extends v0 {
  constructor(e) {
    super(), this.file = e;
  }
  async fetchSlice(e, t) {
    return new Promise((n, r) => {
      const s = this.file.slice(e.offset, e.offset + e.length), o = new FileReader();
      o.onload = (a) => n(a.target.result), o.onerror = r, o.onabort = r, o.readAsArrayBuffer(s), t && t.addEventListener("abort", () => o.abort());
    });
  }
}
function rN(i) {
  return new nN(i);
}
function lp(i) {
  switch (i) {
    case Fe.BYTE:
    case Fe.ASCII:
    case Fe.SBYTE:
    case Fe.UNDEFINED:
      return 1;
    case Fe.SHORT:
    case Fe.SSHORT:
      return 2;
    case Fe.LONG:
    case Fe.SLONG:
    case Fe.FLOAT:
    case Fe.IFD:
      return 4;
    case Fe.RATIONAL:
    case Fe.SRATIONAL:
    case Fe.DOUBLE:
    case Fe.LONG8:
    case Fe.SLONG8:
    case Fe.IFD8:
      return 8;
    default:
      throw new RangeError(`Invalid field type: ${i}`);
  }
}
function sN(i) {
  const e = i.GeoKeyDirectory;
  if (!e)
    return null;
  const t = {};
  for (let n = 4; n <= e[3] * 4; n += 4) {
    const r = p3[e[n]], s = e[n + 1] ? kl[e[n + 1]] : null, o = e[n + 2], a = e[n + 3];
    let l = null;
    if (!s)
      l = a;
    else {
      if (l = i[s], typeof l > "u" || l === null)
        throw new Error(`Could not get value of geoKey '${r}'.`);
      typeof l == "string" ? l = l.substring(a, a + o - 1) : l.subarray && (l = l.subarray(a, a + o), o === 1 && (l = l[0]));
    }
    t[r] = l;
  }
  return t;
}
function No(i, e, t, n) {
  let r = null, s = null;
  const o = lp(e);
  switch (e) {
    case Fe.BYTE:
    case Fe.ASCII:
    case Fe.UNDEFINED:
      r = new Uint8Array(t), s = i.readUint8;
      break;
    case Fe.SBYTE:
      r = new Int8Array(t), s = i.readInt8;
      break;
    case Fe.SHORT:
      r = new Uint16Array(t), s = i.readUint16;
      break;
    case Fe.SSHORT:
      r = new Int16Array(t), s = i.readInt16;
      break;
    case Fe.LONG:
    case Fe.IFD:
      r = new Uint32Array(t), s = i.readUint32;
      break;
    case Fe.SLONG:
      r = new Int32Array(t), s = i.readInt32;
      break;
    case Fe.LONG8:
    case Fe.IFD8:
      r = new Array(t), s = i.readUint64;
      break;
    case Fe.SLONG8:
      r = new Array(t), s = i.readInt64;
      break;
    case Fe.RATIONAL:
      r = new Uint32Array(t * 2), s = i.readUint32;
      break;
    case Fe.SRATIONAL:
      r = new Int32Array(t * 2), s = i.readInt32;
      break;
    case Fe.FLOAT:
      r = new Float32Array(t), s = i.readFloat32;
      break;
    case Fe.DOUBLE:
      r = new Float64Array(t), s = i.readFloat64;
      break;
    default:
      throw new RangeError(`Invalid field type: ${e}`);
  }
  if (e === Fe.RATIONAL || e === Fe.SRATIONAL)
    for (let a = 0; a < t; a += 2)
      r[a] = s.call(
        i,
        n + a * o
      ), r[a + 1] = s.call(
        i,
        n + (a * o + 4)
      );
  else
    for (let a = 0; a < t; ++a)
      r[a] = s.call(
        i,
        n + a * o
      );
  return e === Fe.ASCII ? new TextDecoder("utf-8").decode(r) : r;
}
class oN {
  constructor(e, t, n) {
    this.fileDirectory = e, this.geoKeyDirectory = t, this.nextIFDByteOffset = n;
  }
}
class Pu extends Error {
  constructor(e) {
    super(`No image at index ${e}`), this.index = e;
  }
}
class wb {
  /**
   * (experimental) Reads raster data from the best fitting image. This function uses
   * the image with the lowest resolution that is still a higher resolution than the
   * requested resolution.
   * When specified, the `bbox` option is translated to the `window` option and the
   * `resX` and `resY` to `width` and `height` respectively.
   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected
   * image is called and the result returned.
   * @see GeoTIFFImage.readRasters
   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters
   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise
   */
  async readRasters(e = {}) {
    const { window: t, width: n, height: r } = e;
    let { resX: s, resY: o, bbox: a } = e;
    const l = await this.getImage();
    let h = l;
    const u = await this.getImageCount(), c = l.getBoundingBox();
    if (t && a)
      throw new Error('Both "bbox" and "window" passed.');
    if (n || r) {
      if (t) {
        const [d, m] = l.getOrigin(), [x, v] = l.getResolution();
        a = [
          d + t[0] * x,
          m + t[1] * v,
          d + t[2] * x,
          m + t[3] * v
        ];
      }
      const g = a || c;
      if (n) {
        if (s)
          throw new Error("Both width and resX passed");
        s = (g[2] - g[0]) / n;
      }
      if (r) {
        if (o)
          throw new Error("Both width and resY passed");
        o = (g[3] - g[1]) / r;
      }
    }
    if (s || o) {
      const g = [];
      for (let d = 0; d < u; ++d) {
        const m = await this.getImage(d), { SubfileType: x, NewSubfileType: v } = m.fileDirectory;
        (d === 0 || x === 2 || v & 1) && g.push(m);
      }
      g.sort((d, m) => d.getWidth() - m.getWidth());
      for (let d = 0; d < g.length; ++d) {
        const m = g[d], x = (c[2] - c[0]) / m.getWidth(), v = (c[3] - c[1]) / m.getHeight();
        if (h = m, s && s > x || o && o > v)
          break;
      }
    }
    let f = t;
    if (a) {
      const [g, d] = l.getOrigin(), [m, x] = h.getResolution(l);
      f = [
        Math.round((a[0] - g) / m),
        Math.round((a[1] - d) / x),
        Math.round((a[2] - g) / m),
        Math.round((a[3] - d) / x)
      ], f = [
        Math.min(f[0], f[2]),
        Math.min(f[1], f[3]),
        Math.max(f[0], f[2]),
        Math.max(f[1], f[3])
      ];
    }
    return h.readRasters({ ...e, window: f });
  }
}
class Ca extends wb {
  /**
   * @constructor
   * @param {*} source The datasource to read from.
   * @param {boolean} littleEndian Whether the image uses little endian.
   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.
   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image
   *                                to the first IFD.
   * @param {GeoTIFFOptions} [options] further options.
   */
  constructor(e, t, n, r, s = {}) {
    super(), this.source = e, this.littleEndian = t, this.bigTiff = n, this.firstIFDOffset = r, this.cache = s.cache || !1, this.ifdRequests = [], this.ghostValues = null;
  }
  async getSlice(e, t) {
    const n = this.bigTiff ? 4048 : 1024;
    return new N3(
      (await this.source.fetch([{
        offset: e,
        length: typeof t < "u" ? t : n
      }]))[0],
      e,
      this.littleEndian,
      this.bigTiff
    );
  }
  /**
   * Instructs to parse an image file directory at the given file offset.
   * As there is no way to ensure that a location is indeed the start of an IFD,
   * this function must be called with caution (e.g only using the IFD offsets from
   * the headers or other IFDs).
   * @param {number} offset the offset to parse the IFD at
   * @returns {Promise<ImageFileDirectory>} the parsed IFD
   */
  async parseFileDirectoryAt(e) {
    const t = this.bigTiff ? 20 : 12, n = this.bigTiff ? 8 : 2;
    let r = await this.getSlice(e);
    const s = this.bigTiff ? r.readUint64(e) : r.readUint16(e), o = s * t + (this.bigTiff ? 16 : 6);
    r.covers(e, o) || (r = await this.getSlice(e, o));
    const a = {};
    let l = e + (this.bigTiff ? 8 : 2);
    for (let c = 0; c < s; l += t, ++c) {
      const f = r.readUint16(l), g = r.readUint16(l + 2), d = this.bigTiff ? r.readUint64(l + 4) : r.readUint32(l + 4);
      let m, x;
      const v = lp(g), p = l + (this.bigTiff ? 12 : 8);
      if (v * d <= (this.bigTiff ? 8 : 4))
        m = No(r, g, d, p);
      else {
        const y = r.readOffset(p), E = lp(g) * d;
        if (r.covers(y, E))
          m = No(r, g, d, y);
        else {
          const b = await this.getSlice(y, E);
          m = No(b, g, d, y);
        }
      }
      d === 1 && d3.indexOf(f) === -1 && !(g === Fe.RATIONAL || g === Fe.SRATIONAL) ? x = m[0] : x = m, a[kl[f]] = x;
    }
    const h = sN(a), u = r.readOffset(
      e + n + t * s
    );
    return new oN(
      a,
      h,
      u
    );
  }
  async requestIFD(e) {
    if (this.ifdRequests[e])
      return this.ifdRequests[e];
    if (e === 0)
      return this.ifdRequests[e] = this.parseFileDirectoryAt(this.firstIFDOffset), this.ifdRequests[e];
    if (!this.ifdRequests[e - 1])
      try {
        this.ifdRequests[e - 1] = this.requestIFD(e - 1);
      } catch (t) {
        throw t instanceof Pu ? new Pu(e) : t;
      }
    return this.ifdRequests[e] = (async () => {
      const t = await this.ifdRequests[e - 1];
      if (t.nextIFDByteOffset === 0)
        throw new Pu(e);
      return this.parseFileDirectoryAt(t.nextIFDByteOffset);
    })(), this.ifdRequests[e];
  }
  /**
   * Get the n-th internal subfile of an image. By default, the first is returned.
   *
   * @param {number} [index=0] the index of the image to return.
   * @returns {Promise<GeoTIFFImage>} the image at the given index
   */
  async getImage(e = 0) {
    const t = await this.requestIFD(e);
    return new Eb(
      t.fileDirectory,
      t.geoKeyDirectory,
      this.dataView,
      this.littleEndian,
      this.cache,
      this.source
    );
  }
  /**
   * Returns the count of the internal subfiles.
   *
   * @returns {Promise<number>} the number of internal subfile images
   */
  async getImageCount() {
    let e = 0, t = !0;
    for (; t; )
      try {
        await this.requestIFD(e), ++e;
      } catch (n) {
        if (n instanceof Pu)
          t = !1;
        else
          throw n;
      }
    return e;
  }
  /**
   * Get the values of the COG ghost area as a parsed map.
   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference
   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found
   */
  async getGhostValues() {
    const e = this.bigTiff ? 16 : 8;
    if (this.ghostValues)
      return this.ghostValues;
    const t = "GDAL_STRUCTURAL_METADATA_SIZE=", n = t.length + 100;
    let r = await this.getSlice(e, n);
    if (t === No(r, Fe.ASCII, t.length, e)) {
      const o = No(r, Fe.ASCII, n, e).split(`
`)[0], a = Number(o.split("=")[1].split(" ")[0]) + o.length;
      a > n && (r = await this.getSlice(e, a));
      const l = No(r, Fe.ASCII, a, e);
      this.ghostValues = {}, l.split(`
`).filter((h) => h.length > 0).map((h) => h.split("=")).forEach(([h, u]) => {
        this.ghostValues[h] = u;
      });
    }
    return this.ghostValues;
  }
  /**
   * Parse a (Geo)TIFF file from the given source.
   *
   * @param {*} source The source of data to parse from.
   * @param {GeoTIFFOptions} [options] Additional options.
   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
   *                               to be aborted
   */
  static async fromSource(e, t, n) {
    const r = (await e.fetch([{ offset: 0, length: 1024 }], n))[0], s = new O3(r), o = s.getUint16(0, 0);
    let a;
    if (o === 18761)
      a = !0;
    else if (o === 19789)
      a = !1;
    else
      throw new TypeError("Invalid byte order value.");
    const l = s.getUint16(2, a);
    let h;
    if (l === 42)
      h = !1;
    else if (l === 43) {
      if (h = !0, s.getUint16(4, a) !== 8)
        throw new Error("Unsupported offset byte-size.");
    } else
      throw new TypeError("Invalid magic number.");
    const u = h ? s.getUint64(8, a) : s.getUint32(4, a);
    return new Ca(e, a, h, u, t);
  }
  /**
   * Closes the underlying file buffer
   * N.B. After the GeoTIFF has been completely processed it needs
   * to be closed but only if it has been constructed from a file.
   */
  close() {
    return typeof this.source.close == "function" ? this.source.close() : !1;
  }
}
class aN extends wb {
  /**
   * Construct a new MultiGeoTIFF from a main and several overview files.
   * @param {GeoTIFF} mainFile The main GeoTIFF file.
   * @param {GeoTIFF[]} overviewFiles An array of overview files.
   */
  constructor(e, t) {
    super(), this.mainFile = e, this.overviewFiles = t, this.imageFiles = [e].concat(t), this.fileDirectoriesPerFile = null, this.fileDirectoriesPerFileParsing = null, this.imageCount = null;
  }
  async parseFileDirectoriesPerFile() {
    const e = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map((t) => t.parseFileDirectoryAt(t.firstIFDOffset)));
    return this.fileDirectoriesPerFile = await Promise.all(e), this.fileDirectoriesPerFile;
  }
  /**
   * Get the n-th internal subfile of an image. By default, the first is returned.
   *
   * @param {number} [index=0] the index of the image to return.
   * @returns {Promise<GeoTIFFImage>} the image at the given index
   */
  async getImage(e = 0) {
    await this.getImageCount(), await this.parseFileDirectoriesPerFile();
    let t = 0, n = 0;
    for (let r = 0; r < this.imageFiles.length; r++) {
      const s = this.imageFiles[r];
      for (let o = 0; o < this.imageCounts[r]; o++) {
        if (e === t) {
          const a = await s.requestIFD(n);
          return new Eb(
            a.fileDirectory,
            a.geoKeyDirectory,
            s.dataView,
            s.littleEndian,
            s.cache,
            s.source
          );
        }
        t++, n++;
      }
      n = 0;
    }
    throw new RangeError("Invalid image index");
  }
  /**
   * Returns the count of the internal subfiles.
   *
   * @returns {Promise<number>} the number of internal subfile images
   */
  async getImageCount() {
    if (this.imageCount !== null)
      return this.imageCount;
    const e = [this.mainFile.getImageCount()].concat(this.overviewFiles.map((t) => t.getImageCount()));
    return this.imageCounts = await Promise.all(e), this.imageCount = this.imageCounts.reduce((t, n) => t + n, 0), this.imageCount;
  }
}
async function lN(i, e = {}, t) {
  return Ca.fromSource(ap(i, e), t);
}
async function hN(i, e) {
  return Ca.fromSource(rN(i), e);
}
async function uN(i, e = [], t = {}, n) {
  const r = await Ca.fromSource(ap(i, t), n), s = await Promise.all(
    e.map((o) => Ca.fromSource(ap(o, t)))
  );
  return new aN(r, s);
}
const Do = [0, 0, 0], ts = 5;
class qr {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(e) {
    this.minZoom = e.minZoom !== void 0 ? e.minZoom : 0, this.resolutions_ = e.resolutions, Te(
      ST(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (r, s) => s - r
      ),
      "`resolutions` must be sorted in descending order"
    );
    let t;
    if (!e.origins) {
      for (let r = 0, s = this.resolutions_.length - 1; r < s; ++r)
        if (!t)
          t = this.resolutions_[r] / this.resolutions_[r + 1];
        else if (this.resolutions_[r] / this.resolutions_[r + 1] !== t) {
          t = void 0;
          break;
        }
    }
    this.zoomFactor_ = t, this.maxZoom = this.resolutions_.length - 1, this.origin_ = e.origin !== void 0 ? e.origin : null, this.origins_ = null, e.origins !== void 0 && (this.origins_ = e.origins, Te(
      this.origins_.length == this.resolutions_.length,
      "Number of `origins` and `resolutions` must be equal"
    ));
    const n = e.extent;
    n !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = Mn(n)), Te(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    ), this.tileSizes_ = null, e.tileSizes !== void 0 && (this.tileSizes_ = e.tileSizes, Te(
      this.tileSizes_.length == this.resolutions_.length,
      "Number of `tileSizes` and `resolutions` must be equal"
    )), this.tileSize_ = e.tileSize !== void 0 ? e.tileSize : this.tileSizes_ ? null : Ta, Te(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    ), this.extent_ = n !== void 0 ? n : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], e.sizes !== void 0 ? this.fullTileRanges_ = e.sizes.map((r, s) => {
      const o = new Uf(
        Math.min(0, r[0]),
        Math.max(r[0] - 1, -1),
        Math.min(0, r[1]),
        Math.max(r[1] - 1, -1)
      );
      if (n) {
        const a = this.getTileRangeForExtentAndZ(n, s);
        o.minX = Math.max(a.minX, o.minX), o.maxX = Math.min(a.maxX, o.maxX), o.minY = Math.max(a.minY, o.minY), o.maxY = Math.min(a.maxY, o.maxY);
      }
      return o;
    }) : n && this.calculateTileRanges_(n);
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(e, t, n) {
    const r = this.getTileRangeForExtentAndZ(e, t);
    for (let s = r.minX, o = r.maxX; s <= o; ++s)
      for (let a = r.minY, l = r.maxY; a <= l; ++a)
        n([t, s, a]);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(e, t, n, r) {
    let s, o, a, l = null, h = e[0] - 1;
    for (this.zoomFactor_ === 2 ? (o = e[1], a = e[2]) : l = this.getTileCoordExtent(e, r); h >= this.minZoom; ) {
      if (o !== void 0 && a !== void 0 ? (o = Math.floor(o / 2), a = Math.floor(a / 2), s = Io(o, o, a, a, n)) : s = this.getTileRangeForExtentAndZ(
        l,
        h,
        n
      ), t(h, s))
        return !0;
      --h;
    }
    return !1;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(e) {
    return this.origin_ ? this.origin_ : this.origins_[e];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(e) {
    return this.resolutions_[e];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(e, t, n) {
    if (e[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const s = e[1] * 2, o = e[2] * 2;
        return Io(
          s,
          s + 1,
          o,
          o + 1,
          t
        );
      }
      const r = this.getTileCoordExtent(
        e,
        n || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        r,
        e[0] + 1,
        t
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(e, t, n) {
    if (t > this.maxZoom || t < this.minZoom)
      return null;
    const r = e[0], s = e[1], o = e[2];
    if (t === r)
      return Io(
        s,
        o,
        s,
        o,
        n
      );
    if (this.zoomFactor_) {
      const l = Math.pow(this.zoomFactor_, t - r), h = Math.floor(s * l), u = Math.floor(o * l);
      if (t < r)
        return Io(h, h, u, u, n);
      const c = Math.floor(l * (s + 1)) - 1, f = Math.floor(l * (o + 1)) - 1;
      return Io(h, c, u, f, n);
    }
    const a = this.getTileCoordExtent(e, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(a, t, n);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(e, t, n) {
    this.getTileCoordForXYAndZ_(e[0], e[3], t, !1, Do);
    const r = Do[1], s = Do[2];
    this.getTileCoordForXYAndZ_(e[2], e[1], t, !0, Do);
    const o = Do[1], a = Do[2];
    return Io(r, o, s, a, n);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(e) {
    const t = this.getOrigin(e[0]), n = this.getResolution(e[0]), r = dt(this.getTileSize(e[0]), this.tmpSize_);
    return [
      t[0] + (e[1] + 0.5) * r[0] * n,
      t[1] - (e[2] + 0.5) * r[1] * n
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(e, t) {
    const n = this.getOrigin(e[0]), r = this.getResolution(e[0]), s = dt(this.getTileSize(e[0]), this.tmpSize_), o = n[0] + e[1] * s[0] * r, a = n[1] - (e[2] + 1) * s[1] * r, l = o + s[0] * r, h = a + s[1] * r;
    return Xn(o, a, l, h, t);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(e, t, n) {
    return this.getTileCoordForXYAndResolution_(
      e[0],
      e[1],
      t,
      !1,
      n
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(e, t, n, r, s) {
    const o = this.getZForResolution(n), a = n / this.getResolution(o), l = this.getOrigin(o), h = dt(this.getTileSize(o), this.tmpSize_);
    let u = a * (e - l[0]) / n / h[0], c = a * (l[1] - t) / n / h[1];
    return r ? (u = us(u, ts) - 1, c = us(c, ts) - 1) : (u = ru(u, ts), c = ru(c, ts)), go(o, u, c, s);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(e, t, n, r, s) {
    const o = this.getOrigin(n), a = this.getResolution(n), l = dt(this.getTileSize(n), this.tmpSize_);
    let h = (e - o[0]) / a / l[0], u = (o[1] - t) / a / l[1];
    return r ? (h = us(h, ts) - 1, u = us(u, ts) - 1) : (h = ru(h, ts), u = ru(u, ts)), go(n, h, u, s);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(e, t, n) {
    return this.getTileCoordForXYAndZ_(
      e[0],
      e[1],
      t,
      !1,
      n
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(e) {
    return this.resolutions_[e[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(e) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[e];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(e) {
    return this.fullTileRanges_ ? this.fullTileRanges_[e] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, e) : null;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(e, t) {
    const n = ff(
      this.resolutions_,
      e,
      t || 0
    );
    return ve(n, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(e, t) {
    return NE(
      t,
      0,
      t.length,
      2,
      this.getTileCoordExtent(e)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(e) {
    const t = this.resolutions_.length, n = new Array(t);
    for (let r = this.minZoom; r < t; ++r)
      n[r] = this.getTileRangeForExtentAndZ(e, r);
    this.fullTileRanges_ = n;
  }
}
const cN = `
  attribute vec4 a_position;
  attribute vec4 a_texcoord;

  uniform mat4 u_matrix;
  uniform mat4 u_textureMatrix;

  varying vec2 v_texcoord;

  void main() {
    gl_Position = u_matrix * a_position;
    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;
    v_texcoord = texcoord;
  }
`, fN = `
  precision mediump float;

  varying vec2 v_texcoord;

  uniform sampler2D u_texture;

  void main() {
    if (
      v_texcoord.x < 0.0 ||
      v_texcoord.y < 0.0 ||
      v_texcoord.x > 1.0 ||
      v_texcoord.y > 1.0
    ) {
      discard;
    }
    gl_FragColor = texture2D(u_texture, v_texcoord);
  }
`;
class dN {
  /**
   * @param {WebGLRenderingContext} gl Context to render in.
   */
  constructor(e) {
    this.gl_ = e, this.program_ = hp(e, fN, cN), this.positionLocation = e.getAttribLocation(this.program_, "a_position"), this.texcoordLocation = e.getAttribLocation(this.program_, "a_texcoord"), this.matrixLocation = e.getUniformLocation(this.program_, "u_matrix"), this.textureMatrixLocation = e.getUniformLocation(
      this.program_,
      "u_textureMatrix"
    ), this.textureLocation = e.getUniformLocation(this.program_, "u_texture"), this.positionBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.positionBuffer), this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], e.bufferData(
      e.ARRAY_BUFFER,
      new Float32Array(this.positions),
      e.STATIC_DRAW
    ), this.texcoordBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.texcoordBuffer), this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], e.bufferData(
      e.ARRAY_BUFFER,
      new Float32Array(this.texcoords),
      e.STATIC_DRAW
    );
  }
  /**
   * 2dContext drawImage call implemented in webgl.
   * Unlike images, textures do not have a width and height associated
   * with them so we'll pass in the width and height of the texture.
   *
   * @param {WebGLTexture} tex Image to draw.
   * @param {number} texWidth Image width.
   * @param {number} texHeight Image height.
   * @param {number} srcX Top-left x-point to read src image.
   * @param {number} srcY Top-left y-point to read src image.
   * @param {number} [srcWidth] Width of source to read.
   * @param {number} [srcHeight] Height of source to read.
   * @param {number} [dstX] Top-left x-point of destination.
   * @param {number} [dstY] Top-left y-point of destination.
   * @param {number} [dstWidth] Width of written image in destination.
   * @param {number} [dstHeight] Height of written image in destination.
   * @param {number} [width] Width of canvas.
   * @param {number} [height] Height of canvas.
   */
  drawImage(e, t, n, r, s, o, a, l, h, u, c, f, g) {
    const d = this.gl_;
    l === void 0 && (l = r), h === void 0 && (h = s), o === void 0 && (o = t), a === void 0 && (a = n), u === void 0 && (u = o), c === void 0 && (c = a), f === void 0 && (f = d.canvas.width), g === void 0 && (g = d.canvas.height), d.bindTexture(d.TEXTURE_2D, e), d.useProgram(this.program_), d.bindBuffer(d.ARRAY_BUFFER, this.positionBuffer), d.enableVertexAttribArray(this.positionLocation), d.vertexAttribPointer(this.positionLocation, 2, d.FLOAT, !1, 0, 0), d.bindBuffer(d.ARRAY_BUFFER, this.texcoordBuffer), d.enableVertexAttribArray(this.texcoordLocation), d.vertexAttribPointer(this.texcoordLocation, 2, d.FLOAT, !1, 0, 0);
    let m = Hg(0, f, 0, g, -1, 1);
    m = OF(m, l, h, 0), m = i1(m, u, c, 1), d.uniformMatrix4fv(this.matrixLocation, !1, m);
    let x = NF(r / t, s / n, 0);
    x = i1(
      x,
      o / t,
      a / n,
      1
    ), d.uniformMatrix4fv(this.textureMatrixLocation, !1, x), d.uniform1i(this.textureLocation, 0), d.drawArrays(d.TRIANGLES, 0, this.positions.length / 2);
  }
}
function T1(i, e, t) {
  const n = i.createShader(e);
  if (n === null)
    throw new Error("Shader compilation failed");
  if (i.shaderSource(n, t), i.compileShader(n), !i.getShaderParameter(n, i.COMPILE_STATUS)) {
    const r = i.getShaderInfoLog(n);
    throw r === null ? new Error("Shader info log creation failed") : new Error(r);
  }
  return n;
}
function hp(i, e, t) {
  const n = i.createProgram(), r = T1(i, i.VERTEX_SHADER, t), s = T1(i, i.FRAGMENT_SHADER, e);
  if (n === null)
    throw new Error("Program creation failed");
  if (i.attachShader(n, r), i.attachShader(n, s), i.linkProgram(n), !i.getProgramParameter(n, i.LINK_STATUS))
    throw i.getProgramInfoLog(n) === null ? new Error("Program info log creation failed") : new Error();
  return n;
}
const gN = `
  attribute vec4 a_position;

  uniform mat4 u_matrix;

  void main() {
     gl_Position = u_matrix * a_position;
  }
`, pN = `
  precision mediump float;

  uniform vec4 u_val;
  void main() {
     gl_FragColor = u_val;
  }
`, mN = `
  attribute vec4 a_position;
  attribute vec2 a_texcoord;

  varying vec2 v_texcoord;

  uniform mat4 u_matrix;

  void main() {
     gl_Position = u_matrix * a_position;
     v_texcoord = a_texcoord;
  }
`, _N = `
  precision mediump float;

  varying vec2 v_texcoord;

  uniform sampler2D u_texture;

  void main() {
    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {
      discard;
    }
    gl_FragColor = texture2D(u_texture, v_texcoord);
  }
`;
function yN(i, e, t, n) {
  let r;
  return t && t.length ? r = /** @type {HTMLCanvasElement} */
  t.shift() : di ? r = new OffscreenCanvas(i || 300, e || 300) : r = document.createElement("canvas"), i && (r.width = i), e && (r.height = e), /** @type {WebGLRenderingContext} */
  r.getContext("webgl", n);
}
function xN(i) {
  const e = i.canvas;
  e.width = 1, e.height = 1, i.clear(i.COLOR_BUFFER_BIT | i.DEPTH_BUFFER_BIT | i.STENCIL_BUFFER_BIT);
}
const R1 = [];
function EN(i, e, t, n, r, s, o, a, l, h, u, c, f, g) {
  const d = Math.round(n * e), m = Math.round(n * t);
  i.canvas.width = d, i.canvas.height = m;
  let x, v;
  if (v = i.createTexture(), i.bindTexture(i.TEXTURE_2D, v), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), f ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST)), i.texImage2D(
    i.TEXTURE_2D,
    0,
    i.RGBA,
    d,
    m,
    0,
    i.RGBA,
    u,
    null
  ), x = i.createFramebuffer(), i.bindFramebuffer(i.FRAMEBUFFER, x), i.framebufferTexture2D(
    i.FRAMEBUFFER,
    i.COLOR_ATTACHMENT0,
    i.TEXTURE_2D,
    v,
    0
  ), x === null)
    throw new Error("Could not create framebuffer");
  if (v === null)
    throw new Error("Could not create texture");
  if (l.length === 0)
    return {
      width: d,
      height: m,
      framebuffer: x,
      texture: v
    };
  const p = hi();
  l.forEach(function(I, O, z) {
    jp(p, I.extent);
  });
  let y, E, b;
  const T = 1 / r;
  {
    if (y = i.createTexture(), v === null)
      throw new Error("Could not create texture");
    E = Math.round(_e(p) * T), b = Math.round(it(p) * T);
    const I = i.getParameter(i.MAX_TEXTURE_SIZE), O = Math.max(E, b), z = O > I ? I / O : 1, _ = Math.round(E * z), w = Math.round(b * z);
    i.bindTexture(i.TEXTURE_2D, y), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), f ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST)), i.texImage2D(
      i.TEXTURE_2D,
      0,
      i.RGBA,
      _,
      w,
      0,
      i.RGBA,
      u,
      null
    );
    const S = i.createFramebuffer();
    i.bindFramebuffer(i.FRAMEBUFFER, S), i.framebufferTexture2D(
      i.FRAMEBUFFER,
      i.COLOR_ATTACHMENT0,
      i.TEXTURE_2D,
      y,
      0
    );
    const P = new dN(i);
    l.forEach(function(A, D, k) {
      const U = (A.extent[0] - p[0]) * T * z, G = -(A.extent[3] - p[3]) * T * z, $ = _e(A.extent) * T * z, H = it(A.extent) * T * z;
      if (i.bindFramebuffer(i.FRAMEBUFFER, S), i.viewport(0, 0, _, w), A.clipExtent) {
        const ne = (A.clipExtent[0] - p[0]) * T * z, te = -(A.clipExtent[3] - p[3]) * T * z, re = _e(A.clipExtent) * T * z, ae = it(A.clipExtent) * T * z;
        i.enable(i.SCISSOR_TEST), i.scissor(
          f ? ne : Math.round(ne),
          f ? te : Math.round(te),
          f ? re : Math.round(ne + re) - Math.round(ne),
          f ? ae : Math.round(te + ae) - Math.round(te)
        );
      }
      P.drawImage(
        A.texture,
        A.width,
        A.height,
        h,
        h,
        A.width - 2 * h,
        A.height - 2 * h,
        f ? U : Math.round(U),
        f ? G : Math.round(G),
        f ? $ : Math.round(U + $) - Math.round(U),
        f ? H : Math.round(G + H) - Math.round(G),
        _,
        w
      ), i.disable(i.SCISSOR_TEST);
    }), i.deleteFramebuffer(S);
  }
  const R = Mn(o), M = Mn(p), C = (I) => {
    const O = (I[0][0] - R[0]) / s * n, z = -(I[0][1] - R[1]) / s * n, _ = (I[1][0] - R[0]) / s * n, w = -(I[1][1] - R[1]) / s * n, S = (I[2][0] - R[0]) / s * n, P = -(I[2][1] - R[1]) / s * n;
    return { u1: _, v1: w, u0: O, v0: z, u2: S, v2: P };
  };
  i.bindFramebuffer(i.FRAMEBUFFER, x), i.viewport(0, 0, d, m);
  {
    const I = [], O = [], z = hp(
      i,
      _N,
      mN
    );
    i.useProgram(z);
    const _ = i.getUniformLocation(z, "u_texture");
    i.bindTexture(i.TEXTURE_2D, y), i.uniform1i(_, 0), a.getTriangles().forEach(function(U, G, $) {
      const H = U.source, ne = U.target, { u1: te, v1: re, u0: ae, v0: Re, u2: xe, v2: Ae } = C(ne), Z = (H[0][0] - M[0]) / r / E, at = -(H[0][1] - M[1]) / r / b, ut = (H[1][0] - M[0]) / r / E, Ee = -(H[1][1] - M[1]) / r / b, gt = (H[2][0] - M[0]) / r / E, St = -(H[2][1] - M[1]) / r / b;
      I.push(te, re, ae, Re, xe, Ae), O.push(ut, Ee, Z, at, gt, St);
    });
    const w = Hg(0, d, m, 0, -1, 1), S = i.getUniformLocation(z, "u_matrix");
    i.uniformMatrix4fv(S, !1, w);
    const P = i.getAttribLocation(z, "a_position"), A = i.createBuffer();
    i.bindBuffer(i.ARRAY_BUFFER, A), i.bufferData(i.ARRAY_BUFFER, new Float32Array(I), i.STATIC_DRAW), i.vertexAttribPointer(P, 2, i.FLOAT, !1, 0, 0), i.enableVertexAttribArray(P);
    const D = i.getAttribLocation(z, "a_texcoord"), k = i.createBuffer();
    i.bindBuffer(i.ARRAY_BUFFER, k), i.bufferData(i.ARRAY_BUFFER, new Float32Array(O), i.STATIC_DRAW), i.vertexAttribPointer(D, 2, i.FLOAT, !1, 0, 0), i.enableVertexAttribArray(D), i.drawArrays(i.TRIANGLES, 0, I.length / 2);
  }
  if (c) {
    const I = hp(
      i,
      pN,
      gN
    );
    i.useProgram(I);
    const O = Hg(0, d, m, 0, -1, 1), z = i.getUniformLocation(I, "u_matrix");
    i.uniformMatrix4fv(z, !1, O);
    const _ = Array.isArray(c) ? c : [0, 0, 0, 255], w = i.getUniformLocation(I, "u_val");
    i.uniform4fv(w, _);
    const S = i.getAttribLocation(I, "a_position"), P = i.createBuffer();
    i.bindBuffer(i.ARRAY_BUFFER, P), i.vertexAttribPointer(S, 2, i.FLOAT, !1, 0, 0), i.enableVertexAttribArray(S);
    const A = a.getTriangles().reduce(function(D, k) {
      const U = k.target, { u1: G, v1: $, u0: H, v0: ne, u2: te, v2: re } = C(U);
      return D.concat([G, $, H, ne, H, ne, te, re, te, re, G, $]);
    }, []);
    i.bufferData(i.ARRAY_BUFFER, new Float32Array(A), i.STATIC_DRAW), i.drawArrays(i.LINES, 0, A.length / 2);
  }
  return {
    width: d,
    height: m,
    framebuffer: x,
    texture: v
  };
}
class vN extends rh {
  /**
   * @param {Options} options Tile options.
   */
  constructor(e) {
    super({
      tileCoord: e.tileCoord,
      loader: () => Promise.resolve(new Uint8ClampedArray(4)),
      interpolate: e.interpolate,
      transition: e.transition
    }), this.renderEdges_ = e.renderEdges !== void 0 ? e.renderEdges : !1, this.pixelRatio_ = e.pixelRatio, this.gutter_ = e.gutter, this.reprojData_ = null, this.reprojError_ = null, this.reprojSize_ = void 0, this.sourceTileGrid_ = e.sourceTileGrid, this.targetTileGrid_ = e.targetTileGrid, this.wrappedTileCoord_ = e.wrappedTileCoord || e.tileCoord, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
    const t = e.sourceProj, n = t.getExtent(), r = e.sourceTileGrid.getExtent();
    this.clipExtent_ = t.canWrapX() ? r ? kt(n, r) : n : r;
    const s = this.targetTileGrid_.getTileCoordExtent(
      this.wrappedTileCoord_
    ), o = this.targetTileGrid_.getExtent();
    let a = this.sourceTileGrid_.getExtent();
    const l = o ? kt(s, o) : s;
    if (Zl(l) === 0) {
      this.state = X.EMPTY;
      return;
    }
    n && (a ? a = kt(a, n) : a = n);
    const h = this.targetTileGrid_.getResolution(
      this.wrappedTileCoord_[0]
    ), u = e.targetProj, c = bw(
      t,
      u,
      l,
      h
    );
    if (!isFinite(c) || c <= 0) {
      this.state = X.EMPTY;
      return;
    }
    const f = e.errorThreshold !== void 0 ? e.errorThreshold : Km;
    if (this.triangulation_ = new Hm(
      t,
      u,
      l,
      a,
      c * f,
      h,
      e.transformMatrix
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = X.EMPTY;
      return;
    }
    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(c);
    let g = this.triangulation_.calculateSourceExtent();
    if (a && (t.canWrapX() ? (g[1] = ve(
      g[1],
      a[1],
      a[3]
    ), g[3] = ve(
      g[3],
      a[1],
      a[3]
    )) : g = kt(g, a)), !Zl(g))
      this.state = X.EMPTY;
    else {
      let d = 0, m = 0;
      t.canWrapX() && (d = _e(n), m = Math.floor(
        (g[0] - n[0]) / d
      )), Wp(
        g.slice(),
        t,
        !0
      ).forEach((v) => {
        const p = this.sourceTileGrid_.getTileRangeForExtentAndZ(
          v,
          this.sourceZ_
        ), y = e.getTileFunction;
        for (let E = p.minX; E <= p.maxX; E++)
          for (let b = p.minY; b <= p.maxY; b++) {
            const T = y(this.sourceZ_, E, b, this.pixelRatio_);
            if (T) {
              const R = m * d;
              this.sourceTiles_.push({ tile: T, offset: R });
            }
          }
        ++m;
      }), this.sourceTiles_.length === 0 && (this.state = X.EMPTY);
    }
  }
  /**
   * Get the tile size.
   * @return {import('../size.js').Size} Tile size.
   * @override
   */
  getSize() {
    return this.reprojSize_;
  }
  /**
   * Get the data for the tile.
   * @return {import("../DataTile.js").Data} Tile data.
   * @override
   */
  getData() {
    return this.reprojData_;
  }
  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @override
   */
  getError() {
    return this.reprojError_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = [];
    let t = !1;
    if (this.sourceTiles_.forEach((E) => {
      const b = E.tile;
      if (!b || b.getState() !== X.LOADED)
        return;
      const T = b.getSize(), R = this.gutter_;
      let M;
      const C = Kg(b.getData());
      C ? M = C : (t = !0, M = ZF(Ra(b.getData())));
      const I = [T[0] + 2 * R, T[1] + 2 * R], O = M instanceof Float32Array, z = I[0] * I[1], _ = O ? Float32Array : Uint8ClampedArray, w = new _(
        /** @type {ArrayBuffer} */
        M.buffer
      ), S = _.BYTES_PER_ELEMENT, P = S * w.length / z, A = w.byteLength / I[1], D = Math.floor(
        A / S / I[0]
      ), k = this.sourceTileGrid_.getTileCoordExtent(b.tileCoord);
      k[0] += E.offset, k[2] += E.offset;
      const U = this.clipExtent_?.slice();
      U && (U[0] += E.offset, U[2] += E.offset), e.push({
        extent: k,
        clipExtent: U,
        data: w,
        dataType: _,
        bytesPerPixel: P,
        pixelSize: I,
        bandCount: D
      });
    }), this.sourceTiles_.length = 0, e.length === 0) {
      this.state = X.ERROR, this.changed();
      return;
    }
    const n = this.wrappedTileCoord_[0], r = this.targetTileGrid_.getTileSize(n), s = typeof r == "number" ? r : r[0], o = typeof r == "number" ? r : r[1], a = Math.round(s * this.pixelRatio_), l = Math.round(o * this.pixelRatio_), h = this.targetTileGrid_.getResolution(n), u = this.sourceTileGrid_.getResolution(this.sourceZ_), c = this.targetTileGrid_.getTileCoordExtent(
      this.wrappedTileCoord_
    ), f = e[0].bandCount, g = new e[0].dataType(f * a * l), d = yN(a, l, R1, {
      premultipliedAlpha: !1,
      antialias: !1
    });
    let m;
    const x = d.RGBA;
    let v;
    e[0].dataType == Float32Array ? (v = d.FLOAT, d.getExtension("WEBGL_color_buffer_float"), d.getExtension("OES_texture_float"), d.getExtension("EXT_float_blend"), m = d.getExtension("OES_texture_float_linear") !== null && this.interpolate) : (v = d.UNSIGNED_BYTE, m = this.interpolate);
    const p = 4, y = Math.ceil(f / p);
    for (let E = y - 1; E >= 0; --E) {
      const b = [];
      for (let _ = 0, w = e.length; _ < w; ++_) {
        const S = e[_], P = S.pixelSize, A = P[0], D = P[1], k = new S.dataType(p * A * D), U = S.data;
        let G = E * p;
        for (let H = 0, ne = k.length; H < ne; H += p)
          k[H] = U[G], k[H + 1] = U[G + 1], k[H + 2] = U[G + 2], k[H + 3] = U[G + 3], G += f;
        const $ = d.createTexture();
        d.bindTexture(d.TEXTURE_2D, $), m ? (d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR)) : (d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.NEAREST), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.NEAREST)), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texImage2D(
          d.TEXTURE_2D,
          0,
          x,
          A,
          D,
          0,
          x,
          v,
          k
        ), b.push({
          extent: S.extent,
          clipExtent: S.clipExtent,
          texture: $,
          width: A,
          height: D
        });
      }
      const { framebuffer: T, width: R, height: M } = EN(
        d,
        s,
        o,
        this.pixelRatio_,
        u,
        h,
        c,
        this.triangulation_,
        b,
        this.gutter_,
        v,
        this.renderEdges_,
        m
      ), C = R, I = M * p, O = new e[0].dataType(C * I);
      d.bindFramebuffer(d.FRAMEBUFFER, T), d.readPixels(0, 0, R, M, d.RGBA, v, O);
      let z = E * p;
      for (let _ = 0, w = O.length; _ < w; _ += p) {
        const S = (C - 1 - (_ / I | 0)) * I + _ % I;
        g[z] = O[S], g[z + 1] = O[S + 1], g[z + 2] = O[S + 2], g[z + 3] = O[S + 3], z += f;
      }
    }
    if (xN(d), R1.push(d.canvas), t) {
      const E = ot(s, o), b = new ImageData(g, s);
      E.putImageData(b, 0, 0), this.reprojData_ = E.canvas;
    } else
      this.reprojData_ = g;
    this.reprojSize_ = [a, l], this.state = X.LOADED, this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state !== X.IDLE && this.state !== X.ERROR)
      return;
    this.state = X.LOADING, this.changed();
    let e = 0;
    this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: t }) => {
      const n = t.getState();
      if (n !== X.IDLE && n !== X.LOADING)
        return;
      e++;
      const r = Ce(t, le.CHANGE, () => {
        const s = t.getState();
        (s == X.LOADED || s == X.ERROR || s == X.EMPTY) && (tt(r), e--, e === 0 && (this.unlistenSources_(), this.reproject_()));
      });
      this.sourcesListenerKeys_.push(r);
    }), e === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: t }) {
      t.getState() == X.IDLE && t.load();
    });
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(tt), this.sourcesListenerKeys_ = null;
  }
}
class wN extends qr {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(e) {
    super({
      extent: e.extent,
      origin: e.origin,
      origins: e.origins,
      resolutions: e.resolutions,
      tileSize: e.tileSize,
      tileSizes: e.tileSizes,
      sizes: e.sizes
    }), this.matrixIds_ = e.matrixIds;
  }
  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */
  getMatrixId(e) {
    return this.matrixIds_[e];
  }
  /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */
  getMatrixIds() {
    return this.matrixIds_;
  }
}
function bN(i, e, t) {
  const n = [], r = [], s = [], o = [], a = [];
  t = t !== void 0 ? t : [];
  const l = "SupportedCRS", h = "TileMatrix", u = "Identifier", c = "ScaleDenominator", f = "TopLeftCorner", g = "TileWidth", d = "TileHeight", m = i[l], x = ee(m), v = x.getMetersPerUnit(), p = x.getAxisOrientation().startsWith("ne");
  return i[h].sort(function(y, E) {
    return E[c] - y[c];
  }), i[h].forEach(function(y) {
    let E;
    if (t.length > 0 ? E = t.find(function(b) {
      return y[u] == b[h] ? !0 : y[u].includes(":") ? !1 : i[u] + ":" + y[u] === b[h];
    }) : E = !0, E) {
      r.push(y[u]);
      const b = y[c] * 28e-5 / v, T = y[g], R = y[d];
      p ? s.push([
        y[f][1],
        y[f][0]
      ]) : s.push(y[f]), n.push(b), o.push(
        T == R ? T : [T, R]
      ), a.push([y.MatrixWidth, y.MatrixHeight]);
    }
  }), new wN({
    extent: e,
    origins: s,
    resolutions: n,
    matrixIds: r,
    tileSizes: o,
    sizes: a
  });
}
function Vf(i) {
  let e = i.getDefaultTileGrid();
  return e || (e = RN(i), i.setDefaultTileGrid(e)), e;
}
function SN(i, e, t) {
  const n = e[0], r = i.getTileCoordCenter(e), s = Hn(t);
  if (!nn(s, r)) {
    const o = _e(s), a = Math.ceil(
      (s[0] - r[0]) / o
    );
    return r[0] += o * a, i.getTileCoordForCoordAndZ(r, n);
  }
  return e;
}
function TN(i, e, t, n) {
  n = n !== void 0 ? n : "top-left";
  const r = bb(i, e, t);
  return new qr({
    extent: i,
    origin: IT(i, n),
    resolutions: r,
    tileSize: t
  });
}
function xr(i) {
  const e = i || {}, t = e.extent || ee("EPSG:3857").getExtent(), n = {
    extent: t,
    minZoom: e.minZoom,
    tileSize: e.tileSize,
    resolutions: bb(
      t,
      e.maxZoom,
      e.tileSize,
      e.maxResolution
    )
  };
  return new qr(n);
}
function bb(i, e, t, n) {
  e = e !== void 0 ? e : xw, t = dt(t !== void 0 ? t : Ta);
  const r = it(i), s = _e(i);
  n = n > 0 ? n : Math.max(s / t[0], r / t[1]);
  const o = e + 1, a = new Array(o);
  for (let l = 0; l < o; ++l)
    a[l] = n / Math.pow(2, l);
  return a;
}
function RN(i, e, t, n) {
  const r = Hn(i);
  return TN(r, e, t, n);
}
function Hn(i) {
  i = ee(i);
  let e = i.getExtent();
  if (!e) {
    const t = 180 * ws.degrees / i.getMetersPerUnit();
    e = Xn(-t, -t, t, t);
  }
  return e;
}
class Wf extends vo {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      projection: e.projection,
      state: e.state,
      wrapX: e.wrapX,
      interpolate: e.interpolate
    }), this.on, this.once, this.un, this.tilePixelRatio_ = e.tilePixelRatio !== void 0 ? e.tilePixelRatio : 1, this.tileGrid = e.tileGrid !== void 0 ? e.tileGrid : null;
    const t = [256, 256];
    this.tileGrid && dt(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), t), this.tmpSize = [0, 0], this.key_ = e.key || ie(this), this.tileOptions = {
      transition: e.transition,
      interpolate: e.interpolate
    }, this.zDirection = e.zDirection ? e.zDirection : 0;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(e) {
    this.key_ !== e && (this.key_ = e, this.changed());
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   * @override
   */
  getResolutions(e) {
    const t = e ? this.getTileGridForProjection(e) : this.tileGrid;
    return t ? t.getResolutions() : null;
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {import("../structs/LRUCache.js").default<import("../Tile.js").default>} [tileCache] Tile cache.
   * @return {TileType|null} Tile.
   */
  getTile(e, t, n, r, s, o) {
    return de();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    return this.tileGrid ? this.tileGrid : Vf(e);
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(e, t, n) {
    const r = this.getTileGridForProjection(n), s = this.getTilePixelRatio(t), o = dt(r.getTileSize(e), this.tmpSize);
    return s == 1 ? o : rv(o, s, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(e, t) {
    const n = t !== void 0 ? t : this.getProjection(), r = t !== void 0 ? this.getTileGridForProjection(n) : this.tileGrid || this.getTileGridForProjection(n);
    return this.getWrapX() && n.isGlobal() && (e = SN(r, e, n)), rO(e, r) ? e : null;
  }
  /**
   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
   * @api
   */
  clear() {
  }
  /**
   * @override
   */
  refresh() {
    this.clear(), super.refresh();
  }
}
class Sb extends In {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(e, t) {
    super(e), this.tile = t;
  }
}
const fa = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};
class Bh extends Wf {
  /**
   * @param {Options} options DataTile source options.
   */
  constructor(e) {
    const t = e.projection === void 0 ? "EPSG:3857" : e.projection;
    let n = e.tileGrid;
    n === void 0 && t && (n = xr({
      extent: Hn(t),
      maxResolution: e.maxResolution,
      maxZoom: e.maxZoom,
      minZoom: e.minZoom,
      tileSize: e.tileSize
    })), super({
      cacheSize: 0.1,
      // don't cache on the source
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      projection: t,
      tileGrid: n,
      state: e.state,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate,
      key: e.key,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0, this.tileSize_ = e.tileSize ? dt(e.tileSize) : null, this.tileSizes_ = null, this.tileLoadingKeys_ = {}, this.loader_ = e.loader, this.handleTileChange_ = this.handleTileChange_.bind(this), this.bandCount = e.bandCount === void 0 ? 4 : e.bandCount, this.tileGridForProjection_ = {}, this.crossOrigin_ = e.crossOrigin || "anonymous", this.transformMatrix = null;
  }
  /**
   * Set the source tile sizes.  The length of the array is expected to match the number of
   * levels in the tile grid.
   * @protected
   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.
   */
  setTileSizes(e) {
    this.tileSizes_ = e;
  }
  /**
   * Get the source tile size at the given zoom level.  This may be different than the rendered tile
   * size.
   * @protected
   * @param {number} z Tile zoom level.
   * @return {import('../size.js').Size} The source tile size.
   */
  getTileSize(e) {
    if (this.tileSizes_)
      return this.tileSizes_[e];
    if (this.tileSize_)
      return this.tileSize_;
    const t = this.getTileGrid();
    return t ? dt(t.getTileSize(e)) : [256, 256];
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   * @override
   */
  getGutterForProjection(e) {
    const t = this.getProjection();
    return (!t || wt(t, e)) && !this.transformMatrix ? this.gutter_ : 0;
  }
  /**
   * @param {Loader} loader The data loader.
   * @protected
   */
  setLoader(e) {
    this.loader_ = e;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} targetProj The output projection.
   * @param {import("../proj/Projection.js").default} sourceProj The input projection.
   * @param {import("../structs/LRUCache.js").default<import("../Tile.js").default>} [tileCache] Tile cache.
   * @return {!TileType} Tile.
   */
  getReprojTile_(e, t, n, r, s, o) {
    const a = this.tileGrid || this.getTileGridForProjection(s || r), l = Math.max.apply(
      null,
      a.getResolutions().map((d, m) => {
        const x = dt(a.getTileSize(m)), v = this.getTileSize(m);
        return Math.max(
          v[0] / x[0],
          v[1] / x[1]
        );
      })
    ), h = this.getTileGridForProjection(r), u = [e, t, n], c = this.getTileCoordForTileUrlFunction(
      u,
      r
    ), f = Object.assign(
      {
        sourceProj: s || r,
        sourceTileGrid: a,
        targetProj: r,
        targetTileGrid: h,
        tileCoord: u,
        wrappedTileCoord: c,
        pixelRatio: l,
        gutter: this.gutter_,
        getTileFunction: (d, m, x, v) => this.getTile(d, m, x, v, void 0, o),
        transformMatrix: this.transformMatrix
      },
      /** @type {import("../reproj/DataTile.js").Options} */
      this.tileOptions
    ), g = (
      /** @type {TileType} */
      /** @type {*} */
      new vN(f)
    );
    return g.key = this.getKey(), g;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @param {import("../structs/LRUCache.js").default<import("../Tile.js").default>} [tileCache] Tile cache.
   * @return {TileType|null} Tile (or null if outside source extent).
   * @override
   */
  getTile(e, t, n, r, s, o) {
    const a = this.getProjection();
    if (s && (a && !wt(a, s) || this.transformMatrix))
      return this.getReprojTile_(
        e,
        t,
        n,
        s,
        a,
        o
      );
    const l = this.getTileSize(e), h = this.loader_, u = new AbortController(), c = {
      signal: u.signal,
      crossOrigin: this.crossOrigin_
    }, f = this.getTileCoordForTileUrlFunction([e, t, n]);
    if (!f)
      return null;
    const g = this.getKey(), d = Ol(this, g, e, t, n);
    if (o && o.containsKey(d))
      return (
        /** @type {TileType} */
        o.get(d)
      );
    const m = f[0], x = f[1], v = f[2], p = this.getTileGrid()?.getFullTileRange(m);
    p && (c.maxY = p.getHeight() - 1);
    function y() {
      return ro(function() {
        return h(m, x, v, c);
      });
    }
    const E = Object.assign(
      {
        tileCoord: [e, t, n],
        loader: y,
        size: l,
        controller: u
      },
      this.tileOptions
    ), b = (
      /** @type {TileType} */
      /** @type {*} */
      new rh(E)
    );
    return b.key = this.getKey(), b.addEventListener(le.CHANGE, this.handleTileChange_), o?.set(d, b), b;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   */
  handleTileChange_(e) {
    const t = (
      /** @type {import("../Tile.js").default} */
      e.target
    ), n = ie(t), r = t.getState();
    let s;
    r == X.LOADING ? (this.tileLoadingKeys_[n] = !0, s = fa.TILELOADSTART) : n in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[n], s = r == X.ERROR ? fa.TILELOADERROR : r == X.LOADED ? fa.TILELOADEND : void 0), s && this.dispatchEvent(new Sb(s, t));
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   * @override
   */
  getTileGridForProjection(e) {
    const t = this.getProjection();
    if (this.tileGrid && (!t || wt(t, e)) && !this.transformMatrix)
      return this.tileGrid;
    const n = ie(e);
    return n in this.tileGridForProjection_ || (this.tileGridForProjection_[n] = Vf(e)), this.tileGridForProjection_[n];
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(e, t) {
    const n = ee(e);
    if (n) {
      const r = ie(n);
      r in this.tileGridForProjection_ || (this.tileGridForProjection_[r] = t);
    }
  }
}
function PN(i) {
  return ((i.fileDirectory.NewSubfileType || 0) & 4) === 4;
}
function MN(i, e) {
  if (!i)
    return !1;
  if (i === !0)
    return !0;
  if (e.getSamplesPerPixel() !== 3)
    return !1;
  const t = e.fileDirectory.PhotometricInterpretation, n = Fi;
  return t === n.CMYK || t === n.YCbCr || t === n.CIELab || t === n.ICCLab;
}
const P1 = "STATISTICS_MAXIMUM", M1 = "STATISTICS_MINIMUM", Kd = 256;
let Jd;
function CN() {
  return Jd || (Jd = new G3()), Jd;
}
function AN(i) {
  try {
    return i.getBoundingBox(!0);
  } catch {
    return [0, 0, i.getWidth(), i.getHeight()];
  }
}
function IN(i) {
  try {
    return i.getOrigin().slice(0, 2);
  } catch {
    return [0, i.getHeight()];
  }
}
function LN(i, e) {
  try {
    return i.getResolution(e);
  } catch {
    return [
      e.getWidth() / i.getWidth(),
      e.getHeight() / i.getHeight()
    ];
  }
}
function FN(i) {
  const e = i.geoKeys;
  if (!e)
    return null;
  if (e.ProjectedCSTypeGeoKey && e.ProjectedCSTypeGeoKey !== 32767) {
    const t = "EPSG:" + e.ProjectedCSTypeGeoKey;
    let n = ee(t);
    if (!n) {
      const r = F_(e.ProjLinearUnitsGeoKey);
      r && (n = new oo({
        code: t,
        units: r
      }));
    }
    return n;
  }
  if (e.GeographicTypeGeoKey && e.GeographicTypeGeoKey !== 32767) {
    const t = "EPSG:" + e.GeographicTypeGeoKey;
    let n = ee(t);
    if (!n) {
      const r = F_(e.GeogAngularUnitsGeoKey);
      r && (n = new oo({
        code: t,
        units: r
      }));
    }
    return n;
  }
  return null;
}
function ON(i) {
  return i.getImageCount().then(function(e) {
    const t = new Array(e);
    for (let n = 0; n < e; ++n)
      t[n] = i.getImage(n);
    return Promise.all(t);
  });
}
function NN(i, e) {
  let t;
  return i.blob ? t = hN(i.blob) : i.overviews ? t = uN(i.url, i.overviews, e) : t = lN(i.url, e), t.then(ON);
}
function El(i, e, t, n, r) {
  if (Array.isArray(i)) {
    const s = i.length;
    if (!Array.isArray(e) || s != e.length) {
      const o = new Error(n);
      throw r(o), o;
    }
    for (let o = 0; o < s; ++o)
      El(i[o], e[o], t, n, r);
    return;
  }
  if (e = /** @type {number} */
  e, Math.abs(i - e) > t * i)
    throw new Error(n);
}
function DN(i) {
  return i instanceof Int8Array ? -128 : i instanceof Int16Array ? -32768 : i instanceof Int32Array ? -2147483648 : i instanceof Float32Array ? 12e-39 : 0;
}
function GN(i) {
  return i instanceof Int8Array ? 127 : i instanceof Uint8Array || i instanceof Uint8ClampedArray ? 255 : i instanceof Int16Array ? 32767 : i instanceof Uint16Array ? 65535 : i instanceof Int32Array ? 2147483647 : i instanceof Uint32Array ? 4294967295 : i instanceof Float32Array ? 34e37 : 255;
}
class R0 extends Bh {
  /**
   * @param {Options} options Data tile options.
   */
  constructor(e) {
    super({
      state: "loading",
      tileGrid: null,
      projection: e.projection || null,
      transition: e.transition,
      interpolate: e.interpolate !== !1,
      wrapX: e.wrapX
    }), this.sourceInfo_ = e.sources;
    const t = this.sourceInfo_.length;
    this.sourceOptions_ = e.sourceOptions, this.sourceImagery_ = new Array(t), this.sourceMasks_ = new Array(t), this.resolutionFactors_ = new Array(t), this.samplesPerPixel_, this.nodataValues_, this.metadata_, this.normalize_ = e.normalize !== !1, this.addAlpha_ = !1, this.error_ = null, this.convertToRGB_ = e.convertToRGB || !1, this.setKey(this.sourceInfo_.map((s) => s.url).join(","));
    const n = this, r = new Array(t);
    for (let s = 0; s < t; ++s)
      r[s] = NN(
        this.sourceInfo_[s],
        this.sourceOptions_
      );
    Promise.all(r).then(function(s) {
      n.configure_(s);
    }).catch(function(s) {
      Hl(s), n.error_ = s, n.setState("error");
    });
  }
  /**
   * @return {Error} A source loading error. When the source state is `error`, use this function
   * to get more information about the error. To debug a faulty configuration, you may want to use
   * a listener like
   * ```js
   * geotiffSource.on('change', () => {
   *   if (geotiffSource.getState() === 'error') {
   *     console.error(geotiffSource.getError());
   *   }
   * });
   * ```
   */
  getError() {
    return this.error_;
  }
  /**
   * Determine the projection of the images in this GeoTIFF.
   * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey
   * of each image in turn.
   * You can override this method in a subclass to support more projections.
   *
   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images
   * from a single GeoTIFF.
   */
  determineProjection(e) {
    const t = e[0];
    for (let n = t.length - 1; n >= 0; --n) {
      const r = t[n], s = FN(r);
      if (s) {
        this.projection = s;
        break;
      }
    }
  }
  /**
   * Determine any transform matrix for the images in this GeoTIFF.
   *
   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images
   * from a single GeoTIFF.
   */
  determineTransformMatrix(e) {
    const t = e[0];
    for (let n = t.length - 1; n >= 0; --n) {
      const s = t[n].fileDirectory.ModelTransformation;
      if (s) {
        const [o, a, l, h, u, c, f, g] = s, d = zr(
          zr(
            [
              1 / Math.sqrt(o * o + u * u),
              0,
              0,
              -1 / Math.sqrt(a * a + c * c),
              h,
              g
            ],
            [o, u, a, c, 0, 0]
          ),
          [1, 0, 0, 1, -h, -g]
        );
        this.transformMatrix = d, this.addAlpha_ = !0;
        break;
      }
    }
  }
  /**
   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF
   * must have the same internal tiled structure.
   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images
   * from a single GeoTIFF.
   * @private
   */
  configure_(e) {
    let t, n, r, s, o;
    const a = new Array(e.length), l = new Array(e.length), h = new Array(e.length);
    let u = 0;
    const c = e.length;
    for (let x = 0; x < c; ++x) {
      const v = [], p = [];
      e[x].forEach((C) => {
        PN(C) ? p.push(C) : v.push(C);
      });
      const y = v.length;
      if (p.length > 0 && p.length !== y)
        throw new Error(
          `Expected one mask per image found ${p.length} masks and ${y} images`
        );
      let E, b;
      const T = new Array(y), R = new Array(y), M = new Array(y);
      l[x] = new Array(y), h[x] = new Array(y);
      for (let C = 0; C < y; ++C) {
        const I = v[C], O = I.getGDALNoData();
        h[x][C] = I.getGDALMetadata(0), l[x][C] = O;
        const z = this.sourceInfo_[x].bands;
        a[x] = z ? z.length : I.getSamplesPerPixel();
        const _ = y - (C + 1);
        E || (E = AN(I)), b || (b = IN(I));
        const w = LN(I, v[0]);
        M[_] = w[0];
        const S = [I.getTileWidth(), I.getTileHeight()];
        S[0] !== S[1] && S[1] < Kd && (S[0] = Kd, S[1] = Kd), T[_] = S;
        const P = w[0] / Math.abs(w[1]);
        R[_] = [
          S[0],
          S[1] / P
        ];
      }
      if (t ? kt(t, E, t) : t = E, !n)
        n = b;
      else {
        const C = `Origin mismatch for source ${x}, got [${b}] but expected [${n}]`;
        El(n, b, 0, C, this.viewRejector);
      }
      if (!o)
        o = M, this.resolutionFactors_[x] = 1;
      else {
        o.length - u > M.length && (u = o.length - M.length);
        const C = o[o.length - 1] / M[M.length - 1];
        this.resolutionFactors_[x] = C;
        const I = M.map(
          (z) => z *= C
        ), O = `Resolution mismatch for source ${x}, got [${I}] but expected [${o}]`;
        El(
          o.slice(u, o.length),
          I,
          0.02,
          O,
          this.viewRejector
        );
      }
      r ? El(
        r.slice(u, r.length),
        R,
        0.01,
        `Tile size mismatch for source ${x}`,
        this.viewRejector
      ) : r = R, s ? El(
        s.slice(u, s.length),
        T,
        0,
        `Tile size mismatch for source ${x}`,
        this.viewRejector
      ) : s = T, this.sourceImagery_[x] = v.reverse(), this.sourceMasks_[x] = p.reverse();
    }
    for (let x = 0, v = this.sourceImagery_.length; x < v; ++x) {
      const p = this.sourceImagery_[x];
      for (; p.length < o.length; )
        p.unshift(void 0);
    }
    this.getProjection() || this.determineProjection(e), this.determineTransformMatrix(e), this.samplesPerPixel_ = a, this.nodataValues_ = l, this.metadata_ = h;
    e: for (let x = 0; x < c; ++x) {
      if (this.sourceInfo_[x].nodata !== void 0) {
        this.addAlpha_ = !0;
        break;
      }
      if (this.sourceMasks_[x].length) {
        this.addAlpha_ = !0;
        break;
      }
      const v = l[x], p = this.sourceInfo_[x].bands;
      if (p) {
        for (let y = 0; y < p.length; ++y)
          if (v[p[y] - 1] !== null) {
            this.addAlpha_ = !0;
            break e;
          }
        continue;
      }
      for (let y = 0; y < v.length; ++y)
        if (v[y] !== null) {
          this.addAlpha_ = !0;
          break e;
        }
    }
    let f = this.addAlpha_ ? 1 : 0;
    for (let x = 0; x < c; ++x)
      f += a[x];
    this.bandCount = f;
    const g = new qr({
      extent: t,
      minZoom: u,
      origin: n,
      resolutions: o,
      tileSizes: r
    });
    this.tileGrid = g, this.setTileSizes(s), this.setLoader(this.loadTile_.bind(this)), this.setState("ready");
    const d = 1;
    o.length === 2 ? o = [o[0], o[1], o[1] / 2] : o.length === 1 && (o = [o[0] * 2, o[0], o[0] / 2]);
    let m = t;
    if (this.transformMatrix) {
      const x = lo(st(), this.transformMatrix.slice()), v = hc(
        (p) => rt(x, p)
      );
      m = so(t, v);
    }
    this.viewResolver({
      showFullExtent: !0,
      projection: this.projection,
      resolutions: o,
      center: uc(Vt(m), this.projection),
      extent: _f(m, this.projection),
      zoom: d
    });
  }
  /**
   * @param {number} z The z tile index.
   * @param {number} x The x tile index.
   * @param {number} y The y tile index.
   * @param {import('./DataTile.js').LoaderOptions} options The loader options.
   * @return {Promise} The composed tile data.
   * @private
   */
  loadTile_(e, t, n, r) {
    const s = this.getTileSize(e), o = this.sourceImagery_.length, a = new Array(o * 2), l = this.nodataValues_, h = this.sourceInfo_, u = CN();
    for (let c = 0; c < o; ++c) {
      const f = h[c], g = this.resolutionFactors_[c], d = [
        Math.round(t * (s[0] * g)),
        Math.round(n * (s[1] * g)),
        Math.round((t + 1) * (s[0] * g)),
        Math.round((n + 1) * (s[1] * g))
      ], m = this.sourceImagery_[c][e];
      let x;
      f.bands && (x = f.bands.map(function(b) {
        return b - 1;
      }));
      let v;
      "nodata" in f && f.nodata !== null ? v = f.nodata : x ? v = x.map(function(b) {
        return l[c][b];
      }) : v = l[c];
      const p = {
        window: d,
        width: s[0],
        height: s[1],
        samples: x,
        fillValue: v,
        pool: u,
        interleave: !1,
        signal: r.signal
      };
      MN(this.convertToRGB_, m) ? a[c] = m.readRGB(p) : a[c] = m.readRasters(p);
      const y = o + c, E = this.sourceMasks_[c][e];
      if (!E) {
        a[y] = Promise.resolve(null);
        continue;
      }
      a[y] = E.readRasters({
        window: d,
        width: s[0],
        height: s[1],
        samples: [0],
        pool: u,
        interleave: !1
      });
    }
    return Promise.all(a).then(this.composeTile_.bind(this, s)).catch(function(c) {
      throw Hl(c), c;
    });
  }
  /**
   * @param {import("../size.js").Size} sourceTileSize The source tile size.
   * @param {Array} sourceSamples The source samples.
   * @return {import("../DataTile.js").Data} The composed tile data.
   * @private
   */
  composeTile_(e, t) {
    const n = this.metadata_, r = this.sourceInfo_, s = this.sourceImagery_.length, o = this.bandCount, a = this.samplesPerPixel_, l = this.nodataValues_, h = this.normalize_, u = this.addAlpha_, c = e[0] * e[1], f = c * o;
    let g;
    h ? g = new Uint8Array(f) : g = new Float32Array(f);
    let d = 0;
    for (let m = 0; m < c; ++m) {
      let x = u;
      for (let v = 0; v < s; ++v) {
        const p = r[v];
        let y = p.min, E = p.max, b, T;
        if (h) {
          const R = n[v][0];
          y === void 0 && (R && M1 in R ? y = parseFloat(R[M1]) : y = DN(t[v][0])), E === void 0 && (R && P1 in R ? E = parseFloat(R[P1]) : E = GN(t[v][0])), b = 255 / (E - y), T = -y * b;
        }
        for (let R = 0; R < a[v]; ++R) {
          const M = t[v][R][m];
          let C;
          if (h ? C = ve(b * M + T, 0, 255) : C = M, !u)
            g[d] = C;
          else {
            let I = p.nodata;
            if (I === void 0) {
              let z;
              p.bands ? z = p.bands[R] - 1 : z = R, I = l[v][z];
            }
            const O = isNaN(I);
            (!O && M !== I || O && !isNaN(M)) && (x = !1, g[d] = C);
          }
          d++;
        }
        if (!x) {
          const R = s + v, M = t[R];
          M && !M[0][m] && (x = !0);
        }
      }
      u && (x || (g[d] = 255), d++);
    }
    return g;
  }
}
R0.prototype.getView;
class kN extends Yr {
  /**
   * @param {Options<ImageSourceType>} [options] Layer options.
   */
  constructor(e) {
    e = e || {}, super(e);
  }
}
class P0 extends kN {
  /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
   */
  constructor(e) {
    super(e);
  }
  /**
   * @override
   */
  createRenderer() {
    return new Bw(this);
  }
  /**
   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
   * source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   * @override
   */
  getData(e) {
    return super.getData(e);
  }
}
const is = {
  /**
   * Triggered when a layer is added
   * @event GroupEvent#addlayer
   * @api
   */
  ADDLAYER: "addlayer",
  /**
   * Triggered when a layer is removed
   * @event GroupEvent#removelayer
   * @api
   */
  REMOVELAYER: "removelayer"
};
class ls extends In {
  /**
   * @param {GroupEventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(e, t) {
    super(e), this.layer = t;
  }
}
const Qd = {
  LAYERS: "layers"
};
class Zr extends Ew {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {Options} */
      Object.assign({}, e)
    );
    delete t.layers;
    let n = e.layers;
    super(t), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(Qd.LAYERS, this.handleLayersChanged_), n ? Array.isArray(n) ? n = new rn(n.slice(), { unique: !0 }) : Te(
      typeof /** @type {?} */
      n.getArray == "function",
      "Expected `layers` to be an array or a `Collection`"
    ) : n = new rn(void 0, { unique: !0 }), this.setLayers(n);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(tt), this.layersListenerKeys_.length = 0;
    const e = this.getLayers();
    this.layersListenerKeys_.push(
      Ce(e, ki.ADD, this.handleLayersAdd_, this),
      Ce(
        e,
        ki.REMOVE,
        this.handleLayersRemove_,
        this
      )
    );
    for (const n in this.listenerKeys_)
      this.listenerKeys_[n].forEach(tt);
    Ga(this.listenerKeys_);
    const t = e.getArray();
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      this.registerLayerListeners_(s), this.dispatchEvent(new ls(is.ADDLAYER, s));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(e) {
    const t = [
      Ce(
        e,
        xa.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      Ce(e, le.CHANGE, this.handleLayerChange_, this)
    ];
    e instanceof Zr && t.push(
      Ce(e, is.ADDLAYER, this.handleLayerGroupAdd_, this),
      Ce(
        e,
        is.REMOVELAYER,
        this.handleLayerGroupRemove_,
        this
      )
    ), this.listenerKeys_[ie(e)] = t;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(e) {
    this.dispatchEvent(new ls(is.ADDLAYER, e.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(e) {
    this.dispatchEvent(new ls(is.REMOVELAYER, e.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(e) {
    const t = e.element;
    this.registerLayerListeners_(t), this.dispatchEvent(new ls(is.ADDLAYER, t)), this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(e) {
    const t = e.element, n = ie(t);
    this.listenerKeys_[n].forEach(tt), delete this.listenerKeys_[n], this.dispatchEvent(new ls(is.REMOVELAYER, t)), this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(Qd.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(e) {
    const t = this.getLayers();
    if (t) {
      const n = t.getArray();
      for (let r = 0, s = n.length; r < s; ++r)
        this.dispatchEvent(
          new ls(is.REMOVELAYER, n[r])
        );
    }
    this.set(Qd.LAYERS, e);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(e) {
    return e = e !== void 0 ? e : [], this.getLayers().forEach(function(t) {
      t.getLayersArray(e);
    }), e;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(e) {
    const t = e !== void 0 ? e : [], n = t.length;
    this.getLayers().forEach(function(o) {
      o.getLayerStatesArray(t);
    });
    const r = this.getLayerState();
    let s = r.zIndex;
    !e && r.zIndex === void 0 && (s = 0);
    for (let o = n, a = t.length; o < a; o++) {
      const l = t[o];
      l.opacity *= r.opacity, l.visible = l.visible && r.visible, l.maxResolution = Math.min(
        l.maxResolution,
        r.maxResolution
      ), l.minResolution = Math.max(
        l.minResolution,
        r.minResolution
      ), l.minZoom = Math.max(l.minZoom, r.minZoom), l.maxZoom = Math.min(l.maxZoom, r.maxZoom), r.extent !== void 0 && (l.extent !== void 0 ? l.extent = kt(
        l.extent,
        r.extent
      ) : l.extent = r.extent), l.zIndex === void 0 && (l.zIndex = s);
    }
    return t;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    return "ready";
  }
}
class pt {
  /**
   * Creates a new SourceType.
   * @param {string} name The internal string identifier.
   * @protected
   * @api
   */
  constructor(e) {
    this.name = e;
  }
  /**
   * Converts to a string.
   * @return {string} The internal string identifier.
   * @api
   */
  toString() {
    return this.name;
  }
}
pt.GeoTIFF = new pt("GeoTIFF");
pt.ImageStatic = new pt("ImageStatic");
pt.PMTilesRaster = new pt("PMTilesRaster");
pt.PMTilesVector = new pt("PMTilesVector");
pt.TileJSON = new pt("TileJSON");
pt.TileWMS = new pt("TileWMS");
pt.WMTS = new pt("WMTS");
pt.XYZ = new pt("XYZ");
class UN extends Rf {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */
  constructor(e, t, n, r, s, o, a) {
    let l = e.getExtent();
    l && e.canWrapX() && (l = l.slice(), l[0] = -1 / 0, l[2] = 1 / 0);
    let h = t.getExtent();
    h && t.canWrapX() && (h = h.slice(), h[0] = -1 / 0, h[2] = 1 / 0);
    const u = h ? kt(n, h) : n, c = Vt(u), f = Ac(
      e,
      t,
      c,
      r
    ), g = Km, d = new Hm(
      e,
      t,
      u,
      l,
      f * g,
      r
    ), m = d.calculateSourceExtent(), x = qn(m) ? null : o(m, f, s), v = x ? se.IDLE : se.EMPTY, p = x ? x.getPixelRatio() : 1;
    super(n, r, p, v), this.targetProj_ = t, this.maxSourceExtent_ = l, this.triangulation_ = d, this.targetResolution_ = r, this.targetExtent_ = n, this.sourceImage_ = x, this.sourcePixelRatio_ = p, this.interpolate_ = a, this.canvas_ = null, this.sourceListenerKey_ = null;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.state == se.LOADING && this.unlistenSource_(), super.disposeInternal();
  }
  /**
   * @return {HTMLCanvasElement|OffscreenCanvas} Image.
   * @override
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @return {import("../proj/Projection.js").default} Projection.
   */
  getProjection() {
    return this.targetProj_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = this.sourceImage_.getState();
    if (e == se.LOADED) {
      const t = _e(this.targetExtent_) / this.targetResolution_, n = it(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = Sw(
        t,
        n,
        this.sourcePixelRatio_,
        Oc(this.sourceImage_.getResolution()),
        this.maxSourceExtent_,
        this.targetResolution_,
        this.targetExtent_,
        this.triangulation_,
        [
          {
            extent: this.sourceImage_.getExtent(),
            image: this.sourceImage_.getImage()
          }
        ],
        0,
        void 0,
        this.interpolate_,
        !0
      );
    }
    this.state = e, this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state == se.IDLE) {
      this.state = se.LOADING, this.changed();
      const e = this.sourceImage_.getState();
      e == se.LOADED || e == se.ERROR ? this.reproject_() : (this.sourceListenerKey_ = Ce(
        this.sourceImage_,
        le.CHANGE,
        (t) => {
          const n = this.sourceImage_.getState();
          (n == se.LOADED || n == se.ERROR) && (this.unlistenSource_(), this.reproject_());
        }
      ), this.sourceImage_.load());
    }
  }
  /**
   * @private
   */
  unlistenSource_() {
    tt(
      /** @type {!import("../events.js").EventsKey} */
      this.sourceListenerKey_
    ), this.sourceListenerKey_ = null;
  }
}
const ps = 4, eg = {
  /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: "imageloadstart",
  /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: "imageloadend",
  /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: "imageloaderror"
};
class zN extends In {
  /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */
  constructor(e, t) {
    super(e), this.image = t;
  }
}
class To extends vo {
  /**
   * @param {Options} options Single image source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      projection: e.projection,
      state: e.state,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0
    }), this.on, this.once, this.un, this.loader = e.loader || null, this.resolutions_ = e.resolutions !== void 0 ? e.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0, this.image = null, this.wantedExtent_, this.wantedResolution_, this.static_ = e.loader ? e.loader.length === 0 : !1, this.wantedProjection_ = null;
  }
  /**
   * @return {Array<number>|null} Resolutions.
   * @override
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {Array<number>|null} resolutions Resolutions.
   */
  setResolutions(e) {
    this.resolutions_ = e;
  }
  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */
  findNearestResolution(e) {
    const t = this.getResolutions();
    if (t) {
      const n = ff(t, e, 0);
      e = t[n];
    }
    return e;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImage(e, t, n, r) {
    const s = this.getProjection();
    if (!s || !r || wt(s, r))
      return s && (r = s), this.getImageInternal(e, t, n, r);
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && wt(this.reprojectedImage_.getProjection(), r) && this.reprojectedImage_.getResolution() == t && Pn(this.reprojectedImage_.getExtent(), e))
        return this.reprojectedImage_;
      this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
    }
    return this.reprojectedImage_ = new UN(
      s,
      r,
      e,
      t,
      n,
      (o, a, l) => this.getImageInternal(o, a, l, s),
      this.getInterpolate()
    ), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   * @protected
   */
  getImageInternal(e, t, n, r) {
    if (this.loader) {
      const s = C0(e, t, n, 1), o = this.findNearestResolution(t);
      if (this.image && (this.static_ || this.wantedProjection_ === r && (this.wantedExtent_ && Bi(this.wantedExtent_, s) || Bi(this.image.getExtent(), s)) && (this.wantedResolution_ && Oc(this.wantedResolution_) === o || Oc(this.image.getResolution()) === o)))
        return this.image;
      this.wantedProjection_ = r, this.wantedExtent_ = s, this.wantedResolution_ = o, this.image = new Rf(
        s,
        o,
        n,
        this.loader
      ), this.image.addEventListener(
        le.CHANGE,
        this.handleImageChange.bind(this)
      );
    }
    return this.image;
  }
  /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleImageChange(e) {
    const t = (
      /** @type {import("../Image.js").default} */
      e.target
    );
    let n;
    switch (t.getState()) {
      case se.LOADING:
        this.loading = !0, n = eg.IMAGELOADSTART;
        break;
      case se.LOADED:
        this.loading = !1, n = eg.IMAGELOADEND;
        break;
      case se.ERROR:
        this.loading = !1, n = eg.IMAGELOADERROR;
        break;
      default:
        return;
    }
    this.hasListener(n) && this.dispatchEvent(new zN(n, t));
  }
}
function M0(i, e) {
  i.getImage().src = e;
}
function C0(i, e, t, n) {
  const r = e / t, s = Vt(i), o = us(_e(i) / r, ps), a = us(it(i) / r, ps), l = us((n - 1) * o / 2, ps), h = o + 2 * l, u = us((n - 1) * a / 2, ps), c = a + 2 * u;
  return nc(s, r, 0, [
    h,
    c
  ]);
}
function BN(i) {
  const e = i.load || ja, t = i.imageExtent, n = i.crossOrigin ?? null;
  return () => {
    const r = new Image();
    return r.crossOrigin = n, e(r, i.url).then((s) => {
      const o = _e(t) / s.width, a = it(t) / s.height;
      return { image: s, extent: t, resolution: o !== a ? [o, a] : a, pixelRatio: 1 };
    });
  };
}
class Tb extends To {
  /**
   * @param {Options} options ImageStatic options.
   */
  constructor(e) {
    const t = e.crossOrigin !== void 0 ? e.crossOrigin : null, n = e.imageLoadFunction !== void 0 ? e.imageLoadFunction : M0;
    super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: ee(e.projection)
    }), this.url_ = e.url, this.imageExtent_ = e.imageExtent, this.image = null, this.image = new Rf(
      this.imageExtent_,
      void 0,
      1,
      BN({
        url: e.url,
        imageExtent: e.imageExtent,
        crossOrigin: t,
        load: (r, s) => (this.image.setImage(r), n(this.image, s), ja(r))
      })
    ), this.image.addEventListener(
      le.CHANGE,
      this.handleImageChange.bind(this)
    );
  }
  /**
   * Returns the image extent
   * @return {import("../extent.js").Extent} image extent.
   * @api
   */
  getImageExtent() {
    return this.imageExtent_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   * @override
   */
  getImageInternal(e, t, n, r) {
    return ft(e, this.image.getExtent()) ? this.image : null;
  }
  /**
   * Return the URL used for this image source.
   * @return {string} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
}
function A0(i, e, t, n) {
  const r = document.createElement("script"), s = "olc_" + ie(e);
  function o() {
    delete window[s], r.parentNode.removeChild(r);
  }
  r.async = !0, r.src = i + (i.includes("?") ? "&" : "?") + "callback=" + s;
  const a = setTimeout(function() {
    o(), t && t();
  }, 1e4);
  window[s] = function(l) {
    clearTimeout(a), o(), e(l);
  }, document.head.appendChild(r);
}
class $N extends Error {
  /**
   * @param {XMLHttpRequest} response The XHR object.
   */
  constructor(e) {
    const t = "Unexpected response status: " + e.status;
    super(t), this.name = "ResponseError", this.response = e;
  }
}
class jN extends Error {
  /**
   * @param {XMLHttpRequest} client The XHR object.
   */
  constructor(e) {
    super("Failed to issue request"), this.name = "ClientError", this.client = e;
  }
}
function Rb(i) {
  return new Promise(function(e, t) {
    function n(o) {
      const a = o.target;
      if (!a.status || a.status >= 200 && a.status < 300) {
        let l;
        try {
          l = JSON.parse(a.responseText);
        } catch (h) {
          const u = "Error parsing response text as JSON: " + h.message;
          t(new Error(u));
          return;
        }
        e(l);
        return;
      }
      t(new $N(a));
    }
    function r(o) {
      t(new jN(o.target));
    }
    const s = new XMLHttpRequest();
    s.addEventListener("load", n), s.addEventListener("error", r), s.open("GET", i), s.setRequestHeader("Accept", "application/json"), s.send();
  });
}
function Pb(i, e) {
  return e.includes("://") ? e : new URL(e, i).href;
}
function Ps(i, e) {
  const t = [];
  Object.keys(e).forEach(function(r) {
    e[r] !== null && e[r] !== void 0 && t.push(r + "=" + encodeURIComponent(e[r]));
  });
  const n = t.join("&");
  return i = i.replace(/[?&]$/, ""), i += i.includes("?") ? "&" : "?", i + n;
}
const XN = /\{z\}/g, VN = /\{x\}/g, WN = /\{y\}/g, YN = /\{-y\}/g;
function I0(i, e, t, n, r) {
  return i.replace(XN, e.toString()).replace(VN, t.toString()).replace(WN, n.toString()).replace(YN, function() {
    if (r === void 0)
      throw new Error(
        "If the URL template has a {-y} placeholder, the grid extent must be known"
      );
    return (r - n).toString();
  });
}
function qN(i, e, t, n) {
  const r = Rw(e, t, n), s = $n(r, i.length);
  return i[s];
}
function Yf(i) {
  const e = [];
  let t = /\{([a-z])-([a-z])\}/.exec(i);
  if (t) {
    const n = t[1].charCodeAt(0), r = t[2].charCodeAt(0);
    let s;
    for (s = n; s <= r; ++s)
      e.push(i.replace(t[0], String.fromCharCode(s)));
    return e;
  }
  if (t = /\{(\d+)-(\d+)\}/.exec(i), t) {
    const n = parseInt(t[2], 10);
    for (let r = parseInt(t[1], 10); r <= n; r++)
      e.push(i.replace(t[0], r.toString()));
    return e;
  }
  return e.push(i), e;
}
function ZN(i, e) {
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    (function(t, n, r) {
      if (!t)
        return;
      let s;
      const o = t[0];
      if (e) {
        const a = e.getFullTileRange(o);
        a && (s = a.getHeight() - 1);
      }
      return I0(i, o, t[1], t[2], s);
    })
  );
}
function L0(i, e) {
  const t = i.length, n = new Array(t);
  for (let r = 0; r < t; ++r)
    n[r] = ZN(i[r], e);
  return Aa(n);
}
function Aa(i) {
  return i.length === 1 ? i[0] : (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    (function(e, t, n) {
      if (!e)
        return;
      const r = e0(e), s = $n(r, i.length);
      return i[s](e, t, n);
    })
  );
}
function HN(i, e, t) {
}
class $h extends Wf {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tilePixelRatio: e.tilePixelRatio,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.generateTileUrlFunction_ = this.tileUrlFunction === $h.prototype.tileUrlFunction, this.tileLoadFunction = e.tileLoadFunction, e.tileUrlFunction && (this.tileUrlFunction = e.tileUrlFunction), this.urls = null, e.urls ? this.setUrls(e.urls) : e.url && this.setUrl(e.url), this.tileLoadingKeys_ = {};
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("../Tile.js").default} */
      e.target
    ), n = ie(t), r = t.getState();
    let s;
    r == X.LOADING ? (this.tileLoadingKeys_[n] = !0, s = fa.TILELOADSTART) : n in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[n], s = r == X.ERROR ? fa.TILELOADERROR : r == X.LOADED ? fa.TILELOADEND : void 0), s != null && this.dispatchEvent(new Sb(s, t));
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(e) {
    this.tileLoadFunction = e, this.changed();
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(e, t) {
    this.tileUrlFunction = e, typeof t < "u" ? this.setKey(t) : this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(e) {
    const t = Yf(e);
    this.urls = t, this.setUrls(t);
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(e) {
    this.urls = e;
    const t = e.join(`
`);
    this.generateTileUrlFunction_ ? this.setTileUrlFunction(L0(e, this.tileGrid), t) : this.setKey(t);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(e, t, n) {
  }
}
class Ln extends $h {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : KN,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.crossOrigin = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.tileClass = e.tileClass !== void 0 ? e.tileClass : Gh, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = e.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   * @override
   */
  getGutterForProjection(e) {
    return this.getProjection() && e && !wt(this.getProjection(), e) ? 0 : this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @override
   */
  getKey() {
    let e = super.getKey();
    return this.getInterpolate() || (e += ":disable-interpolation"), e;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   * @override
   */
  getTileGridForProjection(e) {
    const t = this.getProjection();
    if (this.tileGrid && (!t || wt(t, e)))
      return this.tileGrid;
    const n = ie(e);
    return n in this.tileGridForProjection || (this.tileGridForProjection[n] = Vf(e)), this.tileGridForProjection[n];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(e, t, n, r, s, o) {
    const a = [e, t, n], l = this.getTileCoordForTileUrlFunction(
      a,
      s
    ), h = l ? this.tileUrlFunction(l, r, s) : void 0, u = new this.tileClass(
      a,
      h !== void 0 ? X.IDLE : X.EMPTY,
      h !== void 0 ? h : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    return u.key = o, u.addEventListener(le.CHANGE, this.handleTileChange.bind(this)), u;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {import("../structs/LRUCache.js").default<import("../Tile.js").default>} [tileCache] Tile cache.
   * @return {!(ImageTile|ReprojTile)} Tile.
   * @override
   */
  getTile(e, t, n, r, s, o) {
    const a = this.getProjection();
    if (!a || !s || wt(a, s))
      return this.getTileInternal(
        e,
        t,
        n,
        r,
        a || s
      );
    const l = [e, t, n], h = this.getKey(), u = this.getTileGridForProjection(a), c = this.getTileGridForProjection(s), f = this.getTileCoordForTileUrlFunction(
      l,
      s
    ), g = new Jm(
      a,
      u,
      s,
      c,
      l,
      f,
      this.getTilePixelRatio(r),
      this.getGutter(),
      (d, m, x, v) => this.getTileInternal(d, m, x, v, a, o),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    return g.key = h, g;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @param {import("../structs/LRUCache.js").default<import("../Tile.js").default>} [tileCache] Tile cache.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(e, t, n, r, s, o) {
    const a = this.getKey(), l = Ol(this, a, e, t, n);
    if (o && o.containsKey(l))
      return (
        /** @type {!ImageTile} */
        o.get(l)
      );
    const h = this.createTile_(e, t, n, r, s, a);
    return o?.set(l, h), h;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(e) {
    this.renderReprojectionEdges_ != e && (this.renderReprojectionEdges_ = e, this.changed());
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(e, t) {
    const n = ee(e);
    if (n) {
      const r = ie(n);
      r in this.tileGridForProjection || (this.tileGridForProjection[r] = t);
    }
  }
}
function KN(i, e) {
  if (di) {
    const t = i.getCrossOrigin();
    let n = "same-origin", r = "same-origin";
    t === "anonymous" || t === "" ? (n = "cors", r = "omit") : t === "use-credentials" && (n = "cors", r = "include"), fetch(e, {
      mode: n,
      credentials: r
    }).then((s) => {
      if (!s.ok)
        throw new Error(`HTTP ${s.status}`);
      return s.blob();
    }).then((s) => createImageBitmap(s)).then((s) => {
      const o = i.getImage();
      o.width = s.width, o.height = s.height, /** @type {OffscreenCanvas} */
      o.getContext("2d").drawImage(s, 0, 0), s.close?.(), o.dispatchEvent(new Event("load"));
    }).catch(() => {
      i.getImage().dispatchEvent(new Event("error"));
    });
    return;
  }
  i.getImage().src = e;
}
class qf extends Ln {
  /**
   * @param {Options} options TileJSON options.
   */
  constructor(e) {
    if (super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: ee("EPSG:3857"),
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      state: "loading",
      tileLoadFunction: e.tileLoadFunction,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.tileJSON_ = null, this.tileSize_ = e.tileSize, e.url)
      if (e.jsonp)
        A0(
          e.url,
          this.handleTileJSONResponse.bind(this),
          this.handleTileJSONError.bind(this)
        );
      else {
        const t = new XMLHttpRequest();
        t.addEventListener("load", this.onXHRLoad_.bind(this)), t.addEventListener("error", this.onXHRError_.bind(this)), t.open("GET", e.url), t.send();
      }
    else if (e.tileJSON)
      this.handleTileJSONResponse(e.tileJSON);
    else
      throw new Error("Either `url` or `tileJSON` options must be provided");
  }
  /**
   * @private
   * @param {Event} event The load event.
   */
  onXHRLoad_(e) {
    const t = (
      /** @type {XMLHttpRequest} */
      e.target
    );
    if (!t.status || t.status >= 200 && t.status < 300) {
      let n;
      try {
        n = /** @type {Config} */
        JSON.parse(t.responseText);
      } catch {
        this.handleTileJSONError();
        return;
      }
      this.handleTileJSONResponse(n);
    } else
      this.handleTileJSONError();
  }
  /**
   * @private
   * @param {Event} event The error event.
   */
  onXHRError_(e) {
    this.handleTileJSONError();
  }
  /**
   * @return {Config} The tilejson object.
   * @api
   */
  getTileJSON() {
    return this.tileJSON_;
  }
  /**
   * @protected
   * @param {Config} tileJSON Tile JSON.
   */
  handleTileJSONResponse(e) {
    const t = ee("EPSG:4326"), n = this.getProjection();
    let r;
    if (e.bounds !== void 0) {
      const h = xo(
        t,
        n
      );
      r = so(e.bounds, h);
    }
    const s = Hn(n), o = e.minzoom || 0, a = e.maxzoom || 22, l = xr({
      extent: s,
      maxZoom: a,
      minZoom: o,
      tileSize: this.tileSize_
    });
    if (this.tileGrid = l, this.tileUrlFunction = L0(e.tiles, l), e.attribution && !this.getAttributions()) {
      const h = r !== void 0 ? r : s;
      this.setAttributions(function(u) {
        return ft(h, u.extent) ? [e.attribution] : null;
      });
    }
    this.tileJSON_ = e, this.setState("ready");
  }
  /**
   * @protected
   */
  handleTileJSONError() {
    this.setState("error");
  }
}
function tg(i, e, t) {
  if (!(t in i))
    return i[t] = /* @__PURE__ */ new Set([e]), !0;
  const n = i[t], r = n.has(e);
  return r || n.add(e), !r;
}
function JN(i, e, t) {
  const n = i[t];
  return n ? n.delete(e) : !1;
}
function C1(i, e) {
  const t = i.layerStatesArray[i.layerIndex];
  t.extent && (e = kt(
    e,
    xn(t.extent, i.viewState.projection)
  ));
  const n = (
    /** @type {import("../../source/Tile.js").default} */
    t.layer.getRenderSource()
  );
  if (!n.getWrapX()) {
    const r = n.getTileGridForProjection(i.viewState.projection).getExtent();
    r && (e = kt(e, r));
  }
  return e;
}
class Mb extends zm {
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} [options] Options.
   */
  constructor(e, t) {
    super(e), t = t || {}, this.extentChanged = !0, this.renderComplete = !1, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedTiles = [], this.renderedSourceKey_, this.renderedSourceRevision_, this.tempExtent = hi(), this.tempTileRange_ = new Uf(0, 0, 0, 0), this.tempTileCoord_ = go(0, 0, 0);
    const n = t.cacheSize !== void 0 ? t.cacheSize : 512;
    this.tileCache_ = new Ic(n), this.sourceTileCache_ = null, this.maxStaleKeys = n * 0.5;
  }
  /**
   * @return {LRUCache} Tile cache.
   */
  getTileCache() {
    return this.tileCache_;
  }
  /**
   * @return {LRUCache} Tile cache.
   */
  getSourceTileCache() {
    return this.sourceTileCache_ || (this.sourceTileCache_ = new Ic(512)), this.sourceTileCache_;
  }
  /**
   * Get a tile from the cache or create one if needed.
   *
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getOrCreateTile(e, t, n, r) {
    const s = this.tileCache_, a = this.getLayer().getSource(), l = Ol(a, a.getKey(), e, t, n);
    let h;
    if (s.containsKey(l))
      h = s.get(l);
    else {
      const u = r.viewState.projection, c = a.getProjection();
      if (h = a.getTile(
        e,
        t,
        n,
        r.pixelRatio,
        u,
        !c || wt(c, u) ? void 0 : this.getSourceTileCache()
      ), !h)
        return null;
      s.set(l, h);
    }
    return h;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getTile(e, t, n, r) {
    const s = this.getOrCreateTile(e, t, n, r);
    return s || null;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   * @override
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const n = this.getLayer(), r = rt(
      t.pixelToCoordinateTransform,
      e.slice()
    ), s = n.getExtent();
    if (s && !nn(s, r))
      return null;
    const o = t.viewState, a = n.getRenderSource(), l = a.getTileGridForProjection(o.projection), h = a.getTilePixelRatio(t.pixelRatio);
    for (let u = l.getZForResolution(o.resolution); u >= l.getMinZoom(); --u) {
      const c = l.getTileCoordForCoordAndZ(r, u), f = this.getTile(u, c[1], c[2], t);
      if (!f || f.getState() !== X.LOADED)
        continue;
      const g = l.getOrigin(u), d = dt(l.getTileSize(u)), m = l.getResolution(u);
      let x;
      if (f instanceof Gh || f instanceof Jm)
        x = f.getImage();
      else if (f instanceof rh) {
        if (x = Ra(f.getData()), !x)
          continue;
      } else
        continue;
      const v = Math.floor(
        h * ((r[0] - g[0]) / m - c[1] * d[0])
      ), p = Math.floor(
        h * ((g[1] - r[1]) / m - c[2] * d[1])
      ), y = Math.round(
        h * a.getGutterForProjection(o.projection)
      );
      return this.getImageData(x, v + y, p + y);
    }
    return null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(e) {
    this.renderedProjection ? e.viewState.projection !== this.renderedProjection && (this.tileCache_.clear(), this.renderedProjection = e.viewState.projection) : this.renderedProjection = e.viewState.projection;
    const t = this.getLayer().getSource();
    if (!t)
      return !1;
    const n = t.getRevision();
    return this.renderedSourceRevision_ ? this.renderedSourceRevision_ !== n && (this.renderedSourceRevision_ = n, this.renderedSourceKey_ === t.getKey() && (this.tileCache_.clear(), this.sourceTileCache_?.clear())) : this.renderedSourceRevision_ = n, !0;
  }
  /**
   * Determine whether tiles for next extent should be enqueued for rendering.
   * @return {boolean} Rendering tiles for next extent is supported.
   * @protected
   */
  enqueueTilesForNextExtent() {
    return !0;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent The extent to be rendered.
   * @param {number} initialZ The zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @param {number} preload Number of additional levels to load.
   */
  enqueueTiles(e, t, n, r, s) {
    const o = e.viewState, a = this.getLayer(), l = a.getRenderSource(), h = l.getTileGridForProjection(o.projection), u = ie(l);
    u in e.wantedTiles || (e.wantedTiles[u] = {});
    const c = e.wantedTiles[u], f = a.getMapInternal(), g = Math.max(
      n - s,
      h.getMinZoom(),
      h.getZForResolution(
        Math.min(
          a.getMaxResolution(),
          f ? f.getView().getResolutionForZoom(Math.max(a.getMinZoom(), 0)) : h.getResolution(0)
        ),
        l.zDirection
      )
    ), d = o.rotation, m = d ? Xp(
      o.center,
      o.resolution,
      d,
      e.size
    ) : void 0;
    for (let x = n; x >= g; --x) {
      const v = h.getTileRangeForExtentAndZ(
        t,
        x,
        this.tempTileRange_
      ), p = h.getResolution(x);
      for (let y = v.minX; y <= v.maxX; ++y)
        for (let E = v.minY; E <= v.maxY; ++E) {
          if (d && !h.tileCoordIntersectsViewport([x, y, E], m))
            continue;
          const b = this.getTile(x, y, E, e);
          if (!b || !tg(r, b, x))
            continue;
          const R = b.getKey();
          if (c[R] = !0, b.getState() === X.IDLE && !e.tileQueue.isKeyQueued(R)) {
            const M = go(x, y, E, this.tempTileCoord_);
            e.tileQueue.enqueue([
              b,
              u,
              h.getTileCoordCenter(M),
              p
            ]);
          }
        }
    }
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findStaleTile_(e, t) {
    const n = this.tileCache_, r = e[0], s = e[1], o = e[2], a = this.getStaleKeys();
    for (let l = 0; l < a.length; ++l) {
      const h = Ol(
        this.getLayer().getSource(),
        a[l],
        r,
        s,
        o
      );
      if (n.containsKey(h)) {
        const u = n.peek(h);
        if (u.getState() === X.LOADED)
          return u.endTransition(ie(this)), tg(t, u, r), !0;
      }
    }
    return !1;
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {number} altZ The alternate zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findAltTiles_(e, t, n, r) {
    const s = e.getTileRangeForTileCoordAndZ(
      t,
      n,
      this.tempTileRange_
    );
    if (!s)
      return !1;
    let o = !0;
    const a = this.tileCache_, l = this.getLayer().getRenderSource(), h = l.getKey();
    for (let u = s.minX; u <= s.maxX; ++u)
      for (let c = s.minY; c <= s.maxY; ++c) {
        const f = Ol(l, h, n, u, c);
        let g = !1;
        if (a.containsKey(f)) {
          const d = a.peek(f);
          d.getState() === X.LOADED && (tg(r, d, n), g = !0);
        }
        g || (o = !1);
      }
    return o;
  }
  /**
   * Render the layer.
   *
   * The frame rendering logic has three parts:
   *
   *  1. Enqueue tiles
   *  2. Find alt tiles for those that are not yet loaded
   *  3. Render loaded tiles
   *
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(e, t) {
    this.renderComplete = !0;
    const n = e.layerStatesArray[e.layerIndex], r = e.viewState, s = r.projection, o = r.resolution, a = r.center, l = e.pixelRatio, h = this.getLayer(), u = h.getSource(), c = u.getTileGridForProjection(s), f = c.getZForResolution(o, u.zDirection), g = c.getResolution(f), d = u.getKey();
    this.renderedSourceKey_ ? this.renderedSourceKey_ !== d && (this.prependStaleKey(this.renderedSourceKey_), this.renderedSourceKey_ = d) : this.renderedSourceKey_ = d;
    let m = e.extent;
    const x = u.getTilePixelRatio(l);
    this.prepareContainer(e, t);
    const v = this.context.canvas.width, p = this.context.canvas.height, y = n.extent && xn(n.extent);
    y && (m = kt(
      m,
      xn(n.extent)
    ));
    const E = g * v / 2 / x, b = g * p / 2 / x, T = [
      a[0] - E,
      a[1] - b,
      a[0] + E,
      a[1] + b
    ], R = {};
    this.renderedTiles.length = 0;
    const M = h.getPreload();
    if (e.nextExtent && this.enqueueTilesForNextExtent()) {
      const D = c.getZForResolution(
        r.nextResolution,
        u.zDirection
      ), k = C1(e, e.nextExtent);
      this.enqueueTiles(e, k, D, R, M);
    }
    const C = C1(e, m);
    if (this.enqueueTiles(e, C, f, R, 0), M > 0 && setTimeout(() => {
      this.enqueueTiles(
        e,
        C,
        f - 1,
        R,
        M - 1
      );
    }, 0), !(f in R))
      return this.container;
    const I = ie(this), O = e.time;
    for (const D of R[f]) {
      const k = D.getState();
      if (k === X.EMPTY)
        continue;
      const U = D.tileCoord;
      if (k === X.LOADED && D.getAlpha(I, O) === 1) {
        D.endTransition(I);
        continue;
      }
      if (k !== X.ERROR && (this.renderComplete = !1), this.findStaleTile_(U, R)) {
        JN(R, D, f), e.animate = !0;
        continue;
      }
      if (this.findAltTiles_(
        c,
        U,
        f + 1,
        R
      ))
        continue;
      const H = c.getMinZoom();
      for (let ne = f - 1; ne >= H && !this.findAltTiles_(
        c,
        U,
        ne,
        R
      ); --ne)
        ;
    }
    const z = g / o * l / x, _ = this.getRenderContext(e);
    un(
      this.tempTransform,
      v / 2,
      p / 2,
      z,
      z,
      0,
      -v / 2,
      -p / 2
    ), n.extent && this.clipUnrotated(_, e, y), u.getInterpolate() || (_.imageSmoothingEnabled = !1), this.preRender(_, e);
    const w = Object.keys(R).map(Number);
    w.sort(lr);
    let S;
    const P = [], A = [];
    for (let D = w.length - 1; D >= 0; --D) {
      const k = w[D], U = u.getTilePixelSize(
        k,
        l,
        s
      ), $ = c.getResolution(k) / g, H = U[0] * $ * z, ne = U[1] * $ * z, te = c.getTileCoordForCoordAndZ(
        Mn(T),
        k
      ), re = c.getTileCoordExtent(te), ae = rt(this.tempTransform, [
        x * (re[0] - T[0]) / g,
        x * (T[3] - re[3]) / g
      ]), Re = x * u.getGutterForProjection(s);
      for (const xe of R[k]) {
        if (xe.getState() !== X.LOADED)
          continue;
        const Ae = xe.tileCoord, Z = te[1] - Ae[1], at = Math.round(ae[0] - (Z - 1) * H), ut = te[2] - Ae[2], Ee = Math.round(ae[1] - (ut - 1) * ne), gt = Math.round(ae[0] - Z * H), St = Math.round(ae[1] - ut * ne), It = at - gt, Kn = Ee - St, Tt = w.length === 1;
        let Zi = !1;
        S = [gt, St, gt + It, St, gt + It, St + Kn, gt, St + Kn];
        for (let cn = 0, wi = P.length; cn < wi; ++cn)
          if (!Tt && k < A[cn]) {
            const Et = P[cn];
            ft(
              [gt, St, gt + It, St + Kn],
              [Et[0], Et[3], Et[4], Et[7]]
            ) && (Zi || (_.save(), Zi = !0), _.beginPath(), _.moveTo(S[0], S[1]), _.lineTo(S[2], S[3]), _.lineTo(S[4], S[5]), _.lineTo(S[6], S[7]), _.moveTo(Et[6], Et[7]), _.lineTo(Et[4], Et[5]), _.lineTo(Et[2], Et[3]), _.lineTo(Et[0], Et[1]), _.clip());
          }
        P.push(S), A.push(k), this.drawTile(xe, e, gt, St, It, Kn, Re, Tt), Zi && _.restore(), this.renderedTiles.unshift(xe), this.updateUsedTiles(e.usedTiles, u, xe);
      }
    }
    if (this.renderedResolution = g, this.extentChanged = !this.renderedExtent_ || !Pn(this.renderedExtent_, T), this.renderedExtent_ = T, this.renderedPixelRatio = l, this.postRender(this.context, e), n.extent && _.restore(), _.imageSmoothingEnabled = !0, this.renderComplete) {
      const D = (k, U) => {
        const G = ie(u), $ = U.wantedTiles[G], H = $ ? Object.keys($).length : 0;
        this.updateCacheSize(H), this.tileCache_.expireCache(), this.sourceTileCache_?.expireCache();
      };
      e.postRenderFunctions.push(D);
    }
    return this.container;
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   */
  updateCacheSize(e) {
    this.tileCache_.highWaterMark = Math.max(
      this.tileCache_.highWaterMark,
      e * 2
    );
  }
  /**
   * @param {import("../../Tile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   * @protected
   */
  drawTile(e, t, n, r, s, o, a, l) {
    let h;
    if (e instanceof rh) {
      if (h = Ra(e.getData()), !h)
        throw new Error("Rendering array data is not yet supported");
    } else
      h = this.getTileImage(
        /** @type {import("../../ImageTile.js").default} */
        e
      );
    if (!h)
      return;
    const u = this.getRenderContext(t), c = ie(this), f = t.layerStatesArray[t.layerIndex], g = f.opacity * (l ? e.getAlpha(c, t.time) : 1), d = g !== u.globalAlpha;
    d && (u.save(), u.globalAlpha = g), u.drawImage(
      h,
      a,
      a,
      h.width - 2 * a,
      h.height - 2 * a,
      n,
      r,
      s,
      o
    ), d && u.restore(), g !== f.opacity ? t.animate = !0 : l && e.endTransition(c);
  }
  /**
   * @return {HTMLCanvasElement|OffscreenCanvas} Image
   */
  getImage() {
    const e = this.context;
    return e ? e.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|OffscreenCanvas|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(e) {
    return e.getImage();
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(e, t, n) {
    const r = ie(t);
    r in e || (e[r] = {}), e[r][n.getKey()] = !0;
  }
}
class Gc extends $w {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    super(e);
  }
  /**
   * @override
   */
  createRenderer() {
    return new Mb(this, {
      cacheSize: this.getCacheSize()
    });
  }
}
const QN = {
  image: ["Polygon", "Circle", "LineString", "Image", "Text"],
  hybrid: ["Polygon", "LineString"],
  vector: []
}, A1 = {
  hybrid: ["Image", "Text", "Default"],
  vector: ["Polygon", "Circle", "LineString", "Image", "Text", "Default"]
};
class eD extends Mb {
  /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   * @param {import("./TileLayer.js").Options} options Options.
   */
  constructor(e, t) {
    super(e, t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.renderedLayerRevision_, this.renderedPixelToCoordinateTransform_ = null, this.renderedRotation_, this.renderedOpacity_ = 1, this.tmpTransform_ = st(), this.tileClipContexts_ = null;
  }
  /**
   * Determine whether tiles for next extent should be enqueued for rendering.
   * @return {boolean} Rendering tiles for next extent is supported.
   * @override
   */
  enqueueTilesForNextExtent() {
    return this.getLayer().getRenderMode() !== "vector";
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   * @override
   */
  drawTile(e, t, n, r, s, o, a, l) {
    this.updateExecutorGroup_(
      e,
      t.pixelRatio,
      t.viewState.projection
    ), this.tileImageNeedsRender_(e) && this.renderTileImage_(e, t), super.drawTile(e, t, n, r, s, o, a, l);
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @override
   */
  getTile(e, t, n, r) {
    const s = (
      /** @type {import("../../VectorRenderTile.js").default} */
      this.getOrCreateTile(e, t, n, r)
    );
    if (!s)
      return null;
    const o = r.viewState, a = o.resolution, l = r.viewHints, h = this.getLayer().getSource(), u = h.getTileGridForProjection(o.projection), c = !(l[Xe.ANIMATING] || l[Xe.INTERACTING]), f = u.getZForResolution(a, h.zDirection) === e;
    return c && f ? s.wantedResolution = a : s.wantedResolution || (s.wantedResolution = u.getResolution(e)), s;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(e) {
    const t = this.getLayer().getRevision();
    return this.renderedLayerRevision_ !== t && (this.renderedLayerRevision_ = t, this.renderedTiles.length = 0), super.prepareFrame(e);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */
  updateExecutorGroup_(e, t, n) {
    const r = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), s = r.getRevision(), o = r.getRenderOrder() || null, a = e.wantedResolution, l = e.getReplayState(r);
    if (!l.dirty && l.renderedResolution === a && l.renderedRevision == s && l.renderedRenderOrder == o)
      return;
    const h = r.getSource(), u = !!r.getDeclutter(), c = h.getTileGrid(), g = h.getTileGridForProjection(n).getTileCoordExtent(e.wrappedTileCoord), d = h.getSourceTiles(t, n, e), m = ie(r);
    delete e.hitDetectionImageData[m], e.executorGroups[m] = [], l.dirty = !1;
    for (let x = 0, v = d.length; x < v; ++x) {
      const p = d[x];
      if (p.getState() != X.LOADED)
        continue;
      const y = h.getProjection(), E = p.tileCoord;
      let b = c.getTileCoordExtent(E);
      n && y && !wt(n, y) && (b = Or(
        b,
        y,
        n,
        32
      ));
      const T = kt(g, b), R = ln(
        T,
        r.getRenderBuffer() * a,
        this.tempExtent
      ), M = Pn(b, T) ? null : R, C = new ow(
        0,
        T,
        a,
        t
      ), I = wc(
        a,
        t
      ), O = function(P, A) {
        let D;
        const k = P.getStyleFunction() || r.getStyleFunction();
        if (k && (D = k(P, a)), D) {
          const U = this.renderFeature(
            P,
            I,
            D,
            C,
            u,
            A
          );
          l.dirty = l.dirty || U;
        }
      }, z = p.getFeatures();
      o && o !== l.renderedRenderOrder && z.sort(o);
      for (let P = 0, A = z.length; P < A; ++P) {
        let D = z[P];
        n && p.projection && !wt(n, p.projection) && (D = D.clone(), D.getGeometry().applyTransform(Vn(p.projection, n))), (!M || ft(M, D.getGeometry().getExtent())) && O.call(this, D, P);
      }
      const _ = C.finish(), w = r.getRenderMode() !== "vector" && u && d.length === 1 ? null : T, S = new aw(
        w,
        a,
        t,
        h.getOverlaps(),
        _,
        r.getRenderBuffer(),
        !0
      );
      e.executorGroups[m].push(S);
    }
    l.renderedRevision = s, l.renderedRenderOrder = o, l.renderedResolution = a;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   * @override
   */
  forEachFeatureAtCoordinate(e, t, n, r, s) {
    const o = t.viewState.resolution, a = t.viewState.rotation;
    n = n ?? 0;
    const l = this.getLayer(), u = l.getSource().getTileGridForProjection(
      t.viewState.projection
    ), c = Ea([e]);
    ln(c, o * n, c);
    const f = {}, g = function(y, E, b) {
      let T = y.getId();
      T === void 0 && (T = ie(y));
      const R = f[T];
      if (R) {
        if (R !== !0 && b < R.distanceSq) {
          if (b === 0)
            return f[T] = !0, s.splice(s.lastIndexOf(R), 1), r(y, l, E);
          R.geometry = E, R.distanceSq = b;
        }
      } else {
        if (b === 0)
          return f[T] = !0, r(y, l, E);
        s.push(
          f[T] = {
            feature: y,
            layer: l,
            geometry: E,
            distanceSq: b,
            callback: r
          }
        );
      }
    }, d = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    ), m = ie(l), x = l.getDeclutter(), v = x ? t.declutter?.[x]?.all().map((y) => y.value) : null;
    let p;
    e: for (let y = 0, E = d.length; y < E; ++y) {
      const b = d[y], T = u.getTileCoordExtent(b.wrappedTileCoord);
      if (!ft(T, c))
        continue;
      const R = b.executorGroups[m];
      for (let M = 0, C = R.length; M < C; ++M)
        if (p = R[M].forEachFeatureAtCoordinate(
          e,
          o,
          a,
          n,
          g,
          v
        ), p)
          break e;
    }
    return p;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature.js").FeatureLike>>} Promise that resolves with an array of features.
   * @override
   */
  getFeatures(e) {
    return this.renderedTiles.length === 0 ? Promise.resolve([]) : new Promise((t, n) => {
      const r = this.getLayer(), s = r.getSource(), o = this.renderedProjection, a = o.getExtent(), l = this.renderedResolution, h = s.getTileGridForProjection(o), u = rt(
        this.renderedPixelToCoordinateTransform_,
        e.slice()
      ), c = h.getTileCoordForCoordAndResolution(u, l).toString(), f = (
        /** @type {Array<import("../../VectorRenderTile.js").default>} */
        this.renderedTiles.find(
          (y) => y.tileCoord.toString() === c && y.getState() === X.LOADED
        )
      );
      if (!f || f.loadingSourceTiles > 0) {
        t([]);
        return;
      }
      s.getWrapX() && o.canWrapX() && !Bi(
        a,
        h.getTileCoordExtent(f.tileCoord)
      ) && Zp(u, o);
      const g = ie(r), d = h.getTileCoordExtent(f.wrappedTileCoord), m = Mn(d), x = [
        (u[0] - m[0]) / l,
        (m[1] - u[1]) / l
      ], v = f.getSourceTiles().reduce(
        (y, E) => y.concat(E.getFeatures()),
        /** @type {Array<import("../../Feature.js").FeatureLike>} */
        []
      );
      let p = f.hitDetectionImageData[g];
      if (!p) {
        const y = dt(
          h.getTileSize(
            h.getZForResolution(l, s.zDirection)
          )
        ), E = this.renderedRotation_, b = [
          this.getRenderTransform(
            h.getTileCoordCenter(f.wrappedTileCoord),
            l,
            0,
            Qi,
            y[0] * Qi,
            y[1] * Qi,
            0
          )
        ];
        p = lw(
          y,
          b,
          v,
          r.getStyleFunction(),
          h.getTileCoordExtent(f.wrappedTileCoord),
          f.getReplayState(r).renderedResolution,
          E
        ), f.hitDetectionImageData[g] = p;
      }
      t(hw(x, v, p));
    });
  }
  /**
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {Array<import('../../Feature.js').FeatureLike>} Features.
   */
  getFeaturesInExtent(e) {
    const t = [], n = this.getTileCache();
    if (n.getCount() === 0)
      return t;
    const s = this.getLayer().getSource().getTileGridForProjection(
      this.frameState.viewState.projection
    ), o = s.getZForResolution(this.renderedResolution), a = {};
    return n.forEach((l) => {
      if (l.tileCoord[0] !== o || l.getState() !== X.LOADED)
        return;
      const h = l.getSourceTiles();
      for (let u = 0, c = h.length; u < c; ++u) {
        const f = h[u], g = f.getKey();
        if (g in a)
          continue;
        a[g] = !0;
        const d = f.tileCoord;
        if (ft(e, s.getTileCoordExtent(d))) {
          const m = f.getFeatures();
          if (m)
            for (let x = 0, v = m.length; x < v; ++x) {
              const p = m[x], y = p.getGeometry();
              ft(e, y.getExtent()) && t.push(p);
            }
        }
      }
    }), t;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @override
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.renderedLayerRevision_ !== void 0 && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, t) {
    const n = this.context, r = n.globalAlpha;
    n.globalAlpha = t.opacity;
    const s = e.viewHints, o = !(s[Xe.ANIMATING] || s[Xe.INTERACTING]), a = [
      this.context.canvas.width,
      this.context.canvas.height
    ], l = this.getLayer().getDeclutter(), h = l ? e.declutter?.[l] : void 0, u = ie(this.getLayer()), c = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    for (let f = 0, g = c.length; f < g; ++f) {
      const d = c[f], m = d.executorGroups[u];
      if (m)
        for (let x = m.length - 1; x >= 0; --x)
          m[x].execute(
            this.context,
            a,
            this.getTileRenderTransform(d, e),
            e.viewState.rotation,
            o,
            Tc,
            h
          );
    }
    n.globalAlpha = r;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferredInternal(e) {
    const t = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    ), n = ie(this.getLayer()), r = t.reduce(
      (l, h, u) => (h.executorGroups[n].forEach(
        (c) => l.push({
          executorGroup: c,
          index: u
        })
      ), l),
      /** @type {Array<{executorGroup: CanvasExecutorGroup, index: number}>} */
      []
    ), s = r.map(
      ({ executorGroup: l }) => l.getDeferredZIndexContexts()
    ), o = {};
    for (let l = 0, h = r.length; l < h; ++l) {
      const u = r[l].executorGroup.getDeferredZIndexContexts();
      for (const c in u)
        o[c] = !0;
    }
    Object.keys(o).map(Number).sort(lr).forEach((l) => {
      s.forEach((h, u) => {
        h[l] && (h[l].forEach((c) => {
          const { executorGroup: f, index: g } = r[u], d = f.getRenderedContext(), m = d.globalAlpha;
          d.globalAlpha = this.renderedOpacity_;
          const x = this.tileClipContexts_[g];
          x && x.draw(d), c.draw(d), x && d.restore(), d.globalAlpha = m, c.clear();
        }), h[l].length = 0);
      });
    });
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile The tile
   * @param {import('../../Map.js').FrameState} frameState Current frame state
   * @return {import('../../transform.js').Transform} Transform to use to render this tile
   */
  getTileRenderTransform(e, t) {
    const n = t.pixelRatio, r = t.viewState, s = r.center, o = r.resolution, a = r.rotation, l = t.size, h = Math.round(l[0] * n), u = Math.round(l[1] * n), f = this.getLayer().getSource().getTileGridForProjection(
      t.viewState.projection
    ), g = e.tileCoord, d = f.getTileCoordExtent(e.wrappedTileCoord), m = f.getTileCoordExtent(g, this.tempExtent)[0] - d[0];
    return zr(
      Ml(this.inversePixelTransform.slice(), 1 / n, 1 / n),
      this.getRenderTransform(
        s,
        o,
        a,
        n,
        h,
        u,
        m
      )
    );
  }
  /**
   * Render the vectors for this layer.
   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context Target context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  postRender(e, t) {
    const n = t.viewHints, r = !(n[Xe.ANIMATING] || n[Xe.INTERACTING]);
    this.renderedPixelToCoordinateTransform_ = t.pixelToCoordinateTransform.slice(), this.renderedRotation_ = t.viewState.rotation, this.renderedOpacity_ = t.layerStatesArray[t.layerIndex].opacity;
    const s = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), o = s.getRenderMode(), a = e.globalAlpha;
    e.globalAlpha = this.renderedOpacity_;
    const l = s.getDeclutter(), h = l ? A1[o].filter((b) => !Tc.includes(b)) : A1[o], u = t.viewState, c = u.rotation, f = s.getSource(), d = f.getTileGridForProjection(u.projection).getZForResolution(
      u.resolution,
      f.zDirection
    ), m = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    ), x = [], v = [], p = [], y = ie(s);
    let E = !0;
    for (let b = m.length - 1; b >= 0; --b) {
      const T = m[b];
      E = E && !T.getReplayState(s).dirty;
      const R = T.executorGroups[y].filter(
        (w) => w.hasExecutors(h)
      );
      if (R.length === 0)
        continue;
      const M = this.getTileRenderTransform(T, t), C = T.tileCoord[0];
      let I = !1;
      const O = R[0].getClipCoords(M);
      let z = e, _;
      if (O) {
        _ = new Um(), z = _.getContext();
        for (let w = 0, S = x.length; w < S; ++w)
          if (d !== C && C < v[w]) {
            const P = x[w];
            ft(
              [
                O[0],
                O[3],
                O[4],
                O[7]
              ],
              [P[0], P[3], P[4], P[7]]
            ) && (I || (z.save(), I = !0), z.beginPath(), z.moveTo(O[0], O[1]), z.lineTo(O[2], O[3]), z.lineTo(O[4], O[5]), z.lineTo(O[6], O[7]), z.moveTo(P[6], P[7]), z.lineTo(P[4], P[5]), z.lineTo(P[2], P[3]), z.lineTo(P[0], P[1]), z.clip());
          }
        x.push(O), v.push(C);
      }
      for (let w = 0, S = R.length; w < S; ++w)
        R[w].execute(
          e,
          [e.canvas.width, e.canvas.height],
          M,
          c,
          r,
          h,
          t.declutter?.[l]
        );
      I && (z === e ? z.restore() : p[b] = _);
    }
    e.globalAlpha = a, this.ready = E, this.tileClipContexts_ = p, t.declutter || this.renderDeferredInternal(t), super.postRender(e, t);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, t, n, r, s, o) {
    if (!n)
      return !1;
    let a = !1;
    if (Array.isArray(n))
      for (let l = 0, h = n.length; l < h; ++l)
        a = bc(
          r,
          e,
          n[l],
          t,
          this.boundHandleStyleImageChange_,
          void 0,
          s,
          o
        ) || a;
    else
      a = bc(
        r,
        e,
        n,
        t,
        this.boundHandleStyleImageChange_,
        void 0,
        s,
        o
      );
    return a;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} A new tile image was rendered.
   * @private
   */
  tileImageNeedsRender_(e) {
    const t = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    );
    if (t.getRenderMode() === "vector")
      return !1;
    const n = e.getReplayState(t), r = t.getRevision(), s = e.wantedResolution;
    return n.renderedTileResolution !== s || n.renderedTileRevision !== r;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  renderTileImage_(e, t) {
    const n = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), r = e.getReplayState(n), s = n.getRevision(), o = e.executorGroups[ie(n)];
    r.renderedTileRevision = s;
    const a = e.wrappedTileCoord, l = a[0], h = n.getSource();
    let u = t.pixelRatio;
    const f = t.viewState.projection, g = h.getTileGridForProjection(f), d = g.getResolution(e.tileCoord[0]), m = t.pixelRatio / e.wantedResolution * d, x = g.getResolution(l), v = e.getContext();
    u = Math.round(
      Math.max(u, m / u)
    );
    const p = h.getTilePixelSize(l, u, f);
    v.canvas.width = p[0], v.canvas.height = p[1];
    const y = u / m;
    if (y !== 1) {
      const R = Lg(this.tmpTransform_);
      Ml(R, y, y), v.setTransform.apply(v, R);
    }
    const E = g.getTileCoordExtent(a, this.tempExtent), b = m / x, T = Lg(this.tmpTransform_);
    Ml(T, b, -b), xf(T, -E[0], -E[3]);
    for (let R = 0, M = o.length; R < M; ++R)
      o[R].execute(
        v,
        [
          v.canvas.width * y,
          v.canvas.height * y
        ],
        T,
        0,
        !0,
        QN[n.getRenderMode()],
        null
      );
    r.renderedTileResolution = e.wantedResolution;
  }
}
class da extends bo {
  /**
   * @param {Options<VectorTileSourceType, FeatureType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.preload;
    const n = e.cacheSize === void 0 ? 0 : e.cacheSize;
    delete e.cacheSize, delete t.useInterimTilesOnError, super(t), this.on, this.once, this.un, this.cacheSize_ = n;
    const r = e.renderMode || "hybrid";
    Te(
      r == "hybrid" || r == "vector",
      "`renderMode` must be `'hybrid'` or `'vector'`"
    ), this.renderMode_ = r, this.setPreload(e.preload ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    ), this.getBackground, this.setBackground;
  }
  /**
   * @override
   */
  createRenderer() {
    return new eD(this, {
      cacheSize: this.cacheSize_
    });
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   * @override
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * Get features whose bounding box intersects the provided extent. Only features for cached
   * tiles for the last rendered zoom level are available in the source. So this method is only
   * suitable for requesting tiles for extents that are currently rendered.
   *
   * Features are returned in random tile order and as they are included in the tiles. This means
   * they can be clipped, duplicated across tiles, and simplified to the render resolution.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(e) {
    return (
      /** @type {Array<FeatureType>} */
      /** @type {*} */
      this.getRenderer().getFeaturesInExtent(e)
    );
  }
  /**
   * @return {VectorTileRenderType} The render mode.
   */
  getRenderMode() {
    return this.renderMode_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(gs.PRELOAD)
    );
  }
  /**
   * Deprecated.  Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(gs.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set(gs.PRELOAD, e);
  }
  /**
   * Deprecated.  Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set(gs.USE_INTERIM_TILES_ON_ERROR, e);
  }
}
const I1 = [];
class tD extends Za {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
   * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function.
   * @param {function(VectorRenderTile):void} removeSourceTiles Function.
   */
  constructor(e, t, n, r, s) {
    super(e, t, { transition: 0 }), this.context_ = null, this.executorGroups = {}, this.loadingSourceTiles = 0, this.hitDetectionImageData = {}, this.replayState_ = {}, this.sourceTiles = [], this.errorTileKeys = {}, this.wantedResolution, this.getSourceTiles = r.bind(void 0, this), this.removeSourceTiles_ = s, this.wrappedTileCoord = n;
  }
  /**
   * @return {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} The rendering context.
   */
  getContext() {
    return this.context_ || (this.context_ = ot(1, 1, I1)), this.context_;
  }
  /**
   * @return {boolean} Tile has a rendering context.
   */
  hasContext() {
    return !!this.context_;
  }
  /**
   * Get the Canvas for this tile.
   * @return {HTMLCanvasElement|OffscreenCanvas} Canvas.
   */
  getImage() {
    return this.hasContext() ? this.getContext().canvas : null;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {ReplayState} The replay state.
   */
  getReplayState(e) {
    const t = ie(e);
    return t in this.replayState_ || (this.replayState_[t] = {
      dirty: !1,
      renderedRenderOrder: null,
      renderedResolution: NaN,
      renderedRevision: -1,
      renderedTileResolution: NaN,
      renderedTileRevision: -1,
      renderedTileZ: -1
    }), this.replayState_[t];
  }
  /**
   * Load the tile.
   * @override
   */
  load() {
    this.getSourceTiles();
  }
  /**
   * Remove from the cache due to expiry
   * @override
   */
  release() {
    this.context_ && (Ih(this.context_), I1.push(this.context_.canvas), this.context_ = null), this.removeSourceTiles_(this), this.sourceTiles.length = 0, super.release();
  }
}
let Cb = class extends Za {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Data source url.
   * @param {import("./format/Feature.js").default<FeatureType>} format Feature format.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, n, r, s, o) {
    super(e, t, o), this.extent = null, this.format_ = r, this.features_ = null, this.loader_, this.projection = null, this.resolution, this.tileLoadFunction_ = s, this.url_ = n, this.key = n;
  }
  /**
   * @return {string} Tile url.
   */
  getTileUrl() {
    return this.url_;
  }
  /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default<FeatureType>} Feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Get the features for this tile. Geometries will be in the view projection.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    this.state == X.IDLE && (this.setState(X.LOADING), this.tileLoadFunction_(this, this.url_), this.loader_ && this.loader_(this.extent, this.resolution, this.projection));
  }
  /**
   * Handler for successful tile load.
   * @param {Array<FeatureType>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data projection.
   */
  onLoad(e, t) {
    this.setFeatures(e);
  }
  /**
   * Handler for tile load errors.
   */
  onError() {
    this.setState(X.ERROR);
  }
  /**
   * Function for use in a {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the features for the tile.
   * @param {Array<FeatureType>} features Features.
   * @api
   */
  setFeatures(e) {
    this.features_ = e, this.setState(X.LOADED);
  }
  /**
   * Set the feature loader for reading this tile's features.
   * @param {import("./featureloader.js").FeatureLoader<FeatureType>} loader Feature loader.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
};
class Ja extends $h {
  /**
   * @param {!Options<FeatureType>} options Vector tile options.
   */
  constructor(e) {
    const t = e.projection || "EPSG:3857", n = e.extent || Hn(t), r = e.tileGrid || xr({
      extent: n,
      maxResolution: e.maxResolution,
      maxZoom: e.maxZoom !== void 0 ? e.maxZoom : 22,
      minZoom: e.minZoom,
      tileSize: e.tileSize || 512
    });
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      interpolate: !0,
      projection: t,
      state: e.state,
      tileGrid: r,
      tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : Ab,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX === void 0 ? !0 : e.wrapX,
      transition: e.transition,
      zDirection: e.zDirection === void 0 ? 1 : e.zDirection
    }), this.format_ = e.format ? e.format : null, this.tileKeysBySourceTileUrl_ = {}, this.sourceTiles_ = {}, this.overlaps_ = e.overlaps == null ? !0 : e.overlaps, this.tileClass = e.tileClass ? e.tileClass : Cb, this.tileGrids_ = {};
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection").default} projection Projection.
   * @param {VectorRenderTile} tile Vector render tile.
   * @return {Array<import("../VectorTile").default>} Tile keys.
   */
  getSourceTiles(e, t, n) {
    if (n.getState() === X.IDLE) {
      n.setState(X.LOADING);
      const r = n.wrappedTileCoord, s = this.getTileGridForProjection(t);
      let o = s.getTileCoordExtent(r);
      const a = r[0], l = s.getResolution(a);
      ln(o, -l, o);
      const h = this.projection;
      t && this.projection && !wt(t, h) && (o = Or(o, t, h));
      const u = this.tileGrid, c = u.getExtent();
      c && kt(o, c, o);
      let f = l;
      t && h && !wt(t, h) && (f = l / h.getMetersPerUnit() / t.getMetersPerUnit());
      const g = u.getZForResolution(
        f,
        this.zDirection
      );
      u.forEachTileCoord(o, g, (d) => {
        const m = this.tileUrlFunction(
          d,
          e,
          t
        );
        this.sourceTiles_[m] || (this.sourceTiles_[m] = new this.tileClass(
          d,
          m ? X.IDLE : X.EMPTY,
          m,
          this.format_,
          this.tileLoadFunction
        ));
        const x = this.sourceTiles_[m];
        n.sourceTiles.push(x), this.tileKeysBySourceTileUrl_[m] || (this.tileKeysBySourceTileUrl_[m] = []), this.tileKeysBySourceTileUrl_[m].push(n.getKey());
        const v = x.getState();
        if (v < X.LOADED) {
          const p = (y) => {
            this.handleTileChange(y);
            const E = x.getState();
            if (E === X.LOADED || E === X.ERROR) {
              const b = x.getKey();
              b in n.errorTileKeys ? x.getState() === X.LOADED && delete n.errorTileKeys[b] : n.loadingSourceTiles--, E === X.ERROR ? n.errorTileKeys[b] = !0 : x.removeEventListener(le.CHANGE, p), n.loadingSourceTiles === 0 && n.setState(
                Ur(n.errorTileKeys) ? X.LOADED : X.ERROR
              );
            }
          };
          x.addEventListener(le.CHANGE, p), n.loadingSourceTiles++;
        }
        v === X.IDLE && (x.extent = u.getTileCoordExtent(d), x.projection = this.projection, x.resolution = u.getResolution(
          d[0]
        ), x.load());
      }), n.loadingSourceTiles || n.setState(
        n.sourceTiles.some(
          (d) => d.getState() === X.ERROR
        ) ? X.ERROR : X.LOADED
      );
    }
    return n.sourceTiles;
  }
  /**
   * @param {VectorRenderTile} tile Vector render tile.
   */
  removeSourceTiles(e) {
    const t = e.getKey(), n = e.sourceTiles;
    for (let r = 0, s = n.length; r < s; ++r) {
      const o = n[r].getTileUrl();
      if (!this.tileKeysBySourceTileUrl_[o])
        return;
      const a = this.tileKeysBySourceTileUrl_[o].indexOf(t);
      a !== -1 && (this.tileKeysBySourceTileUrl_[o].splice(a, 1), this.tileKeysBySourceTileUrl_[o].length === 0 && (delete this.tileKeysBySourceTileUrl_[o], delete this.sourceTiles_[o]));
    }
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!VectorRenderTile} Tile.
   * @override
   */
  getTile(e, t, n, r, s) {
    const o = [e, t, n];
    let a = this.getTileCoordForTileUrlFunction(
      o,
      s
    );
    const l = this.getTileGrid().getExtent(), h = this.projection, u = this.getTileGridForProjection(s);
    if (a && l) {
      const g = u.getTileCoordExtent(a);
      ln(g, -u.getResolution(e), g), ft(
        l,
        !s || !h || wt(s, h) ? g : Or(g, s, h)
      ) || (a = null);
    }
    let c = !0;
    if (a !== null) {
      const g = this.tileGrid, d = u.getResolution(e);
      let m = d;
      s && h && !wt(s, h) && (m = d / h.getMetersPerUnit() / s.getMetersPerUnit());
      const x = g.getZForResolution(m, 1), v = u.getTileCoordExtent(a);
      ln(v, -d, v), g.forEachTileCoord(
        !s || !h || wt(s, h) ? v : Or(v, s, h),
        x,
        (p) => {
          c = c && !this.tileUrlFunction(
            p,
            r,
            h
          );
        }
      );
    }
    const f = new tD(
      o,
      c ? X.EMPTY : X.IDLE,
      a,
      this.getSourceTiles.bind(this, r, s),
      this.removeSourceTiles.bind(this)
    );
    return f.key = this.getKey(), f;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   * @override
   */
  getTileGridForProjection(e) {
    const t = e.getCode();
    let n = this.tileGrids_[t];
    if (!n) {
      const r = this.projection;
      if (r !== null && !wt(r, e))
        return Vf(e);
      const s = this.tileGrid, o = s.getResolutions().slice(), a = o.map(function(u, c) {
        return s.getOrigin(c);
      }), l = o.map(function(u, c) {
        return s.getTileSize(c);
      }), h = xw + 1;
      for (let u = o.length; u < h; ++u)
        o.push(o[u - 1] / 2), a.push(a[u - 1]), l.push(l[u - 1]);
      n = new qr({
        extent: s.getExtent(),
        origins: a,
        resolutions: o,
        tileSizes: l
      }), this.tileGrids_[t] = n;
    }
    return n;
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   * @override
   */
  getTilePixelRatio(e) {
    return e;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   * @override
   */
  getTilePixelSize(e, t, n) {
    const r = this.getTileGridForProjection(n), s = dt(r.getTileSize(e), this.tmpSize);
    return [
      Math.round(s[0] * t),
      Math.round(s[1] * t)
    ];
  }
  /**
   * @param {boolean} overlaps The source has overlapping geometries.
   */
  setOverlaps(e) {
    this.overlaps_ = e, this.changed();
  }
}
function Ab(i, e) {
  i.setLoader(
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    function(t, n, r) {
      nw(
        e,
        i.getFormat(),
        t,
        n,
        r,
        i.onLoad.bind(i),
        i.onError.bind(i)
      );
    }
  );
}
const up = "1.3.0";
function iD(i, e, t, n, r) {
  r.WIDTH = t[0], r.HEIGHT = t[1];
  const s = n.getAxisOrientation(), o = Yp(r.VERSION, "1.3") >= 0;
  r[o ? "CRS" : "SRS"] = n.getCode();
  const a = o && s.startsWith("ne") ? [e[1], e[0], e[3], e[2]] : e;
  return r.BBOX = a.join(","), Ps(i, r);
}
function nD(i, e, t, n, r, s, o) {
  s = Object.assign({ REQUEST: "GetMap" }, s);
  const a = e / t, l = [
    rc(_e(i) / a, ps),
    rc(it(i) / a, ps)
  ];
  if (t != 1)
    switch (o) {
      case "geoserver":
        const u = 90 * t + 0.5 | 0;
        "FORMAT_OPTIONS" in s ? s.FORMAT_OPTIONS += ";dpi:" + u : s.FORMAT_OPTIONS = "dpi:" + u;
        break;
      case "mapserver":
        s.MAP_RESOLUTION = 90 * t;
        break;
      case "carmentaserver":
      case "qgis":
        s.DPI = 90 * t;
        break;
      default:
        throw new Error("Unknown `serverType` configured");
    }
  return iD(r, i, l, n, s);
}
function L1(i, e) {
  return Object.assign(
    {
      REQUEST: e,
      SERVICE: "WMS",
      VERSION: up,
      FORMAT: "image/png",
      STYLES: "",
      TRANSPARENT: "TRUE"
    },
    i
  );
}
class rD extends Ln {
  /**
   * @param {Options} [options] Tile WMS options.
   */
  constructor(e) {
    e = e || /** @type {Options} */
    {};
    const t = Object.assign({}, e.params);
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileClass: e.tileClass,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0, this.params_ = t, this.v13_ = !0, this.serverType_ = e.serverType, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.tmpExtent_ = hi(), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(e, t, n, r) {
    const s = ee(n), o = this.getProjection() || s;
    let a = this.getTileGrid();
    a || (a = this.getTileGridForProjection(o));
    const l = Sh(
      e,
      s,
      o
    ), h = Ac(
      o,
      s,
      e,
      t
    ), u = a.getZForResolution(h, this.zDirection), c = a.getResolution(u), f = a.getTileCoordForCoordAndZ(l, u);
    if (a.getResolutions().length <= f[0])
      return;
    let g = a.getTileCoordExtent(f, this.tmpExtent_);
    const d = this.gutter_;
    d !== 0 && (g = ln(g, c * d, g));
    const m = {
      QUERY_LAYERS: this.params_.LAYERS
    };
    Object.assign(
      m,
      L1(this.params_, "GetFeatureInfo"),
      r
    );
    const x = Math.floor((l[0] - g[0]) / c), v = Math.floor((g[3] - l[1]) / c);
    return m[this.v13_ ? "I" : "X"] = x, m[this.v13_ ? "J" : "Y"] = v, this.getRequestUrl_(
      f,
      g,
      1,
      o || s,
      m
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(e, t) {
    if (this.urls[0] === void 0)
      return;
    const n = {
      SERVICE: "WMS",
      VERSION: up,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (t === void 0 || t.LAYER === void 0) {
      const r = this.params_.LAYERS;
      if (!(!Array.isArray(r) || r.length === 1))
        return;
      n.LAYER = r;
    }
    if (e !== void 0) {
      const r = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, s = 28e-5;
      n.SCALE = e * r / s;
    }
    return Object.assign(n, t), Ps(
      /** @type {string} */
      this.urls[0],
      n
    );
  }
  /**
   * @return {number} Gutter.
   * @override
   */
  getGutter() {
    return this.gutter_;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(e, t, n, r, s) {
    const o = this.urls;
    if (!o)
      return;
    let a;
    if (o.length == 1)
      a = o[0];
    else {
      const l = $n(e0(e), o.length);
      a = o[l];
    }
    return nD(
      t,
      (this.tileGrid || this.getTileGridForProjection(r)).getResolution(e[0]),
      n,
      r,
      a,
      s,
      this.serverType_
    );
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   * @override
   */
  getTilePixelRatio(e) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : e;
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let e = 0;
    const t = [];
    for (const n in this.params_)
      t[e++] = n + "-" + this.params_[n];
    return t.join("/");
  }
  /**
   * @param {Object} params New URL paremeters.
   * @private
   */
  setParams_(e) {
    this.params_ = e, this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * Set the URL parameters passed to the WMS source.
   * @param {Object} params New URL paremeters.
   * @api
   */
  setParams(e) {
    this.setParams_(Object.assign({}, e));
  }
  /**
   * Update the URL parameters. This method can be used to update a subset of the WMS
   * parameters. Call `setParams` to set all of the parameters.
   * @param {Object} params Updated URL parameters.
   * @api
   */
  updateParams(e) {
    this.setParams_(Object.assign(this.params_, e));
  }
  /**
   * @private
   */
  updateV13_() {
    const e = this.params_.VERSION || up;
    this.v13_ = Yp(e, "1.3") >= 0;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(e, t, n) {
    let r = this.getTileGrid();
    if (r || (r = this.getTileGridForProjection(n)), r.getResolutions().length <= e[0])
      return;
    t != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (t = 1);
    const s = r.getResolution(e[0]);
    let o = r.getTileCoordExtent(e, this.tmpExtent_);
    const a = this.gutter_;
    a !== 0 && (o = ln(o, s * a, o));
    const l = Object.assign(
      {},
      L1(this.params_, "GetMap")
    );
    return this.getRequestUrl_(
      e,
      o,
      t,
      n,
      l
    );
  }
}
class sD extends Ln {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(e) {
    const t = e.requestEncoding !== void 0 ? e.requestEncoding : "KVP", n = e.tileGrid;
    let r = e.urls;
    r === void 0 && e.url !== void 0 && (r = Yf(e.url)), super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileClass: e.tileClass,
      tileGrid: n,
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: e.tilePixelRatio,
      urls: r,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !1,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.version_ = e.version !== void 0 ? e.version : "1.0.0", this.format_ = e.format !== void 0 ? e.format : "image/jpeg", this.dimensions_ = e.dimensions !== void 0 ? e.dimensions : {}, this.layer_ = e.layer, this.matrixSet_ = e.matrixSet, this.style_ = e.style, this.requestEncoding_ = t, this.setKey(this.getKeyForDimensions_()), r && r.length > 0 && (this.tileUrlFunction = Aa(
      r.map(this.createFromWMTSTemplate.bind(this))
    ));
  }
  /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   * @override
   */
  setUrls(e) {
    this.urls = e;
    const t = e.join(`
`);
    this.setTileUrlFunction(
      Aa(
        e.map(this.createFromWMTSTemplate.bind(this))
      ),
      t
    );
  }
  /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */
  getDimensions() {
    return this.dimensions_;
  }
  /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */
  getMatrixSet() {
    return this.matrixSet_;
  }
  /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {RequestEncoding} Request encoding.
   * @api
   */
  getRequestEncoding() {
    return this.requestEncoding_;
  }
  /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */
  getVersion() {
    return this.version_;
  }
  /**
   * @private
   * @return {string} The key for the current dimensions.
   */
  getKeyForDimensions_() {
    const e = this.urls ? this.urls.slice(0) : [];
    for (const t in this.dimensions_)
      e.push(t + "-" + this.dimensions_[t]);
    return e.join("/");
  }
  /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */
  updateDimensions(e) {
    Object.assign(this.dimensions_, e), this.setKey(this.getKeyForDimensions_());
  }
  /**
   * @param {string} template Template.
   * @return {import("../Tile.js").UrlFunction} Tile URL function.
   */
  createFromWMTSTemplate(e) {
    const t = this.requestEncoding_, n = {
      layer: this.layer_,
      style: this.style_,
      tilematrixset: this.matrixSet_
    };
    t == "KVP" && Object.assign(n, {
      Service: "WMTS",
      Request: "GetTile",
      Version: this.version_,
      Format: this.format_
    }), e = t == "KVP" ? Ps(e, n) : e.replace(/\{(\w+?)\}/g, function(o, a) {
      return a.toLowerCase() in n ? n[a.toLowerCase()] : o;
    });
    const r = (
      /** @type {import("../tilegrid/WMTS.js").default} */
      this.tileGrid
    ), s = this.dimensions_;
    return (
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      (function(o, a, l) {
        if (!o)
          return;
        const h = {
          TileMatrix: r.getMatrixId(o[0]),
          TileCol: o[1],
          TileRow: o[2]
        };
        Object.assign(h, s);
        let u = e;
        return t == "KVP" ? u = Ps(u, h) : u = u.replace(/\{(\w+?)\}/g, function(c, f) {
          return encodeURIComponent(h[f]);
        }), u;
      })
    );
  }
}
function Ib(i, e) {
  const n = i.Contents.Layer?.find(function(_) {
    return _.Identifier == e.layer;
  });
  if (!n)
    return null;
  const r = i.Contents.TileMatrixSet;
  let s;
  n.TileMatrixSetLink.length > 1 ? "projection" in e ? s = n.TileMatrixSetLink.findIndex(function(_) {
    const S = r.find(function(D) {
      return D.Identifier == _.TileMatrixSet;
    }).SupportedCRS, P = ee(S), A = ee(e.projection);
    return P && A ? wt(P, A) : S == e.projection;
  }) : s = n.TileMatrixSetLink.findIndex(function(_) {
    return _.TileMatrixSet == e.matrixSet;
  }) : s = 0, s < 0 && (s = 0);
  const o = (
    /** @type {string} */
    n.TileMatrixSetLink[s].TileMatrixSet
  ), a = (
    /** @type {Array<Object>} */
    n.TileMatrixSetLink[s].TileMatrixSetLimits
  );
  let l = (
    /** @type {string} */
    n.Format[0]
  );
  "format" in e && (l = e.format), s = n.Style.findIndex(function(_) {
    return "style" in e ? _.Title == e.style : _.isDefault;
  }), s < 0 && (s = 0);
  const h = (
    /** @type {string} */
    n.Style[s].Identifier
  ), u = {};
  "Dimension" in n && n.Dimension.forEach(function(_, w, S) {
    const P = _.Identifier;
    let A = _.Default;
    A === void 0 && (A = _.Value[0]), u[P] = A;
  });
  const f = i.Contents.TileMatrixSet.find(function(_) {
    return _.Identifier == o;
  });
  let g;
  const d = f.SupportedCRS;
  if (d && (g = ee(d)), "projection" in e) {
    const _ = ee(e.projection);
    _ && (!g || wt(_, g)) && (g = _);
  }
  let m = !1;
  const x = g.getAxisOrientation().startsWith("ne");
  let v = f.TileMatrix[0], p = {
    MinTileCol: 0,
    MinTileRow: 0,
    // subtract one to end up at tile top left
    MaxTileCol: v.MatrixWidth - 1,
    MaxTileRow: v.MatrixHeight - 1
  };
  if (a) {
    p = a[a.length - 1];
    const _ = f.TileMatrix.find(
      (w) => w.Identifier === p.TileMatrix || f.Identifier + ":" + w.Identifier === p.TileMatrix
    );
    _ && (v = _);
  }
  const y = n.BoundingBox?.find(
    (_) => ee(_.crs) && wt(ee(_.crs), g)
  ), E = v.ScaleDenominator * 28e-5 / g.getMetersPerUnit(), b = x ? [v.TopLeftCorner[1], v.TopLeftCorner[0]] : v.TopLeftCorner, T = v.TileWidth * E, R = v.TileHeight * E;
  let M = y?.extent ?? f.BoundingBox;
  M && x && (M = [
    M[1],
    M[0],
    M[3],
    M[2]
  ]);
  let C = [
    b[0] + T * p.MinTileCol,
    // add one to get proper bottom/right coordinate
    b[1] - R * (1 + p.MaxTileRow),
    b[0] + T * (1 + p.MaxTileCol),
    b[1] - R * p.MinTileRow
  ];
  if (M !== void 0 && !Bi(M, C)) {
    const _ = n.WGS84BoundingBox, w = ee("EPSG:4326").getExtent();
    if (C = M, _)
      m = _[0] === w[0] && _[2] === w[2];
    else {
      const S = Or(
        M,
        f.SupportedCRS,
        "EPSG:4326"
      );
      m = S[0] - 1e-10 <= w[0] && S[2] + 1e-10 >= w[2];
    }
  }
  const I = bN(
    f,
    C,
    a
  ), O = [];
  let z = e.requestEncoding;
  if (z = z !== void 0 ? z : "", "OperationsMetadata" in i && "GetTile" in i.OperationsMetadata) {
    const _ = i.OperationsMetadata.GetTile.DCP.HTTP.Get;
    for (let w = 0, S = _.length; w < S; ++w)
      if (_[w].Constraint) {
        const A = _[w].Constraint.find(function(D) {
          return D.name == "GetEncoding";
        }).AllowedValues.Value;
        if (z === "" && (z = A[0]), z === "KVP")
          A.includes("KVP") && O.push(
            /** @type {string} */
            _[w].href
          );
        else
          break;
      } else _[w].href && (z = "KVP", O.push(
        /** @type {string} */
        _[w].href
      ));
  }
  return O.length === 0 && (z = "REST", n.ResourceURL.forEach(function(_) {
    _.resourceType === "tile" && (l = _.format, O.push(
      /** @type {string} */
      _.template
    ));
  })), {
    urls: O,
    layer: e.layer,
    matrixSet: o,
    format: l,
    projection: g,
    requestEncoding: z,
    tileGrid: I,
    style: h,
    dimensions: u,
    wrapX: m,
    crossOrigin: e.crossOrigin
  };
}
class kc extends Ln {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(e) {
    e = e || {};
    const t = e.projection !== void 0 ? e.projection : "EPSG:3857", n = e.tileGrid !== void 0 ? e.tileGrid : xr({
      extent: Hn(t),
      maxResolution: e.maxResolution,
      maxZoom: e.maxZoom,
      minZoom: e.minZoom,
      tileSize: e.tileSize
    });
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: t,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileGrid: n,
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   * @override
   */
  getGutter() {
    return this.gutter_;
  }
}
var Wu = { exports: {} }, oD = Wu.exports, F1;
function aD() {
  return F1 || (F1 = 1, (function(i, e) {
    (function(t, n) {
      i.exports = n();
    })(oD, function() {
      var t = /^v?(?:\d+)(\.(?:[x*]|\d+)(\.(?:[x*]|\d+)(\.(?:[x*]|\d+))?(?:-[\da-z\-]+(?:\.[\da-z\-]+)*)?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
      function n(c, f) {
        return c.indexOf(f) === -1 ? c.length : c.indexOf(f);
      }
      function r(c) {
        var f = c.replace(/^v/, "").replace(/\+.*$/, ""), g = n(f, "-"), d = f.substring(0, g).split(".");
        return d.push(f.substring(g + 1)), d;
      }
      function s(c) {
        return isNaN(Number(c)) ? c : Number(c);
      }
      function o(c) {
        if (typeof c != "string")
          throw new TypeError("Invalid argument expected string");
        if (!t.test(c))
          throw new Error("Invalid argument not valid semver ('" + c + "' received)");
      }
      function a(c, f) {
        [c, f].forEach(o);
        for (var g = r(c), d = r(f), m = 0; m < Math.max(g.length - 1, d.length - 1); m++) {
          var x = parseInt(g[m] || 0, 10), v = parseInt(d[m] || 0, 10);
          if (x > v) return 1;
          if (v > x) return -1;
        }
        var p = g[g.length - 1], y = d[d.length - 1];
        if (p && y) {
          var E = p.split(".").map(s), b = y.split(".").map(s);
          for (m = 0; m < Math.max(E.length, b.length); m++) {
            if (E[m] === void 0 || typeof b[m] == "string" && typeof E[m] == "number") return -1;
            if (b[m] === void 0 || typeof E[m] == "string" && typeof b[m] == "number" || E[m] > b[m]) return 1;
            if (b[m] > E[m]) return -1;
          }
        } else if (p || y)
          return p ? -1 : 1;
        return 0;
      }
      var l = [
        ">",
        ">=",
        "=",
        "<",
        "<="
      ], h = {
        ">": [1],
        ">=": [0, 1],
        "=": [0],
        "<=": [-1, 0],
        "<": [-1]
      };
      function u(c) {
        if (typeof c != "string")
          throw new TypeError("Invalid operator type, expected string but got " + typeof c);
        if (l.indexOf(c) === -1)
          throw new TypeError("Invalid operator, expected one of " + l.join("|"));
      }
      return a.validate = function(c) {
        return typeof c == "string" && t.test(c);
      }, a.compare = function(c, f, g) {
        u(g);
        var d = a(c, f);
        return h[g].indexOf(d) > -1;
      }, a;
    });
  })(Wu)), Wu.exports;
}
var ig, O1;
function lD() {
  if (O1) return ig;
  O1 = 1;
  var i = aD();
  const e = "1.1.0", t = !0, n = {
    classification: "https://stac-extensions.github.io/classification/v2.0.0/schema.json",
    datacube: "https://stac-extensions.github.io/datacube/v2.2.0/schema.json",
    eo: "https://stac-extensions.github.io/eo/v2.0.0/schema.json",
    file: "https://stac-extensions.github.io/file/v2.1.0/schema.json",
    "item-assets": "https://stac-extensions.github.io/item-assets/v1.0.0/schema.json",
    label: "https://stac-extensions.github.io/label/v1.0.1/schema.json",
    pointcloud: "https://stac-extensions.github.io/pointcloud/v1.0.0/schema.json",
    processing: "https://stac-extensions.github.io/processing/v1.2.0/schema.json",
    projection: "https://stac-extensions.github.io/projection/v2.0.0/schema.json",
    raster: "https://stac-extensions.github.io/raster/v2.0.0/schema.json",
    sar: "https://stac-extensions.github.io/sar/v1.0.0/schema.json",
    sat: "https://stac-extensions.github.io/sat/v1.0.0/schema.json",
    scientific: "https://stac-extensions.github.io/scientific/v1.0.0/schema.json",
    table: "https://stac-extensions.github.io/table/v1.2.0/schema.json",
    timestamps: "https://stac-extensions.github.io/timestamps/v1.1.0/schema.json",
    version: "https://stac-extensions.github.io/version/v1.2.0/schema.json",
    view: "https://stac-extensions.github.io/view/v1.0.0/schema.json"
  }, r = {
    // Add a : at the end to indicate it has a prefix, otherwise list all fields separately (see version extension for example).
    itemAndCollection: {
      // with prefix
      "classification:": n.classification,
      "cube:": n.datacube,
      "eo:": n.eo,
      "file:": n.file,
      "label:": n.label,
      "pc:": n.pointcloud,
      "processing:": n.processing,
      "proj:": n.projection,
      "raster:": n.raster,
      "sar:": n.sar,
      "sat:": n.sat,
      "sci:": n.scientific,
      "view:": n.view,
      // without prefix
      version: n.version,
      deprecated: n.version,
      published: n.timestamps,
      expires: n.timestamps,
      unpublished: n.timestamps
    },
    catalog: {
      // None yet
    },
    collection: {
      // None yet
    },
    item: {
      // None yet
    }
  };
  r.collection = Object.assign(r.collection, r.itemAndCollection), r.item = Object.assign(r.item, r.itemAndCollection);
  var s = {
    parseExtension(p) {
      let y = p.match(/^https?:\/\/stac-extensions.github.io\/([^\/]+)\/v([^\/]+)\/[^.]+.json$/i);
      if (y)
        return {
          id: y[1],
          version: y[2]
        };
      let E = p.match(/(\d+\.\d+(\.\d+)([a-z_.-][\w.-]+)?)/i);
      if (E)
        return {
          id: p,
          version: E[1]
        };
      if (p in n)
        return {
          id: p,
          version: "0.0.0"
        };
    }
  }, o = {
    version: e,
    extensions: {},
    set(p) {
      if (typeof p.stac_version != "string" ? o.version = "0.6.0" : o.version = p.stac_version, Array.isArray(p.stac_extensions))
        for (let y of p.stac_extensions) {
          let E = s.parseExtension(y);
          E && (o.extensions[E.id] = E.version);
        }
    },
    before(p, y = null) {
      return o.compare("<", p, y);
    },
    compare(p, y, E = null) {
      let b = E ? o.extensions[E] : o.version;
      return typeof b > "u" ? !1 : i.compare(b, y, p);
    }
  }, a = {
    type(p) {
      let y = typeof p;
      if (y === "object") {
        if (p === null)
          return "null";
        if (Array.isArray(p))
          return "array";
      }
      return y;
    },
    is(p, y) {
      return Array.isArray(y) ? y.includes(a.type(p)) : a.type(p) === y;
    },
    isDefined(p) {
      return typeof p < "u";
    },
    isObject(p) {
      return typeof p == "object" && p === Object(p) && !Array.isArray(p);
    },
    rename(p, y, E) {
      return typeof p[y] < "u" && typeof p[E] > "u" ? (p[E] = p[y], delete p[y], !0) : !1;
    },
    copy(p, y, E) {
      return typeof p[y] < "u" && typeof p[E] > "u" ? (p[E] = p[y], !0) : !1;
    },
    forAll(p, y, E) {
      if (p[y] && typeof p[y] == "object")
        for (let b in p[y])
          E(p[y][b]);
    },
    toArray(p, y) {
      return typeof p[y] < "u" && !Array.isArray(p[y]) ? (p[y] = [p[y]], !0) : !1;
    },
    flattenArray(p, y, E, b = !1) {
      if (Array.isArray(p[y])) {
        for (let T in p[y])
          if (typeof E[T] == "string") {
            let R = p[y][T];
            p[E[T]] = b ? [R] : R;
          }
        return delete p[y], !0;
      }
      return !1;
    },
    flattenOneElementArray(p, y, E = !1) {
      return !E && Array.isArray(p[y]) ? p[y].length === 1 ? (p[y] = p[y][0], !0) : !1 : !0;
    },
    removeFromArray(p, y, E) {
      if (Array.isArray(p[y])) {
        let b = p[y].indexOf(E);
        return b > -1 && p[y].splice(b, 1), !0;
      }
      return !1;
    },
    pickFirst(p, y) {
      return Array.isArray(p[y]) && p[y].length > 0 ? (p[y] = p[y][0], !0) : (delete p[y], !1);
    },
    ensure(p, y, E) {
      return a.type(E) !== a.type(p[y]) && (p[y] = E), !0;
    },
    upgradeExtension(p, y) {
      let { id: E, version: b } = s.parseExtension(y), T = p.stac_extensions.findIndex((R) => {
        let M = s.parseExtension(R);
        return M && M.id === E && i.compare(M.version, b, "<");
      });
      return T !== -1 ? (p.stac_extensions[T] = y, !0) : !1;
    },
    addExtension(p, y) {
      let { id: E, version: b } = s.parseExtension(y), T = p.stac_extensions.findIndex((R) => {
        if (R === y)
          return !0;
        let M = s.parseExtension(R);
        return !!(M && M.id === E && i.compare(M.version, b, "<"));
      });
      return T === -1 ? p.stac_extensions.push(y) : p.stac_extensions[T] = y, p.stac_extensions.sort(), !0;
    },
    removeExtension(p, y) {
      return a.removeFromArray(p, "stac_extensions", y);
    },
    migrateExtensionShortnames(p) {
      let y = Object.keys(n), E = Object.values(n);
      return a.mapValues(p, "stac_extensions", y, E);
    },
    populateExtensions(p, y) {
      let E = [];
      (y == "catalog" || y == "collection") && E.push(p), (y == "item" || y == "collection") && a.isObject(p.assets) && (E = E.concat(Object.values(p.assets))), y == "collection" && a.isObject(p.item_assets) && (E = E.concat(Object.values(p.item_assets))), y == "collection" && a.isObject(p.summaries) && E.push(p.summaries), y == "item" && a.isObject(p.properties) && E.push(p.properties), E.push(p.links);
      let b;
      for (; b = E.pop(); )
        Object.keys(b).forEach((T) => {
          Array.isArray(b.bands) && (E = E.concat(b.bands));
          let R = T.match(/^(\w+:|[^:]+$)/i);
          if (Array.isArray(R)) {
            let M = r[y][R[0]];
            a.is(M, "string") && a.addExtension(p, M);
          }
        });
    },
    mapValues(p, y, E, b) {
      let T = (R) => {
        let M = E.indexOf(R);
        return M >= 0 ? b[M] : R;
      };
      return Array.isArray(p[y]) ? p[y] = p[y].map(T) : typeof p[y] < "u" && (p[y] = T(p[y])), !0;
    },
    mapObject(p, y) {
      for (let E in p)
        p[E] = y(p[E], E);
    },
    moveTo(p, y, E, b = !1, T = !1) {
      let R;
      return b ? T ? R = (M) => Array.isArray(M) : R = (M) => Array.isArray(M) && M.length === 1 : R = a.isDefined, R(p[y]) ? (E[y] = b && !T ? p[y][0] : p[y], delete p[y], !0) : !1;
    },
    runAll(p, y, E, b) {
      for (let T in p)
        T.startsWith("migrate") || p[T](y, E, b);
    },
    toUTC(p, y) {
      if (a.is(p[y], "string"))
        try {
          return p[y] = this.toISOString(p[y]), !0;
        } catch {
        }
      return delete p[y], !1;
    },
    toISOString(p) {
      return p instanceof Date || (p = new Date(p)), p.toISOString().replace(/\.0+(?=[-\+Z])/, "");
    },
    formatString(p, y, E) {
      const b = (T) => a.is(T, ["string", "number"]) ? E.replaceAll("{}", T) : T;
      Array.isArray(p[y]) ? p[y] = p[y].map(b) : p[y] = b(p[y]);
    }
  }, l = {
    multihash: null,
    hexToUint8(p) {
      if (p.length === 0 || p.length % 2 !== 0)
        throw new Error(`The string "${p}" is not valid hex.`);
      return new Uint8Array(p.match(/.{1,2}/g).map((y) => parseInt(y, 16)));
    },
    uint8ToHex(p) {
      return p.reduce((y, E) => y + E.toString(16).padStart(2, "0"), "");
    },
    toMultihash(p, y, E) {
      if (!l.multihash || !a.is(p[y], "string"))
        return !1;
      try {
        const b = l.multihash.encode(l.hexToUint8(p[y]), E);
        return p[y] = l.uint8ToHex(b), !0;
      } catch (b) {
        return console.warn(b), !1;
      }
    }
  }, h = {
    migrate(p, y = !0) {
      return o.set(p), y && (p.stac_version = e), p.type = "Catalog", a.ensure(p, "stac_extensions", []), o.before("1.0.0-rc.1") && a.migrateExtensionShortnames(p), a.ensure(p, "id", ""), a.ensure(p, "description", ""), a.ensure(p, "links", []), a.runAll(h, p, p), o.before("0.8.0") && a.populateExtensions(p, "catalog"), p;
    }
  }, u = {
    migrate(p, y = !0) {
      return h.migrate(p, y), p.type = "Collection", o.before("1.0.0-rc.1") && a.migrateExtensionShortnames(p), a.ensure(p, "license", "other"), a.ensure(p, "extent", {
        spatial: {
          bbox: []
        },
        temporal: {
          interval: []
        }
      }), a.runAll(u, p, p), a.isObject(p.properties) && (a.removeFromArray(p, "stac_extensions", "commons"), delete p.properties), o.before("0.8.0") && a.populateExtensions(p, "collection"), o.before("1.0.0-beta.1") && a.mapValues(p, "stac_extensions", ["assets"], ["item-assets"]), p;
    },
    extent(p) {
      if (a.ensure(p, "extent", {}), o.before("0.8.0") && (Array.isArray(p.extent.spatial) && (p.extent.spatial = {
        bbox: [
          p.extent.spatial
        ]
      }), Array.isArray(p.extent.temporal) && (p.extent.temporal = {
        interval: [
          p.extent.temporal
        ]
      })), a.ensure(p.extent, "spatial", {}), a.ensure(p.extent.spatial, "bbox", []), a.ensure(p.extent, "temporal", {}), a.ensure(p.extent.temporal, "interval", []), o.before("1.0.0-rc.3")) {
        if (p.extent.temporal.interval.length > 1) {
          let y, E;
          for (let b of p.extent.temporal.interval) {
            if (b[0] === null)
              y = null;
            else if (typeof b[0] == "string" && y !== null)
              try {
                let T = new Date(b[0]);
                (typeof y > "u" || T < y) && (y = T);
              } catch {
              }
            if (b[1] === null)
              E = null;
            else if (typeof b[1] == "string" && E !== null)
              try {
                let T = new Date(b[1]);
                (typeof E > "u" || T > E) && (E = T);
              } catch {
              }
          }
          p.extent.temporal.interval.unshift([
            y ? a.toISOString(y) : null,
            E ? a.toISOString(E) : null
          ]);
        }
        if (p.extent.spatial.bbox.length > 1) {
          let y = p.extent.spatial.bbox.reduce((E, b) => Array.isArray(b) ? Math.max(b.length, E) : E, 4);
          if (y >= 4) {
            let E = new Array(y).fill(null), b = y / 2;
            for (let T of p.extent.spatial.bbox) {
              if (!Array.isArray(T) || T.length < 4)
                break;
              for (let R in T) {
                let M = T[R];
                E[R] === null ? E[R] = M : R < b ? E[R] = Math.min(M, E[R]) : E[R] = Math.max(M, E[R]);
              }
            }
            E.findIndex((T) => T === null) === -1 && p.extent.spatial.bbox.unshift(E);
          }
        }
      }
    },
    collectionAssets(p) {
      o.before("1.0.0-rc.1") && a.removeExtension(p, "collection-assets"), d.migrateAll(p);
    },
    itemAsset(p) {
      o.before("1.0.0-beta.2") && a.rename(p, "item_assets", "assets"), a.removeExtension(p, n["item-assets"]), d.migrateAll(p, "item_assets");
    },
    summaries(p) {
      if (a.ensure(p, "summaries", {}), o.before("0.8.0") && a.isObject(p.other_properties)) {
        for (let y in p.other_properties) {
          let E = p.other_properties[y];
          Array.isArray(E.extent) && E.extent.length === 2 ? p.summaries[y] = {
            minimum: E.extent[0],
            maximum: E.extent[1]
          } : Array.isArray(E.values) && (E.values.filter((b) => Array.isArray(b)).length === E.values.length ? p.summaries[y] = E.values.reduce((b, T) => b.concat(T), []) : p.summaries[y] = E.values);
        }
        delete p.other_properties;
      }
      if (o.before("1.0.0-beta.1") && a.isObject(p.properties) && !p.links.find((y) => ["child", "item"].includes(y.rel)))
        for (let y in p.properties) {
          let E = p.properties[y];
          Array.isArray(E) || (E = [E]), p.summaries[y] = E;
        }
      o.before("1.0.0-rc.1") && a.mapObject(p.summaries, (y) => (a.rename(y, "min", "minimum"), a.rename(y, "max", "maximum"), y)), x.migrate(p.summaries, p, !0), a.moveTo(p.summaries, "sci:doi", p, !0) && a.addExtension(p, n.scientific), a.moveTo(p.summaries, "sci:publications", p, !0, !0) && a.addExtension(p, n.scientific), a.moveTo(p.summaries, "sci:citation", p, !0) && a.addExtension(p, n.scientific), a.moveTo(p.summaries, "cube:dimensions", p, !0) && a.addExtension(p, n.datacube), Object.keys(p.summaries).length === 0 && delete p.summaries;
    }
  }, c = {
    migrate(p, y = null, E = !0) {
      o.set(p), E && (p.stac_version = e), a.ensure(p, "stac_extensions", []), o.before("1.0.0-rc.1") && a.migrateExtensionShortnames(p), a.ensure(p, "id", ""), a.ensure(p, "type", "Feature"), a.isObject(p.geometry) || (p.geometry = null), p.geometry !== null && a.ensure(p, "bbox", []), a.ensure(p, "properties", {}), a.ensure(p, "links", []), a.ensure(p, "assets", {});
      let b = !1;
      return a.isObject(y) && a.isObject(y.properties) && (a.removeFromArray(p, "stac_extensions", "commons"), p.properties = Object.assign({}, y.properties, p.properties), b = !0), a.runAll(c, p, p), x.migrate(p.properties, p), d.migrateAll(p), (o.before("0.8.0") || b) && a.populateExtensions(p, "item"), p;
    }
  }, f = {
    migrate(p, y = !0) {
      return a.ensure(p, "collections", []), a.ensure(p, "links", []), a.runAll(f, p, p), p.collections = p.collections.map((E) => u.migrate(E, y)), p;
    }
  }, g = {
    migrate(p, y = !0) {
      return a.ensure(p, "type", "FeatureCollection"), a.ensure(p, "features", []), a.ensure(p, "links", []), a.runAll(g, p, p), p.features = p.features.map((E) => c.migrate(E, null, y)), p;
    }
  }, d = {
    migrateAll(p, y = "assets") {
      for (let E in p[y])
        d.migrate(p[y][E], p);
    },
    migrate(p, y) {
      return a.runAll(d, p, y), x.migrate(p, y), p;
    },
    mediaTypes(p) {
      a.is(p.type, "string") && a.mapValues(
        p,
        "type",
        ["image/vnd.stac.geotiff", "image/vnd.stac.geotiff; cloud-optimized=true"],
        ["image/tiff; application=geotiff", "image/tiff; application=geotiff; profile=cloud-optimized"]
      );
    }
  }, m = {
    migrateAll(p, y) {
      if (o.before("1.0.0")) {
        const E = a.isObject(y.properties) && Array.isArray(y.properties.bands) ? y.properties.bands : [];
        if (Array.isArray(p["eo:bands"]))
          for (let b in p["eo:bands"]) {
            let T = p["eo:bands"][b];
            a.is(T, "number") && a.isObject(E[T]) && (T = E[T]), a.isObject(T) || (T = {}), p["eo:bands"][b] = T;
          }
      }
      if (o.before("1.1.0-beta.1") && (Array.isArray(p["raster:bands"]) || Array.isArray(p["eo:bands"]))) {
        a.ensure(p, "bands", []);
        const E = p["raster:bands"] || [], b = p["eo:bands"] || [], T = Math.max(E.length, b.length);
        for (let R = 0; R < T; R++)
          a.ensure(p.bands, R, {}), Object.assign(p.bands[R], E[R], b[R]), p.bands[R] = m.migrate(p.bands[R], y);
        delete p["raster:bands"], delete p["eo:bands"];
      }
    },
    migrate(p, y) {
      return a.runAll(m, p, y), x.migrate(p, y), p;
    },
    eo(p) {
      o.before("2.0.0-beta.1", "eo") && (a.rename(p, "common_name", "eo:common_name"), a.rename(p, "center_wavelength", "eo:center_wavelength"), a.rename(p, "full_width_half_max", "eo:full_width_half_max"), a.rename(p, "solar_illumination", "eo:solar_illumination"));
    },
    raster(p) {
      o.before("2.0.0-beta.1", "raster") && (a.rename(p, "sampling", "raster:sampling"), a.rename(p, "bits_per_sample", "raster:bits_per_sample"), a.rename(p, "spatial_resolution", "raster:spatial_resolution"), a.rename(p, "scale", "raster:scale"), a.rename(p, "offset", "raster:offset"), a.rename(p, "histogram", "raster:histogram"));
    }
  }, x = {
    migrate(p, y, E = !1) {
      return a.runAll(x, p, y, E), p;
    },
    _commonMetadata(p, y) {
      o.before("1.0.0-rc.3") && (a.toUTC(p, "created"), a.toUTC(p, "updated")), m.migrateAll(p, y);
    },
    _timestamps(p, y) {
      a.toUTC(p, "published"), a.toUTC(p, "expires"), a.toUTC(p, "unpublished"), a.upgradeExtension(y, n.timestamps);
    },
    _versioningIndicator(p, y) {
      a.upgradeExtension(y, n.version);
    },
    checksum(p, y) {
      o.before("0.9.0") && l.multihash && (a.rename(p, "checksum:md5", "checksum:multihash") && l.toMultihash(p, "checksum:multihash", "md5"), a.rename(p, "checksum:sha1", "checksum:multihash") && l.toMultihash(p, "checksum:multihash", "sha1"), a.rename(p, "checksum:sha2", "checksum:multihash") && l.toMultihash(p, "checksum:multihash", "sha2-256"), a.rename(p, "checksum:sha3", "checksum:multihash") && l.toMultihash(p, "checksum:multihash", "sha3-256")), o.before("1.0.0-rc.1") && a.rename(p, "checksum:multihash", "file:checksum") && a.addExtension(y, n.file), a.removeExtension(y, "checksum");
    },
    classification(p, y) {
      o.before("1.1.0", "classification") && a.forAll(p, "classification:classes", (E) => a.rename(E, "color-hint", "color_hint")), o.before("2.0.0", "classification") && a.forAll(p, "classification:classes", (E) => a.ensure(E, "name", E.description)), a.upgradeExtension(y, n.classification);
    },
    cube(p, y) {
      a.upgradeExtension(y, n.datacube);
    },
    dtr(p, y) {
      o.before("0.9.0") && (a.rename(p, "dtr:start_datetime", "start_datetime"), a.rename(p, "dtr:end_datetime", "end_datetime"), a.removeExtension(y, "datetime-range"));
    },
    eo(p, y) {
      o.before("0.9.0") && (a.rename(p, "eo:epsg", "proj:epsg") && a.addExtension(y, n.projection), a.rename(p, "eo:platform", "platform"), a.rename(p, "eo:instrument", "instruments") && a.toArray(p, "instruments"), a.rename(p, "eo:constellation", "constellation"), a.rename(p, "eo:off_nadir", "view:off_nadir") && a.addExtension(y, n.view), a.rename(p, "eo:azimuth", "view:azimuth") && a.addExtension(y, n.view), a.rename(p, "eo:incidence_angle", "view:incidence_angle") && a.addExtension(y, n.view), a.rename(p, "eo:sun_azimuth", "view:sun_azimuth") && a.addExtension(y, n.view), a.rename(p, "eo:sun_elevation", "view:sun_elevation") && a.addExtension(y, n.view)), o.before("1.0.0-beta.1") && a.rename(p, "eo:gsd", "gsd"), a.upgradeExtension(y, n.eo);
    },
    file(p, y, E) {
      a.rename(p, "file:bits_per_sample", "raster:bits_per_sample") && a.addExtension(y, n.raster), a.rename(p, "file:data_type", "data_type"), a.rename(p, "file:unit", "unit"), Array.isArray(p["file:nodata"]) && p["file:nodata"].length > 1 && a.copy(p, "file:nodata", "nodata:values"), a.rename(p, "file:nodata", "nodata") && !E && a.pickFirst(p, "nodata"), a.upgradeExtension(y, n.file);
    },
    label(p, y) {
      o.before("0.8.0") && (a.rename(p, "label:property", "label:properties"), a.rename(p, "label:task", "label:tasks"), a.rename(p, "label:overview", "label:overviews") && a.toArray(p, "label:overviews"), a.rename(p, "label:method", "label:methods"), a.toArray(p, "label:classes")), a.upgradeExtension(y, n.label);
    },
    pc(p, y) {
      o.before("0.8.0") && a.rename(p, "pc:schema", "pc:schemas"), a.upgradeExtension(y, n.pointcloud);
    },
    processing(p, y) {
      a.upgradeExtension(y, n.processing);
    },
    proj(p, y) {
      a.rename(p, "proj:epsg", "proj:code") && a.formatString(p, "proj:code", "EPSG:{}"), a.upgradeExtension(y, n.projection);
    },
    raster(p, y) {
      a.upgradeExtension(y, n.raster);
    },
    sar(p, y, E) {
      a.rename(p, "sar:incidence_angle", "view:incidence_angle") && a.addExtension(y, n.view), a.rename(p, "sar:pass_direction", "sat:orbit_state") && a.mapValues(p, "sat:orbit_state", [null], ["geostationary"]) && a.addExtension(y, n.sat), o.before("0.7.0") && (a.flattenArray(p, "sar:resolution", ["sar:resolution_range", "sar:resolution_azimuth"], E), a.flattenArray(p, "sar:pixel_spacing", ["sar:pixel_spacing_range", "sar:pixel_spacing_azimuth"], E), a.flattenArray(p, "sar:looks", ["sar:looks_range", "sar:looks_azimuth", "sar:looks_equivalent_number"], E), a.rename(p, "sar:off_nadir", "view:off_nadir") && a.addExtension(y, n.view)), o.before("0.9.0") && (a.rename(p, "sar:platform", "platform"), a.rename(p, "sar:instrument", "instruments") && a.toArray(p, "instruments"), a.rename(p, "sar:constellation", "constellation"), a.rename(p, "sar:type", "sar:product_type"), a.rename(p, "sar:polarization", "sar:polarizations"), a.flattenOneElementArray(p, "sar:absolute_orbit", E) && a.rename(p, "sar:absolute_orbit", "sat:absolute_orbit") && a.addExtension(y, n.sat), a.flattenOneElementArray(p, "sar:relative_orbit", E) && a.rename(p, "sar:relative_orbit", "sat:relative_orbit") && a.addExtension(y, n.sat)), a.upgradeExtension(y, n.sar);
    },
    sat(p, y) {
      o.before("0.9.0") && (a.rename(p, "sat:off_nadir_angle", "sat:off_nadir"), a.rename(p, "sat:azimuth_angle", "sat:azimuth"), a.rename(p, "sat:sun_azimuth_angle", "sat:sun_azimuth"), a.rename(p, "sat:sun_elevation_angle", "sat:sun_elevation")), a.upgradeExtension(y, n.sat);
    },
    sci(p, y) {
      a.upgradeExtension(y, n.scientific);
    },
    item(p) {
      o.before("0.8.0") && (a.rename(p, "item:license", "license"), a.rename(p, "item:providers", "providers"));
    },
    table(p, y) {
      a.upgradeExtension(y, n.table);
    },
    view(p, y) {
      a.upgradeExtension(y, n.view);
    }
  }, v = {
    item(p, y = null, E = !0) {
      return c.migrate(p, y, E);
    },
    catalog(p, y = !0) {
      return h.migrate(p, y);
    },
    collection(p, y = !0) {
      return u.migrate(p, y);
    },
    collectionCollection(p, y = !0) {
      return f.migrate(p, y);
    },
    itemCollection(p, y = !0) {
      return g.migrate(p, y);
    },
    stac(p, y = !0) {
      return p.type === "Feature" ? v.item(p, null, y) : p.type === "FeatureCollection" ? v.itemCollection(p, y) : p.type === "Collection" || !p.type && a.isDefined(p.extent) && a.isDefined(p.license) ? v.collection(p, y) : !p.type && Array.isArray(p.collections) ? v.collectionCollection(p, y) : v.catalog(p, y);
    },
    enableMultihash(p) {
      l.multihash = p;
    }
  };
  return ig = v, ig;
}
var hD = lD();
const uD = /* @__PURE__ */ jf(hD);
function Ti(i) {
  return typeof i == "string" && i.length > 0;
}
function Qo(i, e, t, n = 1e-8) {
  if (typeof i != "number")
    return null;
  const r = e - n, s = t + n;
  return i < r || i > s ? null : Math.min(Math.max(i, e), t);
}
function vi(i) {
  return typeof i == "object" && i === Object(i) && !Array.isArray(i);
}
function cD(i) {
  switch (i) {
    case "int8":
      return -128;
    case "int16":
      return -32768;
    case "int32":
      return -2147483648;
  }
  return i.startsWith("u") ? 0 : null;
}
function fD(i) {
  switch (i) {
    case "int8":
      return 127;
    case "uint8":
      return 255;
    case "int16":
      return 32767;
    case "uint16":
      return 65535;
    case "int32":
      return 2147483647;
    case "uint32":
      return 4294967295;
  }
  return null;
}
function Lb(i) {
  const e = {
    minimum: null,
    maximum: null
  }, t = (l) => l.minimum !== null && l.maximum !== null, n = i.getMetadata("statistics");
  if (vi(n) && (typeof n.minimum == "number" && (e.minimum = n.minimum), typeof n.maximum == "number" && (e.maximum = n.maximum), t(e)))
    return e;
  const r = i.getMetadata("raster:histogram");
  if (vi(r) && (typeof r.min == "number" && (e.minimum = r.min), typeof r.max == "number" && (e.maximum = r.max), t(e)))
    return e;
  const s = i.getMetadata("classification:classes");
  if (Array.isArray(s) && (s.reduce((l, h) => (l.minimum = Math.min(l.minimum, h.value), l.maximum = Math.max(l.maximum, h.value), l), e), t(e)))
    return e;
  const o = i.getMetadata("file:values");
  if (Array.isArray(o) && (o.reduce((l, h) => (l.minimum = Math.min(l.minimum, ...h.values), l.maximum = Math.max(l.maximum, ...h.values), l), e), t(e)))
    return e;
  const a = i.getMetadata("data_type");
  return a && (e.minimum = cD(a), e.maximum = fD(a)), e;
}
function Fb(i) {
  let e = [];
  const t = i.getMetadata("nodata");
  if (typeof t < "u")
    e.push(t);
  else {
    const n = i.getMetadata("file:nodata");
    if (typeof n < "u")
      e = n;
    else {
      const r = i.getMetadata("classification:classes");
      Array.isArray(r) && (e = r.filter((s) => !!s.nodata).map((s) => s.value));
    }
  }
  return e.map((n) => n === "nan" ? NaN : n === "+inf" ? 1 / 0 : n === "-inf" ? -1 / 0 : n);
}
function Qa(i) {
  let e = i.length >= 6, t = i[0], n = i[e ? 3 : 2], r = i[1], s = i[e ? 4 : 3], o = { west: t, east: n, south: r, north: s };
  return e && (o.base = i[2], o.height = i[5]), o;
}
function ng(i) {
  let { west: e, east: t, south: n, north: r } = Qa(i);
  return [
    [
      [e, r],
      [e, n],
      [t, n],
      [t, r],
      [e, r]
    ]
  ];
}
function dD(i) {
  if (i = ur(i, !0), !i)
    return null;
  let e = Qa(i), t = [];
  if (Db(i)) {
    let n = (e.west + 360 + e.east) / 2;
    n > 180 && (n -= 360), t.push(n);
  } else
    t.push((e.west + e.east) / 2);
  return t.push((e.south + e.north) / 2), typeof e.base < "u" && t.push((e.base + e.height) / 2), t;
}
function Ob(i) {
  if (Array.isArray(i[0]))
    return i.map(Ob);
  const [e, t] = i;
  return [Qo(e, -180, 180), Qo(t, -90, 90)];
}
function Yu(i) {
  return vi(i) && (i.bbox && (i.bbox = ur(i.bbox)), i.type === "FeatureCollection" ? i.features.forEach((e) => Yu(e)) : i.type === "Feature" ? i.geometry = Yu(i.geometry) : i.type === "GeometryCollection" ? i.geometries.forEach((e) => Yu(e)) : i.coordinates && (i.coordinates = Ob(i.coordinates))), i;
}
function Nb(i) {
  if (i.every((n) => typeof n == "number") && (i = [i]), i = i.map((n) => ur(n)).filter((n) => n !== null), !Array.isArray(i) || i.length === 0)
    return null;
  let e = i.reduce((n, r) => {
    if (Db(r)) {
      let { west: s, east: o, south: a, north: l } = Qa(r);
      n.push(ng([-180, a, o, l])), n.push(ng([s, a, 180, l]));
    } else
      n.push(ng(r));
    return n;
  }, []), t = null;
  if (e.length === 1 ? t = {
    type: "Polygon",
    coordinates: e[0]
  } : e.length > 1 && (t = {
    type: "MultiPolygon",
    coordinates: e
  }), t)
    return {
      type: "Feature",
      geometry: t,
      properties: {}
    };
}
function ur(i, e = !1) {
  if (!Array.isArray(i) || ![4, 6].includes(i.length))
    return null;
  let { west: t, east: n, south: r, north: s, base: o, height: a } = Qa(i);
  return t = Qo(t, -180, 180), r = Qo(r, -90, 90), n = Qo(n, -180, 180), s = Qo(s, -90, 90), e && i.length === 6 ? i = [t, r, o, n, s, a] : i = [t, r, n, s], i.some((l) => l === null) ? null : i;
}
function Db(i) {
  if (i = ur(i), !i)
    return !1;
  let { west: e, east: t } = Qa(i);
  return e > t;
}
function F0(i) {
  if (!Array.isArray(i) || i.length === 0)
    return null;
  const e = {
    west: null,
    south: null,
    east: null,
    north: null
  }, t = ["west", "south"];
  for (let r of i) {
    if (r = ur(r), !r)
      continue;
    const s = Qa(r);
    for (const o in s)
      if (e[o] === null)
        e[o] = s[o];
      else {
        const a = t.includes(o) ? Math.min : Math.max;
        e[o] = a(e[o], s[o]);
      }
  }
  let n = [e.west, e.south, e.east, e.north];
  return ur(n);
}
class jh {
  constructor(e, t = {}, n = []) {
    if (!vi(e))
      throw new Error("Given data is not an object");
    if (e instanceof jh) {
      for (let r of n)
        this[r] = e[r];
      e = e.toJSON();
    }
    this._keyMap = t, this._privateKeys = ["_keyMap", "_privateKeys"].concat(n);
    for (let r in e)
      typeof this[r] > "u" && (r in t ? this[r] = t[r](e[r], this) : this[r] = e[r]);
  }
  /**
   * Check whether this given object is a STAC Item.
   * 
   * @returns {boolean} `true` if the object is a STAC Item, `false` otherwise.
   */
  isItem() {
    return this.type === "Feature";
  }
  /**
   * Check whether this given object is a STAC Catalog.
   * 
   * @returns {boolean} `true` if the object is a STAC Catalog, `false` otherwise.
   */
  isCatalog() {
    return this.type === "Catalog";
  }
  /**
   * Check whether this given object is "catalog-like", i.e. a Catalog or Collection.
   * 
   * @returns {boolean} `true` if the object is a "catalog-like", `false` otherwise.
   */
  isCatalogLike() {
    return this.isCatalog() || this.isCollection();
  }
  /**
   * Check whether this given object is a STAC Collection.
   * 
   * @returns {boolean} `true` if the object is a STAC Collection, `false` otherwise.
   */
  isCollection() {
    return this.type === "Collection";
  }
  /**
   * Check whether this given object is a STAC ItemCollection.
   * 
   * @returns {boolean} `true` if the object is a STAC ItemCollection, `false` otherwise.
   */
  isItemCollection() {
    return this.type === "FeatureCollection";
  }
  /**
   * Check whether this given object is a STAC Collection of Collections (i.e. API Collections).
   * 
   * @returns {boolean} `true` if the object is a STAC CollectionCollection, `false` otherwise.
   */
  isCollectionCollection() {
    return !1;
  }
  /**
   * Check whether this given object is a STAC Asset.
   * 
   * @returns {boolean} `true` if the object is a STAC Asset, `false` otherwise.
   */
  isAsset() {
    return !1;
  }
  /**
   * Check whether this given object is a STAC Link.
   * 
   * @returns {boolean} `true` if the object is a STAC Link, `false` otherwise.
   */
  isLink() {
    return !1;
  }
  /**
   * Check whether this given object is a STAC Band.
   * 
   * @returns {boolean} `true` if the object is a STAC Band, `false` otherwise.
   */
  isBand() {
    return !1;
  }
  /**
   * Returns the type of the STAC object.
   * 
   * One of:
   * - Asset
   * - Catalog
   * - Collection
   * - CollectionCollection
   * - Item
   * - ItemCollection
   * - Link
   * - Band
   * @abstract
   * @returns {string}
   */
  getObjectType() {
  }
  /**
   * Gets the absolute URL of the STAC entity (if provided explicitly or available from the self link).
   * 
   * @param {boolean} stringify If `true` (default), a string is returned, otherwise a URI object.
   * @returns {string|null} Absolute URL
   */
  getAbsoluteUrl(e = !0) {
    return null;
  }
  /**
   * Returns the metadata for the STAC entity.
   * 
   * @param {string} field Field name
   * @returns {*}
   */
  getMetadata(e) {
    return this[e];
  }
  /**
   * Returns a GeoJSON Feature or FeatureCollection for this STAC object.
   * 
   * @returns {Object|null} GeoJSON object or `null`
   */
  toGeoJSON() {
    return null;
  }
  /**
   * Returns a single bounding box for the STAC entity.
   * 
   * @returns {BoundingBox|null}
   */
  getBoundingBox() {
    return null;
  }
  /**
   * Returns the center of the STAC entity.
   * 
   * @returns {BoundingBox|null}
   */
  getCenter() {
    return dD(this.getBoundingBox());
  }
  /**
   * Returns a list of bounding boxes for the STAC entity.
   * 
   * @returns {Array.<BoundingBox>}
   */
  getBoundingBoxes() {
    return [];
  }
  /**
   * Returns a plain object for JSON export.
   * 
   * @returns {Object} Plain object
   */
  toJSON() {
    let e = {};
    return Object.keys(this).forEach((t) => {
      if (typeof this[t] == "function" || this._privateKeys.includes(t))
        return;
      let n = this[t];
      if (t in this._keyMap) {
        let r = Array.isArray(n) ? [] : {};
        for (let s in n)
          typeof n[s].toJSON == "function" ? r[s] = n[s].toJSON() : r[s] = n[s];
        n = r;
      }
      e[t] = n;
    }), e;
  }
}
var qu = { exports: {} }, vl = { exports: {} };
var gD = vl.exports, N1;
function pD() {
  return N1 || (N1 = 1, (function(i, e) {
    (function(t) {
      var n = e && !e.nodeType && e, r = i && !i.nodeType && i, s = typeof m1 == "object" && m1;
      (s.global === s || s.window === s || s.self === s) && (t = s);
      var o, a = 2147483647, l = 36, h = 1, u = 26, c = 38, f = 700, g = 72, d = 128, m = "-", x = /^xn--/, v = /[^\x20-\x7E]/, p = /[\x2E\u3002\uFF0E\uFF61]/g, y = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, E = l - h, b = Math.floor, T = String.fromCharCode, R;
      function M(U) {
        throw new RangeError(y[U]);
      }
      function C(U, G) {
        for (var $ = U.length, H = []; $--; )
          H[$] = G(U[$]);
        return H;
      }
      function I(U, G) {
        var $ = U.split("@"), H = "";
        $.length > 1 && (H = $[0] + "@", U = $[1]), U = U.replace(p, ".");
        var ne = U.split("."), te = C(ne, G).join(".");
        return H + te;
      }
      function O(U) {
        for (var G = [], $ = 0, H = U.length, ne, te; $ < H; )
          ne = U.charCodeAt($++), ne >= 55296 && ne <= 56319 && $ < H ? (te = U.charCodeAt($++), (te & 64512) == 56320 ? G.push(((ne & 1023) << 10) + (te & 1023) + 65536) : (G.push(ne), $--)) : G.push(ne);
        return G;
      }
      function z(U) {
        return C(U, function(G) {
          var $ = "";
          return G > 65535 && (G -= 65536, $ += T(G >>> 10 & 1023 | 55296), G = 56320 | G & 1023), $ += T(G), $;
        }).join("");
      }
      function _(U) {
        return U - 48 < 10 ? U - 22 : U - 65 < 26 ? U - 65 : U - 97 < 26 ? U - 97 : l;
      }
      function w(U, G) {
        return U + 22 + 75 * (U < 26) - ((G != 0) << 5);
      }
      function S(U, G, $) {
        var H = 0;
        for (U = $ ? b(U / f) : U >> 1, U += b(U / G); U > E * u >> 1; H += l)
          U = b(U / E);
        return b(H + (E + 1) * U / (U + c));
      }
      function P(U) {
        var G = [], $ = U.length, H, ne = 0, te = d, re = g, ae, Re, xe, Ae, Z, at, ut, Ee, gt;
        for (ae = U.lastIndexOf(m), ae < 0 && (ae = 0), Re = 0; Re < ae; ++Re)
          U.charCodeAt(Re) >= 128 && M("not-basic"), G.push(U.charCodeAt(Re));
        for (xe = ae > 0 ? ae + 1 : 0; xe < $; ) {
          for (Ae = ne, Z = 1, at = l; xe >= $ && M("invalid-input"), ut = _(U.charCodeAt(xe++)), (ut >= l || ut > b((a - ne) / Z)) && M("overflow"), ne += ut * Z, Ee = at <= re ? h : at >= re + u ? u : at - re, !(ut < Ee); at += l)
            gt = l - Ee, Z > b(a / gt) && M("overflow"), Z *= gt;
          H = G.length + 1, re = S(ne - Ae, H, Ae == 0), b(ne / H) > a - te && M("overflow"), te += b(ne / H), ne %= H, G.splice(ne++, 0, te);
        }
        return z(G);
      }
      function A(U) {
        var G, $, H, ne, te, re, ae, Re, xe, Ae, Z, at = [], ut, Ee, gt, St;
        for (U = O(U), ut = U.length, G = d, $ = 0, te = g, re = 0; re < ut; ++re)
          Z = U[re], Z < 128 && at.push(T(Z));
        for (H = ne = at.length, ne && at.push(m); H < ut; ) {
          for (ae = a, re = 0; re < ut; ++re)
            Z = U[re], Z >= G && Z < ae && (ae = Z);
          for (Ee = H + 1, ae - G > b((a - $) / Ee) && M("overflow"), $ += (ae - G) * Ee, G = ae, re = 0; re < ut; ++re)
            if (Z = U[re], Z < G && ++$ > a && M("overflow"), Z == G) {
              for (Re = $, xe = l; Ae = xe <= te ? h : xe >= te + u ? u : xe - te, !(Re < Ae); xe += l)
                St = Re - Ae, gt = l - Ae, at.push(
                  T(w(Ae + St % gt, 0))
                ), Re = b(St / gt);
              at.push(T(w(Re, 0))), te = S($, Ee, H == ne), $ = 0, ++H;
            }
          ++$, ++G;
        }
        return at.join("");
      }
      function D(U) {
        return I(U, function(G) {
          return x.test(G) ? P(G.slice(4).toLowerCase()) : G;
        });
      }
      function k(U) {
        return I(U, function(G) {
          return v.test(G) ? "xn--" + A(G) : G;
        });
      }
      if (o = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "1.3.2",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: O,
          encode: z
        },
        decode: P,
        encode: A,
        toASCII: k,
        toUnicode: D
      }, n && r)
        if (i.exports == n)
          r.exports = o;
        else
          for (R in o)
            o.hasOwnProperty(R) && (n[R] = o[R]);
      else
        t.punycode = o;
    })(gD);
  })(vl, vl.exports)), vl.exports;
}
var Zu = { exports: {} };
var mD = Zu.exports, D1;
function _D() {
  return D1 || (D1 = 1, (function(i) {
    (function(e, t) {
      i.exports ? i.exports = t() : e.IPv6 = t(e);
    })(mD, function(e) {
      var t = e && e.IPv6;
      function n(s) {
        var o = s.toLowerCase(), a = o.split(":"), l = a.length, h = 8;
        a[0] === "" && a[1] === "" && a[2] === "" ? (a.shift(), a.shift()) : a[0] === "" && a[1] === "" ? a.shift() : a[l - 1] === "" && a[l - 2] === "" && a.pop(), l = a.length, a[l - 1].indexOf(".") !== -1 && (h = 7);
        var u;
        for (u = 0; u < l && a[u] !== ""; u++)
          ;
        if (u < h)
          for (a.splice(u, 1, "0000"); a.length < h; )
            a.splice(u, 0, "0000");
        for (var c, f = 0; f < h; f++) {
          c = a[f].split("");
          for (var g = 0; g < 3 && (c[0] === "0" && c.length > 1); g++)
            c.splice(0, 1);
          a[f] = c.join("");
        }
        var d = -1, m = 0, x = 0, v = -1, p = !1;
        for (f = 0; f < h; f++)
          p ? a[f] === "0" ? x += 1 : (p = !1, x > m && (d = v, m = x)) : a[f] === "0" && (p = !0, v = f, x = 1);
        x > m && (d = v, m = x), m > 1 && a.splice(d, m, ""), l = a.length;
        var y = "";
        for (a[0] === "" && (y = ":"), f = 0; f < l && (y += a[f], f !== l - 1); f++)
          y += ":";
        return a[l - 1] === "" && (y += ":"), y;
      }
      function r() {
        return e.IPv6 === this && (e.IPv6 = t), this;
      }
      return {
        best: n,
        noConflict: r
      };
    });
  })(Zu)), Zu.exports;
}
var Hu = { exports: {} };
var yD = Hu.exports, G1;
function xD() {
  return G1 || (G1 = 1, (function(i) {
    (function(e, t) {
      i.exports ? i.exports = t() : e.SecondLevelDomains = t(e);
    })(yD, function(e) {
      var t = e && e.SecondLevelDomains, n = {
        // list of known Second Level Domains
        // converted list of SLDs from https://github.com/gavingmiller/second-level-domains
        // ----
        // publicsuffix.org is more current and actually used by a couple of browsers internally.
        // downside is it also contains domains like "dyndns.org" - which is fine for the security
        // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js
        // ----
        list: {
          ac: " com gov mil net org ",
          ae: " ac co gov mil name net org pro sch ",
          af: " com edu gov net org ",
          al: " com edu gov mil net org ",
          ao: " co ed gv it og pb ",
          ar: " com edu gob gov int mil net org tur ",
          at: " ac co gv or ",
          au: " asn com csiro edu gov id net org ",
          ba: " co com edu gov mil net org rs unbi unmo unsa untz unze ",
          bb: " biz co com edu gov info net org store tv ",
          bh: " biz cc com edu gov info net org ",
          bn: " com edu gov net org ",
          bo: " com edu gob gov int mil net org tv ",
          br: " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
          bs: " com edu gov net org ",
          bz: " du et om ov rg ",
          ca: " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
          ck: " biz co edu gen gov info net org ",
          cn: " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
          co: " com edu gov mil net nom org ",
          cr: " ac c co ed fi go or sa ",
          cy: " ac biz com ekloges gov ltd name net org parliament press pro tm ",
          do: " art com edu gob gov mil net org sld web ",
          dz: " art asso com edu gov net org pol ",
          ec: " com edu fin gov info med mil net org pro ",
          eg: " com edu eun gov mil name net org sci ",
          er: " com edu gov ind mil net org rochest w ",
          es: " com edu gob nom org ",
          et: " biz com edu gov info name net org ",
          fj: " ac biz com info mil name net org pro ",
          fk: " ac co gov net nom org ",
          fr: " asso com f gouv nom prd presse tm ",
          gg: " co net org ",
          gh: " com edu gov mil org ",
          gn: " ac com gov net org ",
          gr: " com edu gov mil net org ",
          gt: " com edu gob ind mil net org ",
          gu: " com edu gov net org ",
          hk: " com edu gov idv net org ",
          hu: " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
          id: " ac co go mil net or sch web ",
          il: " ac co gov idf k12 muni net org ",
          in: " ac co edu ernet firm gen gov i ind mil net nic org res ",
          iq: " com edu gov i mil net org ",
          ir: " ac co dnssec gov i id net org sch ",
          it: " edu gov ",
          je: " co net org ",
          jo: " com edu gov mil name net org sch ",
          jp: " ac ad co ed go gr lg ne or ",
          ke: " ac co go info me mobi ne or sc ",
          kh: " com edu gov mil net org per ",
          ki: " biz com de edu gov info mob net org tel ",
          km: " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
          kn: " edu gov net org ",
          kr: " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
          kw: " com edu gov net org ",
          ky: " com edu gov net org ",
          kz: " com edu gov mil net org ",
          lb: " com edu gov net org ",
          lk: " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
          lr: " com edu gov net org ",
          lv: " asn com conf edu gov id mil net org ",
          ly: " com edu gov id med net org plc sch ",
          ma: " ac co gov m net org press ",
          mc: " asso tm ",
          me: " ac co edu gov its net org priv ",
          mg: " com edu gov mil nom org prd tm ",
          mk: " com edu gov inf name net org pro ",
          ml: " com edu gov net org presse ",
          mn: " edu gov org ",
          mo: " com edu gov net org ",
          mt: " com edu gov net org ",
          mv: " aero biz com coop edu gov info int mil museum name net org pro ",
          mw: " ac co com coop edu gov int museum net org ",
          mx: " com edu gob net org ",
          my: " com edu gov mil name net org sch ",
          nf: " arts com firm info net other per rec store web ",
          ng: " biz com edu gov mil mobi name net org sch ",
          ni: " ac co com edu gob mil net nom org ",
          np: " com edu gov mil net org ",
          nr: " biz com edu gov info net org ",
          om: " ac biz co com edu gov med mil museum net org pro sch ",
          pe: " com edu gob mil net nom org sld ",
          ph: " com edu gov i mil net ngo org ",
          pk: " biz com edu fam gob gok gon gop gos gov net org web ",
          pl: " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
          pr: " ac biz com edu est gov info isla name net org pro prof ",
          ps: " com edu gov net org plo sec ",
          pw: " belau co ed go ne or ",
          ro: " arts com firm info nom nt org rec store tm www ",
          rs: " ac co edu gov in org ",
          sb: " com edu gov net org ",
          sc: " com edu gov net org ",
          sh: " co com edu gov net nom org ",
          sl: " com edu gov net org ",
          st: " co com consulado edu embaixada gov mil net org principe saotome store ",
          sv: " com edu gob org red ",
          sz: " ac co org ",
          tr: " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
          tt: " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
          tw: " club com ebiz edu game gov idv mil net org ",
          mu: " ac co com gov net or org ",
          mz: " ac co edu gov org ",
          na: " co com ",
          nz: " ac co cri geek gen govt health iwi maori mil net org parliament school ",
          pa: " abo ac com edu gob ing med net nom org sld ",
          pt: " com edu gov int net nome org publ ",
          py: " com edu gov mil net org ",
          qa: " com edu gov mil net org ",
          re: " asso com nom ",
          ru: " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
          rw: " ac co com edu gouv gov int mil net ",
          sa: " com edu gov med net org pub sch ",
          sd: " com edu gov info med net org tv ",
          se: " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
          sg: " com edu gov idn net org per ",
          sn: " art com edu gouv org perso univ ",
          sy: " com edu gov mil net news org ",
          th: " ac co go in mi net or ",
          tj: " ac biz co com edu go gov info int mil name net nic org test web ",
          tn: " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
          tz: " ac co go ne or ",
          ua: " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
          ug: " ac co go ne or org sc ",
          uk: " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
          us: " dni fed isa kids nsn ",
          uy: " com edu gub mil net org ",
          ve: " co com edu gob info mil net org web ",
          vi: " co com k12 net org ",
          vn: " ac biz com edu gov health info int name net org pro ",
          ye: " co com gov ltd me net org plc ",
          yu: " ac co edu gov org ",
          za: " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
          zm: " ac co com edu gov net org sch ",
          // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains
          com: "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
          net: "gb jp se uk ",
          org: "ae",
          de: "com "
        },
        // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost
        // in both performance and memory footprint. No initialization required.
        // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4
        // Following methods use lastIndexOf() rather than array.split() in order
        // to avoid any memory allocations.
        has: function(r) {
          var s = r.lastIndexOf(".");
          if (s <= 0 || s >= r.length - 1)
            return !1;
          var o = r.lastIndexOf(".", s - 1);
          if (o <= 0 || o >= s - 1)
            return !1;
          var a = n.list[r.slice(s + 1)];
          return a ? a.indexOf(" " + r.slice(o + 1, s) + " ") >= 0 : !1;
        },
        is: function(r) {
          var s = r.lastIndexOf(".");
          if (s <= 0 || s >= r.length - 1)
            return !1;
          var o = r.lastIndexOf(".", s - 1);
          if (o >= 0)
            return !1;
          var a = n.list[r.slice(s + 1)];
          return a ? a.indexOf(" " + r.slice(0, s) + " ") >= 0 : !1;
        },
        get: function(r) {
          var s = r.lastIndexOf(".");
          if (s <= 0 || s >= r.length - 1)
            return null;
          var o = r.lastIndexOf(".", s - 1);
          if (o <= 0 || o >= s - 1)
            return null;
          var a = n.list[r.slice(s + 1)];
          return !a || a.indexOf(" " + r.slice(o + 1, s) + " ") < 0 ? null : r.slice(o + 1);
        },
        noConflict: function() {
          return e.SecondLevelDomains === this && (e.SecondLevelDomains = t), this;
        }
      };
      return n;
    });
  })(Hu)), Hu.exports;
}
var ED = qu.exports, k1;
function vD() {
  return k1 || (k1 = 1, (function(i) {
    (function(e, t) {
      i.exports ? i.exports = t(pD(), _D(), xD()) : e.URI = t(e.punycode, e.IPv6, e.SecondLevelDomains, e);
    })(ED, function(e, t, n, r) {
      var s = r && r.URI;
      function o(_, w) {
        var S = arguments.length >= 1, P = arguments.length >= 2;
        if (!(this instanceof o))
          return S ? P ? new o(_, w) : new o(_) : new o();
        if (_ === void 0) {
          if (S)
            throw new TypeError("undefined is not a valid argument for URI");
          typeof location < "u" ? _ = location.href + "" : _ = "";
        }
        if (_ === null && S)
          throw new TypeError("null is not a valid argument for URI");
        return this.href(_), w !== void 0 ? this.absoluteTo(w) : this;
      }
      function a(_) {
        return /^[0-9]+$/.test(_);
      }
      o.version = "1.19.11";
      var l = o.prototype, h = Object.prototype.hasOwnProperty;
      function u(_) {
        return _.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      }
      function c(_) {
        return _ === void 0 ? "Undefined" : String(Object.prototype.toString.call(_)).slice(8, -1);
      }
      function f(_) {
        return c(_) === "Array";
      }
      function g(_, w) {
        var S = {}, P, A;
        if (c(w) === "RegExp")
          S = null;
        else if (f(w))
          for (P = 0, A = w.length; P < A; P++)
            S[w[P]] = !0;
        else
          S[w] = !0;
        for (P = 0, A = _.length; P < A; P++) {
          var D = S && S[_[P]] !== void 0 || !S && w.test(_[P]);
          D && (_.splice(P, 1), A--, P--);
        }
        return _;
      }
      function d(_, w) {
        var S, P;
        if (f(w)) {
          for (S = 0, P = w.length; S < P; S++)
            if (!d(_, w[S]))
              return !1;
          return !0;
        }
        var A = c(w);
        for (S = 0, P = _.length; S < P; S++)
          if (A === "RegExp") {
            if (typeof _[S] == "string" && _[S].match(w))
              return !0;
          } else if (_[S] === w)
            return !0;
        return !1;
      }
      function m(_, w) {
        if (!f(_) || !f(w) || _.length !== w.length)
          return !1;
        _.sort(), w.sort();
        for (var S = 0, P = _.length; S < P; S++)
          if (_[S] !== w[S])
            return !1;
        return !0;
      }
      function x(_) {
        var w = /^\/+|\/+$/g;
        return _.replace(w, "");
      }
      o._parts = function() {
        return {
          protocol: null,
          username: null,
          password: null,
          hostname: null,
          urn: null,
          port: null,
          path: null,
          query: null,
          fragment: null,
          // state
          preventInvalidHostname: o.preventInvalidHostname,
          duplicateQueryParameters: o.duplicateQueryParameters,
          escapeQuerySpace: o.escapeQuerySpace
        };
      }, o.preventInvalidHostname = !1, o.duplicateQueryParameters = !1, o.escapeQuerySpace = !0, o.protocol_expression = /^[a-z][a-z0-9.+-]*$/i, o.idn_expression = /[^a-z0-9\._-]/i, o.punycode_expression = /(xn--)/i, o.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, o.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/, o.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig, o.findUri = {
        // valid "scheme://" or "www."
        start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
        // everything up to the next whitespace
        end: /[\s\r\n]|$/,
        // trim trailing punctuation captured by end RegExp
        trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,
        // balanced parens inclusion (), [], {}, <>
        parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
      }, o.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, o.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g, o.defaultPorts = {
        http: "80",
        https: "443",
        ftp: "21",
        gopher: "70",
        ws: "80",
        wss: "443"
      }, o.hostProtocols = [
        "http",
        "https"
      ], o.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/, o.domAttributes = {
        a: "href",
        blockquote: "cite",
        link: "href",
        base: "href",
        script: "src",
        form: "action",
        img: "src",
        area: "href",
        iframe: "src",
        embed: "src",
        source: "src",
        track: "src",
        input: "src",
        // but only if type="image"
        audio: "src",
        video: "src"
      }, o.getDomAttribute = function(_) {
        if (!(!_ || !_.nodeName)) {
          var w = _.nodeName.toLowerCase();
          if (!(w === "input" && _.type !== "image"))
            return o.domAttributes[w];
        }
      };
      function v(_) {
        return escape(_);
      }
      function p(_) {
        return encodeURIComponent(_).replace(/[!'()*]/g, v).replace(/\*/g, "%2A");
      }
      o.encode = p, o.decode = decodeURIComponent, o.iso8859 = function() {
        o.encode = escape, o.decode = unescape;
      }, o.unicode = function() {
        o.encode = p, o.decode = decodeURIComponent;
      }, o.characters = {
        pathname: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
            map: {
              // -._~!'()*
              "%24": "$",
              "%26": "&",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%3A": ":",
              "%40": "@"
            }
          },
          decode: {
            expression: /[\/\?#]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23"
            }
          }
        },
        reserved: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
            map: {
              // gen-delims
              "%3A": ":",
              "%2F": "/",
              "%3F": "?",
              "%23": "#",
              "%5B": "[",
              "%5D": "]",
              "%40": "@",
              // sub-delims
              "%21": "!",
              "%24": "$",
              "%26": "&",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "="
            }
          }
        },
        urnpath: {
          // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
          // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
          // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
          // note that the colon character is not featured in the encoding map; this is because URI.js
          // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
          // should not appear unencoded in a segment itself.
          // See also the note above about RFC3986 and capitalalized hex digits.
          encode: {
            expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
            map: {
              "%21": "!",
              "%24": "$",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%40": "@"
            }
          },
          // These characters are the characters called out by RFC2141 as "reserved" characters that
          // should never appear in a URN, plus the colon character (see note above).
          decode: {
            expression: /[\/\?#:]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23",
              ":": "%3A"
            }
          }
        }
      }, o.encodeQuery = function(_, w) {
        var S = o.encode(_ + "");
        return w === void 0 && (w = o.escapeQuerySpace), w ? S.replace(/%20/g, "+") : S;
      }, o.decodeQuery = function(_, w) {
        _ += "", w === void 0 && (w = o.escapeQuerySpace);
        try {
          return o.decode(w ? _.replace(/\+/g, "%20") : _);
        } catch {
          return _;
        }
      };
      var y = { encode: "encode", decode: "decode" }, E, b = function(_, w) {
        return function(S) {
          try {
            return o[w](S + "").replace(o.characters[_][w].expression, function(P) {
              return o.characters[_][w].map[P];
            });
          } catch {
            return S;
          }
        };
      };
      for (E in y)
        o[E + "PathSegment"] = b("pathname", y[E]), o[E + "UrnPathSegment"] = b("urnpath", y[E]);
      var T = function(_, w, S) {
        return function(P) {
          var A;
          S ? A = function(G) {
            return o[w](o[S](G));
          } : A = o[w];
          for (var D = (P + "").split(_), k = 0, U = D.length; k < U; k++)
            D[k] = A(D[k]);
          return D.join(_);
        };
      };
      o.decodePath = T("/", "decodePathSegment"), o.decodeUrnPath = T(":", "decodeUrnPathSegment"), o.recodePath = T("/", "encodePathSegment", "decode"), o.recodeUrnPath = T(":", "encodeUrnPathSegment", "decode"), o.encodeReserved = b("reserved", "encode"), o.parse = function(_, w) {
        var S;
        return w || (w = {
          preventInvalidHostname: o.preventInvalidHostname
        }), _ = _.replace(o.leading_whitespace_expression, ""), _ = _.replace(o.ascii_tab_whitespace, ""), S = _.indexOf("#"), S > -1 && (w.fragment = _.substring(S + 1) || null, _ = _.substring(0, S)), S = _.indexOf("?"), S > -1 && (w.query = _.substring(S + 1) || null, _ = _.substring(0, S)), _ = _.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://"), _ = _.replace(/^[/\\]{2,}/i, "//"), _.substring(0, 2) === "//" ? (w.protocol = null, _ = _.substring(2), _ = o.parseAuthority(_, w)) : (S = _.indexOf(":"), S > -1 && (w.protocol = _.substring(0, S) || null, w.protocol && !w.protocol.match(o.protocol_expression) ? w.protocol = void 0 : _.substring(S + 1, S + 3).replace(/\\/g, "/") === "//" ? (_ = _.substring(S + 3), _ = o.parseAuthority(_, w)) : (_ = _.substring(S + 1), w.urn = !0))), w.path = _, w;
      }, o.parseHost = function(_, w) {
        _ || (_ = ""), _ = _.replace(/\\/g, "/");
        var S = _.indexOf("/"), P, A;
        if (S === -1 && (S = _.length), _.charAt(0) === "[")
          P = _.indexOf("]"), w.hostname = _.substring(1, P) || null, w.port = _.substring(P + 2, S) || null, w.port === "/" && (w.port = null);
        else {
          var D = _.indexOf(":"), k = _.indexOf("/"), U = _.indexOf(":", D + 1);
          U !== -1 && (k === -1 || U < k) ? (w.hostname = _.substring(0, S) || null, w.port = null) : (A = _.substring(0, S).split(":"), w.hostname = A[0] || null, w.port = A[1] || null);
        }
        return w.hostname && _.substring(S).charAt(0) !== "/" && (S++, _ = "/" + _), w.preventInvalidHostname && o.ensureValidHostname(w.hostname, w.protocol), w.port && o.ensureValidPort(w.port), _.substring(S) || "/";
      }, o.parseAuthority = function(_, w) {
        return _ = o.parseUserinfo(_, w), o.parseHost(_, w);
      }, o.parseUserinfo = function(_, w) {
        var S = _, P = _.indexOf("\\");
        P !== -1 && (_ = _.replace(/\\/g, "/"));
        var A = _.indexOf("/"), D = _.lastIndexOf("@", A > -1 ? A : _.length - 1), k;
        return D > -1 && (A === -1 || D < A) ? (k = _.substring(0, D).split(":"), w.username = k[0] ? o.decode(k[0]) : null, k.shift(), w.password = k[0] ? o.decode(k.join(":")) : null, _ = S.substring(D + 1)) : (w.username = null, w.password = null), _;
      }, o.parseQuery = function(_, w) {
        if (!_)
          return {};
        if (_ = _.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, ""), !_)
          return {};
        for (var S = {}, P = _.split("&"), A = P.length, D, k, U, G = 0; G < A; G++)
          D = P[G].split("="), k = o.decodeQuery(D.shift(), w), U = D.length ? o.decodeQuery(D.join("="), w) : null, k !== "__proto__" && (h.call(S, k) ? ((typeof S[k] == "string" || S[k] === null) && (S[k] = [S[k]]), S[k].push(U)) : S[k] = U);
        return S;
      }, o.build = function(_) {
        var w = "", S = !1;
        return _.protocol && (w += _.protocol + ":"), !_.urn && (w || _.hostname) && (w += "//", S = !0), w += o.buildAuthority(_) || "", typeof _.path == "string" && (_.path.charAt(0) !== "/" && S && (w += "/"), w += _.path), typeof _.query == "string" && _.query && (w += "?" + _.query), typeof _.fragment == "string" && _.fragment && (w += "#" + _.fragment), w;
      }, o.buildHost = function(_) {
        var w = "";
        if (_.hostname)
          o.ip6_expression.test(_.hostname) ? w += "[" + _.hostname + "]" : w += _.hostname;
        else return "";
        return _.port && (w += ":" + _.port), w;
      }, o.buildAuthority = function(_) {
        return o.buildUserinfo(_) + o.buildHost(_);
      }, o.buildUserinfo = function(_) {
        var w = "";
        return _.username && (w += o.encode(_.username)), _.password && (w += ":" + o.encode(_.password)), w && (w += "@"), w;
      }, o.buildQuery = function(_, w, S) {
        var P = "", A, D, k, U;
        for (D in _)
          if (D !== "__proto__" && h.call(_, D))
            if (f(_[D]))
              for (A = {}, k = 0, U = _[D].length; k < U; k++)
                _[D][k] !== void 0 && A[_[D][k] + ""] === void 0 && (P += "&" + o.buildQueryParameter(D, _[D][k], S), w !== !0 && (A[_[D][k] + ""] = !0));
            else _[D] !== void 0 && (P += "&" + o.buildQueryParameter(D, _[D], S));
        return P.substring(1);
      }, o.buildQueryParameter = function(_, w, S) {
        return o.encodeQuery(_, S) + (w !== null ? "=" + o.encodeQuery(w, S) : "");
      }, o.addQuery = function(_, w, S) {
        if (typeof w == "object")
          for (var P in w)
            h.call(w, P) && o.addQuery(_, P, w[P]);
        else if (typeof w == "string") {
          if (_[w] === void 0) {
            _[w] = S;
            return;
          } else typeof _[w] == "string" && (_[w] = [_[w]]);
          f(S) || (S = [S]), _[w] = (_[w] || []).concat(S);
        } else
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
      }, o.setQuery = function(_, w, S) {
        if (typeof w == "object")
          for (var P in w)
            h.call(w, P) && o.setQuery(_, P, w[P]);
        else if (typeof w == "string")
          _[w] = S === void 0 ? null : S;
        else
          throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
      }, o.removeQuery = function(_, w, S) {
        var P, A, D;
        if (f(w))
          for (P = 0, A = w.length; P < A; P++)
            _[w[P]] = void 0;
        else if (c(w) === "RegExp")
          for (D in _)
            w.test(D) && (_[D] = void 0);
        else if (typeof w == "object")
          for (D in w)
            h.call(w, D) && o.removeQuery(_, D, w[D]);
        else if (typeof w == "string")
          S !== void 0 ? c(S) === "RegExp" ? !f(_[w]) && S.test(_[w]) ? _[w] = void 0 : _[w] = g(_[w], S) : _[w] === String(S) && (!f(S) || S.length === 1) ? _[w] = void 0 : f(_[w]) && (_[w] = g(_[w], S)) : _[w] = void 0;
        else
          throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
      }, o.hasQuery = function(_, w, S, P) {
        switch (c(w)) {
          case "String":
            break;
          case "RegExp":
            for (var A in _)
              if (h.call(_, A) && w.test(A) && (S === void 0 || o.hasQuery(_, A, S)))
                return !0;
            return !1;
          case "Object":
            for (var D in w)
              if (h.call(w, D) && !o.hasQuery(_, D, w[D]))
                return !1;
            return !0;
          default:
            throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
        }
        switch (c(S)) {
          case "Undefined":
            return w in _;
          // data[name] !== undefined;
          case "Boolean":
            var k = !!(f(_[w]) ? _[w].length : _[w]);
            return S === k;
          case "Function":
            return !!S(_[w], w, _);
          case "Array":
            if (!f(_[w]))
              return !1;
            var U = P ? d : m;
            return U(_[w], S);
          case "RegExp":
            return f(_[w]) ? P ? d(_[w], S) : !1 : !!(_[w] && _[w].match(S));
          case "Number":
            S = String(S);
          /* falls through */
          case "String":
            return f(_[w]) ? P ? d(_[w], S) : !1 : _[w] === S;
          default:
            throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
        }
      }, o.joinPaths = function() {
        for (var _ = [], w = [], S = 0, P = 0; P < arguments.length; P++) {
          var A = new o(arguments[P]);
          _.push(A);
          for (var D = A.segment(), k = 0; k < D.length; k++)
            typeof D[k] == "string" && w.push(D[k]), D[k] && S++;
        }
        if (!w.length || !S)
          return new o("");
        var U = new o("").segment(w);
        return (_[0].path() === "" || _[0].path().slice(0, 1) === "/") && U.path("/" + U.path()), U.normalize();
      }, o.commonPath = function(_, w) {
        var S = Math.min(_.length, w.length), P;
        for (P = 0; P < S; P++)
          if (_.charAt(P) !== w.charAt(P)) {
            P--;
            break;
          }
        return P < 1 ? _.charAt(0) === w.charAt(0) && _.charAt(0) === "/" ? "/" : "" : ((_.charAt(P) !== "/" || w.charAt(P) !== "/") && (P = _.substring(0, P).lastIndexOf("/")), _.substring(0, P + 1));
      }, o.withinString = function(_, w, S) {
        S || (S = {});
        var P = S.start || o.findUri.start, A = S.end || o.findUri.end, D = S.trim || o.findUri.trim, k = S.parens || o.findUri.parens, U = /[a-z0-9-]=["']?$/i;
        for (P.lastIndex = 0; ; ) {
          var G = P.exec(_);
          if (!G)
            break;
          var $ = G.index;
          if (S.ignoreHtml) {
            var H = _.slice(Math.max($ - 3, 0), $);
            if (H && U.test(H))
              continue;
          }
          for (var ne = $ + _.slice($).search(A), te = _.slice($, ne), re = -1; ; ) {
            var ae = k.exec(te);
            if (!ae)
              break;
            var Re = ae.index + ae[0].length;
            re = Math.max(re, Re);
          }
          if (re > -1 ? te = te.slice(0, re) + te.slice(re).replace(D, "") : te = te.replace(D, ""), !(te.length <= G[0].length) && !(S.ignore && S.ignore.test(te))) {
            ne = $ + te.length;
            var xe = w(te, $, ne, _);
            if (xe === void 0) {
              P.lastIndex = ne;
              continue;
            }
            xe = String(xe), _ = _.slice(0, $) + xe + _.slice(ne), P.lastIndex = $ + xe.length;
          }
        }
        return P.lastIndex = 0, _;
      }, o.ensureValidHostname = function(_, w) {
        var S = !!_, P = !!w, A = !1;
        if (P && (A = d(o.hostProtocols, w)), A && !S)
          throw new TypeError("Hostname cannot be empty, if protocol is " + w);
        if (_ && _.match(o.invalid_hostname_characters)) {
          if (!e)
            throw new TypeError('Hostname "' + _ + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
          if (e.toASCII(_).match(o.invalid_hostname_characters))
            throw new TypeError('Hostname "' + _ + '" contains characters other than [A-Z0-9.-:_]');
        }
      }, o.ensureValidPort = function(_) {
        if (_) {
          var w = Number(_);
          if (!(a(w) && w > 0 && w < 65536))
            throw new TypeError('Port "' + _ + '" is not a valid port');
        }
      }, o.noConflict = function(_) {
        if (_) {
          var w = {
            URI: this.noConflict()
          };
          return r.URITemplate && typeof r.URITemplate.noConflict == "function" && (w.URITemplate = r.URITemplate.noConflict()), r.IPv6 && typeof r.IPv6.noConflict == "function" && (w.IPv6 = r.IPv6.noConflict()), r.SecondLevelDomains && typeof r.SecondLevelDomains.noConflict == "function" && (w.SecondLevelDomains = r.SecondLevelDomains.noConflict()), w;
        } else r.URI === this && (r.URI = s);
        return this;
      }, l.build = function(_) {
        return _ === !0 ? this._deferred_build = !0 : (_ === void 0 || this._deferred_build) && (this._string = o.build(this._parts), this._deferred_build = !1), this;
      }, l.clone = function() {
        return new o(this);
      }, l.valueOf = l.toString = function() {
        return this.build(!1)._string;
      };
      function R(_) {
        return function(w, S) {
          return w === void 0 ? this._parts[_] || "" : (this._parts[_] = w || null, this.build(!S), this);
        };
      }
      function M(_, w) {
        return function(S, P) {
          return S === void 0 ? this._parts[_] || "" : (S !== null && (S = S + "", S.charAt(0) === w && (S = S.substring(1))), this._parts[_] = S, this.build(!P), this);
        };
      }
      l.protocol = R("protocol"), l.username = R("username"), l.password = R("password"), l.hostname = R("hostname"), l.port = R("port"), l.query = M("query", "?"), l.fragment = M("fragment", "#"), l.search = function(_, w) {
        var S = this.query(_, w);
        return typeof S == "string" && S.length ? "?" + S : S;
      }, l.hash = function(_, w) {
        var S = this.fragment(_, w);
        return typeof S == "string" && S.length ? "#" + S : S;
      }, l.pathname = function(_, w) {
        if (_ === void 0 || _ === !0) {
          var S = this._parts.path || (this._parts.hostname ? "/" : "");
          return _ ? (this._parts.urn ? o.decodeUrnPath : o.decodePath)(S) : S;
        } else
          return this._parts.urn ? this._parts.path = _ ? o.recodeUrnPath(_) : "" : this._parts.path = _ ? o.recodePath(_) : "/", this.build(!w), this;
      }, l.path = l.pathname, l.href = function(_, w) {
        var S;
        if (_ === void 0)
          return this.toString();
        this._string = "", this._parts = o._parts();
        var P = _ instanceof o, A = typeof _ == "object" && (_.hostname || _.path || _.pathname);
        if (_.nodeName) {
          var D = o.getDomAttribute(_);
          _ = _[D] || "", A = !1;
        }
        if (!P && A && _.pathname !== void 0 && (_ = _.toString()), typeof _ == "string" || _ instanceof String)
          this._parts = o.parse(String(_), this._parts);
        else if (P || A) {
          var k = P ? _._parts : _;
          for (S in k)
            S !== "query" && h.call(this._parts, S) && (this._parts[S] = k[S]);
          k.query && this.query(k.query, !1);
        } else
          throw new TypeError("invalid input");
        return this.build(!w), this;
      }, l.is = function(_) {
        var w = !1, S = !1, P = !1, A = !1, D = !1, k = !1, U = !1, G = !this._parts.urn;
        switch (this._parts.hostname && (G = !1, S = o.ip4_expression.test(this._parts.hostname), P = o.ip6_expression.test(this._parts.hostname), w = S || P, A = !w, D = A && n && n.has(this._parts.hostname), k = A && o.idn_expression.test(this._parts.hostname), U = A && o.punycode_expression.test(this._parts.hostname)), _.toLowerCase()) {
          case "relative":
            return G;
          case "absolute":
            return !G;
          // hostname identification
          case "domain":
          case "name":
            return A;
          case "sld":
            return D;
          case "ip":
            return w;
          case "ip4":
          case "ipv4":
          case "inet4":
            return S;
          case "ip6":
          case "ipv6":
          case "inet6":
            return P;
          case "idn":
            return k;
          case "url":
            return !this._parts.urn;
          case "urn":
            return !!this._parts.urn;
          case "punycode":
            return U;
        }
        return null;
      };
      var C = l.protocol, I = l.port, O = l.hostname;
      l.protocol = function(_, w) {
        if (_ && (_ = _.replace(/:(\/\/)?$/, ""), !_.match(o.protocol_expression)))
          throw new TypeError('Protocol "' + _ + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
        return C.call(this, _, w);
      }, l.scheme = l.protocol, l.port = function(_, w) {
        return this._parts.urn ? _ === void 0 ? "" : this : (_ !== void 0 && (_ === 0 && (_ = null), _ && (_ += "", _.charAt(0) === ":" && (_ = _.substring(1)), o.ensureValidPort(_))), I.call(this, _, w));
      }, l.hostname = function(_, w) {
        if (this._parts.urn)
          return _ === void 0 ? "" : this;
        if (_ !== void 0) {
          var S = { preventInvalidHostname: this._parts.preventInvalidHostname }, P = o.parseHost(_, S);
          if (P !== "/")
            throw new TypeError('Hostname "' + _ + '" contains characters other than [A-Z0-9.-]');
          _ = S.hostname, this._parts.preventInvalidHostname && o.ensureValidHostname(_, this._parts.protocol);
        }
        return O.call(this, _, w);
      }, l.origin = function(_, w) {
        if (this._parts.urn)
          return _ === void 0 ? "" : this;
        if (_ === void 0) {
          var S = this.protocol(), P = this.authority();
          return P ? (S ? S + "://" : "") + this.authority() : "";
        } else {
          var A = o(_);
          return this.protocol(A.protocol()).authority(A.authority()).build(!w), this;
        }
      }, l.host = function(_, w) {
        if (this._parts.urn)
          return _ === void 0 ? "" : this;
        if (_ === void 0)
          return this._parts.hostname ? o.buildHost(this._parts) : "";
        var S = o.parseHost(_, this._parts);
        if (S !== "/")
          throw new TypeError('Hostname "' + _ + '" contains characters other than [A-Z0-9.-]');
        return this.build(!w), this;
      }, l.authority = function(_, w) {
        if (this._parts.urn)
          return _ === void 0 ? "" : this;
        if (_ === void 0)
          return this._parts.hostname ? o.buildAuthority(this._parts) : "";
        var S = o.parseAuthority(_, this._parts);
        if (S !== "/")
          throw new TypeError('Hostname "' + _ + '" contains characters other than [A-Z0-9.-]');
        return this.build(!w), this;
      }, l.userinfo = function(_, w) {
        if (this._parts.urn)
          return _ === void 0 ? "" : this;
        if (_ === void 0) {
          var S = o.buildUserinfo(this._parts);
          return S && S.substring(0, S.length - 1);
        } else
          return _[_.length - 1] !== "@" && (_ += "@"), o.parseUserinfo(_, this._parts), this.build(!w), this;
      }, l.resource = function(_, w) {
        var S;
        return _ === void 0 ? this.path() + this.search() + this.hash() : (S = o.parse(_), this._parts.path = S.path, this._parts.query = S.query, this._parts.fragment = S.fragment, this.build(!w), this);
      }, l.subdomain = function(_, w) {
        if (this._parts.urn)
          return _ === void 0 ? "" : this;
        if (_ === void 0) {
          if (!this._parts.hostname || this.is("IP"))
            return "";
          var S = this._parts.hostname.length - this.domain().length - 1;
          return this._parts.hostname.substring(0, S) || "";
        } else {
          var P = this._parts.hostname.length - this.domain().length, A = this._parts.hostname.substring(0, P), D = new RegExp("^" + u(A));
          if (_ && _.charAt(_.length - 1) !== "." && (_ += "."), _.indexOf(":") !== -1)
            throw new TypeError("Domains cannot contain colons");
          return _ && o.ensureValidHostname(_, this._parts.protocol), this._parts.hostname = this._parts.hostname.replace(D, _), this.build(!w), this;
        }
      }, l.domain = function(_, w) {
        if (this._parts.urn)
          return _ === void 0 ? "" : this;
        if (typeof _ == "boolean" && (w = _, _ = void 0), _ === void 0) {
          if (!this._parts.hostname || this.is("IP"))
            return "";
          var S = this._parts.hostname.match(/\./g);
          if (S && S.length < 2)
            return this._parts.hostname;
          var P = this._parts.hostname.length - this.tld(w).length - 1;
          return P = this._parts.hostname.lastIndexOf(".", P - 1) + 1, this._parts.hostname.substring(P) || "";
        } else {
          if (!_)
            throw new TypeError("cannot set domain empty");
          if (_.indexOf(":") !== -1)
            throw new TypeError("Domains cannot contain colons");
          if (o.ensureValidHostname(_, this._parts.protocol), !this._parts.hostname || this.is("IP"))
            this._parts.hostname = _;
          else {
            var A = new RegExp(u(this.domain()) + "$");
            this._parts.hostname = this._parts.hostname.replace(A, _);
          }
          return this.build(!w), this;
        }
      }, l.tld = function(_, w) {
        if (this._parts.urn)
          return _ === void 0 ? "" : this;
        if (typeof _ == "boolean" && (w = _, _ = void 0), _ === void 0) {
          if (!this._parts.hostname || this.is("IP"))
            return "";
          var S = this._parts.hostname.lastIndexOf("."), P = this._parts.hostname.substring(S + 1);
          return w !== !0 && n && n.list[P.toLowerCase()] && n.get(this._parts.hostname) || P;
        } else {
          var A;
          if (_)
            if (_.match(/[^a-zA-Z0-9-]/))
              if (n && n.is(_))
                A = new RegExp(u(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(A, _);
              else
                throw new TypeError('TLD "' + _ + '" contains characters other than [A-Z0-9]');
            else {
              if (!this._parts.hostname || this.is("IP"))
                throw new ReferenceError("cannot set TLD on non-domain host");
              A = new RegExp(u(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(A, _);
            }
          else throw new TypeError("cannot set TLD empty");
          return this.build(!w), this;
        }
      }, l.directory = function(_, w) {
        if (this._parts.urn)
          return _ === void 0 ? "" : this;
        if (_ === void 0 || _ === !0) {
          if (!this._parts.path && !this._parts.hostname)
            return "";
          if (this._parts.path === "/")
            return "/";
          var S = this._parts.path.length - this.filename().length - 1, P = this._parts.path.substring(0, S) || (this._parts.hostname ? "/" : "");
          return _ ? o.decodePath(P) : P;
        } else {
          var A = this._parts.path.length - this.filename().length, D = this._parts.path.substring(0, A), k = new RegExp("^" + u(D));
          return this.is("relative") || (_ || (_ = "/"), _.charAt(0) !== "/" && (_ = "/" + _)), _ && _.charAt(_.length - 1) !== "/" && (_ += "/"), _ = o.recodePath(_), this._parts.path = this._parts.path.replace(k, _), this.build(!w), this;
        }
      }, l.filename = function(_, w) {
        if (this._parts.urn)
          return _ === void 0 ? "" : this;
        if (typeof _ != "string") {
          if (!this._parts.path || this._parts.path === "/")
            return "";
          var S = this._parts.path.lastIndexOf("/"), P = this._parts.path.substring(S + 1);
          return _ ? o.decodePathSegment(P) : P;
        } else {
          var A = !1;
          _.charAt(0) === "/" && (_ = _.substring(1)), _.match(/\.?\//) && (A = !0);
          var D = new RegExp(u(this.filename()) + "$");
          return _ = o.recodePath(_), this._parts.path = this._parts.path.replace(D, _), A ? this.normalizePath(w) : this.build(!w), this;
        }
      }, l.suffix = function(_, w) {
        if (this._parts.urn)
          return _ === void 0 ? "" : this;
        if (_ === void 0 || _ === !0) {
          if (!this._parts.path || this._parts.path === "/")
            return "";
          var S = this.filename(), P = S.lastIndexOf("."), A, D;
          return P === -1 ? "" : (A = S.substring(P + 1), D = /^[a-z0-9%]+$/i.test(A) ? A : "", _ ? o.decodePathSegment(D) : D);
        } else {
          _.charAt(0) === "." && (_ = _.substring(1));
          var k = this.suffix(), U;
          if (k)
            _ ? U = new RegExp(u(k) + "$") : U = new RegExp(u("." + k) + "$");
          else {
            if (!_)
              return this;
            this._parts.path += "." + o.recodePath(_);
          }
          return U && (_ = o.recodePath(_), this._parts.path = this._parts.path.replace(U, _)), this.build(!w), this;
        }
      }, l.segment = function(_, w, S) {
        var P = this._parts.urn ? ":" : "/", A = this.path(), D = A.substring(0, 1) === "/", k = A.split(P);
        if (_ !== void 0 && typeof _ != "number" && (S = w, w = _, _ = void 0), _ !== void 0 && typeof _ != "number")
          throw new Error('Bad segment "' + _ + '", must be 0-based integer');
        if (D && k.shift(), _ < 0 && (_ = Math.max(k.length + _, 0)), w === void 0)
          return _ === void 0 ? k : k[_];
        if (_ === null || k[_] === void 0)
          if (f(w)) {
            k = [];
            for (var U = 0, G = w.length; U < G; U++)
              !w[U].length && (!k.length || !k[k.length - 1].length) || (k.length && !k[k.length - 1].length && k.pop(), k.push(x(w[U])));
          } else (w || typeof w == "string") && (w = x(w), k[k.length - 1] === "" ? k[k.length - 1] = w : k.push(w));
        else
          w ? k[_] = x(w) : k.splice(_, 1);
        return D && k.unshift(""), this.path(k.join(P), S);
      }, l.segmentCoded = function(_, w, S) {
        var P, A, D;
        if (typeof _ != "number" && (S = w, w = _, _ = void 0), w === void 0) {
          if (P = this.segment(_, w, S), !f(P))
            P = P !== void 0 ? o.decode(P) : void 0;
          else
            for (A = 0, D = P.length; A < D; A++)
              P[A] = o.decode(P[A]);
          return P;
        }
        if (!f(w))
          w = typeof w == "string" || w instanceof String ? o.encode(w) : w;
        else
          for (A = 0, D = w.length; A < D; A++)
            w[A] = o.encode(w[A]);
        return this.segment(_, w, S);
      };
      var z = l.query;
      return l.query = function(_, w) {
        if (_ === !0)
          return o.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if (typeof _ == "function") {
          var S = o.parseQuery(this._parts.query, this._parts.escapeQuerySpace), P = _.call(this, S);
          return this._parts.query = o.buildQuery(P || S, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), this.build(!w), this;
        } else return _ !== void 0 && typeof _ != "string" ? (this._parts.query = o.buildQuery(_, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), this.build(!w), this) : z.call(this, _, w);
      }, l.setQuery = function(_, w, S) {
        var P = o.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if (typeof _ == "string" || _ instanceof String)
          P[_] = w !== void 0 ? w : null;
        else if (typeof _ == "object")
          for (var A in _)
            h.call(_, A) && (P[A] = _[A]);
        else
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        return this._parts.query = o.buildQuery(P, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof _ != "string" && (S = w), this.build(!S), this;
      }, l.addQuery = function(_, w, S) {
        var P = o.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return o.addQuery(P, _, w === void 0 ? null : w), this._parts.query = o.buildQuery(P, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof _ != "string" && (S = w), this.build(!S), this;
      }, l.removeQuery = function(_, w, S) {
        var P = o.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return o.removeQuery(P, _, w), this._parts.query = o.buildQuery(P, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof _ != "string" && (S = w), this.build(!S), this;
      }, l.hasQuery = function(_, w, S) {
        var P = o.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return o.hasQuery(P, _, w, S);
      }, l.setSearch = l.setQuery, l.addSearch = l.addQuery, l.removeSearch = l.removeQuery, l.hasSearch = l.hasQuery, l.normalize = function() {
        return this._parts.urn ? this.normalizeProtocol(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build() : this.normalizeProtocol(!1).normalizeHostname(!1).normalizePort(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build();
      }, l.normalizeProtocol = function(_) {
        return typeof this._parts.protocol == "string" && (this._parts.protocol = this._parts.protocol.toLowerCase(), this.build(!_)), this;
      }, l.normalizeHostname = function(_) {
        return this._parts.hostname && (this.is("IDN") && e ? this._parts.hostname = e.toASCII(this._parts.hostname) : this.is("IPv6") && t && (this._parts.hostname = t.best(this._parts.hostname)), this._parts.hostname = this._parts.hostname.toLowerCase(), this.build(!_)), this;
      }, l.normalizePort = function(_) {
        return typeof this._parts.protocol == "string" && this._parts.port === o.defaultPorts[this._parts.protocol] && (this._parts.port = null, this.build(!_)), this;
      }, l.normalizePath = function(_) {
        var w = this._parts.path;
        if (!w)
          return this;
        if (this._parts.urn)
          return this._parts.path = o.recodeUrnPath(this._parts.path), this.build(!_), this;
        if (this._parts.path === "/")
          return this;
        w = o.recodePath(w);
        var S, P = "", A, D;
        for (w.charAt(0) !== "/" && (S = !0, w = "/" + w), (w.slice(-3) === "/.." || w.slice(-2) === "/.") && (w += "/"), w = w.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/"), S && (P = w.substring(1).match(/^(\.\.\/)+/) || "", P && (P = P[0])); A = w.search(/\/\.\.(\/|$)/), A !== -1; ) {
          if (A === 0) {
            w = w.substring(3);
            continue;
          }
          D = w.substring(0, A).lastIndexOf("/"), D === -1 && (D = A), w = w.substring(0, D) + w.substring(A + 3);
        }
        return S && this.is("relative") && (w = P + w.substring(1)), this._parts.path = w, this.build(!_), this;
      }, l.normalizePathname = l.normalizePath, l.normalizeQuery = function(_) {
        return typeof this._parts.query == "string" && (this._parts.query.length ? this.query(o.parseQuery(this._parts.query, this._parts.escapeQuerySpace)) : this._parts.query = null, this.build(!_)), this;
      }, l.normalizeFragment = function(_) {
        return this._parts.fragment || (this._parts.fragment = null, this.build(!_)), this;
      }, l.normalizeSearch = l.normalizeQuery, l.normalizeHash = l.normalizeFragment, l.iso8859 = function() {
        var _ = o.encode, w = o.decode;
        o.encode = escape, o.decode = decodeURIComponent;
        try {
          this.normalize();
        } finally {
          o.encode = _, o.decode = w;
        }
        return this;
      }, l.unicode = function() {
        var _ = o.encode, w = o.decode;
        o.encode = p, o.decode = unescape;
        try {
          this.normalize();
        } finally {
          o.encode = _, o.decode = w;
        }
        return this;
      }, l.readable = function() {
        var _ = this.clone();
        _.username("").password("").normalize();
        var w = "";
        if (_._parts.protocol && (w += _._parts.protocol + "://"), _._parts.hostname && (_.is("punycode") && e ? (w += e.toUnicode(_._parts.hostname), _._parts.port && (w += ":" + _._parts.port)) : w += _.host()), _._parts.hostname && _._parts.path && _._parts.path.charAt(0) !== "/" && (w += "/"), w += _.path(!0), _._parts.query) {
          for (var S = "", P = 0, A = _._parts.query.split("&"), D = A.length; P < D; P++) {
            var k = (A[P] || "").split("=");
            S += "&" + o.decodeQuery(k[0], this._parts.escapeQuerySpace).replace(/&/g, "%26"), k[1] !== void 0 && (S += "=" + o.decodeQuery(k[1], this._parts.escapeQuerySpace).replace(/&/g, "%26"));
          }
          w += "?" + S.substring(1);
        }
        return w += o.decodeQuery(_.hash(), !0), w;
      }, l.absoluteTo = function(_) {
        var w = this.clone(), S = ["protocol", "username", "password", "hostname", "port"], P, A, D;
        if (this._parts.urn)
          throw new Error("URNs do not have any generally defined hierarchical components");
        if (_ instanceof o || (_ = new o(_)), w._parts.protocol || (w._parts.protocol = _._parts.protocol, this._parts.hostname))
          return w;
        for (A = 0; D = S[A]; A++)
          w._parts[D] = _._parts[D];
        return w._parts.path ? (w._parts.path.substring(-2) === ".." && (w._parts.path += "/"), w.path().charAt(0) !== "/" && (P = _.directory(), P = P || (_.path().indexOf("/") === 0 ? "/" : ""), w._parts.path = (P ? P + "/" : "") + w._parts.path, w.normalizePath())) : (w._parts.path = _._parts.path, w._parts.query || (w._parts.query = _._parts.query)), w.build(), w;
      }, l.relativeTo = function(_) {
        var w = this.clone().normalize(), S, P, A, D, k;
        if (w._parts.urn)
          throw new Error("URNs do not have any generally defined hierarchical components");
        if (_ = new o(_).normalize(), S = w._parts, P = _._parts, D = w.path(), k = _.path(), D.charAt(0) !== "/")
          throw new Error("URI is already relative");
        if (k.charAt(0) !== "/")
          throw new Error("Cannot calculate a URI relative to another relative URI");
        if (S.protocol === P.protocol && (S.protocol = null), S.username !== P.username || S.password !== P.password || S.protocol !== null || S.username !== null || S.password !== null)
          return w.build();
        if (S.hostname === P.hostname && S.port === P.port)
          S.hostname = null, S.port = null;
        else
          return w.build();
        if (D === k)
          return S.path = "", w.build();
        if (A = o.commonPath(D, k), !A)
          return w.build();
        var U = P.path.substring(A.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
        return S.path = U + S.path.substring(A.length) || "./", w.build();
      }, l.equals = function(_) {
        var w = this.clone(), S = new o(_), P = {}, A = {}, D = {}, k, U, G;
        if (w.normalize(), S.normalize(), w.toString() === S.toString())
          return !0;
        if (k = w.query(), U = S.query(), w.query(""), S.query(""), w.toString() !== S.toString() || k.length !== U.length)
          return !1;
        P = o.parseQuery(k, this._parts.escapeQuerySpace), A = o.parseQuery(U, this._parts.escapeQuerySpace);
        for (G in P)
          if (h.call(P, G)) {
            if (f(P[G])) {
              if (!m(P[G], A[G]))
                return !1;
            } else if (P[G] !== A[G])
              return !1;
            D[G] = !0;
          }
        for (G in A)
          if (h.call(A, G) && !D[G])
            return !1;
        return !0;
      }, l.preventInvalidHostname = function(_) {
        return this._parts.preventInvalidHostname = !!_, this;
      }, l.duplicateQueryParameters = function(_) {
        return this._parts.duplicateQueryParameters = !!_, this;
      }, l.escapeQuerySpace = function(_) {
        return this._parts.escapeQuerySpace = !!_, this;
      }, o;
    });
  })(qu)), qu.exports;
}
var wD = vD();
const ah = /* @__PURE__ */ jf(wD), U1 = [
  "http",
  "https"
];
function bD(i, e, t = !0) {
  return SD(i, e, !1, t);
}
function SD(i, e = null, t = !1, n = !0) {
  let r = ah(i);
  if (e && r.is("relative")) {
    let s = ah(e), o = s.path();
    !o.endsWith("/") && !o.endsWith(".json") && s.path(o + "/"), r = r.absoluteTo(s);
  }
  return r.normalize(), t && (r.query(""), r.fragment("")), n ? r.toString() : r;
}
const cp = "application/geo+json", TD = [
  "application/json",
  cp,
  "text/json"
], z1 = [
  "image/gif",
  "image/jpeg",
  "image/apng",
  "image/png",
  "image/webp"
], Gb = [
  "image/tiff; application=geotiff; profile=cloud-optimized",
  "image/vnd.stac.geotiff; cloud-optimized=true"
], kb = [
  "application/geotiff",
  "image/tiff; application=geotiff",
  "image/vnd.stac.geotiff"
].concat(Gb);
function O0(i, e, t = !1) {
  return Array.isArray(e) || (e = [e]), t && typeof i > "u" ? !0 : typeof i != "string" ? !1 : (e = e.map((n) => n.toLowerCase()), e.includes(i.toLowerCase()));
}
function RD(i, e = !1) {
  return O0(i, TD, e);
}
class Ub extends jh {
  constructor(e, t = null, n = {}, r = []) {
    super(e, n, ["_context"].concat(r)), this._context || (this._context = t);
  }
  /**
   * Gets the URL of the reference as absolute URL.
   * 
   * @param {boolean} stringify If `true` (default), a string is returned, otherwise a URI object.
   * @returns {URI|string|null}
   */
  getAbsoluteUrl(e = !0) {
    return this._context ? bD(this.href, this._context.getAbsoluteUrl(), e) : this.href.includes("://") ? e ? this.href : ah(this.href) : null;
  }
  /**
   * Returns the STAC entity that contains the reference.
   * 
   * @returns {STAC|null}
   */
  getContext() {
    return this._context;
  }
  /**
   * Checks whether a given reference can be displayed by a browser.
   * 
   * A browser can usually display an image if it is a specific file format (e.g. JPEG, PNG, ...) and is served over HTTP(S).
   * 
   * @returns {boolean} `true` if a browser can display the given reference, `false` otherwise.
   * @see {canBrowserDisplayImage}
   */
  canBrowserDisplayImage(e = !1) {
    if (typeof this.href != "string")
      return !1;
    if (!e && typeof this.type > "u")
      return !1;
    let t = this.getAbsoluteUrl(!1);
    t || (t = ah(this.href));
    const n = t.protocol().toLowerCase(), r = t.suffix().toLowerCase();
    return Ti(n) && !U1.includes(n) ? !1 : Ti(this.type) && z1.includes(this.type.toLowerCase()) ? !0 : !!(typeof this.type > "u" && Ti(r) && (r === "jpg" || z1.includes("image/" + r)));
  }
  /**
   * Checks whether this entity is of a specific type.
   * 
   * @param {string|Array.<string>} types One or more media types.
   * @returns {boolean} `true` is this entity is one of the given types, `false` otherwise.
   */
  isType(e) {
    return Ti(this.type) && O0(this.type, e);
  }
  /**
   * Checks whether this entity is a GeoTiff (including COGs).
   * 
   * @returns {boolean} `true` is this entity is a GeoTiff, `false` otherwise.
   */
  isGeoTIFF() {
    return this.isType(kb);
  }
  /**
   * Checks whether this entity is a COG (excluding pure GeoTiffs).
   * 
   * @returns {boolean} `true` is this entity is a COG, `false` otherwise.
   */
  isCOG() {
    return this.isType(Gb);
  }
  /**
   * Checks whether the entity is accessible via HTTP or HTTPS.
   * 
   * Returns `null` if no URI is available, otherwise a `boolean` value.
   * 
   * @returns {boolean|null} `true` is this entity is available via HTTP or HTTPS, `false` or `null` otherwise.
   */
  isHTTP() {
    let e = this.getAbsoluteUrl(!1);
    if (!e)
      return null;
    const t = e.protocol().toLowerCase();
    return Ti(t) && U1.includes(t);
  }
  /**
   * Returns whether the entity is a preview image.
   * 
   * @returns {boolean} `true` if the entity is a preview, `false` otherwise.
   */
  isPreview() {
    return !1;
  }
}
class N0 extends Ub {
  constructor(e, t = null) {
    super(e, t);
  }
  /**
   * Check whether this given object is a STAC LInk.
   * 
   * @returns {boolean} `true` if the object is a STAC Link, `false` otherwise.
   */
  isLink() {
    return !0;
  }
  /**
   * Returns the type of the STAC object, here: 'Link'.
   * 
   * @returns {string}
   */
  getObjectType() {
    return "Link";
  }
  /**
   * Returns whether the link is a preview image.
   * 
   * @returns {boolean} `true` if the link is a preview, `false` otherwise.
   */
  isPreview() {
    return this.rel === "preview";
  }
  /**
   * Converts an array of STAC Links into an array of stac-js Links.
   * 
   * @param {Array.<Object>} links Links
   * @param {STAC|null} context The object that contains the links
   * @returns {Array.<Link>} Improved Links
   */
  static fromLinks(e, t = null) {
    return Array.isArray(e) ? e.map((n) => vi(n) ? new N0(n, t) : n) : [];
  }
}
class zb extends jh {
  constructor(e, t = null, n = {}, r = []) {
    if (super(
      e,
      Object.assign({ links: N0.fromLinks }, n),
      ["_url"].concat(r)
    ), !this._url && (this._url = t, !this._url)) {
      let s = this.getSelfLink();
      s && (this._url = s.href);
    }
  }
  /**
   * Gets the absolute URL of the STAC entity (if provided explicitly or available from the self link).
   * 
   * @param {boolean} stringify If `true` (default), a string is returned, otherwise a URI object.
   * @returns {string|null} Absolute URL
   */
  getAbsoluteUrl(e = !0) {
    return e ? this._url : ah(this._url);
  }
  /**
   * Sets the absolute URL of the STAC entity.
   * 
   * @param {string} url Absolute URL
   */
  setAbsoluteUrl(e) {
    this._url = e;
  }
  /**
   * 
   * @todo
   * @param {string} rel 
   * @param {boolean} allowUndefined 
   * @returns {Array.<Link>}
   */
  getStacLinksWithRel(e, t = !0) {
    return this.getLinksWithRels([e]).filter((n) => RD(n.type, t));
  }
  /**
   * 
   * @todo
   * @param {string} rel 
   * @param {boolean} allowUndefined 
   * @returns {Link} 
   */
  getStacLinkWithRel(e, t = !0) {
    const n = this.getStacLinksWithRel(e, t);
    return n.length > 0 ? n[0] : null;
  }
  /**
   * 
   * @todo
   * @returns {Array.<Link>}
   */
  getLinks() {
    return Array.isArray(this.links) ? this.links.filter((e) => vi(e) && Ti(e.href)) : [];
  }
  /**
   * 
   * @todo
   * @param {string} rel 
   * @returns {Link} 
   */
  getLinkWithRel(e) {
    return this.getLinks().find((t) => t.rel === e) || null;
  }
  /**
   * 
   * @todo
   * @param {Array.<string>} rels 
   * @returns {Array.<Link>} 
   */
  getLinksWithRels(e) {
    return this.getLinks().filter((t) => e.includes(t.rel));
  }
  /**
   * 
   * @todo
   * @param {Array.<string>} rels 
   * @returns {Array.<Link>} 
   */
  getLinksWithOtherRels(e) {
    return this.getLinks().filter((t) => !e.includes(t.rel));
  }
  /**
   * Returns the self link, if present.
   * 
   * @returns {Link|null} The self link
   */
  getSelfLink() {
    return this.getStacLinkWithRel("self");
  }
  /**
   * Returns the root link, if present.
   * 
   * @returns {Link|null} The root link
   */
  getRootLink() {
    return this.getStacLinkWithRel("root");
  }
  /**
   * Returns the parent link, if present.
   * 
   * @returns {Link|null} The parent link
   */
  getParentLink() {
    return this.getStacLinkWithRel("parent");
  }
}
class D0 extends zb {
  constructor(e, t = null, n = {}, r = []) {
    super(e, t, n, r);
  }
  /**
   * Returns all STAC entities in this list.
   * 
   * @returns {Array.<STAC>} All STAC entities
   */
  getAll() {
    return [];
  }
}
class Ia extends jh {
  constructor(e, t = null, n = null) {
    super(e, {}, ["_index", "_context"]), typeof this._index != "number" && (this._index = typeof t == "string" ? parseInt(t, 10) : t), this._context || (this._context = n);
  }
  /**
   * Returns the STAC entity that contains the band.
   * 
   * @returns {Collection|Item|Asset|null}
   */
  getContext() {
    return this._context;
  }
  /**
   * Returns the type of the STAC object, here: 'Band'.
   * 
   * @returns {string}
   */
  getObjectType() {
    return "Band";
  }
  /**
   * Check whether this given object is a STAC Band.
   * 
   * @returns {boolean} `true` if the object is a STAC Band, `false` otherwise.
   */
  isBand() {
    return !0;
  }
  /**
   * Returns the index of the band.
   * 
   * @returns {number|null} Index of the band
   */
  getIndex() {
    return this._index;
  }
  /**
   * Returns the metadata for the given field name.
   * 
   * Returns the metadata from the asset, if present.
   * Otherwise, returns the metadata from calling `getMetadata()` on the STAC entity that contains the asset.
   * 
   * @param {string} field Field name
   * @returns {*} The value of the field
   */
  getMetadata(e) {
    if (typeof this[e] < "u")
      return this[e];
    if (this._context)
      return this._context.getMetadata(e);
  }
  /**
   * Gets the reported minimum and maximum values for a band.
   * 
   * Searches through different extension fields in raster, classification, and file.
   * 
   * @returns {Statistics}
   */
  getMinMaxValues() {
    return Lb(this);
  }
  /**
   * Gets the reported no-data values for a band.
   * 
   * Searches through different extension fields in raster, classification, and file.
   * 
   * @returns {Array.<*>}
   */
  getNoDataValues() {
    return Fb(this);
  }
  /**
   * Converts an object of STAC Bands into an array of stac-js Bands.
   * 
   * @param {Array.<Object>} bands Bands
   * @param {Collection|Item|Asset|null} context The object that contains the bands
   * @returns {Array.<Band>} Improved Bands
   */
  static fromBands(e, t = null) {
    let n = [];
    if (Array.isArray(e))
      for (let r in e) {
        const s = e[r], o = s instanceof Ia ? s : new Ia(s, r, t);
        n.push(o);
      }
    return n;
  }
}
const PD = [
  "created",
  "updated",
  "published",
  "expires",
  "unpublished",
  "bands"
];
class Sn extends Ub {
  constructor(e, t = null, n = null) {
    const r = {
      bands: Ia.fromBands,
      alternate: Sn.fromAssets
    };
    super(e, n, r, ["_key"]), this._key || (this._key = t);
  }
  /**
   * Returns the type of the STAC object, here: 'Asset'.
   * 
   * @returns {string}
   */
  getObjectType() {
    return "Asset";
  }
  /**
   * Check whether this given object is a STAC Asset.
   * 
   * @returns {boolean} `true` if the object is a STAC Asset, `false` otherwise.
   */
  isAsset() {
    return !0;
  }
  /**
   * Gets the URL of the asset as absolute URL.
   * 
   * @param {boolean} stringify If `true` (default), a string is returned, otherwise a URI object.
   * @returns {URI|string|null}
   */
  getAbsoluteUrl(e = !0) {
    return this.isDefinition() ? null : super.getAbsoluteUrl(e);
  }
  /**
   * Returns the key of the asset.
   * 
   * @returns {string|null} Key of the asset
   */
  getKey() {
    return this._key;
  }
  /**
   * Returns the metadata for the given field name.
   * 
   * Returns the metadata from the asset, if present.
   * Otherwise, returns the metadata from calling `getMetadata()` on the STAC entity that contains the asset.
   * 
   * @param {string} field Field name
   * @returns {*} The value of the field
   */
  getMetadata(e) {
    if (typeof this[e] < "u")
      return this[e];
    if (this._context instanceof Sn)
      return this._context.getMetadata(e);
    if (this._context && !PD.includes(e))
      return this._context.getMetadata(e);
  }
  /**
   * Returns the bands for the asset.
   * 
   * @returns {Array.<Band>}
   */
  getBands() {
    return this.bands || [];
  }
  /**
   * The RGB bands.
   * 
   * @typedef {Object} VisualBands
   * @property {Band} red The red band with its index
   * @property {Band} green The green band with its index
   * @property {Band} blue The blue band with its index
   */
  /**
   * Find the RGB bands.
   * 
   * @returns {VisualBands|null} Object with the RGB bands or null
   */
  findVisualBands() {
    const e = {
      red: null,
      green: null,
      blue: null
    }, t = this.getBands();
    for (const r in t) {
      const s = parseInt(r, 10), o = t[s];
      vi(o) && Ti(o["eo:common_name"]) && o["eo:common_name"] in e && (e[o["eo:common_name"]] = o);
    }
    return Object.values(e).every((r) => r !== null) ? e : null;
  }
  /**
   * Returns the band for the given criteria.
   * 
   * Searches the given `property` (default: `name`) for the given value(s).
   * 
   * @param {*} value A single value to find or a list of values to find one of.
   * @param {string} property The property in the bands to match against.
   * @returns {Band|null}
   * @see {getBands}
   */
  findBand(e, t = "name") {
    Array.isArray(e) || (e = [e]);
    const n = this.getBands(), r = n.findIndex((s) => vi(s) && e.includes(s[t]));
    return r >= 0 ? n[r] : null;
  }
  /**
   * Returns the band for the given band index.
   * 
   * Passes through the (band) objects.
   * 
   * @param {number|Object} band
   * @returns {Object|null}
   * @see {getBands}
   */
  getBand(e) {
    return vi(e) || e === null ? e : this.getBands()[e] || null;
  }
  /**
   * Gets the reported minimum and maximum values for an asset.
   * 
   * Searches through different extension fields in raster, classification, and file.
   * 
   * @returns {Statistics}
   */
  getMinMaxValues() {
    return Lb(this);
  }
  /**
   * Gets the reported no-data values for an asset.
   * 
   * Searches through different extension fields in nodata, classification, and file.
   * 
   * @returns {Array.<*>}
   */
  getNoDataValues() {
    return Fb(this);
  }
  /**
   * Returns whether this asset is an Item Asset definition (i.e., doesn't have an href) or not.
   * 
   * @returns {boolean} `true` if this asset is an Item Asset definition, `false` otherwise.
   */
  isDefinition() {
    return !Ti(this.href);
  }
  /**
   * Checks whether the asset is accessible via HTTP or HTTPS.
   * 
   * Returns `null` for item asset definitions, otherwise a `boolean` value.
   * 
   * @returns {boolean|null} `true` if this asset is available via HTTP or HTTPS, `false` or `null` otherwise.
   */
  isHTTP() {
    return this.isDefinition() ? null : super.isHTTP();
  }
  /**
   * Returns whether the asset is a preview image (thumbnail / overview).
   * 
   * An asset is a preview if one of the roles is 'thumbnail' or 'overview'.
   * it is also a preview if the key is 'thumbnail' or 'overview'.
   * 
   * @returns {boolean} `true` if the asset is a preview, `false` otherwise.
   */
  isPreview() {
    const e = ["thumbnail", "overview"];
    return e.includes(this.getKey()) ? !0 : Array.isArray(this.roles) && this.roles.some((t) => e.includes(t));
  }
  /**
   * Checks whether this asset has a specific role assigned.
   * 
   * @param {string|Array.<string>} roles One or more roles.
   * @param {boolean} includeKey Also returns `true` if the asset key equals to one of the given roles.
   * @returns {boolean} `true` if this asset is one of the given roles (or key), `false` otherwise.
   */
  hasRole(e, t = !1) {
    return Array.isArray(e) || (e = [e]), t && e.includes(this.getKey()) ? !0 : Array.isArray(this.roles) && !!this.roles.find((n) => e.includes(n));
  }
  /**
   * Converts an object of STAC Assets into an object of stac-js Assets.
   * 
   * @param {Object.<string, Object>} assets Assets
   * @param {Collection|Item|null} context The object that contains the assets
   * @returns {Object.<string, Asset>} Improved Assets
   */
  static fromAssets(e, t = null) {
    let n = {};
    if (vi(e))
      for (let r in e) {
        const s = e[r], o = s instanceof Sn ? s : new Sn(s, r, t);
        n[r] = o;
      }
    return n;
  }
}
function Bb(i) {
  if (!i)
    return;
  const e = String(i), t = e.indexOf("@"), n = t !== -1 ? e.substr(t + 1) : void 0, r = t !== -1 ? e.substr(0, t) : e, s = String(r).replace(/-/g, "_").split("_");
  if (!s.length || s.length > 4)
    return;
  const o = s.shift();
  if (!o)
    return;
  const a = {
    keyword: n,
    language: o.toLowerCase()
  };
  if (!s.length)
    return a;
  if (s.length === 3) {
    const u = s.pop();
    u && (a.variant = u.toUpperCase());
  }
  let l = s.pop();
  if (l.length > 3 && (a.keyword = l, l = s.pop()), l && (a.country = l.toUpperCase()), !s.length)
    return a;
  const h = s.pop();
  return typeof h == "string" && h.length >= 1 && (a.script = h[0].toUpperCase() + h.substring(1).toLowerCase()), a;
}
function MD(i) {
  const e = {};
  return i.forEach((t) => {
    const { language: n, country: r } = Bb(t);
    if (!n)
      throw new Error(`Locale ${t} is not parsable`);
    e[n] || (e[n] = {
      countries: {},
      firstCountry: void 0,
      main: void 0
    });
    const s = e[n];
    r ? (s.countries[r] = t, s.firstCountry || (s.firstCountry = t)) : s.main = t;
  }), e;
}
function fp(i, e, t, n) {
  const r = Array.isArray(i) ? MD(i) : i;
  if (!e && t)
    return fp(i, t, void 0);
  if (!e)
    return;
  const { language: s, country: o } = Bb(e);
  if (!s)
    return t;
  if (!r[s])
    return e === t ? void 0 : fp(i, t, null);
  const { countries: a, main: l = t, firstCountry: h } = r[s];
  return !a || !o ? l : a[o] ? a[o] : l;
}
class Ar extends zb {
  constructor(e, t = null, n = {}, r = []) {
    super(e, t, n, r);
  }
  /**
   * Returns a single temporal extent for the STAC entity.
   * 
   * @returns {Array.<Date|null>|null}
   */
  getTemporalExtent() {
    return null;
  }
  /**
   * Returns the temporal extent(s) for the STAC entity.
   * 
   * @returns {Array.<Array.<Date|null>>}
   */
  getTemporalExtents() {
    return [];
  }
  /**
   * Get the "best" link for a specific locale (with fallback).
   * 
   * @param {string} locale 
   * @param {?string} fallbackLocale 
   * @returns {Link|null} The link with the given locale or null if not found.
   * @see {@link getBest}
   */
  getLocaleLink(e, t = null) {
    let n = this.getStacLinksWithRel("alternate").filter((o) => Ti(o.hreflang)), r;
    Array.isArray(this.languages) ? r = this.languages.map((o) => o.code) : r = n.map((o) => o.hreflang);
    let s = fp(r, e, t);
    return n.find((o) => o.hreflang === s) || null;
  }
  /**
   * Get the icons from the links in a STAC entity.
   * 
   * @param {boolean} allowUndefined 
   * @returns {Array.<Link>}
   */
  getIcons(e = !0) {
    return this.getLinksWithRels(["icon"]).filter((t) => t.canBrowserDisplayImage(e));
  }
  /**
   * Get the thumbnails from the assets and links in a STAC entity.
   * 
   * @param {boolean} browserOnly - Return only images that can be shown in a browser natively (PNG/JPG/GIF/WEBP + HTTP/S).
   * @param {string|null} prefer - If not `null` (default), prefers a role over the other. Either `thumbnail` or `overview`.
   * @returns {Array.<STACReference>} Asset or Link
   */
  getThumbnails(e = !0, t = null) {
    let n = this.getAssets().filter((r) => r.isPreview());
    if (n.length === 0 && (n = this.getLinks().filter((r) => r.isPreview())), n.length === 0) {
      const r = this.getAsset("thumbnail");
      r && n.push(r);
    }
    if (e && (n = n.filter((r) => r.canBrowserDisplayImage())), t && n.length > 1) {
      let r = (s) => Array.isArray(s.roles) && s.roles.includes(t) || s.getKey() === t;
      n = n.filter(r).concat(n.filter((s) => !r(s)));
    }
    return n;
  }
  /**
   * Determines the default GeoTiff asset for visualization.
   * 
   * @param {boolean} httpOnly Return only GeoTiffs that can be accessed via HTTP(S)
   * @param {boolean} cogOnly Return only COGs
   * @returns {Asset} Default GeoTiff asset
   * @see {rankGeoTIFFs}
   */
  getDefaultGeoTIFF(e = !0, t = !1) {
    return this.rankGeoTIFFs(e, t)[0]?.asset;
  }
  /**
   * Object with an asset and the corresponding score.
   * 
   * @typedef {Object} AssetScore
   * @property {Asset} asset
   * @property {number} score
   */
  /**
   * A function that can influence the score.
   * 
   * Returns a relative addition to the score.
   * Negative values subtract from the score.
   * 
   * @callback STAC~rankGeoTIFFs
   * @param {Asset} asset The asset to calculate the score for.
   */
  /**
   * Ranks the GeoTiff assets for visualization purposes.
   * 
   * The score factors can be found below:
   * - Roles/Keys (by default) - if multiple roles apply only the highest score is added:
   *   - overview => +3
   *   - thumbnail => +2
   *   - visual => +2
   *   - data => +1
   *   - none of the above => no change
   * - Other factors:
   *   - media type is COG: +2 (if cogOnly = false)
   *   - has RGB bands: +1
   *   - additionalCriteria: +/- a custom value
   * 
   * @param {boolean} httpOnly Return only GeoTiffs that can be accessed via HTTP(S)
   * @param {boolean} cogOnly Return only COGs
   * @param {Object.<string, number>} roleScores Roles (and keys) considered for the scoring. They key is the role name, the value is the score. Higher is better. Defaults to the roles and scores detailed above. An empty object disables role-based scoring.
   * @param {STAC~rankGeoTIFFs} additionalCriteria A function to customize the score by adding/subtracting.
   * @returns {Array.<AssetScore>} GeoTiff assets sorted by score in descending order.
   */
  rankGeoTIFFs(e = !0, t = !1, n = null, r = null) {
    vi(n) || (n = {
      data: 1,
      visual: 2,
      thumbnail: 2,
      overview: 3
    });
    let s = [], o = this.getAssetsByTypes(kb);
    e && (o = o.filter((l) => l.isHTTP() && (!t || l.isCOG())));
    let a = Object.entries(n);
    for (let l of o) {
      let h = 0;
      if (a.length > 0) {
        let u = a.filter(([c]) => l.hasRole(c, !0)).map(([, c]) => c);
        u.length > 0 && (h += Math.max(...u));
      }
      !t && l.isCOG() && (h += 2), l.findVisualBands() && (h += 1), typeof r == "function" && (h += r(l)), s.push({ asset: l, score: h });
    }
    return s.sort((l, h) => h.score - l.score), s;
  }
  /**
   * The single-band assets for RGB composites.
   * 
  * @typedef {Object} VisualAssets
  * @property {Band} red The red band with its index
  * @property {Band} green The green band with its index
  * @property {Band} blue The blue band with its index
  */
  /**
   * Find the single-band assets for RGB.
   * 
   * @returns {VisualAssets|null} Object with the RGB bands or null
   */
  findVisualAssets() {
    let e = {
      red: null,
      green: null,
      blue: null
    }, t = Object.keys(e), n = this.getAssets();
    for (let s of n) {
      let o = s.findBand(t, "eo:common_name");
      o && (e[o["eo:common_name"]] = s);
    }
    return Object.values(e).every((s) => s !== null) ? e : null;
  }
  /**
   * 
   * @todo
   * @param {string} key
   * @returns {Asset|null}
   */
  getAsset(e) {
    return vi(this.assets) && this.assets[e] || null;
  }
  /**
   * 
   * @todo
   * @returns {Array.<Asset>}
   */
  getAssets() {
    return vi(this.assets) ? Object.values(this.assets) : [];
  }
  /**
   * Returns all assets that contain at least one of the given roles.
   * 
   * @param {string|Array.<string>} roles One or more roles.
   * @param {boolean} includeKey Also returns `true` if the asset key equals to one of the given roles.
   * @returns {Array.<Asset>} The assets with the given roles.
   */
  getAssetsWithRoles(e, t = !1) {
    return this.getAssets().filter((n) => n.hasRole(e, t));
  }
  /**
   * 
   * @todo
   * @param {string} role 
   * @param {boolean} includeKey 
   * @returns {Asset|null}
   */
  getAssetWithRole(e, t = !1) {
    return this.getAssetsWithRoles([e], t)[0] || null;
  }
  /**
   * 
   * @todo
   * @param {Array.<string>} types 
   * @returns {Array.<Asset>}
   */
  getAssetsByTypes(e) {
    return this.getAssets().filter((t) => O0(t.type, e));
  }
  /**
   * 
   * @todo
   * @param {*} other 
   * @returns {boolean}
   */
  equals(e) {
    return this === e ? !0 : !(e instanceof Ar) || this.getObjectType() !== e.getObjectType() ? !1 : !!(this.id && this.id === e.id);
  }
  /**
   * Checks whether a specific extension is implemented.
   * 
   * The pattern can contain `*` as a wildcard, e.g. for version numbers.
   * 
   * @param {string} pattern The extension URI to check for.
   * @returns {boolean} `true` if the extension is implemented, `false` otherwise.
   */
  supportsExtension(e) {
    if (!Array.isArray(this.stac_extensions))
      return !1;
    let t = new RegExp("^" + e.replaceAll("*", "[^/]+") + "$");
    return this.stac_extensions.some((n) => t.test(n));
  }
}
class $b extends Ar {
  constructor(e, t = null, n = {}, r = []) {
    super(e, t, n, r);
  }
  /**
   * Returns the type of the STAC object, here: 'Catalog' or 'Collection'.
   * 
   * @returns {string}
   */
  getObjectType() {
    return this.type;
  }
  /**
   * Returns the search link, if present.
   * 
   * If a specific method is provied, can exclude other methods from being returned.
   * 
   * @returns {Link|null} The search link
   */
  getSearchLink(e = null) {
    let t = this.getStacLinksWithRel("search");
    return e ? t[0] || null : t.find((n) => n.method === e || !e && !n.method) || null;
  }
  /**
   * Returns the link for API collections, if present.
   * 
   * @returns {Link|null} The API collections link
   */
  getApiCollectionsLink() {
    return this.getStacLinkWithRel("data");
  }
  /**
   * Returns the link for API items, if present.
   * 
   * @returns {Link|null} The API items link
   */
  getApiItemsLink() {
    return this.getStacLinkWithRel("items");
  }
  /**
   * Returns all child links.
   * 
   * @returns {Array.<Link>} The child links
   */
  getChildLinks() {
    return this.getStacLinksWithRel("child");
  }
  /**
   * Returns all item links.
   * 
   * @returns {Array.<Link>} The child links
   */
  getItemLinks() {
    return this.getStacLinksWithRel("item");
  }
}
class CD extends $b {
  constructor(e, t = null) {
    super(e, t);
  }
}
function wl(i) {
  if (Ti(i) && i.length >= 10)
    try {
      let t = i.match(/^(-?\d{1,})-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(?:\.(\d*))?(?:Z|[+-]00:00)?$/i).slice(1).map((n) => parseInt(n, 10));
      return new Date(Date.UTC(t[0], t[1] - 1, t[2], t[3], t[4], t[5], t[6] || 0));
    } catch {
      return null;
    }
  return null;
}
function AD(i, e) {
  return new Date(i.valueOf() + (e - i) / 2);
}
function jb(i) {
  if (!Array.isArray(i) || i.length === 0)
    return null;
  let e, t;
  const n = (r, s, o) => typeof r > "u" ? s : r === null || s === null ? null : o(r, s);
  return i.forEach(([r, s]) => {
    e = n(e, r, Math.min), t = n(t, s, Math.max);
  }), [
    e === null ? null : new Date(e),
    t === null ? null : new Date(t)
  ];
}
class dp extends $b {
  constructor(e, t = null) {
    const n = {
      assets: Sn.fromAssets,
      item_assets: Sn.fromAssets
    };
    super(e, t, n);
  }
  /**
   * Returns a GeoJSON Feature for this STAC Collection.
   * 
   * The Feature contains a Polygon or MultiPolygon based on the given number of valid bounding boxes.
   * 
   * @returns {Object|null} GeoJSON object or `null`
   */
  toGeoJSON() {
    let e = Nb(this.getBoundingBoxes());
    return e && (e.id = this.id), e;
  }
  /**
   * Returns a single union 2D bounding box for the whole collection.
   * 
   * @returns {BoundingBox|null}
   */
  getBoundingBox() {
    let e = this.getRawBoundingBoxes();
    return e.length > 0 ? ur(e[0]) : null;
  }
  /**
   * Returns the individual 2D bounding boxes for the collection,
   * without the union bounding box if multiple bounding boxes are given.
   * 
   * @returns {Array.<BoundingBox>}
   */
  getBoundingBoxes() {
    let e = this.getRawBoundingBoxes();
    return e.length === 1 ? [ur(e[0])] : e.length > 1 ? e.slice(1).map(ur) : null;
  }
  /**
   * Returns all bounding boxes from the collection, including the union bounding box.
   * 
   * @returns {Array.<BoundingBox>}
   */
  getRawBoundingBoxes() {
    let e = this.extent?.spatial?.bbox;
    return Array.isArray(e) && e.length > 0 ? e : [];
  }
  /**
   * Returns a single temporal extent for the STAC Collection.
   * 
   * @returns {Array.<Date|null>|null}
   */
  getTemporalExtent() {
    return this.getTemporalExtents()[0] || null;
  }
  /**
   * Returns the temporal extent(s) for the STAC Collection.
   * 
   * @returns {Array.<Array.<Date|null>>}
   */
  getTemporalExtents() {
    let e = this.extent?.temporal?.interval;
    return Array.isArray(e) && e.length > 0 ? e.filter((t) => Array.isArray(t) && (Ti(t[0]) || Ti(t[1]))).map((t) => t.map((n) => wl(n))) : [];
  }
  /**
   * Returns metadata from the Collection summaries for the given field name.
   * 
   * @param {string} field Field name
   * @returns {Array.<*>|Object|undefined} The value of the field
   */
  getSummary(e) {
    if (vi(this.summaries))
      return this.summaries[e];
  }
  /**
   * Returns the bands.
   * 
   * @returns {Array.<Band>}
   */
  getBands() {
    let e = this.getMetadata("bands");
    return Array.isArray(e) || (e = this.getSummary("bands")), Array.isArray(e) ? Ia.fromBands(e, this) : [];
  }
}
class ID extends D0 {
  constructor(e, t = null) {
    const n = {
      collections: (r) => r.map(
        (s) => s instanceof dp ? s : new dp(s)
      )
    };
    super(e, t, n);
  }
  /**
   * Returns the type of the STAC object, here: 'CollectionCollection'.
   * 
   * @returns {string}
   */
  getObjectType() {
    return "CollectionCollection";
  }
  /**
   * Returns all collections.
   * 
   * @returns {Array.<Collection>} All STAC Collections
   */
  getAll() {
    return this.collections;
  }
  /**
   * Check whether this given object is a STAC Collection of Collections (i.e. API Collections).
   * 
   * @returns {boolean} `true` if the object is a STAC CollectionCollection, `false` otherwise.
   */
  isCollectionCollection() {
    return !0;
  }
  /**
   * Returns a GeoJSON Feature Collection for this STAC object.
   * 
   * @returns {Object|null} GeoJSON object or `null`
   */
  toGeoJSON() {
    return {
      type: "FeatureCollection",
      features: this.collections.map((t) => t.toGeoJSON()).filter((t) => t !== null)
    };
  }
  /**
   * Returns a single 2D bounding box for all the STAC collections.
   * 
   * @returns {BoundingBox|null}
   */
  getBoundingBox() {
    return F0(this.getBoundingBoxes());
  }
  /**
   * Returns a list of 2D bounding boxes for all the STAC collections.
   * 
   * @returns {Array.<BoundingBox>}
   */
  getBoundingBoxes() {
    return this.collections.map((e) => e.getBoundingBox());
  }
  /**
   * Returns a single temporal extent for the all the STAC collections.
   * 
   * @returns {Array.<Date|null>|null}
   */
  getTemporalExtent() {
    return jb(this.getTemporalExtents());
  }
  /**
   * Returns the temporal extent(s) for the all the STAC collections.
   * 
   * @returns {Array.<Array.<Date|null>>}
   */
  getTemporalExtents() {
    return this.collections.map((e) => e.getTemporalExtent());
  }
}
class Uc extends Ar {
  constructor(e, t = null) {
    super(e, t, { assets: Sn.fromAssets });
  }
  /**
   * Returns the type of the STAC object, here: 'Item'.
   * 
   * @returns {string}
   */
  getObjectType() {
    return "Item";
  }
  /**
   * Returns a GeoJSON Feature for this STAC object.
   * 
   * @returns {Object|null} GeoJSON object or `null`
   */
  toGeoJSON() {
    return this.toJSON();
  }
  /**
   * Returns a single 2D bounding box for the item.
   * 
   * @returns {BoundingBox|null}
   */
  getBoundingBox() {
    return ur(this.bbox);
  }
  /**
   * Returns 2D bounding boxes for the item.
   * 
   * @returns {Array.<BoundingBox>}
   */
  getBoundingBoxes() {
    const e = this.getBoundingBox();
    return e ? [e] : [];
  }
  /**
   * Returns a datetime for the STAC Item.
   * 
   * If no datetime but start or end datetime are specified, computes a datetime from them.
   * 
   * @returns {Date|null}
   */
  getDateTime() {
    let e = wl(this.properties.datetime);
    if (!e) {
      let t = wl(this.properties.start_datetime), n = wl(this.properties.end_datetime);
      return t && n ? AD(t, n) : t || n;
    }
    return e;
  }
  /**
   * Returns a single temporal extent for the STAC Item.
   * 
   * @returns {Array.<Date|null>|null}
   */
  getTemporalExtent() {
    return this.getTemporalExtents()[0] || null;
  }
  /**
   * Returns the temporal extent(s) for the STAC Item.
   * 
   * @returns {Array.<Array.<Date|null>>}
   */
  getTemporalExtents() {
    let e = [];
    return Ti(this.properties.start_datetime) || Ti(this.properties.end_datetime) ? e = [[this.properties.start_datetime || null, this.properties.end_datetime || null]] : Ti(this.properties.datetime) && (e = [[this.properties.datetime, this.properties.datetime]]), e.map((t) => t.map((n) => wl(n)));
  }
  /**
   * Returns metadata from the Item properties for the given field name.
   * 
   * @param {string} field Field name
   * @returns {*} The value of the field
   */
  getMetadata(e) {
    return this.properties[e];
  }
  /**
   * Returns the bands.
   * 
   * @todo Merge bands from assets
   * @returns {Array.<Band>}
   */
  getBands() {
    const e = this.getMetadata("bands");
    return Array.isArray(e) ? Ia.fromBands(e, this) : [];
  }
  /**
   * Returns the collection link, if present.
   * 
   * @returns {Link|null} The collection link
   */
  getCollectionLink() {
    return this.getStacLinkWithRel("collection");
  }
}
class Xb extends D0 {
  constructor(e, t = null) {
    const n = {
      features: (r) => r.map(
        (s) => s instanceof Uc ? s : new Uc(s)
      )
    };
    super(e, t, n);
  }
  /**
   * Returns the type of the STAC object, here: 'ItemCollection'.
   * 
   * @returns {string}
   */
  getObjectType() {
    return "ItemCollection";
  }
  /**
   * Returns all items.
   * 
   * @returns {Array.<Item>} All STAC Items
   */
  getAll() {
    return this.features;
  }
  /**
   * Returns a GeoJSON FeatureCollection for this STAC object.
   * 
   * @returns {Object|null} GeoJSON object or `null`
   */
  toGeoJSON() {
    return this.toJSON();
  }
  /**
   * Returns a single 2D bounding box for all the STAC items.
   * 
   * @returns {BoundingBox|null}
   */
  getBoundingBox() {
    return F0(this.getBoundingBoxes());
  }
  /**
   * Returns a list of 2D bounding boxes for all the STAC items.
   * 
   * @returns {Array.<BoundingBox>}
   */
  getBoundingBoxes() {
    return this.features.map((e) => e.getBoundingBox());
  }
  /**
   * Returns a single temporal extent for all the STAC items.
   * 
   * @returns {Array.<Date|null>|null}
   */
  getTemporalExtent() {
    return jb(this.getTemporalExtents());
  }
  /**
   * Returns the temporal extent(s) for all the STAC items.
   * 
   * @returns {Array.<Array.<Date|null>>}
   */
  getTemporalExtents() {
    return this.features.map((e) => e.getTemporalExtent());
  }
}
function Mu(i, e = !0, t = !1) {
  return e && (i = uD.stac(i, t)), i.type === "Feature" ? new Uc(i) : i.type === "FeatureCollection" ? new Xb(i) : i.type === "Collection" || !i.type && typeof i.extent < "u" && typeof i.license < "u" ? new dp(i) : !i.type && Array.isArray(i.collections) ? new ID(i) : new CD(i);
}
let G0 = null;
function LD() {
  return !!G0;
}
function Vb(i) {
  G0 = i;
  const e = Object.keys(i.defs), t = e.length;
  let n, r;
  for (n = 0; n < t; ++n) {
    const s = e[n];
    if (!ra(s)) {
      const o = i.defs(s);
      let a = (
        /** @type {import("./Units.js").Units} */
        o.units
      );
      !a && o.projName === "longlat" && (a = "degrees"), lc(
        new oo({
          code: s,
          axisOrientation: o.axis,
          metersPerUnit: o.to_meter,
          units: a
        })
      );
    }
  }
  for (n = 0; n < t; ++n) {
    const s = e[n], o = ra(s);
    for (r = 0; r < t; ++r) {
      const a = e[r], l = ra(a);
      if (!Bu(s, a))
        if (i.defs[s] === i.defs[a])
          Ag([o, l]);
        else {
          const h = i(s, a);
          u2(
            o,
            l,
            j_(o, l, h.forward),
            j_(l, o, h.inverse)
          );
        }
    }
  }
}
let FD = async function(i) {
  const e = await fetch(`https://epsg.io/${i}.proj4`);
  if (!e.ok)
    throw new Error(`Unexpected response from epsg.io: ${e.status}`);
  return e.text();
};
async function OD(i) {
  typeof i == "string" && (i = parseInt(i.split(":").pop(), 10));
  const e = G0;
  if (!e)
    throw new Error("Proj4 must be registered first with register(proj4)");
  const t = "EPSG:" + i;
  return e.defs(t) || (e.defs(t, await FD(i)), Vb(e)), ra(t);
}
const ND = "https://stac-extensions.github.io/label/v1.*/schema.json", Wb = new gi({ color: "rgba(0,0,0,0)" });
function Yb(i, e, t = "rgba(255,255,255,0.4)", n = 5) {
  let r = Wb;
  t && (r = new gi({
    color: t
  }));
  const s = new Ri({
    color: i,
    width: e
  });
  return new Mt({
    image: new Xa({
      fill: r,
      stroke: s,
      radius: n
    }),
    fill: r,
    stroke: s
  });
}
const DD = Yb("#3399CC", 3), B1 = Yb("#ff9933", 2, null);
function GD(i, e) {
  const t = {
    url: i.getAbsoluteUrl()
  };
  let n = i, r = i.getBands();
  r.length === 1 && (n = r[0], r = []);
  const { minimum: s, maximum: o } = n.getMinMaxValues();
  if (typeof s == "number" && (t.min = s), typeof o == "number" && (t.max = o), typeof t.min != "number" && typeof t.max != "number" && r.length > 1)
    for (const l of r) {
      const { minimum: h, maximum: u } = l.getMinMaxValues();
      typeof h == "number" && (typeof t.min > "u" || h < t.min) && (t.min = h), typeof u == "number" && (typeof t.max > "u" || u > t.max) && (t.max = u);
    }
  const a = n.getNoDataValues();
  if (a.length > 0)
    t.nodata = a[0];
  else if (r.length > 1) {
    let l;
    for (const h of r) {
      const u = h.getNoDataValues();
      if (u.length > 0) {
        if (typeof l > "u")
          l = u[0];
        else if (l !== u[0]) {
          l = void 0;
          break;
        }
      }
    }
    typeof l < "u" && (t.nodata = l);
  }
  if (e.length > 0)
    t.bands = e;
  else {
    const l = i.findVisualBands();
    l && (t.bands = [
      l.red.getIndex() + 1,
      l.green.getIndex() + 1,
      l.blue.getIndex() + 1
    ]);
  }
  return t;
}
async function $1(i, e = void 0) {
  let t = e;
  if (LD()) {
    const n = i.getMetadata("proj:code");
    if (n)
      try {
        if (n.startsWith("EPSG:")) {
          const r = parseInt(n.replace("EPSG:", ""), 10);
          t = await OD(r);
        }
      } catch {
      }
  }
  return t;
}
function j1(i, e) {
  const t = i.clone();
  return e.hasOnlyBounds() || t.setFill(Wb), t;
}
function kD(i) {
  let e = i.href;
  if (e.includes("{s}"))
    if (Array.isArray(i["href:servers"]) && i["href:servers"].length > 0) {
      const t = Math.random() * i["href:servers"].length | 0;
      e = e.replace("{s}", i["href:servers"][t]);
    } else
      return null;
  return e;
}
const gp = 65536 * 65536, X1 = 1 / gp, UD = 12, V1 = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8"), rg = 0, Cu = 1, hl = 2, Au = 5;
class zD {
  /**
   * @param {Uint8Array | ArrayBuffer} [buf]
   */
  constructor(e = new Uint8Array(16)) {
    this.buf = ArrayBuffer.isView(e) ? e : new Uint8Array(e), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
  }
  // === READING =================================================================
  /**
   * @template T
   * @param {(tag: number, result: T, pbf: Pbf) => void} readField
   * @param {T} result
   * @param {number} [end]
   */
  readFields(e, t, n = this.length) {
    for (; this.pos < n; ) {
      const r = this.readVarint(), s = r >> 3, o = this.pos;
      this.type = r & 7, e(s, t, this), this.pos === o && this.skip(r);
    }
    return t;
  }
  /**
   * @template T
   * @param {(tag: number, result: T, pbf: Pbf) => void} readField
   * @param {T} result
   */
  readMessage(e, t) {
    return this.readFields(e, t, this.readVarint() + this.pos);
  }
  readFixed32() {
    const e = this.dataView.getUint32(this.pos, !0);
    return this.pos += 4, e;
  }
  readSFixed32() {
    const e = this.dataView.getInt32(this.pos, !0);
    return this.pos += 4, e;
  }
  // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
  readFixed64() {
    const e = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * gp;
    return this.pos += 8, e;
  }
  readSFixed64() {
    const e = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * gp;
    return this.pos += 8, e;
  }
  readFloat() {
    const e = this.dataView.getFloat32(this.pos, !0);
    return this.pos += 4, e;
  }
  readDouble() {
    const e = this.dataView.getFloat64(this.pos, !0);
    return this.pos += 8, e;
  }
  /**
   * @param {boolean} [isSigned]
   */
  readVarint(e) {
    const t = this.buf;
    let n, r;
    return r = t[this.pos++], n = r & 127, r < 128 || (r = t[this.pos++], n |= (r & 127) << 7, r < 128) || (r = t[this.pos++], n |= (r & 127) << 14, r < 128) || (r = t[this.pos++], n |= (r & 127) << 21, r < 128) ? n : (r = t[this.pos], n |= (r & 15) << 28, BD(n, e, this));
  }
  readVarint64() {
    return this.readVarint(!0);
  }
  readSVarint() {
    const e = this.readVarint();
    return e % 2 === 1 ? (e + 1) / -2 : e / 2;
  }
  readBoolean() {
    return !!this.readVarint();
  }
  readString() {
    const e = this.readVarint() + this.pos, t = this.pos;
    return this.pos = e, e - t >= UD && V1 ? V1.decode(this.buf.subarray(t, e)) : eG(this.buf, t, e);
  }
  readBytes() {
    const e = this.readVarint() + this.pos, t = this.buf.subarray(this.pos, e);
    return this.pos = e, t;
  }
  // verbose for performance reasons; doesn't affect gzipped size
  /**
   * @param {number[]} [arr]
   * @param {boolean} [isSigned]
   */
  readPackedVarint(e = [], t) {
    const n = this.readPackedEnd();
    for (; this.pos < n; ) e.push(this.readVarint(t));
    return e;
  }
  /** @param {number[]} [arr] */
  readPackedSVarint(e = []) {
    const t = this.readPackedEnd();
    for (; this.pos < t; ) e.push(this.readSVarint());
    return e;
  }
  /** @param {boolean[]} [arr] */
  readPackedBoolean(e = []) {
    const t = this.readPackedEnd();
    for (; this.pos < t; ) e.push(this.readBoolean());
    return e;
  }
  /** @param {number[]} [arr] */
  readPackedFloat(e = []) {
    const t = this.readPackedEnd();
    for (; this.pos < t; ) e.push(this.readFloat());
    return e;
  }
  /** @param {number[]} [arr] */
  readPackedDouble(e = []) {
    const t = this.readPackedEnd();
    for (; this.pos < t; ) e.push(this.readDouble());
    return e;
  }
  /** @param {number[]} [arr] */
  readPackedFixed32(e = []) {
    const t = this.readPackedEnd();
    for (; this.pos < t; ) e.push(this.readFixed32());
    return e;
  }
  /** @param {number[]} [arr] */
  readPackedSFixed32(e = []) {
    const t = this.readPackedEnd();
    for (; this.pos < t; ) e.push(this.readSFixed32());
    return e;
  }
  /** @param {number[]} [arr] */
  readPackedFixed64(e = []) {
    const t = this.readPackedEnd();
    for (; this.pos < t; ) e.push(this.readFixed64());
    return e;
  }
  /** @param {number[]} [arr] */
  readPackedSFixed64(e = []) {
    const t = this.readPackedEnd();
    for (; this.pos < t; ) e.push(this.readSFixed64());
    return e;
  }
  readPackedEnd() {
    return this.type === hl ? this.readVarint() + this.pos : this.pos + 1;
  }
  /** @param {number} val */
  skip(e) {
    const t = e & 7;
    if (t === rg) for (; this.buf[this.pos++] > 127; )
      ;
    else if (t === hl) this.pos = this.readVarint() + this.pos;
    else if (t === Au) this.pos += 4;
    else if (t === Cu) this.pos += 8;
    else throw new Error(`Unimplemented type: ${t}`);
  }
  // === WRITING =================================================================
  /**
   * @param {number} tag
   * @param {number} type
   */
  writeTag(e, t) {
    this.writeVarint(e << 3 | t);
  }
  /** @param {number} min */
  realloc(e) {
    let t = this.length || 16;
    for (; t < this.pos + e; ) t *= 2;
    if (t !== this.length) {
      const n = new Uint8Array(t);
      n.set(this.buf), this.buf = n, this.dataView = new DataView(n.buffer), this.length = t;
    }
  }
  finish() {
    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
  }
  /** @param {number} val */
  writeFixed32(e) {
    this.realloc(4), this.dataView.setInt32(this.pos, e, !0), this.pos += 4;
  }
  /** @param {number} val */
  writeSFixed32(e) {
    this.realloc(4), this.dataView.setInt32(this.pos, e, !0), this.pos += 4;
  }
  /** @param {number} val */
  writeFixed64(e) {
    this.realloc(8), this.dataView.setInt32(this.pos, e & -1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(e * X1), !0), this.pos += 8;
  }
  /** @param {number} val */
  writeSFixed64(e) {
    this.realloc(8), this.dataView.setInt32(this.pos, e & -1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(e * X1), !0), this.pos += 8;
  }
  /** @param {number} val */
  writeVarint(e) {
    if (e = +e || 0, e > 268435455 || e < 0) {
      $D(e, this);
      return;
    }
    this.realloc(4), this.buf[this.pos++] = e & 127 | (e > 127 ? 128 : 0), !(e <= 127) && (this.buf[this.pos++] = (e >>>= 7) & 127 | (e > 127 ? 128 : 0), !(e <= 127) && (this.buf[this.pos++] = (e >>>= 7) & 127 | (e > 127 ? 128 : 0), !(e <= 127) && (this.buf[this.pos++] = e >>> 7 & 127)));
  }
  /** @param {number} val */
  writeSVarint(e) {
    this.writeVarint(e < 0 ? -e * 2 - 1 : e * 2);
  }
  /** @param {boolean} val */
  writeBoolean(e) {
    this.writeVarint(+e);
  }
  /** @param {string} str */
  writeString(e) {
    e = String(e), this.realloc(e.length * 4), this.pos++;
    const t = this.pos;
    this.pos = tG(this.buf, e, this.pos);
    const n = this.pos - t;
    n >= 128 && W1(t, n, this), this.pos = t - 1, this.writeVarint(n), this.pos += n;
  }
  /** @param {number} val */
  writeFloat(e) {
    this.realloc(4), this.dataView.setFloat32(this.pos, e, !0), this.pos += 4;
  }
  /** @param {number} val */
  writeDouble(e) {
    this.realloc(8), this.dataView.setFloat64(this.pos, e, !0), this.pos += 8;
  }
  /** @param {Uint8Array} buffer */
  writeBytes(e) {
    const t = e.length;
    this.writeVarint(t), this.realloc(t);
    for (let n = 0; n < t; n++) this.buf[this.pos++] = e[n];
  }
  /**
   * @template T
   * @param {(obj: T, pbf: Pbf) => void} fn
   * @param {T} obj
   */
  writeRawMessage(e, t) {
    this.pos++;
    const n = this.pos;
    e(t, this);
    const r = this.pos - n;
    r >= 128 && W1(n, r, this), this.pos = n - 1, this.writeVarint(r), this.pos += r;
  }
  /**
   * @template T
   * @param {number} tag
   * @param {(obj: T, pbf: Pbf) => void} fn
   * @param {T} obj
   */
  writeMessage(e, t, n) {
    this.writeTag(e, hl), this.writeRawMessage(t, n);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedVarint(e, t) {
    t.length && this.writeMessage(e, VD, t);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedSVarint(e, t) {
    t.length && this.writeMessage(e, WD, t);
  }
  /**
   * @param {number} tag
   * @param {boolean[]} arr
   */
  writePackedBoolean(e, t) {
    t.length && this.writeMessage(e, ZD, t);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedFloat(e, t) {
    t.length && this.writeMessage(e, YD, t);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedDouble(e, t) {
    t.length && this.writeMessage(e, qD, t);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedFixed32(e, t) {
    t.length && this.writeMessage(e, HD, t);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedSFixed32(e, t) {
    t.length && this.writeMessage(e, KD, t);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedFixed64(e, t) {
    t.length && this.writeMessage(e, JD, t);
  }
  /**
   * @param {number} tag
   * @param {number[]} arr
   */
  writePackedSFixed64(e, t) {
    t.length && this.writeMessage(e, QD, t);
  }
  /**
   * @param {number} tag
   * @param {Uint8Array} buffer
   */
  writeBytesField(e, t) {
    this.writeTag(e, hl), this.writeBytes(t);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeFixed32Field(e, t) {
    this.writeTag(e, Au), this.writeFixed32(t);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeSFixed32Field(e, t) {
    this.writeTag(e, Au), this.writeSFixed32(t);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeFixed64Field(e, t) {
    this.writeTag(e, Cu), this.writeFixed64(t);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeSFixed64Field(e, t) {
    this.writeTag(e, Cu), this.writeSFixed64(t);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeVarintField(e, t) {
    this.writeTag(e, rg), this.writeVarint(t);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeSVarintField(e, t) {
    this.writeTag(e, rg), this.writeSVarint(t);
  }
  /**
   * @param {number} tag
   * @param {string} str
   */
  writeStringField(e, t) {
    this.writeTag(e, hl), this.writeString(t);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeFloatField(e, t) {
    this.writeTag(e, Au), this.writeFloat(t);
  }
  /**
   * @param {number} tag
   * @param {number} val
   */
  writeDoubleField(e, t) {
    this.writeTag(e, Cu), this.writeDouble(t);
  }
  /**
   * @param {number} tag
   * @param {boolean} val
   */
  writeBooleanField(e, t) {
    this.writeVarintField(e, +t);
  }
}
function BD(i, e, t) {
  const n = t.buf;
  let r, s;
  if (s = n[t.pos++], r = (s & 112) >> 4, s < 128 || (s = n[t.pos++], r |= (s & 127) << 3, s < 128) || (s = n[t.pos++], r |= (s & 127) << 10, s < 128) || (s = n[t.pos++], r |= (s & 127) << 17, s < 128) || (s = n[t.pos++], r |= (s & 127) << 24, s < 128) || (s = n[t.pos++], r |= (s & 1) << 31, s < 128)) return Go(i, r, e);
  throw new Error("Expected varint not more than 10 bytes");
}
function Go(i, e, t) {
  return t ? e * 4294967296 + (i >>> 0) : (e >>> 0) * 4294967296 + (i >>> 0);
}
function $D(i, e) {
  let t, n;
  if (i >= 0 ? (t = i % 4294967296 | 0, n = i / 4294967296 | 0) : (t = ~(-i % 4294967296), n = ~(-i / 4294967296), t ^ 4294967295 ? t = t + 1 | 0 : (t = 0, n = n + 1 | 0)), i >= 18446744073709552e3 || i < -18446744073709552e3)
    throw new Error("Given varint doesn't fit into 10 bytes");
  e.realloc(10), jD(t, n, e), XD(n, e);
}
function jD(i, e, t) {
  t.buf[t.pos++] = i & 127 | 128, i >>>= 7, t.buf[t.pos++] = i & 127 | 128, i >>>= 7, t.buf[t.pos++] = i & 127 | 128, i >>>= 7, t.buf[t.pos++] = i & 127 | 128, i >>>= 7, t.buf[t.pos] = i & 127;
}
function XD(i, e) {
  const t = (i & 7) << 4;
  e.buf[e.pos++] |= t | ((i >>>= 3) ? 128 : 0), i && (e.buf[e.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (e.buf[e.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (e.buf[e.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (e.buf[e.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (e.buf[e.pos++] = i & 127)))));
}
function W1(i, e, t) {
  const n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (Math.LN2 * 7));
  t.realloc(n);
  for (let r = t.pos - 1; r >= i; r--) t.buf[r + n] = t.buf[r];
}
function VD(i, e) {
  for (let t = 0; t < i.length; t++) e.writeVarint(i[t]);
}
function WD(i, e) {
  for (let t = 0; t < i.length; t++) e.writeSVarint(i[t]);
}
function YD(i, e) {
  for (let t = 0; t < i.length; t++) e.writeFloat(i[t]);
}
function qD(i, e) {
  for (let t = 0; t < i.length; t++) e.writeDouble(i[t]);
}
function ZD(i, e) {
  for (let t = 0; t < i.length; t++) e.writeBoolean(i[t]);
}
function HD(i, e) {
  for (let t = 0; t < i.length; t++) e.writeFixed32(i[t]);
}
function KD(i, e) {
  for (let t = 0; t < i.length; t++) e.writeSFixed32(i[t]);
}
function JD(i, e) {
  for (let t = 0; t < i.length; t++) e.writeFixed64(i[t]);
}
function QD(i, e) {
  for (let t = 0; t < i.length; t++) e.writeSFixed64(i[t]);
}
function eG(i, e, t) {
  let n = "", r = e;
  for (; r < t; ) {
    const s = i[r];
    let o = null, a = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
    if (r + a > t) break;
    let l, h, u;
    a === 1 ? s < 128 && (o = s) : a === 2 ? (l = i[r + 1], (l & 192) === 128 && (o = (s & 31) << 6 | l & 63, o <= 127 && (o = null))) : a === 3 ? (l = i[r + 1], h = i[r + 2], (l & 192) === 128 && (h & 192) === 128 && (o = (s & 15) << 12 | (l & 63) << 6 | h & 63, (o <= 2047 || o >= 55296 && o <= 57343) && (o = null))) : a === 4 && (l = i[r + 1], h = i[r + 2], u = i[r + 3], (l & 192) === 128 && (h & 192) === 128 && (u & 192) === 128 && (o = (s & 15) << 18 | (l & 63) << 12 | (h & 63) << 6 | u & 63, (o <= 65535 || o >= 1114112) && (o = null))), o === null ? (o = 65533, a = 1) : o > 65535 && (o -= 65536, n += String.fromCharCode(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), n += String.fromCharCode(o), r += a;
  }
  return n;
}
function tG(i, e, t) {
  for (let n = 0, r, s; n < e.length; n++) {
    if (r = e.charCodeAt(n), r > 55295 && r < 57344)
      if (s)
        if (r < 56320) {
          i[t++] = 239, i[t++] = 191, i[t++] = 189, s = r;
          continue;
        } else
          r = s - 55296 << 10 | r - 56320 | 65536, s = null;
      else {
        r > 56319 || n + 1 === e.length ? (i[t++] = 239, i[t++] = 191, i[t++] = 189) : s = r;
        continue;
      }
    else s && (i[t++] = 239, i[t++] = 191, i[t++] = 189, s = null);
    r < 128 ? i[t++] = r : (r < 2048 ? i[t++] = r >> 6 | 192 : (r < 65536 ? i[t++] = r >> 12 | 224 : (i[t++] = r >> 18 | 240, i[t++] = r >> 12 & 63 | 128), i[t++] = r >> 6 & 63 | 128), i[t++] = r & 63 | 128);
  }
  return t;
}
class k0 extends Ph {
  /**
   * @param {Options<FeatureType>} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.dataProjection = new oo({
      code: "",
      units: "tile-pixels"
    }), this.featureClass = e.featureClass ? e.featureClass : (
      /** @type {import('./Feature.js').FeatureToFeatureClass<FeatureType>} */
      fi
    ), this.geometryName_ = e.geometryName, this.layerName_ = e.layerName ? e.layerName : "layer", this.layers_ = e.layers ? e.layers : null, this.idProperty_ = e.idProperty, this.supportedMediaTypes = [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ];
  }
  /**
   * Read the raw geometry from the pbf offset stored in a raw feature's geometry
   * property.
   * @param {PBF} pbf PBF.
   * @param {Object} feature Raw feature.
   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
   * @param {Array<number>} ends Array to store ends in.
   * @private
   */
  readRawGeometry_(e, t, n, r) {
    e.pos = t.geometry;
    const s = e.readVarint() + e.pos;
    let o = 1, a = 0, l = 0, h = 0, u = 0, c = 0;
    for (; e.pos < s; ) {
      if (!a) {
        const f = e.readVarint();
        o = f & 7, a = f >> 3;
      }
      if (a--, o === 1 || o === 2)
        l += e.readSVarint(), h += e.readSVarint(), o === 1 && u > c && (r.push(u), c = u), n.push(l, h), u += 2;
      else if (o === 7)
        u > c && (n.push(
          n[c],
          n[c + 1]
        ), u += 2);
      else
        throw new Error("Invalid command found in the PBF");
    }
    u > c && (r.push(u), c = u);
  }
  /**
   * @private
   * @param {PBF} pbf PBF
   * @param {Object} rawFeature Raw Mapbox feature.
   * @param {import("./Feature.js").ReadOptions} options Read options.
   * @return {FeatureType|null} Feature.
   */
  createFeature_(e, t, n) {
    const r = t.type;
    if (r === 0)
      return null;
    let s;
    const o = t.properties;
    let a;
    this.idProperty_ ? (a = o[this.idProperty_], delete o[this.idProperty_]) : a = t.id, o[this.layerName_] = t.layer.name;
    const l = (
      /** @type {Array<number>} */
      []
    ), h = (
      /** @type {Array<number>} */
      []
    );
    this.readRawGeometry_(e, t, l, h);
    const u = oG(r, h.length);
    if (this.featureClass === fi)
      s = new /** @type {import('./Feature.js').FeatureToFeatureClass<RenderFeature>} */
      this.featureClass(u, l, h, 2, o, a), s.transform(n.dataProjection);
    else {
      let c;
      if (u == "Polygon") {
        const d = cm(l, h);
        c = d.length > 1 ? new Cn(l, "XY", d) : new ei(l, "XY", h);
      } else
        c = u === "Point" ? new Jt(l, "XY") : u === "LineString" ? new Wt(l, "XY") : u === "MultiPoint" ? new Zn(l, "XY") : u === "MultiLineString" ? new Xi(l, "XY", h) : null;
      const f = (
        /** @type {typeof import("../Feature.js").default} */
        this.featureClass
      );
      s = new f(), this.geometryName_ && s.setGeometryName(this.geometryName_);
      const g = xt(c, !1, n);
      s.setGeometry(g), a !== void 0 && s.setId(a), s.setProperties(o, !0);
    }
    return (
      /** @type {FeatureType} */
      s
    );
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   * @override
   */
  getType() {
    return "arraybuffer";
  }
  /**
   * Read all features.
   *
   * @param {ArrayBuffer} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<FeatureType>} Features.
   * @api
   * @override
   */
  readFeatures(e, t) {
    const n = this.layers_;
    t = this.adaptOptions(t);
    const r = ee(t.dataProjection);
    r.setWorldExtent(t.extent), t.dataProjection = r;
    const s = new zD(
      /** @type {ArrayBuffer} */
      e
    ), o = s.readFields(iG, {}), a = [];
    for (const l in o) {
      if (n && !n.includes(l))
        continue;
      const h = o[l], u = h ? [0, 0, h.extent, h.extent] : null;
      r.setExtent(u);
      for (let c = 0, f = h.length; c < f; ++c) {
        const g = sG(s, h, c), d = this.createFeature_(s, g, t);
        d !== null && a.push(d);
      }
    }
    return (
      /** @type {Array<FeatureType>} */
      a
    );
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   * @override
   */
  readProjection(e) {
    return this.dataProjection;
  }
  /**
   * Sets the layers that features will be read from.
   * @param {Array<string>} layers Layers.
   * @api
   */
  setLayers(e) {
    this.layers_ = e;
  }
}
function iG(i, e, t) {
  if (i === 3) {
    const n = {
      keys: [],
      values: [],
      features: []
    }, r = t.readVarint() + t.pos;
    t.readFields(nG, n, r), n.length = n.features.length, n.length && (e[n.name] = n);
  }
}
function nG(i, e, t) {
  if (i === 15)
    e.version = t.readVarint();
  else if (i === 1)
    e.name = t.readString();
  else if (i === 5)
    e.extent = t.readVarint();
  else if (i === 2)
    e.features.push(t.pos);
  else if (i === 3)
    e.keys.push(t.readString());
  else if (i === 4) {
    let n = null;
    const r = t.readVarint() + t.pos;
    for (; t.pos < r; )
      i = t.readVarint() >> 3, n = i === 1 ? t.readString() : i === 2 ? t.readFloat() : i === 3 ? t.readDouble() : i === 4 ? t.readVarint64() : i === 5 ? t.readVarint() : i === 6 ? t.readSVarint() : i === 7 ? t.readBoolean() : null;
    e.values.push(n);
  }
}
function rG(i, e, t) {
  if (i == 1)
    e.id = t.readVarint();
  else if (i == 2) {
    const n = t.readVarint() + t.pos;
    for (; t.pos < n; ) {
      const r = e.layer.keys[t.readVarint()], s = e.layer.values[t.readVarint()];
      e.properties[r] = s;
    }
  } else i == 3 ? e.type = t.readVarint() : i == 4 && (e.geometry = t.pos);
}
function sG(i, e, t) {
  i.pos = e.features[t];
  const n = i.readVarint() + i.pos, r = {
    layer: e,
    type: 0,
    properties: {}
  };
  return i.readFields(rG, r, n), r;
}
function oG(i, e) {
  let t;
  return i === 1 ? t = e === 1 ? "Point" : "MultiPoint" : i === 2 ? t = e === 1 ? "LineString" : "MultiLineString" : i === 3 && (t = "Polygon"), t;
}
var qb = Object.defineProperty, Y1 = Object.getOwnPropertySymbols, aG = Object.prototype.hasOwnProperty, lG = Object.prototype.propertyIsEnumerable, q1 = (i, e, t) => e in i ? qb(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, zc = (i, e) => {
  for (var t in e || (e = {}))
    aG.call(e, t) && q1(i, t, e[t]);
  if (Y1)
    for (var t of Y1(e))
      lG.call(e, t) && q1(i, t, e[t]);
  return i;
}, Zf = (i, e) => qb(i, "name", { value: e, configurable: !0 }), hG = (i, e, t) => new Promise((n, r) => {
  var s = (l) => {
    try {
      a(t.next(l));
    } catch (h) {
      r(h);
    }
  }, o = (l) => {
    try {
      a(t.throw(l));
    } catch (h) {
      r(h);
    }
  }, a = (l) => l.done ? n(l.value) : Promise.resolve(l.value).then(s, o);
  a((t = t.apply(i, e)).next());
}), Zb = class extends Bh {
  constructor(e) {
    super(zc(zc({}, e), {
      state: "loading"
    })), this.loadImage = /* @__PURE__ */ Zf((n) => new Promise((r, s) => {
      const o = new Image();
      o.addEventListener("load", () => r(o)), o.addEventListener("error", () => s(new Error("load failed"))), o.src = n;
    }), "loadImage");
    const t = new sh(e.url);
    t.getHeader().then((n) => {
      const r = e.projection === void 0 ? "EPSG:3857" : e.projection;
      this.tileGrid = e.tileGrid || xr({
        extent: Hn(r),
        maxResolution: e.maxResolution,
        minZoom: n.minZoom,
        maxZoom: n.maxZoom,
        tileSize: e.tileSize
      }), this.setLoader((s, o, a) => hG(this, null, function* () {
        const l = yield t.getZxy(s, o, a);
        if (!l)
          return new Uint8Array();
        const h = URL.createObjectURL(new Blob([l.data])), u = yield this.loadImage(h);
        return URL.revokeObjectURL(h), u;
      })), this.setState("ready");
    });
  }
};
Zf(Zb, "PMTilesRasterSource");
var Z1 = Zb, Hb = class extends Ja {
  constructor(e) {
    super(zc(zc({}, e), {
      state: "loading",
      url: "pmtiles://{z}/{x}/{y}",
      format: e.format || new k0()
    })), this.tileLoadFunction = /* @__PURE__ */ Zf((t, n) => {
      const r = t, s = new RegExp(/pmtiles:\/\/(\d+)\/(\d+)\/(\d+)/), o = n.match(s);
      if (!(o && o.length >= 4))
        throw Error("Could not parse tile URL");
      const a = +o[1], l = +o[2], h = +o[3];
      r.setLoader(
        (u, c, f) => {
          this.pmtiles_.getZxy(a, l, h).then((g) => {
            if (g) {
              const d = r.getFormat();
              r.setFeatures(
                d.readFeatures(g.data, {
                  extent: u,
                  featureProjection: f
                })
              ), r.setState(X.LOADED);
            } else
              r.setFeatures([]), r.setState(X.EMPTY);
          }).catch((g) => {
            r.setFeatures([]), r.setState(X.ERROR);
          });
        }
      );
    }, "tileLoadFunction"), this.pmtiles_ = new sh(e.url), this.pmtiles_.getHeader().then((t) => {
      const n = e.projection || "EPSG:3857", r = e.extent || Hn(n);
      this.tileGrid = e.tileGrid || xr({
        extent: r,
        maxResolution: e.maxResolution,
        maxZoom: e.maxZoom !== void 0 ? e.maxZoom : t.maxZoom,
        minZoom: t.minZoom,
        tileSize: e.tileSize || 512
      }), this.setTileLoadFunction(this.tileLoadFunction), this.setState("ready");
    });
  }
};
Zf(Hb, "PMTilesVectorSource");
var uG = Hb;
class U0 extends Zr {
  /**
   * @param {Options} options Layer options.
   * @api
   */
  constructor(e) {
    const t = {};
    if ([
      "opacity",
      "visible",
      "zIndex",
      "minResolution",
      "maxResolution",
      "minZoom",
      "maxZoom",
      "properties"
    ].forEach((n) => t[n] = e[n]), super(t), this.getSourceOptions_ = e.getSourceOptions, this.children_ = null, this.childrenOptions_ = e.childrenOptions || {}, this.assets_ = null, this.bands_ = [], this.crossOrigin_ = e.crossOrigin || null, this.displayFootprint_ = e.displayFootprint !== !1, this.displayGeoTiffByDefault_ = !!e.displayGeoTiffByDefault, this.displayPreview_ = !!e.displayPreview, this.displayOverview_ = e.displayOverview !== !1, this.displayWebMapLink_ = e.displayWebMapLink || !1, this.buildTileUrlTemplate_ = e.buildTileUrlTemplate || null, this.useTileLayerAsFallback_ = e.useTileLayerAsFallback || !1, this.boundsStyle_ = e.boundsStyle || DD, this.collectionStyle_ = e.collectionStyle || B1, this.boundsLayer_ = null, this.disableMigration_ = e.disableMigration || !1, this.map_ = null, this.eventQueue_ = [], e.httpRequestFn && (this.fetch_ = e.httpRequestFn), e.data) {
      try {
        this.configure_(e.data, e.url, e.children, e.assets, e.bands);
      } catch (n) {
        this.handleError_(n);
      }
      return;
    }
    if (!e.url)
      throw new Error("Either url or data must be provided");
    this.fetch_(e.url).then((n) => this.configure_(n, e.url, e.children, e.assets, e.bands)).catch((n) => this.handleError_(n));
  }
  /**
   * Default function make HTTP requests with.
   *
   * @param {string} url The URL to request and the output is a promise that resolves with the response body.
   * @param {string} responseType The return type, either `json` (default) or `text`.
   * @return {Promise<*>} The (parsed) response body.
   */
  async fetch_(e, t = "json") {
    const n = await fetch(e);
    if (!n.ok)
      throw new Error(`Unexpected response from ${e}: ${n.status}`);
    return t === "json" ? await n.json() : t === "text" ? await n.text() : null;
  }
  /**
   * Returns the vector layer that visualizes the bounds / footprint.
   * @return {VectorLayer|null} The vector layer for the bounds
   * @api
   */
  getBoundsLayer() {
    return this.boundsLayer_;
  }
  /**
   * Returns `true` if the layer shows nothing.
   *
   * This method should be called after the layersready event only.
   *
   * @return {boolean} Is the layer empty?
   * @api
   */
  isEmpty() {
    var e;
    if (this.getLayers().getLength() > 1)
      return !1;
    const n = (e = this.getData()) === null || e === void 0 ? void 0 : e.getBoundingBox();
    return !n || qn(n) ? !0 : !this.boundsLayer_ || !this.displayFootprint_;
  }
  /**
   * @param {Error} error The error.
   * @private
   */
  handleError_(e) {
    this.dispatch_(new x4(e));
  }
  /**
   * @param {STAC|Asset|Object} data The STAC data.
   * @param {string} url The url to the data.
   * @param {ItemCollection|Object|Array<STAC>|string|null} children The child STAC entities to show.
   * @param {Array<Asset|string>|null} assets The assets to show.
   * @param {Array<number>} bands The (one-based) bands to show.
   * @private
   */
  configure_(e, t = null, n = null, r = null, s = []) {
    let o;
    e instanceof Sn || e instanceof Ar ? o = e : (o = Mu(e, !this.disableMigration_), t && t.includes("://") && o.setAbsoluteUrl(t)), this.set("stac", o), this.bands_ = s, this.boundsLayer_ = this.addFootprint_();
    const a = () => {
      this.boundsLayer_ && this.boundsLayer_.setStyle(j1(this.boundsStyle_, this));
    };
    this.getLayers().on("add", a), this.getLayers().on("remove", a);
    const l = (u) => this.handleError_(u), h = [];
    n && h.push(this.setChildren(n, null, !1).catch(l)), r && h.push(this.setAssets(r, !1).catch(l)), Promise.all(h).then(() => this.updateLayers().catch(l)), this.dispatch_("sourceready");
  }
  /**
   * Dispatch an event.
   * Move it to the queue if the map is not yet set.
   * This is necessary as otherwise some events would be
   * dispatched before someone could listen to them.
   *
   * @param {string|ErrorEvent} event The event.
   * @private
   */
  dispatch_(e) {
    this.eventQueue_.push(e), this.flush_();
  }
  /**
   * Flush all events.
   * @private
   */
  flush_() {
    if (this.map_) {
      for (const e of this.eventQueue_)
        this.dispatchEvent(e);
      this.eventQueue_ = [];
    }
  }
  /**
   * Set the map and flush all events.
   * The events should only be flushed once the map is set, otherwise some
   * functions such as getExtent() return no meaningul values.
   *
   * @param {Map} map The map
   */
  setMap_(e) {
    this.map_ !== e && (this.map_ = e, this.flush_());
  }
  /**
   * @param {Array<STAC>} collection The list of STAC entities to show.
   * @param {Options} [options] Options for the children.
   * @return {Promise} Resolves when complete.
   * @private
   */
  async addChildren_(e, t = {}) {
    const n = e.map((r) => {
      const s = {
        data: r,
        crossOrigin: this.crossOrigin_,
        boundsStyle: this.collectionStyle_,
        displayGeoTiffByDefault: this.displayGeoTiffByDefault_,
        displayOverview: this.displayOverview_,
        displayPreview: this.displayPreview_,
        displayFootprint: this.displayFootprint_,
        useTileLayerAsFallback: this.useTileLayerAsFallback_,
        buildTileUrlTemplate: this.buildTileUrlTemplate_
      }, o = new U0(Object.assign(s, t));
      return o.on("sourceready", () => {
        o.map_ && this.setMap_(o.map_);
      }), this.addLayer_(o, null), o;
    });
    return await Promise.all(n);
  }
  /**
   * @param {Asset|Link} [image] A STAC Link or Asset
   * @return {Promise<ImageLayer|undefined>} Resolves with am ImageLayer or udnefined when complete.
   * @private
   */
  async addPreviewImage_(e) {
    const t = await $1(e, "EPSG:4326"), n = e.getContext().getBoundingBoxes();
    if (n.length !== 1)
      return;
    const r = n[0];
    let s = {
      url: e.getAbsoluteUrl(),
      projection: t,
      imageExtent: Or(r, "EPSG:4326", t),
      crossOrigin: this.crossOrigin_
    };
    this.getSourceOptions_ && (s = await this.getSourceOptions_(pt.ImageStatic, s, e));
    const o = new P0({
      source: new Tb(s)
    });
    return this.addLayer_(o, e), o;
  }
  /**
   * Adds a layer for a link that implements the web-map-links extension.
   * Supports: PMTiles, TileJSON, WMS, WMTS, XYZ
   * @see https://github.com/stac-extensions/web-map-links
   * @param {Link} link A web map link
   * @return {Promise<Array<Layer>|undefined>} Resolves with a list of layers or undefined when complete.
   * @api
   */
  async addLayerForLink(e) {
    const t = kD(e);
    if (!t)
      return;
    const n = {
      attributions: e.getMetadata("attribution") || this.getData().getMetadata("attribution"),
      crossOrigin: this.crossOrigin_,
      url: t
    }, r = async (o, a) => (this.getSourceOptions_ && (a = await this.getSourceOptions_(o, a, e)), a), s = [];
    switch (e.rel) {
      case "pmtiles":
        const a = await new sh(n.url).getHeader();
        let l;
        switch (a.tileType) {
          case Vo.Mvt:
            l = new uG(await r(pt.PMTilesVector, n));
            break;
          case Vo.Avif:
          case Vo.Jpeg:
          case Vo.Png:
          case Vo.Webp:
            l = new Z1(await r(pt.PMTilesRaster, n));
            break;
          default:
            return;
        }
        s.push(l);
        break;
      case "tilejson":
        s.push(new qf(await r(pt.TileJSON, n)));
        break;
      case "wms":
        if (!Array.isArray(e["wms:layers"]))
          break;
        for (const c in e["wms:layers"]) {
          const f = e["wms:layers"][c] || "";
          let g = "";
          Array.isArray(e["wms:styles"]) && typeof e["wms:styles"][c] == "string" && (g = e["wms:styles"][c]);
          const d = Object.assign({
            LAYERS: f,
            STYLES: g
          }, e["wms:dimensions"]);
          typeof e["wms:transparent"] == "boolean" && (d.TRANSPARENT = String(e["wms:transparent"])), typeof e.type == "string" && e.type.startsWith("image/") && (d.FORMAT = e.type);
          const m = await r(pt.TileWMS, Object.assign({}, n, { params: d }));
          s.push(new rD(m));
        }
        break;
      case "wmts":
        const h = await this.getWmtsCapabilities_(t);
        if (!h)
          return;
        let u = [];
        Array.isArray(e["wmts:layer"]) ? u = e["wmts:layer"] : typeof e["wmts:layer"] == "string" && (u = [e["wmts:layer"]]);
        for (const c of u) {
          let f = Object.assign({}, n, { layer: c });
          typeof e.type == "string" && e.type.startsWith("image/") && (f.format = e.type), f = await r(pt.WMTS, f);
          const g = Ib(h, f);
          g !== null && s.push(new sD(g));
        }
        break;
      case "xyz":
        s.push(new kc(await r(pt.XYZ, n)));
        break;
      default:
        return;
    }
    return s.map((o) => {
      let a;
      return o instanceof Ja ? a = new da({
        source: o,
        declutter: !0
      }) : o instanceof Z1 ? a = new Nc({ source: o }) : a = new Gc({ source: o }), this.addLayer_(a, e), a;
    });
  }
  /**
   * @param {Asset} [asset] A STAC Asset
   * @return {Promise<Layer|undefined>} Resolves with a Layer or undefined when complete.
   * @private
   */
  async addGeoTiff_(e) {
    if (this.buildTileUrlTemplate_ && !this.useTileLayerAsFallback_)
      return await this.addTileLayerForImagery_(e);
    let n = {
      sources: [GD(e, this.bands_)],
      convertToRGB: "auto"
    };
    const r = await $1(e);
    r && (n.projection = r), this.getSourceOptions_ && (n = await this.getSourceOptions_(pt.GeoTIFF, n, e));
    const s = new R0(n), o = new Promise((a, l) => {
      s.on("error", l), s.on("change", () => {
        s.getState() === "error" ? l(s.getError()) : a();
      });
    });
    try {
      await o;
      const a = new Nc({ source: s });
      return this.addLayer_(a, e), a;
    } catch (a) {
      if (this.useTileLayerAsFallback_)
        return await this.addTileLayerForImagery_(e);
      this.handleError_(a);
    }
  }
  /**
   * @param {Asset|Link} [data] A STAC Asset or Link
   * @return {Promise<TileLayer>} Resolves with a TileLayer when complete.
   * @private
   */
  async addTileLayerForImagery_(e) {
    let t = this.buildTileUrlTemplate_(e);
    t instanceof Promise && (t = await t);
    let n = {
      crossOrigin: this.crossOrigin_,
      url: t
    };
    this.getSourceOptions_ && (n = await this.getSourceOptions_(pt.XYZ, n, e));
    const r = new Gc({
      source: new kc(n)
    });
    return this.addLayer_(r, e), r;
  }
  /**
   * @param {Layer|LayerGroup} [layer] A Layer to add to the LayerGroup
   * @param {import("stac-js").STACObject} [data] The STAC object, can be any class exposed by stac-js
   * @param {number} [zIndex=0] The z-index for the layer
   * @private
   */
  addLayer_(e, t = null, n = 0) {
    t && e.set("stac", t), e.setZIndex(n), this.getLayers().push(e);
  }
  /**
   * @return {VectorLayer|null} The vector layer showing the geometry/bbox.
   * @private
   */
  addFootprint_() {
    let e = null;
    const t = this.getData();
    if (t.isItemCollection() || t.isCollectionCollection() ? e = Nb(t.getBoundingBox()) : e = t.toGeoJSON(), e) {
      const n = this.createGeoJsonLayer_(e, j1(this.boundsStyle_, this), this.displayFootprint_);
      return n.set("bounds", !0), n.on("change", () => this.setMap_(n.getMapInternal())), this.addLayer_(n, t, 1), n;
    }
    return null;
  }
  /**
   * @param {Asset} [asset] A STAC Asset
   * @return {Promise<Layer|undefined>} Resolves with a Layer or undefined when complete.
   * @private
   */
  async addGeoJson_(e) {
    try {
      const t = await this.fetch_(e.getAbsoluteUrl()), n = this.createGeoJsonLayer_(t);
      return this.addLayer_(n, e), n;
    } catch (t) {
      this.handleError_(t);
    }
  }
  /**
   * Creates a GeoJSON vector layer from the given GeoJSON object.
   *
   * @param {GeoJSON} [geojson] The GeoJSON object.
   * @param {Style} [style] The style for the layer.
   * @param {boolean} [visible] Whether the layer is visible.
   * @return {VectorLayer} The new vector layer.
   * @private
   */
  createGeoJsonLayer_(e, t = null, n = !0) {
    const r = new Dc(), s = new ys({
      format: r,
      loader: (o, a, l) => {
        e = Yu(e);
        const h = r.readFeatures(e, {
          featureProjection: l
        });
        s.addFeatures(h);
      }
    });
    return t || (t = B1), new Nh({ source: s, style: t, visible: n });
  }
  /**
   * Adds GeoJSON labels and GeoTIFF source imagery to the map based on the label extension.
   *
   * @return {Promise<Layer|undefined>} The layer added to the map.
   * @private
   */
  async addLabelExtension_() {
    const e = this.getData();
    if (!(e instanceof Uc))
      return;
    let t = e.getAssetsWithRoles(["labels", "labels-vector"], !0), n;
    t.length > 1 && (n = t.find((s) => s.roles.includes("labels-vector"))), n || (n = e.getAsset("vector_labels")), n || (t = e.getAssets().filter((s) => s.type === cp && !s.roles), t.length === 1 && (n = t[0]));
    const r = e.getLinksWithRels(["source"]);
    if (n && r.length > 0) {
      const s = r.map(async (a) => {
        try {
          const l = await this.fetch_(a.getAbsoluteUrl());
          return Mu(l);
        } catch (l) {
          return this.handleError_(l), null;
        }
      }), o = (await Promise.all(s)).filter((a) => a instanceof Ar);
      await this.addChildren_(o, { displayFootprint: !1 });
    }
    try {
      await this.addGeoJson_(n);
    } catch (s) {
      this.handleError_(s);
    }
  }
  /**
   * Update the layers shown manually based on the current configuration.
   * Usually this doesn't need to be called manually.
   * @param {boolean} [emit=true] Whether to emit the `layersready` event once the layers are updated.
   * @return {Promise} Resolves once the layers are updated.
   * @api
   */
  async updateLayers(e = !0) {
    const t = this.getLayers();
    for (let s = t.getLength() - 1; s >= 0; s--) {
      const o = t.item(s);
      o.get("stac") && !o.get("bounds") && t.removeAt(s);
    }
    const n = this.getData();
    if (Array.isArray(this.displayWebMapLink_)) {
      const s = this.getWebMapLinks().map(async (o) => await this.addLayerForLink(o));
      await Promise.all(s);
    }
    this.children_ && await this.addChildren_(this.children_, this.childrenOptions_);
    const r = this.getAssets();
    if (r) {
      const s = r.map(async (o) => {
        if (o) {
          if (o.type === cp)
            return await this.addGeoJson_(o);
          if (o.isGeoTIFF())
            return await this.addGeoTiff_(o);
          if (o.canBrowserDisplayImage())
            return await this.addPreviewImage_(o);
        }
      });
      await Promise.all(s);
    }
    if (this.hasOnlyBounds()) {
      if (n instanceof D0)
        await this.addChildren_(n.getAll(), this.childrenOptions_);
      else if (n instanceof Ar) {
        if (n.isItem() && n.supportsExtension(ND) && n.getMetadata("label:type") === "vector") {
          await this.addLabelExtension_(), e && this.dispatch_("layersready");
          return;
        }
        const s = this.getWebMapLinks();
        if (s.length > 0)
          await this.addLayerForLink(s[0]);
        else {
          const o = n.getDefaultGeoTIFF(!0, !this.displayGeoTiffByDefault_);
          let a;
          if (o && this.displayOverview_ && (a = await this.addGeoTiff_(o)), this.displayPreview_ && (!o || !a)) {
            const l = n.getThumbnails(!0, "overview");
            l.length > 0 && await this.addPreviewImage_(l[0]);
          }
        }
      }
    }
    e && this.dispatch_("layersready");
  }
  /**
   * Indicates whether the LayerGroup shows only the bounds layer (i.e. no imagery/tile layers).
   * @return {boolean} `true` if only the bounds layer is shown, `false` otherwise.
   * @api
   */
  hasOnlyBounds() {
    const e = this.getBoundsLayer();
    return typeof this.getLayersArray().find((n) => n !== e) > "u";
  }
  /**
   * Returns all potential web map links based on the given value for `displayWebMapLink`.
   * @return {Array<Link>} An array of links.
   * @api
   */
  getWebMapLinks() {
    const e = this.getData();
    if (e instanceof Sn)
      return [];
    let t = ["xyz", "tilejson", "pmtiles", "wmts", "wms"];
    typeof this.displayWebMapLink_ == "string" && (t = [this.displayWebMapLink_]);
    let n = e.getLinksWithRels(t);
    return Array.isArray(this.displayWebMapLink_) ? n = this.displayWebMapLink_.map((r) => {
      if (typeof r == "string") {
        const s = n.find((o) => o.id === r);
        return s || null;
      }
      return r;
    }).filter((r) => !!r) : n.sort((r, s) => {
      const o = t.indexOf(r.rel), a = t.indexOf(s.rel);
      return o - a;
    }), n;
  }
  /**
   * Update the assets to be rendered.
   * @param {Array<string|Asset>|null} assets The assets to show.
   * @param {boolean} [updateLayers=true] Whether to update the layers right away.
   * @return {Promise} Resolves when all assets are rendered.
   * @api
   */
  async setAssets(e, t = !0) {
    if (e !== this.assets_) {
      if (Array.isArray(e)) {
        const n = this.getData();
        this.assets_ = e.map((r) => n instanceof Ar && typeof r == "string" ? n.getAsset(r) : r instanceof Sn ? r : new Sn(r));
      } else
        this.assets_ = null;
      t && await this.updateLayers();
    }
  }
  /**
   * Updates the children STAC entities to be rendered.
   *
   * If an object is passed, it must be a GeoJSON FeatureCollection.
   *
   * @param {ItemCollection|Object|Array<STAC|Object>|null} childs The children to show.
   * @param {Options|null} [options=null] Optionally, new STACLayer options for the children. Only applies if `children` are given.
   * @param {boolean} [updateLayers=true] Whether to update the layers right away.
   * @return {Promise} Resolves when all items are rendered.
   * @api
   */
  async setChildren(e, t = null, n = !0) {
    e instanceof Xb ? this.children_ = e.getAll() : vi(e) && e.type === "FeatureCollection" ? this.children_ = Mu(e, !this.disableMigration_).getAll() : Array.isArray(e) ? this.children_ = e.map((r) => r instanceof Ar ? r : Mu(r, !this.disableMigration_)) : this.children_ = null, this.children_ && this.children_.length === 0 && (this.children_ = null), this.children_ && vi(t) && (this.childrenOptions_ = t), n && await this.updateLayers();
  }
  /**
   * Get the STAC object.
   *
   * @return {STAC|Asset} The STAC object.
   * @api
   */
  getData() {
    return this.get("stac");
  }
  /**
   * Get the children STAC entities.
   *
   * @return {Array<STAC>} The STAC child entities.
   * @api
   */
  getChildren() {
    return this.children_;
  }
  /**
   * Get the STAC assets shown.
   *
   * @return {Array<Asset>} The STAC assets.
   * @api
   */
  getAssets() {
    return this.assets_;
  }
  /**
   * Get the extent of the layer.
   * If `displayFootprint` is set to `false`, the extent is always returned in
   * EPSG:4326 instead of the map projection. Make sure to transform it with the
   * ol.proj.transformExtent function if needed.
   *
   * @return {Extent|undefined} The layer extent.
   * @api
   */
  getExtent() {
    if (!this.map_)
      return;
    const e = this.map_.getView();
    if (!e)
      return;
    let t;
    const n = this.getData();
    n && (t = n.getBoundingBox());
    const r = this.getChildren();
    if (r) {
      const s = r.map((o) => o.getBoundingBox());
      t = F0(s);
    }
    if (t)
      return Or(t, "EPSG:4326", e.getProjection());
  }
  getLayerState() {
    const e = super.getLayerState();
    return e.extent = void 0, e;
  }
  /**
   * Get the attributions of the STAC entity assigned to this layer.
   *
   * @return {Array<string>} Attributions for this layer.
   * @api
   */
  getAttributions() {
    const e = [], t = this.getData();
    if (t) {
      const n = t.getMetadata("attribution");
      n && n.push(n);
    }
    return e;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   */
  getSource() {
    return null;
  }
  /**
   * Gets the WMTS capabilities from the given web-map-links URL.
   * @param {string} url Base URL for the WMTS
   * @return {Promise<Object|null>} Resolves with the WMTS Capabilities object
   * @private
   */
  async getWmtsCapabilities_(e) {
    try {
      const t = new URL(e);
      t.searchParams.set("service", "wmts"), t.searchParams.set("request", "GetCapabilities");
      const n = await this.fetch_(t.toString(), "text");
      return new Gm().read(n);
    } catch {
      return null;
    }
  }
}
var cG = 8, fG = {
  version: {
    required: !0,
    type: "enum",
    values: [
      8
    ]
  },
  name: {
    type: "string"
  },
  metadata: {
    type: "*"
  },
  center: {
    type: "array",
    value: "number"
  },
  centerAltitude: {
    type: "number"
  },
  zoom: {
    type: "number"
  },
  bearing: {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees"
  },
  pitch: {
    type: "number",
    default: 0,
    units: "degrees"
  },
  roll: {
    type: "number",
    default: 0,
    units: "degrees"
  },
  state: {
    type: "state",
    default: {}
  },
  light: {
    type: "light"
  },
  sky: {
    type: "sky"
  },
  projection: {
    type: "projection"
  },
  terrain: {
    type: "terrain"
  },
  sources: {
    required: !0,
    type: "sources"
  },
  sprite: {
    type: "sprite"
  },
  glyphs: {
    type: "string"
  },
  transition: {
    type: "transition"
  },
  layers: {
    required: !0,
    type: "array",
    value: "layer"
  }
}, dG = {
  "*": {
    type: "source"
  }
}, gG = [
  "source_vector",
  "source_raster",
  "source_raster_dem",
  "source_geojson",
  "source_video",
  "source_image"
], pG = {
  type: {
    required: !0,
    type: "enum",
    values: {
      vector: {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {},
      tms: {}
    },
    default: "xyz"
  },
  minzoom: {
    type: "number",
    default: 0
  },
  maxzoom: {
    type: "number",
    default: 22
  },
  attribution: {
    type: "string"
  },
  promoteId: {
    type: "promoteId"
  },
  volatile: {
    type: "boolean",
    default: !1
  },
  "*": {
    type: "*"
  }
}, mG = {
  type: {
    required: !0,
    type: "enum",
    values: {
      raster: {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  minzoom: {
    type: "number",
    default: 0
  },
  maxzoom: {
    type: "number",
    default: 22
  },
  tileSize: {
    type: "number",
    default: 512,
    units: "pixels"
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {},
      tms: {}
    },
    default: "xyz"
  },
  attribution: {
    type: "string"
  },
  volatile: {
    type: "boolean",
    default: !1
  },
  "*": {
    type: "*"
  }
}, _G = {
  type: {
    required: !0,
    type: "enum",
    values: {
      "raster-dem": {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  minzoom: {
    type: "number",
    default: 0
  },
  maxzoom: {
    type: "number",
    default: 22
  },
  tileSize: {
    type: "number",
    default: 512,
    units: "pixels"
  },
  attribution: {
    type: "string"
  },
  encoding: {
    type: "enum",
    values: {
      terrarium: {},
      mapbox: {},
      custom: {}
    },
    default: "mapbox"
  },
  redFactor: {
    type: "number",
    default: 1
  },
  blueFactor: {
    type: "number",
    default: 1
  },
  greenFactor: {
    type: "number",
    default: 1
  },
  baseShift: {
    type: "number",
    default: 0
  },
  volatile: {
    type: "boolean",
    default: !1
  },
  "*": {
    type: "*"
  }
}, yG = {
  type: {
    required: !0,
    type: "enum",
    values: {
      geojson: {}
    }
  },
  data: {
    required: !0,
    type: "*"
  },
  maxzoom: {
    type: "number",
    default: 18
  },
  attribution: {
    type: "string"
  },
  buffer: {
    type: "number",
    default: 128,
    maximum: 512,
    minimum: 0
  },
  filter: {
    type: "*"
  },
  tolerance: {
    type: "number",
    default: 0.375
  },
  cluster: {
    type: "boolean",
    default: !1
  },
  clusterRadius: {
    type: "number",
    default: 50,
    minimum: 0
  },
  clusterMaxZoom: {
    type: "number"
  },
  clusterMinPoints: {
    type: "number"
  },
  clusterProperties: {
    type: "*"
  },
  lineMetrics: {
    type: "boolean",
    default: !1
  },
  generateId: {
    type: "boolean",
    default: !1
  },
  promoteId: {
    type: "promoteId"
  }
}, xG = {
  type: {
    required: !0,
    type: "enum",
    values: {
      video: {}
    }
  },
  urls: {
    required: !0,
    type: "array",
    value: "string"
  },
  coordinates: {
    required: !0,
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number"
    }
  }
}, EG = {
  type: {
    required: !0,
    type: "enum",
    values: {
      image: {}
    }
  },
  url: {
    required: !0,
    type: "string"
  },
  coordinates: {
    required: !0,
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number"
    }
  }
}, vG = {
  id: {
    type: "string",
    required: !0
  },
  type: {
    type: "enum",
    values: {
      fill: {},
      line: {},
      symbol: {},
      circle: {},
      heatmap: {},
      "fill-extrusion": {},
      raster: {},
      hillshade: {},
      "color-relief": {},
      background: {}
    },
    required: !0
  },
  metadata: {
    type: "*"
  },
  source: {
    type: "string"
  },
  "source-layer": {
    type: "string"
  },
  minzoom: {
    type: "number",
    minimum: 0,
    maximum: 24
  },
  maxzoom: {
    type: "number",
    minimum: 0,
    maximum: 24
  },
  filter: {
    type: "filter"
  },
  layout: {
    type: "layout"
  },
  paint: {
    type: "paint"
  }
}, wG = [
  "layout_fill",
  "layout_line",
  "layout_circle",
  "layout_heatmap",
  "layout_fill-extrusion",
  "layout_symbol",
  "layout_raster",
  "layout_hillshade",
  "layout_color-relief",
  "layout_background"
], bG = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, SG = {
  "fill-sort-key": {
    type: "number",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, TG = {
  "circle-sort-key": {
    type: "number",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, RG = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, PG = {
  "line-cap": {
    type: "enum",
    values: {
      butt: {},
      round: {},
      square: {}
    },
    default: "butt",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-join": {
    type: "enum",
    values: {
      bevel: {},
      round: {},
      miter: {}
    },
    default: "miter",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "line-miter-limit": {
    type: "number",
    default: 2,
    requires: [
      {
        "line-join": "miter"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-round-limit": {
    type: "number",
    default: 1.05,
    requires: [
      {
        "line-join": "round"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-sort-key": {
    type: "number",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, MG = {
  "symbol-placement": {
    type: "enum",
    values: {
      point: {},
      line: {},
      "line-center": {}
    },
    default: "point",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-spacing": {
    type: "number",
    default: 250,
    minimum: 1,
    units: "pixels",
    requires: [
      {
        "symbol-placement": "line"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-avoid-edges": {
    type: "boolean",
    default: !1,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-sort-key": {
    type: "number",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "symbol-z-order": {
    type: "enum",
    values: {
      auto: {},
      "viewport-y": {},
      source: {}
    },
    default: "auto",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-allow-overlap": {
    type: "boolean",
    default: !1,
    requires: [
      "icon-image",
      {
        "!": "icon-overlap"
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-overlap": {
    type: "enum",
    values: {
      never: {},
      always: {},
      cooperative: {}
    },
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-ignore-placement": {
    type: "boolean",
    default: !1,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-optional": {
    type: "boolean",
    default: !1,
    requires: [
      "icon-image",
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-rotation-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    default: "auto",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-size": {
    type: "number",
    default: 1,
    minimum: 0,
    units: "factor of the original icon size",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-text-fit": {
    type: "enum",
    values: {
      none: {},
      width: {},
      height: {},
      both: {}
    },
    default: "none",
    requires: [
      "icon-image",
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-text-fit-padding": {
    type: "array",
    value: "number",
    length: 4,
    default: [
      0,
      0,
      0,
      0
    ],
    units: "pixels",
    requires: [
      "icon-image",
      "text-field",
      {
        "icon-text-fit": [
          "both",
          "width",
          "height"
        ]
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-image": {
    type: "resolvedImage",
    tokens: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-rotate": {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-padding": {
    type: "padding",
    default: [
      2
    ],
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-keep-upright": {
    type: "boolean",
    default: !1,
    requires: [
      "icon-image",
      {
        "icon-rotation-alignment": "map"
      },
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-offset": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-anchor": {
    type: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    default: "center",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    default: "auto",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    default: "auto",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-rotation-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      "viewport-glyph": {},
      auto: {}
    },
    default: "auto",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-field": {
    type: "formatted",
    default: "",
    tokens: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-font": {
    type: "array",
    value: "string",
    default: [
      "Open Sans Regular",
      "Arial Unicode MS Regular"
    ],
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-size": {
    type: "number",
    default: 16,
    minimum: 0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-max-width": {
    type: "number",
    default: 10,
    minimum: 0,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-line-height": {
    type: "number",
    default: 1.2,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-letter-spacing": {
    type: "number",
    default: 0,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-justify": {
    type: "enum",
    values: {
      auto: {},
      left: {},
      center: {},
      right: {}
    },
    default: "center",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-radial-offset": {
    type: "number",
    units: "ems",
    default: 0,
    requires: [
      "text-field"
    ],
    "property-type": "data-driven",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    }
  },
  "text-variable-anchor": {
    type: "array",
    value: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-variable-anchor-offset": {
    type: "variableAnchorOffsetCollection",
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-anchor": {
    type: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    default: "center",
    requires: [
      "text-field",
      {
        "!": "text-variable-anchor"
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-max-angle": {
    type: "number",
    default: 45,
    units: "degrees",
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-writing-mode": {
    type: "array",
    value: "enum",
    values: {
      horizontal: {},
      vertical: {}
    },
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-rotate": {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-padding": {
    type: "number",
    default: 2,
    minimum: 0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-keep-upright": {
    type: "boolean",
    default: !0,
    requires: [
      "text-field",
      {
        "text-rotation-alignment": "map"
      },
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-transform": {
    type: "enum",
    values: {
      none: {},
      uppercase: {},
      lowercase: {}
    },
    default: "none",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-offset": {
    type: "array",
    value: "number",
    units: "ems",
    length: 2,
    default: [
      0,
      0
    ],
    requires: [
      "text-field",
      {
        "!": "text-radial-offset"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-allow-overlap": {
    type: "boolean",
    default: !1,
    requires: [
      "text-field",
      {
        "!": "text-overlap"
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-overlap": {
    type: "enum",
    values: {
      never: {},
      always: {},
      cooperative: {}
    },
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-ignore-placement": {
    type: "boolean",
    default: !1,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-optional": {
    type: "boolean",
    default: !1,
    requires: [
      "text-field",
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, CG = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, AG = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, IG = {
  type: "array",
  value: "*"
}, LG = {
  type: "enum",
  values: {
    "==": {},
    "!=": {},
    ">": {},
    ">=": {},
    "<": {},
    "<=": {},
    in: {},
    "!in": {},
    all: {},
    any: {},
    none: {},
    has: {},
    "!has": {}
  }
}, FG = {
  type: "enum",
  values: {
    Point: {},
    LineString: {},
    Polygon: {}
  }
}, OG = {
  type: "array",
  minimum: 0,
  maximum: 24,
  value: [
    "number",
    "color"
  ],
  length: 2
}, NG = {
  type: "array",
  value: "*",
  minimum: 1
}, DG = {
  anchor: {
    type: "enum",
    default: "viewport",
    values: {
      map: {},
      viewport: {}
    },
    "property-type": "data-constant",
    transition: !1,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    }
  },
  position: {
    type: "array",
    default: [
      1.15,
      210,
      30
    ],
    length: 3,
    value: "number",
    "property-type": "data-constant",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    }
  },
  color: {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  intensity: {
    type: "number",
    "property-type": "data-constant",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  }
}, GG = {
  "sky-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#88C6FC",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "horizon-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "fog-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "fog-ground-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "horizon-fog-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "sky-horizon-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "atmosphere-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  }
}, kG = {
  source: {
    type: "string",
    required: !0
  },
  exaggeration: {
    type: "number",
    minimum: 0,
    default: 1
  }
}, UG = {
  type: {
    type: "projectionDefinition",
    default: "mercator",
    "property-type": "data-constant",
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    }
  }
}, zG = [
  "paint_fill",
  "paint_line",
  "paint_circle",
  "paint_heatmap",
  "paint_fill-extrusion",
  "paint_symbol",
  "paint_raster",
  "paint_hillshade",
  "paint_color-relief",
  "paint_background"
], BG = {
  "fill-antialias": {
    type: "boolean",
    default: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    requires: [
      {
        "!": "fill-pattern"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-outline-color": {
    type: "color",
    transition: !0,
    requires: [
      {
        "!": "fill-pattern"
      },
      {
        "fill-antialias": !0
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "fill-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-pattern": {
    type: "resolvedImage",
    transition: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "cross-faded-data-driven"
  }
}, $G = {
  "line-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    requires: [
      {
        "!": "line-pattern"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "line-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-width": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-gap-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-offset": {
    type: "number",
    default: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-dasharray": {
    type: "array",
    value: "number",
    minimum: 0,
    transition: !0,
    units: "line widths",
    requires: [
      {
        "!": "line-pattern"
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "cross-faded"
  },
  "line-pattern": {
    type: "resolvedImage",
    transition: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "cross-faded-data-driven"
  },
  "line-gradient": {
    type: "color",
    transition: !1,
    requires: [
      {
        "!": "line-dasharray"
      },
      {
        "!": "line-pattern"
      },
      {
        source: "geojson",
        has: {
          lineMetrics: !0
        }
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "line-progress"
      ]
    },
    "property-type": "color-ramp"
  }
}, jG = {
  "circle-radius": {
    type: "number",
    default: 5,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-blur": {
    type: "number",
    default: 0,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "circle-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-scale": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "viewport",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-stroke-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  }
}, XG = {
  "heatmap-radius": {
    type: "number",
    default: 30,
    minimum: 1,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "heatmap-weight": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "heatmap-intensity": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "heatmap-color": {
    type: "color",
    default: [
      "interpolate",
      [
        "linear"
      ],
      [
        "heatmap-density"
      ],
      0,
      "rgba(0, 0, 255, 0)",
      0.1,
      "royalblue",
      0.3,
      "cyan",
      0.5,
      "lime",
      0.7,
      "yellow",
      1,
      "red"
    ],
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "heatmap-density"
      ]
    },
    "property-type": "color-ramp"
  },
  "heatmap-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, VG = {
  "icon-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-color": {
    type: "color",
    default: "rgba(0, 0, 0, 0)",
    transition: !0,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "icon-image",
      "icon-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    overridable: !0,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-color": {
    type: "color",
    default: "rgba(0, 0, 0, 0)",
    transition: !0,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "text-field",
      "text-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, WG = {
  "raster-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-hue-rotate": {
    type: "number",
    default: 0,
    period: 360,
    transition: !0,
    units: "degrees",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-min": {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-max": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-saturation": {
    type: "number",
    default: 0,
    minimum: -1,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-contrast": {
    type: "number",
    default: 0,
    minimum: -1,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-resampling": {
    type: "enum",
    values: {
      linear: {},
      nearest: {}
    },
    default: "linear",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-fade-duration": {
    type: "number",
    default: 300,
    minimum: 0,
    transition: !1,
    units: "milliseconds",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, YG = {
  "hillshade-illumination-direction": {
    type: "numberArray",
    default: 335,
    minimum: 0,
    maximum: 359,
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-illumination-altitude": {
    type: "numberArray",
    default: 45,
    minimum: 0,
    maximum: 90,
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-illumination-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "viewport",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-exaggeration": {
    type: "number",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-shadow-color": {
    type: "colorArray",
    default: "#000000",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-highlight-color": {
    type: "colorArray",
    default: "#FFFFFF",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-accent-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-method": {
    type: "enum",
    values: {
      standard: {},
      basic: {},
      combined: {},
      igor: {},
      multidirectional: {}
    },
    default: "standard",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, qG = {
  "background-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    requires: [
      {
        "!": "background-pattern"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "background-pattern": {
    type: "resolvedImage",
    transition: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "cross-faded"
  },
  "background-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, ZG = {
  duration: {
    type: "number",
    default: 300,
    minimum: 0,
    units: "milliseconds"
  },
  delay: {
    type: "number",
    default: 0,
    minimum: 0,
    units: "milliseconds"
  }
}, HG = {
  "*": {
    type: "string"
  }
}, KG = {
  $version: cG,
  $root: fG,
  sources: dG,
  source: gG,
  source_vector: pG,
  source_raster: mG,
  source_raster_dem: _G,
  source_geojson: yG,
  source_video: xG,
  source_image: EG,
  layer: vG,
  layout: wG,
  layout_background: bG,
  layout_fill: SG,
  layout_circle: TG,
  layout_heatmap: RG,
  "layout_fill-extrusion": {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  },
  layout_line: PG,
  layout_symbol: MG,
  layout_raster: CG,
  layout_hillshade: AG,
  "layout_color-relief": {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  },
  filter: IG,
  filter_operator: LG,
  geometry_type: FG,
  function: {
    expression: {
      type: "expression"
    },
    stops: {
      type: "array",
      value: "function_stop"
    },
    base: {
      type: "number",
      default: 1,
      minimum: 0
    },
    property: {
      type: "string",
      default: "$zoom"
    },
    type: {
      type: "enum",
      values: {
        identity: {},
        exponential: {},
        interval: {},
        categorical: {}
      },
      default: "exponential"
    },
    colorSpace: {
      type: "enum",
      values: {
        rgb: {},
        lab: {},
        hcl: {}
      },
      default: "rgb"
    },
    default: {
      type: "*",
      required: !1
    }
  },
  function_stop: OG,
  expression: NG,
  light: DG,
  sky: GG,
  terrain: kG,
  projection: UG,
  paint: zG,
  paint_fill: BG,
  "paint_fill-extrusion": {
    "fill-extrusion-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-color": {
      type: "color",
      default: "#000000",
      transition: !0,
      requires: [
        {
          "!": "fill-extrusion-pattern"
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-translate": {
      type: "array",
      value: "number",
      length: 2,
      default: [
        0,
        0
      ],
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-translate-anchor": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      default: "map",
      requires: [
        "fill-extrusion-translate"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-pattern": {
      type: "resolvedImage",
      transition: !0,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "cross-faded-data-driven"
    },
    "fill-extrusion-height": {
      type: "number",
      default: 0,
      minimum: 0,
      units: "meters",
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-base": {
      type: "number",
      default: 0,
      minimum: 0,
      units: "meters",
      transition: !0,
      requires: [
        "fill-extrusion-height"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-vertical-gradient": {
      type: "boolean",
      default: !0,
      transition: !1,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    }
  },
  paint_line: $G,
  paint_circle: jG,
  paint_heatmap: XG,
  paint_symbol: VG,
  paint_raster: WG,
  paint_hillshade: YG,
  "paint_color-relief": {
    "color-relief-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "color-relief-color": {
      type: "color",
      transition: !1,
      expression: {
        interpolated: !0,
        parameters: [
          "elevation"
        ]
      },
      "property-type": "color-ramp"
    }
  },
  paint_background: qG,
  transition: ZG,
  "property-type": {
    "data-driven": {
      type: "property-type"
    },
    "cross-faded": {
      type: "property-type"
    },
    "cross-faded-data-driven": {
      type: "property-type"
    },
    "color-ramp": {
      type: "property-type"
    },
    "data-constant": {
      type: "property-type"
    },
    constant: {
      type: "property-type"
    }
  },
  promoteId: HG
};
const JG = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
function QG(i, e) {
  const t = {};
  for (const n in i)
    n !== "ref" && (t[n] = i[n]);
  return JG.forEach((n) => {
    n in e && (t[n] = e[n]);
  }), t;
}
function Kb(i) {
  i = i.slice();
  const e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < i.length; t++)
    e[i[t].id] = i[t];
  for (let t = 0; t < i.length; t++)
    "ref" in i[t] && (i[t] = QG(i[t], e[i[t].ref]));
  return i;
}
class or extends Error {
  constructor(e, t) {
    super(t), this.message = t, this.key = e;
  }
}
class z0 {
  constructor(e, t = []) {
    this.parent = e, this.bindings = {};
    for (const [n, r] of t)
      this.bindings[n] = r;
  }
  concat(e) {
    return new z0(this, e);
  }
  get(e) {
    if (this.bindings[e])
      return this.bindings[e];
    if (this.parent)
      return this.parent.get(e);
    throw new Error(`${e} not found in scope.`);
  }
  has(e) {
    return this.bindings[e] ? !0 : this.parent ? this.parent.has(e) : !1;
  }
}
const Hf = { kind: "null" }, K = { kind: "number" }, Oe = { kind: "string" }, Ie = { kind: "boolean" }, cr = { kind: "color" }, Kf = { kind: "projectionDefinition" }, Qs = { kind: "object" }, Me = { kind: "value" }, e8 = { kind: "error" }, Jf = { kind: "collator" }, Qf = { kind: "formatted" }, ed = { kind: "padding" }, lh = { kind: "colorArray" }, td = { kind: "numberArray" }, Xh = { kind: "resolvedImage" }, id = { kind: "variableAnchorOffsetCollection" };
function tn(i, e) {
  return {
    kind: "array",
    itemType: i,
    N: e
  };
}
function bt(i) {
  if (i.kind === "array") {
    const e = bt(i.itemType);
    return typeof i.N == "number" ? `array<${e}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${e}>`;
  } else
    return i.kind;
}
const t8 = [
  Hf,
  K,
  Oe,
  Ie,
  cr,
  Kf,
  Qf,
  Qs,
  tn(Me),
  ed,
  td,
  lh,
  Xh,
  id
];
function hh(i, e) {
  if (e.kind === "error")
    return null;
  if (i.kind === "array") {
    if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !hh(i.itemType, e.itemType)) && (typeof i.N != "number" || i.N === e.N))
      return null;
  } else {
    if (i.kind === e.kind)
      return null;
    if (i.kind === "value") {
      for (const t of t8)
        if (!hh(t, e))
          return null;
    }
  }
  return `Expected ${bt(i)} but found ${bt(e)} instead.`;
}
function B0(i, e) {
  return e.some((t) => t.kind === i.kind);
}
function eo(i, e) {
  return e.some((t) => t === "null" ? i === null : t === "array" ? Array.isArray(i) : t === "object" ? i && !Array.isArray(i) && typeof i == "object" : t === typeof i);
}
function ns(i, e) {
  return i.kind === "array" && e.kind === "array" ? i.itemType.kind === e.itemType.kind && typeof i.N == "number" : i.kind === e.kind;
}
const Jb = 0.96422, Qb = 1, eS = 0.82521, tS = 4 / 29, ga = 6 / 29, iS = 3 * ga * ga, i8 = ga * ga * ga, n8 = Math.PI / 180, r8 = 180 / Math.PI;
function nS(i) {
  return i = i % 360, i < 0 && (i += 360), i;
}
function rS([i, e, t, n]) {
  i = sg(i), e = sg(e), t = sg(t);
  let r, s;
  const o = og((0.2225045 * i + 0.7168786 * e + 0.0606169 * t) / Qb);
  i === e && e === t ? r = s = o : (r = og((0.4360747 * i + 0.3850649 * e + 0.1430804 * t) / Jb), s = og((0.0139322 * i + 0.0971045 * e + 0.7141733 * t) / eS));
  const a = 116 * o - 16;
  return [a < 0 ? 0 : a, 500 * (r - o), 200 * (o - s), n];
}
function sg(i) {
  return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
}
function og(i) {
  return i > i8 ? Math.pow(i, 1 / 3) : i / iS + tS;
}
function sS([i, e, t, n]) {
  let r = (i + 16) / 116, s = isNaN(e) ? r : r + e / 500, o = isNaN(t) ? r : r - t / 200;
  return r = Qb * lg(r), s = Jb * lg(s), o = eS * lg(o), [
    ag(3.1338561 * s - 1.6168667 * r - 0.4906146 * o),
    // D50 -> sRGB
    ag(-0.9787684 * s + 1.9161415 * r + 0.033454 * o),
    ag(0.0719453 * s - 0.2289914 * r + 1.4052427 * o),
    n
  ];
}
function ag(i) {
  return i = i <= 304e-5 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - 0.055, i < 0 ? 0 : i > 1 ? 1 : i;
}
function lg(i) {
  return i > ga ? i * i * i : iS * (i - tS);
}
function s8(i) {
  const [e, t, n, r] = rS(i), s = Math.sqrt(t * t + n * n);
  return [Math.round(s * 1e4) ? nS(Math.atan2(n, t) * r8) : NaN, s, e, r];
}
function o8([i, e, t, n]) {
  return i = isNaN(i) ? 0 : i * n8, sS([t, Math.cos(i) * e, Math.sin(i) * e, n]);
}
function a8([i, e, t, n]) {
  i = nS(i), e /= 100, t /= 100;
  function r(s) {
    const o = (s + i / 30) % 12, a = e * Math.min(t, 1 - t);
    return t - a * Math.max(-1, Math.min(o - 3, 9 - o, 1));
  }
  return [r(0), r(8), r(4), n];
}
const l8 = Object.hasOwn || function(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
};
function oS(i, e) {
  return l8(i, e) ? i[e] : void 0;
}
function h8(i) {
  if (i = i.toLowerCase().trim(), i === "transparent")
    return [0, 0, 0, 0];
  const e = oS(u8, i);
  if (e) {
    const [r, s, o] = e;
    return [r / 255, s / 255, o / 255, 1];
  }
  if (i.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(i)) {
    const s = i.length < 6 ? 1 : 2;
    let o = 1;
    return [
      Iu(i.slice(o, o += s)),
      Iu(i.slice(o, o += s)),
      Iu(i.slice(o, o += s)),
      Iu(i.slice(o, o + s) || "ff")
    ];
  }
  if (i.startsWith("rgb")) {
    const r = /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, s = i.match(r);
    if (s) {
      const [
        o,
        // eslint-disable-line @typescript-eslint/no-unused-vars
        a,
        // <numeric>
        l,
        // %         (optional)
        h,
        // ,         (optional)
        u,
        // <numeric>
        c,
        // %         (optional)
        f,
        // ,         (optional)
        g,
        // <numeric>
        d,
        // %         (optional)
        m,
        // ,|/       (optional)
        x,
        // <numeric> (optional)
        v
        // %         (optional)
      ] = s, p = [h || " ", f || " ", m].join("");
      if (p === "  " || p === "  /" || p === ",," || p === ",,,") {
        const y = [l, c, d].join(""), E = y === "%%%" ? 100 : y === "" ? 255 : 0;
        if (E) {
          const b = [
            Wo(+a / E, 0, 1),
            Wo(+u / E, 0, 1),
            Wo(+g / E, 0, 1),
            x ? H1(+x, v) : 1
          ];
          if (K1(b))
            return b;
        }
      }
      return;
    }
  }
  const t = /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, n = i.match(t);
  if (n) {
    const [
      r,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      s,
      // <numeric>
      o,
      // ,         (optional)
      a,
      // <numeric>
      l,
      // ,         (optional)
      h,
      // <numeric>
      u,
      // ,|/       (optional)
      c,
      // <numeric> (optional)
      f
      // %         (optional)
    ] = n, g = [o || " ", l || " ", u].join("");
    if (g === "  " || g === "  /" || g === ",," || g === ",,,") {
      const d = [
        +s,
        Wo(+a, 0, 100),
        Wo(+h, 0, 100),
        c ? H1(+c, f) : 1
      ];
      if (K1(d))
        return a8(d);
    }
  }
}
function Iu(i) {
  return parseInt(i.padEnd(2, i), 16) / 255;
}
function H1(i, e) {
  return Wo(e ? i / 100 : i, 0, 1);
}
function Wo(i, e, t) {
  return Math.min(Math.max(e, i), t);
}
function K1(i) {
  return !i.some(Number.isNaN);
}
const u8 = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
function to(i, e, t) {
  return i + t * (e - i);
}
function uh(i, e, t) {
  return i.map((n, r) => to(n, e[r], t));
}
class et {
  /**
   * @param r Red component premultiplied by `alpha` 0..1
   * @param g Green component premultiplied by `alpha` 0..1
   * @param b Blue component premultiplied by `alpha` 0..1
   * @param [alpha=1] Alpha component 0..1
   * @param [premultiplied=true] Whether the `r`, `g` and `b` values have already
   * been multiplied by alpha. If `true` nothing happens if `false` then they will
   * be multiplied automatically.
   */
  constructor(e, t, n, r = 1, s = !0) {
    this.r = e, this.g = t, this.b = n, this.a = r, s || (this.r *= r, this.g *= r, this.b *= r, r || this.overwriteGetter("rgb", [e, t, n, r]));
  }
  /**
   * Parses CSS color strings and converts colors to sRGB color space if needed.
   * Officially supported color formats:
   * - keyword, e.g. 'aquamarine' or 'steelblue'
   * - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'
   * - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'
   * - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'
   *
   * @param input CSS color string to parse.
   * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
   */
  static parse(e) {
    if (e instanceof et)
      return e;
    if (typeof e != "string")
      return;
    const t = h8(e);
    if (t)
      return new et(...t, !1);
  }
  /**
   * Used in color interpolation and by 'to-rgba' expression.
   *
   * @returns Gien color, with reversed alpha blending, in sRGB color space.
   */
  get rgb() {
    const { r: e, g: t, b: n, a: r } = this, s = r || 1 / 0;
    return this.overwriteGetter("rgb", [e / s, t / s, n / s, r]);
  }
  /**
   * Used in color interpolation.
   *
   * @returns Gien color, with reversed alpha blending, in HCL color space.
   */
  get hcl() {
    return this.overwriteGetter("hcl", s8(this.rgb));
  }
  /**
   * Used in color interpolation.
   *
   * @returns Gien color, with reversed alpha blending, in LAB color space.
   */
  get lab() {
    return this.overwriteGetter("lab", rS(this.rgb));
  }
  /**
   * Lazy getter pattern. When getter is called for the first time lazy value
   * is calculated and then overwrites getter function in given object instance.
   *
   * @example:
   * const redColor = Color.parse('red');
   * let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate
   * // the value of red in HCL space and invoke this `overwriteGetter` function
   * // which in turn will set a field with a key 'hcl' in the `redColor` object.
   * // In other words it will override `get hcl()` from its `Color` prototype
   * // with its own property: hcl = [calculated red value in hcl].
   * let y = redColor.hcl; // next call will no longer invoke getter but simply
   * // return the previously calculated value
   * x === y; // true - `x` is exactly the same object as `y`
   *
   * @param getterKey Getter key
   * @param lazyValue Lazily calculated value to be memoized by current instance
   * @private
   */
  overwriteGetter(e, t) {
    return Object.defineProperty(this, e, { value: t }), t;
  }
  /**
   * Used by 'to-string' expression.
   *
   * @returns Serialized color in format `rgba(r,g,b,a)`
   * where r,g,b are numbers within 0..255 and alpha is number within 1..0
   *
   * @example
   * var purple = new Color.parse('purple');
   * purple.toString; // = "rgba(128,0,128,1)"
   * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
   * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
   */
  toString() {
    const [e, t, n, r] = this.rgb;
    return `rgba(${[e, t, n].map((s) => Math.round(s * 255)).join(",")},${r})`;
  }
  static interpolate(e, t, n, r = "rgb") {
    switch (r) {
      case "rgb": {
        const [s, o, a, l] = uh(e.rgb, t.rgb, n);
        return new et(s, o, a, l, !1);
      }
      case "hcl": {
        const [s, o, a, l] = e.hcl, [h, u, c, f] = t.hcl;
        let g, d;
        if (!isNaN(s) && !isNaN(h)) {
          let y = h - s;
          h > s && y > 180 ? y -= 360 : h < s && s - h > 180 && (y += 360), g = s + n * y;
        } else isNaN(s) ? isNaN(h) ? g = NaN : (g = h, (a === 1 || a === 0) && (d = u)) : (g = s, (c === 1 || c === 0) && (d = o));
        const [m, x, v, p] = o8([
          g,
          d ?? to(o, u, n),
          to(a, c, n),
          to(l, f, n)
        ]);
        return new et(m, x, v, p, !1);
      }
      case "lab": {
        const [s, o, a, l] = sS(uh(e.lab, t.lab, n));
        return new et(s, o, a, l, !1);
      }
    }
  }
}
et.black = new et(0, 0, 0, 1);
et.white = new et(1, 1, 1, 1);
et.transparent = new et(0, 0, 0, 0);
et.red = new et(1, 0, 0, 1);
class $0 {
  constructor(e, t, n) {
    e ? this.sensitivity = t ? "variant" : "case" : this.sensitivity = t ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
  }
  compare(e, t) {
    return this.collator.compare(e, t);
  }
  resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }
}
const c8 = ["bottom", "center", "top"];
class pp {
  constructor(e, t, n, r, s, o) {
    this.text = e, this.image = t, this.scale = n, this.fontStack = r, this.textColor = s, this.verticalAlign = o;
  }
}
class kr {
  constructor(e) {
    this.sections = e;
  }
  static fromString(e) {
    return new kr([new pp(e, null, null, null, null, null)]);
  }
  isEmpty() {
    return this.sections.length === 0 ? !0 : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
  }
  static factory(e) {
    return e instanceof kr ? e : kr.fromString(e);
  }
  toString() {
    return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
  }
}
class zn {
  constructor(e) {
    this.values = e.slice();
  }
  /**
   * Numeric padding values
   * @param input A padding value
   * @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.
   */
  static parse(e) {
    if (e instanceof zn)
      return e;
    if (typeof e == "number")
      return new zn([e, e, e, e]);
    if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
      for (const t of e)
        if (typeof t != "number")
          return;
      switch (e.length) {
        case 1:
          e = [e[0], e[0], e[0], e[0]];
          break;
        case 2:
          e = [e[0], e[1], e[0], e[1]];
          break;
        case 3:
          e = [e[0], e[1], e[2], e[1]];
          break;
      }
      return new zn(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, t, n) {
    return new zn(uh(e.values, t.values, n));
  }
}
class Bn {
  constructor(e) {
    this.values = e.slice();
  }
  /**
   * Numeric NumberArray values
   * @param input A NumberArray value
   * @returns A `NumberArray` instance, or `undefined` if the input is not a valid NumberArray value.
   */
  static parse(e) {
    if (e instanceof Bn)
      return e;
    if (typeof e == "number")
      return new Bn([e]);
    if (Array.isArray(e)) {
      for (const t of e)
        if (typeof t != "number")
          return;
      return new Bn(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, t, n) {
    return new Bn(uh(e.values, t.values, n));
  }
}
class sn {
  constructor(e) {
    this.values = e.slice();
  }
  /**
   * ColorArray values
   * @param input A ColorArray value
   * @returns A `ColorArray` instance, or `undefined` if the input is not a valid ColorArray value.
   */
  static parse(e) {
    if (e instanceof sn)
      return e;
    if (typeof e == "string") {
      const n = et.parse(e);
      return n ? new sn([n]) : void 0;
    }
    if (!Array.isArray(e))
      return;
    const t = [];
    for (const n of e) {
      if (typeof n != "string")
        return;
      const r = et.parse(n);
      if (!r)
        return;
      t.push(r);
    }
    return new sn(t);
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, t, n, r = "rgb") {
    const s = [];
    if (e.values.length != t.values.length)
      throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${t.values.length}), cannot interpolate.`);
    for (let o = 0; o < e.values.length; o++)
      s.push(et.interpolate(e.values[o], t.values[o], n, r));
    return new sn(s);
  }
}
class Ct extends Error {
  constructor(e) {
    super(e), this.name = "RuntimeError";
  }
  toJSON() {
    return this.message;
  }
}
const f8 = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
class fr {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof fr)
      return e;
    if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {
      for (let t = 0; t < e.length; t += 2) {
        const n = e[t], r = e[t + 1];
        if (typeof n != "string" || !f8.has(n) || !Array.isArray(r) || r.length !== 2 || typeof r[0] != "number" || typeof r[1] != "number")
          return;
      }
      return new fr(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, t, n) {
    const r = e.values, s = t.values;
    if (r.length !== s.length)
      throw new Ct(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${t.toString()}`);
    const o = [];
    for (let a = 0; a < r.length; a += 2) {
      if (r[a] !== s[a])
        throw new Ct(`Cannot interpolate values containing mismatched anchors. from[${a}]: ${r[a]}, to[${a}]: ${s[a]}`);
      o.push(r[a]);
      const [l, h] = r[a + 1], [u, c] = s[a + 1];
      o.push([to(l, u, n), to(h, c, n)]);
    }
    return new fr(o);
  }
}
class Ls {
  constructor(e) {
    this.name = e.name, this.available = e.available;
  }
  toString() {
    return this.name;
  }
  static fromString(e) {
    return e ? new Ls({ name: e, available: !1 }) : null;
  }
}
class Gn {
  constructor(e, t, n) {
    this.from = e, this.to = t, this.transition = n;
  }
  static interpolate(e, t, n) {
    return new Gn(e, t, n);
  }
  static parse(e) {
    if (e instanceof Gn)
      return e;
    if (Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number")
      return new Gn(e[0], e[1], e[2]);
    if (typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number")
      return new Gn(e.from, e.to, e.transition);
    if (typeof e == "string")
      return new Gn(e, e, 1);
  }
}
function aS(i, e, t, n) {
  return typeof i == "number" && i >= 0 && i <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof t == "number" && t >= 0 && t <= 255 ? typeof n > "u" || typeof n == "number" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[i, e, t, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == "number" ? [i, e, t, n] : [i, e, t]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
}
function ch(i) {
  if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof Gn || i instanceof et || i instanceof $0 || i instanceof kr || i instanceof zn || i instanceof Bn || i instanceof sn || i instanceof fr || i instanceof Ls)
    return !0;
  if (Array.isArray(i)) {
    for (const e of i)
      if (!ch(e))
        return !1;
    return !0;
  } else if (typeof i == "object") {
    for (const e in i)
      if (!ch(i[e]))
        return !1;
    return !0;
  } else
    return !1;
}
function Xt(i) {
  if (i === null)
    return Hf;
  if (typeof i == "string")
    return Oe;
  if (typeof i == "boolean")
    return Ie;
  if (typeof i == "number")
    return K;
  if (i instanceof et)
    return cr;
  if (i instanceof Gn)
    return Kf;
  if (i instanceof $0)
    return Jf;
  if (i instanceof kr)
    return Qf;
  if (i instanceof zn)
    return ed;
  if (i instanceof Bn)
    return td;
  if (i instanceof sn)
    return lh;
  if (i instanceof fr)
    return id;
  if (i instanceof Ls)
    return Xh;
  if (Array.isArray(i)) {
    const e = i.length;
    let t;
    for (const n of i) {
      const r = Xt(n);
      if (!t)
        t = r;
      else {
        if (t === r)
          continue;
        t = Me;
        break;
      }
    }
    return tn(t || Me, e);
  } else
    return Qs;
}
function Ul(i) {
  const e = typeof i;
  return i === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(i) : i instanceof et || i instanceof Gn || i instanceof kr || i instanceof zn || i instanceof Bn || i instanceof sn || i instanceof fr || i instanceof Ls ? i.toString() : JSON.stringify(i);
}
class La {
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (!ch(e[1]))
      return t.error("invalid value");
    const n = e[1];
    let r = Xt(n);
    const s = t.expectedType;
    return r.kind === "array" && r.N === 0 && s && s.kind === "array" && (typeof s.N != "number" || s.N === 0) && (r = s), new La(r, n);
  }
  evaluate() {
    return this.value;
  }
  eachChild() {
  }
  outputDefined() {
    return !0;
  }
}
const Lu = {
  string: Oe,
  number: K,
  boolean: Ie,
  object: Qs
};
class kn {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    let n = 1, r;
    const s = e[0];
    if (s === "array") {
      let a;
      if (e.length > 2) {
        const h = e[1];
        if (typeof h != "string" || !(h in Lu) || h === "object")
          return t.error('The item type argument of "array" must be one of string, number, boolean', 1);
        a = Lu[h], n++;
      } else
        a = Me;
      let l;
      if (e.length > 3) {
        if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2])))
          return t.error('The length argument to "array" must be a positive integer literal', 2);
        l = e[2], n++;
      }
      r = tn(a, l);
    } else {
      if (!Lu[s])
        throw new Error(`Types doesn't contain name = ${s}`);
      r = Lu[s];
    }
    const o = [];
    for (; n < e.length; n++) {
      const a = t.parse(e[n], n, Me);
      if (!a)
        return null;
      o.push(a);
    }
    return new kn(r, o);
  }
  evaluate(e) {
    for (let t = 0; t < this.args.length; t++) {
      const n = this.args[t].evaluate(e);
      if (hh(this.type, Xt(n))) {
        if (t === this.args.length - 1)
          throw new Ct(`Expected value to be of type ${bt(this.type)}, but found ${bt(Xt(n))} instead.`);
      } else return n;
    }
    throw new Error();
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
}
const J1 = {
  "to-boolean": Ie,
  "to-color": cr,
  "to-number": K,
  "to-string": Oe
};
class ms {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    const n = e[0];
    if (!J1[n])
      throw new Error(`Can't parse ${n} as it is not part of the known types`);
    if ((n === "to-boolean" || n === "to-string") && e.length !== 2)
      return t.error("Expected one argument.");
    const r = J1[n], s = [];
    for (let o = 1; o < e.length; o++) {
      const a = t.parse(e[o], o, Me);
      if (!a)
        return null;
      s.push(a);
    }
    return new ms(r, s);
  }
  evaluate(e) {
    switch (this.type.kind) {
      case "boolean":
        return !!this.args[0].evaluate(e);
      case "color": {
        let t, n;
        for (const r of this.args) {
          if (t = r.evaluate(e), n = null, t instanceof et)
            return t;
          if (typeof t == "string") {
            const s = e.parseColor(t);
            if (s)
              return s;
          } else if (Array.isArray(t) && (t.length < 3 || t.length > 4 ? n = `Invalid rgba value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : n = aS(t[0], t[1], t[2], t[3]), !n))
            return new et(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
        }
        throw new Ct(n || `Could not parse color from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "padding": {
        let t;
        for (const n of this.args) {
          t = n.evaluate(e);
          const r = zn.parse(t);
          if (r)
            return r;
        }
        throw new Ct(`Could not parse padding from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "numberArray": {
        let t;
        for (const n of this.args) {
          t = n.evaluate(e);
          const r = Bn.parse(t);
          if (r)
            return r;
        }
        throw new Ct(`Could not parse numberArray from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "colorArray": {
        let t;
        for (const n of this.args) {
          t = n.evaluate(e);
          const r = sn.parse(t);
          if (r)
            return r;
        }
        throw new Ct(`Could not parse colorArray from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "variableAnchorOffsetCollection": {
        let t;
        for (const n of this.args) {
          t = n.evaluate(e);
          const r = fr.parse(t);
          if (r)
            return r;
        }
        throw new Ct(`Could not parse variableAnchorOffsetCollection from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "number": {
        let t = null;
        for (const n of this.args) {
          if (t = n.evaluate(e), t === null)
            return 0;
          const r = Number(t);
          if (!isNaN(r))
            return r;
        }
        throw new Ct(`Could not convert ${JSON.stringify(t)} to number.`);
      }
      case "formatted":
        return kr.fromString(Ul(this.args[0].evaluate(e)));
      case "resolvedImage":
        return Ls.fromString(Ul(this.args[0].evaluate(e)));
      case "projectionDefinition":
        return this.args[0].evaluate(e);
      default:
        return Ul(this.args[0].evaluate(e));
    }
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
}
const d8 = ["Unknown", "Point", "LineString", "Polygon"];
class lS {
  constructor() {
    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
  }
  id() {
    return this.feature && "id" in this.feature ? this.feature.id : null;
  }
  geometryType() {
    return this.feature ? typeof this.feature.type == "number" ? d8[this.feature.type] : this.feature.type : null;
  }
  geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
  }
  canonicalID() {
    return this.canonical;
  }
  properties() {
    return this.feature && this.feature.properties || {};
  }
  parseColor(e) {
    let t = this._parseColorCache.get(e);
    return t || (t = et.parse(e), this._parseColorCache.set(e, t)), t;
  }
}
class nd {
  constructor(e, t, n = [], r, s = new z0(), o = []) {
    this.registry = e, this.path = n, this.key = n.map((a) => `[${a}]`).join(""), this.scope = s, this.errors = o, this.expectedType = r, this._isConstant = t;
  }
  /**
   * @param expr the JSON expression to parse
   * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
   * @param options
   * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
   * @private
   */
  parse(e, t, n, r, s = {}) {
    return t ? this.concat(t, n, r)._parse(e, s) : this._parse(e, s);
  }
  _parse(e, t) {
    (e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number") && (e = ["literal", e]);
    function n(r, s, o) {
      return o === "assert" ? new kn(s, [r]) : o === "coerce" ? new ms(s, [r]) : r;
    }
    if (Array.isArray(e)) {
      if (e.length === 0)
        return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
      const r = e[0];
      if (typeof r != "string")
        return this.error(`Expression name must be a string, but found ${typeof r} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
      const s = this.registry[r];
      if (s) {
        let o = s.parse(e, this);
        if (!o)
          return null;
        if (this.expectedType) {
          const a = this.expectedType, l = o.type;
          if ((a.kind === "string" || a.kind === "number" || a.kind === "boolean" || a.kind === "object" || a.kind === "array") && l.kind === "value")
            o = n(o, a, t.typeAnnotation || "assert");
          else if (a.kind === "projectionDefinition" && ["string", "array"].includes(l.kind) || ["color", "formatted", "resolvedImage"].includes(a.kind) && ["value", "string"].includes(l.kind) || ["padding", "numberArray"].includes(a.kind) && ["value", "number", "array"].includes(l.kind) || a.kind === "colorArray" && ["value", "string", "array"].includes(l.kind) || a.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(l.kind))
            o = n(o, a, t.typeAnnotation || "coerce");
          else if (this.checkSubtype(a, l))
            return null;
        }
        if (!(o instanceof La) && o.type.kind !== "resolvedImage" && this._isConstant(o)) {
          const a = new lS();
          try {
            o = new La(o.type, o.evaluate(a));
          } catch (l) {
            return this.error(l.message), null;
          }
        }
        return o;
      }
      return this.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
    } else return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof e == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error(`Expected an array, but found ${typeof e} instead.`);
  }
  /**
   * Returns a copy of this context suitable for parsing the subexpression at
   * index `index`, optionally appending to 'let' binding map.
   *
   * Note that `errors` property, intended for collecting errors while
   * parsing, is copied by reference rather than cloned.
   * @private
   */
  concat(e, t, n) {
    const r = typeof e == "number" ? this.path.concat(e) : this.path, s = n ? this.scope.concat(n) : this.scope;
    return new nd(this.registry, this._isConstant, r, t || null, s, this.errors);
  }
  /**
   * Push a parsing (or type checking) error into the `this.errors`
   * @param error The message
   * @param keys Optionally specify the source of the error at a child
   * of the current expression at `this.key`.
   * @private
   */
  error(e, ...t) {
    const n = `${this.key}${t.map((r) => `[${r}]`).join("")}`;
    this.errors.push(new or(n, e));
  }
  /**
   * Returns null if `t` is a subtype of `expected`; otherwise returns an
   * error message and also pushes it to `this.errors`.
   * @param expected The expected type
   * @param t The actual type
   * @returns null if `t` is a subtype of `expected`; otherwise returns an error message
   */
  checkSubtype(e, t) {
    const n = hh(e, t);
    return n && this.error(n), n;
  }
}
class rd {
  constructor(e, t) {
    this.type = t.type, this.bindings = [].concat(e), this.result = t;
  }
  evaluate(e) {
    return this.result.evaluate(e);
  }
  eachChild(e) {
    for (const t of this.bindings)
      e(t[1]);
    e(this.result);
  }
  static parse(e, t) {
    if (e.length < 4)
      return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
    const n = [];
    for (let s = 1; s < e.length - 1; s += 2) {
      const o = e[s];
      if (typeof o != "string")
        return t.error(`Expected string, but found ${typeof o} instead.`, s);
      if (/[^a-zA-Z0-9_]/.test(o))
        return t.error("Variable names must contain only alphanumeric characters or '_'.", s);
      const a = t.parse(e[s + 1], s + 1);
      if (!a)
        return null;
      n.push([o, a]);
    }
    const r = t.parse(e[e.length - 1], e.length - 1, t.expectedType, n);
    return r ? new rd(n, r) : null;
  }
  outputDefined() {
    return this.result.outputDefined();
  }
}
class sd {
  constructor(e, t) {
    this.type = t.type, this.name = e, this.boundExpression = t;
  }
  static parse(e, t) {
    if (e.length !== 2 || typeof e[1] != "string")
      return t.error("'var' expression requires exactly one string literal argument.");
    const n = e[1];
    return t.scope.has(n) ? new sd(n, t.scope.get(n)) : t.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1);
  }
  evaluate(e) {
    return this.boundExpression.evaluate(e);
  }
  eachChild() {
  }
  outputDefined() {
    return !1;
  }
}
class j0 {
  constructor(e, t, n) {
    this.type = e, this.index = t, this.input = n;
  }
  static parse(e, t) {
    if (e.length !== 3)
      return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1, K), r = t.parse(e[2], 2, tn(t.expectedType || Me));
    if (!n || !r)
      return null;
    const s = r.type;
    return new j0(s.itemType, n, r);
  }
  evaluate(e) {
    const t = this.index.evaluate(e), n = this.input.evaluate(e);
    if (t < 0)
      throw new Ct(`Array index out of bounds: ${t} < 0.`);
    if (t >= n.length)
      throw new Ct(`Array index out of bounds: ${t} > ${n.length - 1}.`);
    if (t !== Math.floor(t))
      throw new Ct(`Array index must be an integer, but found ${t} instead.`);
    return n[t];
  }
  eachChild(e) {
    e(this.index), e(this.input);
  }
  outputDefined() {
    return !1;
  }
}
class X0 {
  constructor(e, t) {
    this.type = Ie, this.needle = e, this.haystack = t;
  }
  static parse(e, t) {
    if (e.length !== 3)
      return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1, Me), r = t.parse(e[2], 2, Me);
    return !n || !r ? null : B0(n.type, [Ie, Oe, K, Hf, Me]) ? new X0(n, r) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${bt(n.type)} instead`);
  }
  evaluate(e) {
    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
    if (!n)
      return !1;
    if (!eo(t, ["boolean", "string", "number", "null"]))
      throw new Ct(`Expected first argument to be of type boolean, string, number or null, but found ${bt(Xt(t))} instead.`);
    if (!eo(n, ["string", "array"]))
      throw new Ct(`Expected second argument to be of type array or string, but found ${bt(Xt(n))} instead.`);
    return n.indexOf(t) >= 0;
  }
  eachChild(e) {
    e(this.needle), e(this.haystack);
  }
  outputDefined() {
    return !0;
  }
}
class Bc {
  constructor(e, t, n) {
    this.type = K, this.needle = e, this.haystack = t, this.fromIndex = n;
  }
  static parse(e, t) {
    if (e.length <= 2 || e.length >= 5)
      return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1, Me), r = t.parse(e[2], 2, Me);
    if (!n || !r)
      return null;
    if (!B0(n.type, [Ie, Oe, K, Hf, Me]))
      return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${bt(n.type)} instead`);
    if (e.length === 4) {
      const s = t.parse(e[3], 3, K);
      return s ? new Bc(n, r, s) : null;
    } else
      return new Bc(n, r);
  }
  evaluate(e) {
    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
    if (!eo(t, ["boolean", "string", "number", "null"]))
      throw new Ct(`Expected first argument to be of type boolean, string, number or null, but found ${bt(Xt(t))} instead.`);
    let r;
    if (this.fromIndex && (r = this.fromIndex.evaluate(e)), eo(n, ["string"])) {
      const s = n.indexOf(t, r);
      return s === -1 ? -1 : [...n.slice(0, s)].length;
    } else {
      if (eo(n, ["array"]))
        return n.indexOf(t, r);
      throw new Ct(`Expected second argument to be of type array or string, but found ${bt(Xt(n))} instead.`);
    }
  }
  eachChild(e) {
    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
  }
  outputDefined() {
    return !1;
  }
}
class V0 {
  constructor(e, t, n, r, s, o) {
    this.inputType = e, this.type = t, this.input = n, this.cases = r, this.outputs = s, this.otherwise = o;
  }
  static parse(e, t) {
    if (e.length < 5)
      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if (e.length % 2 !== 1)
      return t.error("Expected an even number of arguments.");
    let n, r;
    t.expectedType && t.expectedType.kind !== "value" && (r = t.expectedType);
    const s = {}, o = [];
    for (let h = 2; h < e.length - 1; h += 2) {
      let u = e[h];
      const c = e[h + 1];
      Array.isArray(u) || (u = [u]);
      const f = t.concat(h);
      if (u.length === 0)
        return f.error("Expected at least one branch label.");
      for (const d of u) {
        if (typeof d != "number" && typeof d != "string")
          return f.error("Branch labels must be numbers or strings.");
        if (typeof d == "number" && Math.abs(d) > Number.MAX_SAFE_INTEGER)
          return f.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
        if (typeof d == "number" && Math.floor(d) !== d)
          return f.error("Numeric branch labels must be integer values.");
        if (!n)
          n = Xt(d);
        else if (f.checkSubtype(n, Xt(d)))
          return null;
        if (typeof s[String(d)] < "u")
          return f.error("Branch labels must be unique.");
        s[String(d)] = o.length;
      }
      const g = t.parse(c, h, r);
      if (!g)
        return null;
      r = r || g.type, o.push(g);
    }
    const a = t.parse(e[1], 1, Me);
    if (!a)
      return null;
    const l = t.parse(e[e.length - 1], e.length - 1, r);
    return !l || a.type.kind !== "value" && t.concat(1).checkSubtype(n, a.type) ? null : new V0(n, r, a, s, o, l);
  }
  evaluate(e) {
    const t = this.input.evaluate(e);
    return (Xt(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);
  }
  eachChild(e) {
    e(this.input), this.outputs.forEach(e), e(this.otherwise);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
  }
}
class W0 {
  constructor(e, t, n) {
    this.type = e, this.branches = t, this.otherwise = n;
  }
  static parse(e, t) {
    if (e.length < 4)
      return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
    if (e.length % 2 !== 0)
      return t.error("Expected an odd number of arguments.");
    let n;
    t.expectedType && t.expectedType.kind !== "value" && (n = t.expectedType);
    const r = [];
    for (let o = 1; o < e.length - 1; o += 2) {
      const a = t.parse(e[o], o, Ie);
      if (!a)
        return null;
      const l = t.parse(e[o + 1], o + 1, n);
      if (!l)
        return null;
      r.push([a, l]), n = n || l.type;
    }
    const s = t.parse(e[e.length - 1], e.length - 1, n);
    if (!s)
      return null;
    if (!n)
      throw new Error("Can't infer output type");
    return new W0(n, r, s);
  }
  evaluate(e) {
    for (const [t, n] of this.branches)
      if (t.evaluate(e))
        return n.evaluate(e);
    return this.otherwise.evaluate(e);
  }
  eachChild(e) {
    for (const [t, n] of this.branches)
      e(t), e(n);
    e(this.otherwise);
  }
  outputDefined() {
    return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined();
  }
}
class $c {
  constructor(e, t, n, r) {
    this.type = e, this.input = t, this.beginIndex = n, this.endIndex = r;
  }
  static parse(e, t) {
    if (e.length <= 2 || e.length >= 5)
      return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1, Me), r = t.parse(e[2], 2, K);
    if (!n || !r)
      return null;
    if (!B0(n.type, [tn(Me), Oe, Me]))
      return t.error(`Expected first argument to be of type array or string, but found ${bt(n.type)} instead`);
    if (e.length === 4) {
      const s = t.parse(e[3], 3, K);
      return s ? new $c(n.type, n, r, s) : null;
    } else
      return new $c(n.type, n, r);
  }
  evaluate(e) {
    const t = this.input.evaluate(e), n = this.beginIndex.evaluate(e);
    let r;
    if (this.endIndex && (r = this.endIndex.evaluate(e)), eo(t, ["string"]))
      return [...t].slice(n, r).join("");
    if (eo(t, ["array"]))
      return t.slice(n, r);
    throw new Ct(`Expected first argument to be of type array or string, but found ${bt(Xt(t))} instead.`);
  }
  eachChild(e) {
    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
  }
  outputDefined() {
    return !1;
  }
}
function hS(i, e) {
  const t = i.length - 1;
  let n = 0, r = t, s = 0, o, a;
  for (; n <= r; )
    if (s = Math.floor((n + r) / 2), o = i[s], a = i[s + 1], o <= e) {
      if (s === t || e < a)
        return s;
      n = s + 1;
    } else if (o > e)
      r = s - 1;
    else
      throw new Ct("Input is not a number.");
  return 0;
}
class od {
  constructor(e, t, n) {
    this.type = e, this.input = t, this.labels = [], this.outputs = [];
    for (const [r, s] of n)
      this.labels.push(r), this.outputs.push(s);
  }
  static parse(e, t) {
    if (e.length - 1 < 4)
      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if ((e.length - 1) % 2 !== 0)
      return t.error("Expected an even number of arguments.");
    const n = t.parse(e[1], 1, K);
    if (!n)
      return null;
    const r = [];
    let s = null;
    t.expectedType && t.expectedType.kind !== "value" && (s = t.expectedType);
    for (let o = 1; o < e.length; o += 2) {
      const a = o === 1 ? -1 / 0 : e[o], l = e[o + 1], h = o, u = o + 1;
      if (typeof a != "number")
        return t.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', h);
      if (r.length && r[r.length - 1][0] >= a)
        return t.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', h);
      const c = t.parse(l, u, s);
      if (!c)
        return null;
      s = s || c.type, r.push([a, c]);
    }
    return new od(s, n, r);
  }
  evaluate(e) {
    const t = this.labels, n = this.outputs;
    if (t.length === 1)
      return n[0].evaluate(e);
    const r = this.input.evaluate(e);
    if (r <= t[0])
      return n[0].evaluate(e);
    const s = t.length;
    if (r >= t[s - 1])
      return n[s - 1].evaluate(e);
    const o = hS(t, r);
    return n[o].evaluate(e);
  }
  eachChild(e) {
    e(this.input);
    for (const t of this.outputs)
      e(t);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
}
function g8(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var hg, Q1;
function p8() {
  if (Q1) return hg;
  Q1 = 1, hg = i;
  function i(e, t, n, r) {
    this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (r - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = n, this.p2y = r;
  }
  return i.prototype = {
    sampleCurveX: function(e) {
      return ((this.ax * e + this.bx) * e + this.cx) * e;
    },
    sampleCurveY: function(e) {
      return ((this.ay * e + this.by) * e + this.cy) * e;
    },
    sampleCurveDerivativeX: function(e) {
      return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
    },
    solveCurveX: function(e, t) {
      if (t === void 0 && (t = 1e-6), e < 0) return 0;
      if (e > 1) return 1;
      for (var n = e, r = 0; r < 8; r++) {
        var s = this.sampleCurveX(n) - e;
        if (Math.abs(s) < t) return n;
        var o = this.sampleCurveDerivativeX(n);
        if (Math.abs(o) < 1e-6) break;
        n = n - s / o;
      }
      var a = 0, l = 1;
      for (n = e, r = 0; r < 20 && (s = this.sampleCurveX(n), !(Math.abs(s - e) < t)); r++)
        e > s ? a = n : l = n, n = (l - a) * 0.5 + a;
      return n;
    },
    solve: function(e, t) {
      return this.sampleCurveY(this.solveCurveX(e, t));
    }
  }, hg;
}
var m8 = p8(), _8 = /* @__PURE__ */ g8(m8);
class dr {
  constructor(e, t, n, r, s) {
    this.type = e, this.operator = t, this.interpolation = n, this.input = r, this.labels = [], this.outputs = [];
    for (const [o, a] of s)
      this.labels.push(o), this.outputs.push(a);
  }
  static interpolationFactor(e, t, n, r) {
    let s = 0;
    if (e.name === "exponential")
      s = ug(t, e.base, n, r);
    else if (e.name === "linear")
      s = ug(t, 1, n, r);
    else if (e.name === "cubic-bezier") {
      const o = e.controlPoints;
      s = new _8(o[0], o[1], o[2], o[3]).solve(ug(t, 1, n, r));
    }
    return s;
  }
  static parse(e, t) {
    let [n, r, s, ...o] = e;
    if (!Array.isArray(r) || r.length === 0)
      return t.error("Expected an interpolation type expression.", 1);
    if (r[0] === "linear")
      r = { name: "linear" };
    else if (r[0] === "exponential") {
      const h = r[1];
      if (typeof h != "number")
        return t.error("Exponential interpolation requires a numeric base.", 1, 1);
      r = {
        name: "exponential",
        base: h
      };
    } else if (r[0] === "cubic-bezier") {
      const h = r.slice(1);
      if (h.length !== 4 || h.some((u) => typeof u != "number" || u < 0 || u > 1))
        return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
      r = {
        name: "cubic-bezier",
        controlPoints: h
      };
    } else
      return t.error(`Unknown interpolation type ${String(r[0])}`, 1, 0);
    if (e.length - 1 < 4)
      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if ((e.length - 1) % 2 !== 0)
      return t.error("Expected an even number of arguments.");
    if (s = t.parse(s, 2, K), !s)
      return null;
    const a = [];
    let l = null;
    (n === "interpolate-hcl" || n === "interpolate-lab") && t.expectedType != lh ? l = cr : t.expectedType && t.expectedType.kind !== "value" && (l = t.expectedType);
    for (let h = 0; h < o.length; h += 2) {
      const u = o[h], c = o[h + 1], f = h + 3, g = h + 4;
      if (typeof u != "number")
        return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f);
      if (a.length && a[a.length - 1][0] >= u)
        return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', f);
      const d = t.parse(c, g, l);
      if (!d)
        return null;
      l = l || d.type, a.push([u, d]);
    }
    return !ns(l, K) && !ns(l, Kf) && !ns(l, cr) && !ns(l, ed) && !ns(l, td) && !ns(l, lh) && !ns(l, id) && !ns(l, tn(K)) ? t.error(`Type ${bt(l)} is not interpolatable.`) : new dr(l, n, r, s, a);
  }
  evaluate(e) {
    const t = this.labels, n = this.outputs;
    if (t.length === 1)
      return n[0].evaluate(e);
    const r = this.input.evaluate(e);
    if (r <= t[0])
      return n[0].evaluate(e);
    const s = t.length;
    if (r >= t[s - 1])
      return n[s - 1].evaluate(e);
    const o = hS(t, r), a = t[o], l = t[o + 1], h = dr.interpolationFactor(this.interpolation, r, a, l), u = n[o].evaluate(e), c = n[o + 1].evaluate(e);
    switch (this.operator) {
      case "interpolate":
        switch (this.type.kind) {
          case "number":
            return to(u, c, h);
          case "color":
            return et.interpolate(u, c, h);
          case "padding":
            return zn.interpolate(u, c, h);
          case "colorArray":
            return sn.interpolate(u, c, h);
          case "numberArray":
            return Bn.interpolate(u, c, h);
          case "variableAnchorOffsetCollection":
            return fr.interpolate(u, c, h);
          case "array":
            return uh(u, c, h);
          case "projectionDefinition":
            return Gn.interpolate(u, c, h);
        }
      case "interpolate-hcl":
        switch (this.type.kind) {
          case "color":
            return et.interpolate(u, c, h, "hcl");
          case "colorArray":
            return sn.interpolate(u, c, h, "hcl");
        }
      case "interpolate-lab":
        switch (this.type.kind) {
          case "color":
            return et.interpolate(u, c, h, "lab");
          case "colorArray":
            return sn.interpolate(u, c, h, "lab");
        }
    }
  }
  eachChild(e) {
    e(this.input);
    for (const t of this.outputs)
      e(t);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
}
function ug(i, e, t, n) {
  const r = n - t, s = i - t;
  return r === 0 ? 0 : e === 1 ? s / r : (Math.pow(e, s) - 1) / (Math.pow(e, r) - 1);
}
class fh {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    let n = null;
    const r = t.expectedType;
    r && r.kind !== "value" && (n = r);
    const s = [];
    for (const a of e.slice(1)) {
      const l = t.parse(a, 1 + s.length, n, void 0, { typeAnnotation: "omit" });
      if (!l)
        return null;
      n = n || l.type, s.push(l);
    }
    if (!n)
      throw new Error("No output type");
    return r && s.some((a) => hh(r, a.type)) ? new fh(Me, s) : new fh(n, s);
  }
  evaluate(e) {
    let t = null, n = 0, r;
    for (const s of this.args)
      if (n++, t = s.evaluate(e), t && t instanceof Ls && !t.available && (r || (r = t.name), t = null, n === this.args.length && (t = r)), t !== null)
        break;
    return t;
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
}
function ex(i, e) {
  return i === "==" || i === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
}
function y8(i, e, t) {
  return e === t;
}
function x8(i, e, t) {
  return e !== t;
}
function E8(i, e, t) {
  return e < t;
}
function v8(i, e, t) {
  return e > t;
}
function w8(i, e, t) {
  return e <= t;
}
function b8(i, e, t) {
  return e >= t;
}
function uS(i, e, t, n) {
  return n.compare(e, t) === 0;
}
function S8(i, e, t, n) {
  return !uS(i, e, t, n);
}
function T8(i, e, t, n) {
  return n.compare(e, t) < 0;
}
function R8(i, e, t, n) {
  return n.compare(e, t) > 0;
}
function P8(i, e, t, n) {
  return n.compare(e, t) <= 0;
}
function M8(i, e, t, n) {
  return n.compare(e, t) >= 0;
}
function el(i, e, t) {
  const n = i !== "==" && i !== "!=";
  return class cS {
    constructor(s, o, a) {
      this.type = Ie, this.lhs = s, this.rhs = o, this.collator = a, this.hasUntypedArgument = s.type.kind === "value" || o.type.kind === "value";
    }
    static parse(s, o) {
      if (s.length !== 3 && s.length !== 4)
        return o.error("Expected two or three arguments.");
      const a = s[0];
      let l = o.parse(s[1], 1, Me);
      if (!l)
        return null;
      if (!ex(a, l.type))
        return o.concat(1).error(`"${a}" comparisons are not supported for type '${bt(l.type)}'.`);
      let h = o.parse(s[2], 2, Me);
      if (!h)
        return null;
      if (!ex(a, h.type))
        return o.concat(2).error(`"${a}" comparisons are not supported for type '${bt(h.type)}'.`);
      if (l.type.kind !== h.type.kind && l.type.kind !== "value" && h.type.kind !== "value")
        return o.error(`Cannot compare types '${bt(l.type)}' and '${bt(h.type)}'.`);
      n && (l.type.kind === "value" && h.type.kind !== "value" ? l = new kn(h.type, [l]) : l.type.kind !== "value" && h.type.kind === "value" && (h = new kn(l.type, [h])));
      let u = null;
      if (s.length === 4) {
        if (l.type.kind !== "string" && h.type.kind !== "string" && l.type.kind !== "value" && h.type.kind !== "value")
          return o.error("Cannot use collator to compare non-string types.");
        if (u = o.parse(s[3], 3, Jf), !u)
          return null;
      }
      return new cS(l, h, u);
    }
    evaluate(s) {
      const o = this.lhs.evaluate(s), a = this.rhs.evaluate(s);
      if (n && this.hasUntypedArgument) {
        const l = Xt(o), h = Xt(a);
        if (l.kind !== h.kind || !(l.kind === "string" || l.kind === "number"))
          throw new Ct(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${l.kind}, ${h.kind}) instead.`);
      }
      if (this.collator && !n && this.hasUntypedArgument) {
        const l = Xt(o), h = Xt(a);
        if (l.kind !== "string" || h.kind !== "string")
          return e(s, o, a);
      }
      return this.collator ? t(s, o, a, this.collator.evaluate(s)) : e(s, o, a);
    }
    eachChild(s) {
      s(this.lhs), s(this.rhs), this.collator && s(this.collator);
    }
    outputDefined() {
      return !0;
    }
  };
}
const C8 = el("==", y8, uS), A8 = el("!=", x8, S8), I8 = el("<", E8, T8), L8 = el(">", v8, R8), F8 = el("<=", w8, P8), O8 = el(">=", b8, M8);
class ad {
  constructor(e, t, n) {
    this.type = Jf, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error("Expected one argument.");
    const n = e[1];
    if (typeof n != "object" || Array.isArray(n))
      return t.error("Collator options argument must be an object.");
    const r = t.parse(n["case-sensitive"] === void 0 ? !1 : n["case-sensitive"], 1, Ie);
    if (!r)
      return null;
    const s = t.parse(n["diacritic-sensitive"] === void 0 ? !1 : n["diacritic-sensitive"], 1, Ie);
    if (!s)
      return null;
    let o = null;
    return n.locale && (o = t.parse(n.locale, 1, Oe), !o) ? null : new ad(r, s, o);
  }
  evaluate(e) {
    return new $0(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
  }
  eachChild(e) {
    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
  }
  outputDefined() {
    return !1;
  }
}
class Y0 {
  constructor(e, t, n, r, s) {
    this.type = Oe, this.number = e, this.locale = t, this.currency = n, this.minFractionDigits = r, this.maxFractionDigits = s;
  }
  static parse(e, t) {
    if (e.length !== 3)
      return t.error("Expected two arguments.");
    const n = t.parse(e[1], 1, K);
    if (!n)
      return null;
    const r = e[2];
    if (typeof r != "object" || Array.isArray(r))
      return t.error("NumberFormat options argument must be an object.");
    let s = null;
    if (r.locale && (s = t.parse(r.locale, 1, Oe), !s))
      return null;
    let o = null;
    if (r.currency && (o = t.parse(r.currency, 1, Oe), !o))
      return null;
    let a = null;
    if (r["min-fraction-digits"] && (a = t.parse(r["min-fraction-digits"], 1, K), !a))
      return null;
    let l = null;
    return r["max-fraction-digits"] && (l = t.parse(r["max-fraction-digits"], 1, K), !l) ? null : new Y0(n, s, o, a, l);
  }
  evaluate(e) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
      style: this.currency ? "currency" : "decimal",
      currency: this.currency ? this.currency.evaluate(e) : void 0,
      minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
      maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
    }).format(this.number.evaluate(e));
  }
  eachChild(e) {
    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
  }
  outputDefined() {
    return !1;
  }
}
class q0 {
  constructor(e) {
    this.type = Qf, this.sections = e;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    const n = e[1];
    if (!Array.isArray(n) && typeof n == "object")
      return t.error("First argument must be an image or text section.");
    const r = [];
    let s = !1;
    for (let o = 1; o <= e.length - 1; ++o) {
      const a = e[o];
      if (s && typeof a == "object" && !Array.isArray(a)) {
        s = !1;
        let l = null;
        if (a["font-scale"] && (l = t.parse(a["font-scale"], 1, K), !l))
          return null;
        let h = null;
        if (a["text-font"] && (h = t.parse(a["text-font"], 1, tn(Oe)), !h))
          return null;
        let u = null;
        if (a["text-color"] && (u = t.parse(a["text-color"], 1, cr), !u))
          return null;
        let c = null;
        if (a["vertical-align"]) {
          if (typeof a["vertical-align"] == "string" && !c8.includes(a["vertical-align"]))
            return t.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${a["vertical-align"]}' instead.`);
          if (c = t.parse(a["vertical-align"], 1, Oe), !c)
            return null;
        }
        const f = r[r.length - 1];
        f.scale = l, f.font = h, f.textColor = u, f.verticalAlign = c;
      } else {
        const l = t.parse(e[o], 1, Me);
        if (!l)
          return null;
        const h = l.type.kind;
        if (h !== "string" && h !== "value" && h !== "null" && h !== "resolvedImage")
          return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        s = !0, r.push({ content: l, scale: null, font: null, textColor: null, verticalAlign: null });
      }
    }
    return new q0(r);
  }
  evaluate(e) {
    const t = (n) => {
      const r = n.content.evaluate(e);
      return Xt(r) === Xh ? new pp("", r, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null) : new pp(Ul(r), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(",") : null, n.textColor ? n.textColor.evaluate(e) : null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null);
    };
    return new kr(this.sections.map(t));
  }
  eachChild(e) {
    for (const t of this.sections)
      e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor), t.verticalAlign && e(t.verticalAlign);
  }
  outputDefined() {
    return !1;
  }
}
class Z0 {
  constructor(e) {
    this.type = Xh, this.input = e;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error("Expected two arguments.");
    const n = t.parse(e[1], 1, Oe);
    return n ? new Z0(n) : t.error("No image name provided.");
  }
  evaluate(e) {
    const t = this.input.evaluate(e), n = Ls.fromString(t);
    return n && e.availableImages && (n.available = e.availableImages.indexOf(t) > -1), n;
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return !1;
  }
}
class H0 {
  constructor(e) {
    this.type = K, this.input = e;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1);
    return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? t.error(`Expected argument of type string or array, but found ${bt(n.type)} instead.`) : new H0(n) : null;
  }
  evaluate(e) {
    const t = this.input.evaluate(e);
    if (typeof t == "string")
      return [...t].length;
    if (Array.isArray(t))
      return t.length;
    throw new Ct(`Expected value to be of type string or array, but found ${bt(Xt(t))} instead.`);
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return !1;
  }
}
const gr = 8192;
function N8(i, e) {
  const t = D8(i[0]), n = k8(i[1]), r = Math.pow(2, e.z);
  return [Math.round(t * r * gr), Math.round(n * r * gr)];
}
function K0(i, e) {
  const t = Math.pow(2, e.z), n = (i[0] / gr + e.x) / t, r = (i[1] / gr + e.y) / t;
  return [G8(n), U8(r)];
}
function D8(i) {
  return (180 + i) / 360;
}
function G8(i) {
  return i * 360 - 180;
}
function k8(i) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360;
}
function U8(i) {
  return 360 / Math.PI * Math.atan(Math.exp((180 - i * 360) * Math.PI / 180)) - 90;
}
function Vh(i, e) {
  i[0] = Math.min(i[0], e[0]), i[1] = Math.min(i[1], e[1]), i[2] = Math.max(i[2], e[0]), i[3] = Math.max(i[3], e[1]);
}
function dh(i, e) {
  return !(i[0] <= e[0] || i[2] >= e[2] || i[1] <= e[1] || i[3] >= e[3]);
}
function z8(i, e, t) {
  return e[1] > i[1] != t[1] > i[1] && i[0] < (t[0] - e[0]) * (i[1] - e[1]) / (t[1] - e[1]) + e[0];
}
function B8(i, e, t) {
  const n = i[0] - e[0], r = i[1] - e[1], s = i[0] - t[0], o = i[1] - t[1];
  return n * o - s * r === 0 && n * s <= 0 && r * o <= 0;
}
function ld(i, e, t, n) {
  const r = [e[0] - i[0], e[1] - i[1]], s = [n[0] - t[0], n[1] - t[1]];
  return V8(s, r) === 0 ? !1 : !!(tx(i, e, t, n) && tx(t, n, i, e));
}
function $8(i, e, t) {
  for (const n of t)
    for (let r = 0; r < n.length - 1; ++r)
      if (ld(i, e, n[r], n[r + 1]))
        return !0;
  return !1;
}
function tl(i, e, t = !1) {
  let n = !1;
  for (const r of e)
    for (let s = 0; s < r.length - 1; s++) {
      if (B8(i, r[s], r[s + 1]))
        return t;
      z8(i, r[s], r[s + 1]) && (n = !n);
    }
  return n;
}
function j8(i, e) {
  for (const t of e)
    if (tl(i, t))
      return !0;
  return !1;
}
function fS(i, e) {
  for (const t of i)
    if (!tl(t, e))
      return !1;
  for (let t = 0; t < i.length - 1; ++t)
    if ($8(i[t], i[t + 1], e))
      return !1;
  return !0;
}
function X8(i, e) {
  for (const t of e)
    if (fS(i, t))
      return !0;
  return !1;
}
function V8(i, e) {
  return i[0] * e[1] - i[1] * e[0];
}
function tx(i, e, t, n) {
  const r = i[0] - t[0], s = i[1] - t[1], o = e[0] - t[0], a = e[1] - t[1], l = n[0] - t[0], h = n[1] - t[1], u = r * h - l * s, c = o * h - l * a;
  return u > 0 && c < 0 || u < 0 && c > 0;
}
function J0(i, e, t) {
  const n = [];
  for (let r = 0; r < i.length; r++) {
    const s = [];
    for (let o = 0; o < i[r].length; o++) {
      const a = N8(i[r][o], t);
      Vh(e, a), s.push(a);
    }
    n.push(s);
  }
  return n;
}
function dS(i, e, t) {
  const n = [];
  for (let r = 0; r < i.length; r++) {
    const s = J0(i[r], e, t);
    n.push(s);
  }
  return n;
}
function gS(i, e, t, n) {
  if (i[0] < t[0] || i[0] > t[2]) {
    const r = n * 0.5;
    let s = i[0] - t[0] > r ? -n : t[0] - i[0] > r ? n : 0;
    s === 0 && (s = i[0] - t[2] > r ? -n : t[2] - i[0] > r ? n : 0), i[0] += s;
  }
  Vh(e, i);
}
function W8(i) {
  i[0] = i[1] = 1 / 0, i[2] = i[3] = -1 / 0;
}
function ix(i, e, t, n) {
  const r = Math.pow(2, n.z) * gr, s = [n.x * gr, n.y * gr], o = [];
  for (const a of i)
    for (const l of a) {
      const h = [l.x + s[0], l.y + s[1]];
      gS(h, e, t, r), o.push(h);
    }
  return o;
}
function nx(i, e, t, n) {
  const r = Math.pow(2, n.z) * gr, s = [n.x * gr, n.y * gr], o = [];
  for (const a of i) {
    const l = [];
    for (const h of a) {
      const u = [h.x + s[0], h.y + s[1]];
      Vh(e, u), l.push(u);
    }
    o.push(l);
  }
  if (e[2] - e[0] <= r / 2) {
    W8(e);
    for (const a of o)
      for (const l of a)
        gS(l, e, t, r);
  }
  return o;
}
function Y8(i, e) {
  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r = i.canonicalID();
  if (e.type === "Polygon") {
    const s = J0(e.coordinates, n, r), o = ix(i.geometry(), t, n, r);
    if (!dh(t, n))
      return !1;
    for (const a of o)
      if (!tl(a, s))
        return !1;
  }
  if (e.type === "MultiPolygon") {
    const s = dS(e.coordinates, n, r), o = ix(i.geometry(), t, n, r);
    if (!dh(t, n))
      return !1;
    for (const a of o)
      if (!j8(a, s))
        return !1;
  }
  return !0;
}
function q8(i, e) {
  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r = i.canonicalID();
  if (e.type === "Polygon") {
    const s = J0(e.coordinates, n, r), o = nx(i.geometry(), t, n, r);
    if (!dh(t, n))
      return !1;
    for (const a of o)
      if (!fS(a, s))
        return !1;
  }
  if (e.type === "MultiPolygon") {
    const s = dS(e.coordinates, n, r), o = nx(i.geometry(), t, n, r);
    if (!dh(t, n))
      return !1;
    for (const a of o)
      if (!X8(a, s))
        return !1;
  }
  return !0;
}
class io {
  constructor(e, t) {
    this.type = Ie, this.geojson = e, this.geometries = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (ch(e[1])) {
      const n = e[1];
      if (n.type === "FeatureCollection") {
        const r = [];
        for (const s of n.features) {
          const { type: o, coordinates: a } = s.geometry;
          o === "Polygon" && r.push(a), o === "MultiPolygon" && r.push(...a);
        }
        if (r.length) {
          const s = {
            type: "MultiPolygon",
            coordinates: r
          };
          return new io(n, s);
        }
      } else if (n.type === "Feature") {
        const r = n.geometry.type;
        if (r === "Polygon" || r === "MultiPolygon")
          return new io(n, n.geometry);
      } else if (n.type === "Polygon" || n.type === "MultiPolygon")
        return new io(n, n);
    }
    return t.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point")
        return Y8(e, this.geometries);
      if (e.geometryType() === "LineString")
        return q8(e, this.geometries);
    }
    return !1;
  }
  eachChild() {
  }
  outputDefined() {
    return !0;
  }
}
class pS {
  constructor(e = [], t = (n, r) => n < r ? -1 : n > r ? 1 : 0) {
    if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0)
      for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
  }
  push(e) {
    this.data.push(e), this._up(this.length++);
  }
  pop() {
    if (this.length === 0) return;
    const e = this.data[0], t = this.data.pop();
    return --this.length > 0 && (this.data[0] = t, this._down(0)), e;
  }
  peek() {
    return this.data[0];
  }
  _up(e) {
    const { data: t, compare: n } = this, r = t[e];
    for (; e > 0; ) {
      const s = e - 1 >> 1, o = t[s];
      if (n(r, o) >= 0) break;
      t[e] = o, e = s;
    }
    t[e] = r;
  }
  _down(e) {
    const { data: t, compare: n } = this, r = this.length >> 1, s = t[e];
    for (; e < r; ) {
      let o = (e << 1) + 1;
      const a = o + 1;
      if (a < this.length && n(t[a], t[o]) < 0 && (o = a), n(t[o], s) >= 0) break;
      t[e] = t[o], e = o;
    }
    t[e] = s;
  }
}
function Z8(i, e) {
  if (i.length <= 1)
    return [i];
  const n = [];
  let r, s;
  for (const o of i) {
    const a = H8(o);
    a !== 0 && (o.area = Math.abs(a), s === void 0 && (s = a < 0), s === a < 0 ? (r && n.push(r), r = [o]) : r.push(o));
  }
  return r && n.push(r), n;
}
function H8(i) {
  let e = 0;
  for (let t = 0, n = i.length, r = n - 1, s, o; t < n; r = t++)
    s = i[t], o = i[r], e += (o.x - s.x) * (s.y + o.y);
  return e;
}
const K8 = 6378.137, rx = 1 / 298.257223563, sx = rx * (2 - rx), ox = Math.PI / 180;
class Q0 {
  constructor(e) {
    const t = ox * K8 * 1e3, n = Math.cos(e * ox), r = 1 / (1 - sx * (1 - n * n)), s = Math.sqrt(r);
    this.kx = t * s * n, this.ky = t * s * r * (1 - sx);
  }
  /**
   * Given two points of the form [longitude, latitude], returns the distance.
   *
   * @param a - point [longitude, latitude]
   * @param b - point [longitude, latitude]
   * @returns distance
   * @example
   * const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);
   * //=distance
   */
  distance(e, t) {
    const n = this.wrap(e[0] - t[0]) * this.kx, r = (e[1] - t[1]) * this.ky;
    return Math.sqrt(n * n + r * r);
  }
  /**
   * Returns an object of the form {point, index, t}, where point is closest point on the line
   * from the given point, index is the start index of the segment with the closest point,
   * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.
   *
   * @param line - an array of points that form the line
   * @param p - point [longitude, latitude]
   * @returns the nearest point, its index in the array and the proportion along the line
   * @example
   * const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;
   * //=point
   */
  pointOnLine(e, t) {
    let n = 1 / 0, r, s, o, a;
    for (let l = 0; l < e.length - 1; l++) {
      let h = e[l][0], u = e[l][1], c = this.wrap(e[l + 1][0] - h) * this.kx, f = (e[l + 1][1] - u) * this.ky, g = 0;
      (c !== 0 || f !== 0) && (g = (this.wrap(t[0] - h) * this.kx * c + (t[1] - u) * this.ky * f) / (c * c + f * f), g > 1 ? (h = e[l + 1][0], u = e[l + 1][1]) : g > 0 && (h += c / this.kx * g, u += f / this.ky * g)), c = this.wrap(t[0] - h) * this.kx, f = (t[1] - u) * this.ky;
      const d = c * c + f * f;
      d < n && (n = d, r = h, s = u, o = l, a = g);
    }
    return {
      point: [r, s],
      index: o,
      t: Math.max(0, Math.min(1, a))
    };
  }
  wrap(e) {
    for (; e < -180; )
      e += 360;
    for (; e > 180; )
      e -= 360;
    return e;
  }
}
const mp = 100, _p = 50;
function mS(i, e) {
  return e[0] - i[0];
}
function jc(i) {
  return i[1] - i[0] + 1;
}
function jr(i, e) {
  return i[1] >= i[0] && i[1] < e;
}
function yp(i, e) {
  if (i[0] > i[1])
    return [null, null];
  const t = jc(i);
  if (e) {
    if (t === 2)
      return [i, null];
    const r = Math.floor(t / 2);
    return [
      [i[0], i[0] + r],
      [i[0] + r, i[1]]
    ];
  }
  if (t === 1)
    return [i, null];
  const n = Math.floor(t / 2) - 1;
  return [
    [i[0], i[0] + n],
    [i[0] + n + 1, i[1]]
  ];
}
function xp(i, e) {
  if (!jr(e, i.length))
    return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (let n = e[0]; n <= e[1]; ++n)
    Vh(t, i[n]);
  return t;
}
function Ep(i) {
  const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (const t of i)
    for (const n of t)
      Vh(e, n);
  return e;
}
function ax(i) {
  return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0;
}
function e_(i, e, t) {
  if (!ax(i) || !ax(e))
    return NaN;
  let n = 0, r = 0;
  return i[2] < e[0] && (n = e[0] - i[2]), i[0] > e[2] && (n = i[0] - e[2]), i[1] > e[3] && (r = i[1] - e[3]), i[3] < e[1] && (r = e[1] - i[3]), t.distance([0, 0], [n, r]);
}
function Ks(i, e, t) {
  const n = t.pointOnLine(e, i);
  return t.distance(i, n.point);
}
function t_(i, e, t, n, r) {
  const s = Math.min(Ks(i, [t, n], r), Ks(e, [t, n], r)), o = Math.min(Ks(t, [i, e], r), Ks(n, [i, e], r));
  return Math.min(s, o);
}
function J8(i, e, t, n, r) {
  if (!(jr(e, i.length) && jr(n, t.length)))
    return 1 / 0;
  let o = 1 / 0;
  for (let a = e[0]; a < e[1]; ++a) {
    const l = i[a], h = i[a + 1];
    for (let u = n[0]; u < n[1]; ++u) {
      const c = t[u], f = t[u + 1];
      if (ld(l, h, c, f))
        return 0;
      o = Math.min(o, t_(l, h, c, f, r));
    }
  }
  return o;
}
function Q8(i, e, t, n, r) {
  if (!(jr(e, i.length) && jr(n, t.length)))
    return NaN;
  let o = 1 / 0;
  for (let a = e[0]; a <= e[1]; ++a)
    for (let l = n[0]; l <= n[1]; ++l)
      if (o = Math.min(o, r.distance(i[a], t[l])), o === 0)
        return o;
  return o;
}
function e5(i, e, t) {
  if (tl(i, e, !0))
    return 0;
  let n = 1 / 0;
  for (const r of e) {
    const s = r[0], o = r[r.length - 1];
    if (s !== o && (n = Math.min(n, Ks(i, [o, s], t)), n === 0))
      return n;
    const a = t.pointOnLine(r, i);
    if (n = Math.min(n, t.distance(i, a.point)), n === 0)
      return n;
  }
  return n;
}
function t5(i, e, t, n) {
  if (!jr(e, i.length))
    return NaN;
  for (let s = e[0]; s <= e[1]; ++s)
    if (tl(i[s], t, !0))
      return 0;
  let r = 1 / 0;
  for (let s = e[0]; s < e[1]; ++s) {
    const o = i[s], a = i[s + 1];
    for (const l of t)
      for (let h = 0, u = l.length, c = u - 1; h < u; c = h++) {
        const f = l[c], g = l[h];
        if (ld(o, a, f, g))
          return 0;
        r = Math.min(r, t_(o, a, f, g, n));
      }
  }
  return r;
}
function lx(i, e) {
  for (const t of i)
    for (const n of t)
      if (tl(n, e, !0))
        return !0;
  return !1;
}
function i5(i, e, t, n = 1 / 0) {
  const r = Ep(i), s = Ep(e);
  if (n !== 1 / 0 && e_(r, s, t) >= n)
    return n;
  if (dh(r, s)) {
    if (lx(i, e))
      return 0;
  } else if (lx(e, i))
    return 0;
  let o = 1 / 0;
  for (const a of i)
    for (let l = 0, h = a.length, u = h - 1; l < h; u = l++) {
      const c = a[u], f = a[l];
      for (const g of e)
        for (let d = 0, m = g.length, x = m - 1; d < m; x = d++) {
          const v = g[x], p = g[d];
          if (ld(c, f, v, p))
            return 0;
          o = Math.min(o, t_(c, f, v, p, t));
        }
    }
  return o;
}
function hx(i, e, t, n, r, s) {
  if (!s)
    return;
  const o = e_(xp(n, s), r, t);
  o < e && i.push([o, s, [0, 0]]);
}
function Fu(i, e, t, n, r, s, o) {
  if (!s || !o)
    return;
  const a = e_(xp(n, s), xp(r, o), t);
  a < e && i.push([a, s, o]);
}
function Xc(i, e, t, n, r = 1 / 0) {
  let s = Math.min(n.distance(i[0], t[0][0]), r);
  if (s === 0)
    return s;
  const o = new pS([[0, [0, i.length - 1], [0, 0]]], mS), a = Ep(t);
  for (; o.length > 0; ) {
    const l = o.pop();
    if (l[0] >= s)
      continue;
    const h = l[1], u = e ? _p : mp;
    if (jc(h) <= u) {
      if (!jr(h, i.length))
        return NaN;
      if (e) {
        const c = t5(i, h, t, n);
        if (isNaN(c) || c === 0)
          return c;
        s = Math.min(s, c);
      } else
        for (let c = h[0]; c <= h[1]; ++c) {
          const f = e5(i[c], t, n);
          if (s = Math.min(s, f), s === 0)
            return 0;
        }
    } else {
      const c = yp(h, e);
      hx(o, s, n, i, a, c[0]), hx(o, s, n, i, a, c[1]);
    }
  }
  return s;
}
function Vc(i, e, t, n, r, s = 1 / 0) {
  let o = Math.min(s, r.distance(i[0], t[0]));
  if (o === 0)
    return o;
  const a = new pS([[0, [0, i.length - 1], [0, t.length - 1]]], mS);
  for (; a.length > 0; ) {
    const l = a.pop();
    if (l[0] >= o)
      continue;
    const h = l[1], u = l[2], c = e ? _p : mp, f = n ? _p : mp;
    if (jc(h) <= c && jc(u) <= f) {
      if (!jr(h, i.length) && jr(u, t.length))
        return NaN;
      let g;
      if (e && n)
        g = J8(i, h, t, u, r), o = Math.min(o, g);
      else if (e && !n) {
        const d = i.slice(h[0], h[1] + 1);
        for (let m = u[0]; m <= u[1]; ++m)
          if (g = Ks(t[m], d, r), o = Math.min(o, g), o === 0)
            return o;
      } else if (!e && n) {
        const d = t.slice(u[0], u[1] + 1);
        for (let m = h[0]; m <= h[1]; ++m)
          if (g = Ks(i[m], d, r), o = Math.min(o, g), o === 0)
            return o;
      } else
        g = Q8(i, h, t, u, r), o = Math.min(o, g);
    } else {
      const g = yp(h, e), d = yp(u, n);
      Fu(a, o, r, i, t, g[0], d[0]), Fu(a, o, r, i, t, g[0], d[1]), Fu(a, o, r, i, t, g[1], d[0]), Fu(a, o, r, i, t, g[1], d[1]);
    }
  }
  return o;
}
function n5(i, e) {
  const t = i.geometry(), n = t.flat().map((o) => K0([o.x, o.y], i.canonical));
  if (t.length === 0)
    return NaN;
  const r = new Q0(n[0][1]);
  let s = 1 / 0;
  for (const o of e) {
    switch (o.type) {
      case "Point":
        s = Math.min(s, Vc(n, !1, [o.coordinates], !1, r, s));
        break;
      case "LineString":
        s = Math.min(s, Vc(n, !1, o.coordinates, !0, r, s));
        break;
      case "Polygon":
        s = Math.min(s, Xc(n, !1, o.coordinates, r, s));
        break;
    }
    if (s === 0)
      return s;
  }
  return s;
}
function r5(i, e) {
  const t = i.geometry(), n = t.flat().map((o) => K0([o.x, o.y], i.canonical));
  if (t.length === 0)
    return NaN;
  const r = new Q0(n[0][1]);
  let s = 1 / 0;
  for (const o of e) {
    switch (o.type) {
      case "Point":
        s = Math.min(s, Vc(n, !0, [o.coordinates], !1, r, s));
        break;
      case "LineString":
        s = Math.min(s, Vc(n, !0, o.coordinates, !0, r, s));
        break;
      case "Polygon":
        s = Math.min(s, Xc(n, !0, o.coordinates, r, s));
        break;
    }
    if (s === 0)
      return s;
  }
  return s;
}
function s5(i, e) {
  const t = i.geometry();
  if (t.length === 0 || t[0].length === 0)
    return NaN;
  const n = Z8(t).map((o) => o.map((a) => a.map((l) => K0([l.x, l.y], i.canonical)))), r = new Q0(n[0][0][0][1]);
  let s = 1 / 0;
  for (const o of e)
    for (const a of n) {
      switch (o.type) {
        case "Point":
          s = Math.min(s, Xc([o.coordinates], !1, a, r, s));
          break;
        case "LineString":
          s = Math.min(s, Xc(o.coordinates, !0, a, r, s));
          break;
        case "Polygon":
          s = Math.min(s, i5(a, o.coordinates, r, s));
          break;
      }
      if (s === 0)
        return s;
    }
  return s;
}
function cg(i) {
  return i.type === "MultiPolygon" ? i.coordinates.map((e) => ({
    type: "Polygon",
    coordinates: e
  })) : i.type === "MultiLineString" ? i.coordinates.map((e) => ({
    type: "LineString",
    coordinates: e
  })) : i.type === "MultiPoint" ? i.coordinates.map((e) => ({
    type: "Point",
    coordinates: e
  })) : [i];
}
class no {
  constructor(e, t) {
    this.type = K, this.geojson = e, this.geometries = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (ch(e[1])) {
      const n = e[1];
      if (n.type === "FeatureCollection")
        return new no(n, n.features.map((r) => cg(r.geometry)).flat());
      if (n.type === "Feature")
        return new no(n, cg(n.geometry));
      if ("type" in n && "coordinates" in n)
        return new no(n, cg(n));
    }
    return t.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point")
        return n5(e, this.geometries);
      if (e.geometryType() === "LineString")
        return r5(e, this.geometries);
      if (e.geometryType() === "Polygon")
        return s5(e, this.geometries);
    }
    return NaN;
  }
  eachChild() {
  }
  outputDefined() {
    return !0;
  }
}
class Wh {
  constructor(e) {
    this.type = Me, this.key = e;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
    const n = e[1];
    return n == null ? t.error("Global state property must be defined.") : typeof n != "string" ? t.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new Wh(n);
  }
  evaluate(e) {
    var t;
    const n = (t = e.globals) === null || t === void 0 ? void 0 : t.globalState;
    return !n || Object.keys(n).length === 0 ? null : oS(n, this.key);
  }
  eachChild() {
  }
  outputDefined() {
    return !1;
  }
}
const hd = {
  // special forms
  "==": C8,
  "!=": A8,
  ">": L8,
  "<": I8,
  ">=": O8,
  "<=": F8,
  array: kn,
  at: j0,
  boolean: kn,
  case: W0,
  coalesce: fh,
  collator: ad,
  format: q0,
  image: Z0,
  in: X0,
  "index-of": Bc,
  interpolate: dr,
  "interpolate-hcl": dr,
  "interpolate-lab": dr,
  length: H0,
  let: rd,
  literal: La,
  match: V0,
  number: kn,
  "number-format": Y0,
  object: kn,
  slice: $c,
  step: od,
  string: kn,
  "to-boolean": ms,
  "to-color": ms,
  "to-number": ms,
  "to-string": ms,
  var: sd,
  within: io,
  distance: no,
  "global-state": Wh
};
class on {
  constructor(e, t, n, r) {
    this.name = e, this.type = t, this._evaluate = n, this.args = r;
  }
  evaluate(e) {
    return this._evaluate(e, this.args);
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return !1;
  }
  static parse(e, t) {
    const n = e[0], r = on.definitions[n];
    if (!r)
      return t.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
    const s = Array.isArray(r) ? r[0] : r.type, o = Array.isArray(r) ? [[r[1], r[2]]] : r.overloads, a = o.filter(([h]) => !Array.isArray(h) || // varags
    h.length === e.length - 1);
    let l = null;
    for (const [h, u] of a) {
      l = new nd(t.registry, Wc, t.path, null, t.scope);
      const c = [];
      let f = !1;
      for (let g = 1; g < e.length; g++) {
        const d = e[g], m = Array.isArray(h) ? h[g - 1] : h.type, x = l.parse(d, 1 + c.length, m);
        if (!x) {
          f = !0;
          break;
        }
        c.push(x);
      }
      if (!f) {
        if (Array.isArray(h) && h.length !== c.length) {
          l.error(`Expected ${h.length} arguments, but found ${c.length} instead.`);
          continue;
        }
        for (let g = 0; g < c.length; g++) {
          const d = Array.isArray(h) ? h[g] : h.type, m = c[g];
          l.concat(g + 1).checkSubtype(d, m.type);
        }
        if (l.errors.length === 0)
          return new on(n, s, u, c);
      }
    }
    if (a.length === 1)
      t.errors.push(...l.errors);
    else {
      const u = (a.length ? a : o).map(([f]) => a5(f)).join(" | "), c = [];
      for (let f = 1; f < e.length; f++) {
        const g = t.parse(e[f], 1 + c.length);
        if (!g)
          return null;
        c.push(bt(g.type));
      }
      t.error(`Expected arguments of type ${u}, but found (${c.join(", ")}) instead.`);
    }
    return null;
  }
  static register(e, t) {
    on.definitions = t;
    for (const n in t)
      e[n] = on;
  }
}
function ux(i, [e, t, n, r]) {
  e = e.evaluate(i), t = t.evaluate(i), n = n.evaluate(i);
  const s = r ? r.evaluate(i) : 1, o = aS(e, t, n, s);
  if (o)
    throw new Ct(o);
  return new et(e / 255, t / 255, n / 255, s, !1);
}
function cx(i, e) {
  return i in e;
}
function fg(i, e) {
  const t = e[i];
  return typeof t > "u" ? null : t;
}
function o5(i, e, t, n) {
  for (; t <= n; ) {
    const r = t + n >> 1;
    if (e[r] === i)
      return !0;
    e[r] > i ? n = r - 1 : t = r + 1;
  }
  return !1;
}
function Ds(i) {
  return { type: i };
}
on.register(hd, {
  error: [
    e8,
    [Oe],
    (i, [e]) => {
      throw new Ct(e.evaluate(i));
    }
  ],
  typeof: [
    Oe,
    [Me],
    (i, [e]) => bt(Xt(e.evaluate(i)))
  ],
  "to-rgba": [
    tn(K, 4),
    [cr],
    (i, [e]) => {
      const [t, n, r, s] = e.evaluate(i).rgb;
      return [t * 255, n * 255, r * 255, s];
    }
  ],
  rgb: [
    cr,
    [K, K, K],
    ux
  ],
  rgba: [
    cr,
    [K, K, K, K],
    ux
  ],
  has: {
    type: Ie,
    overloads: [
      [
        [Oe],
        (i, [e]) => cx(e.evaluate(i), i.properties())
      ],
      [
        [Oe, Qs],
        (i, [e, t]) => cx(e.evaluate(i), t.evaluate(i))
      ]
    ]
  },
  get: {
    type: Me,
    overloads: [
      [
        [Oe],
        (i, [e]) => fg(e.evaluate(i), i.properties())
      ],
      [
        [Oe, Qs],
        (i, [e, t]) => fg(e.evaluate(i), t.evaluate(i))
      ]
    ]
  },
  "feature-state": [
    Me,
    [Oe],
    (i, [e]) => fg(e.evaluate(i), i.featureState || {})
  ],
  properties: [
    Qs,
    [],
    (i) => i.properties()
  ],
  "geometry-type": [
    Oe,
    [],
    (i) => i.geometryType()
  ],
  id: [
    Me,
    [],
    (i) => i.id()
  ],
  zoom: [
    K,
    [],
    (i) => i.globals.zoom
  ],
  "heatmap-density": [
    K,
    [],
    (i) => i.globals.heatmapDensity || 0
  ],
  elevation: [
    K,
    [],
    (i) => i.globals.elevation || 0
  ],
  "line-progress": [
    K,
    [],
    (i) => i.globals.lineProgress || 0
  ],
  accumulated: [
    Me,
    [],
    (i) => i.globals.accumulated === void 0 ? null : i.globals.accumulated
  ],
  "+": [
    K,
    Ds(K),
    (i, e) => {
      let t = 0;
      for (const n of e)
        t += n.evaluate(i);
      return t;
    }
  ],
  "*": [
    K,
    Ds(K),
    (i, e) => {
      let t = 1;
      for (const n of e)
        t *= n.evaluate(i);
      return t;
    }
  ],
  "-": {
    type: K,
    overloads: [
      [
        [K, K],
        (i, [e, t]) => e.evaluate(i) - t.evaluate(i)
      ],
      [
        [K],
        (i, [e]) => -e.evaluate(i)
      ]
    ]
  },
  "/": [
    K,
    [K, K],
    (i, [e, t]) => e.evaluate(i) / t.evaluate(i)
  ],
  "%": [
    K,
    [K, K],
    (i, [e, t]) => e.evaluate(i) % t.evaluate(i)
  ],
  ln2: [
    K,
    [],
    () => Math.LN2
  ],
  pi: [
    K,
    [],
    () => Math.PI
  ],
  e: [
    K,
    [],
    () => Math.E
  ],
  "^": [
    K,
    [K, K],
    (i, [e, t]) => Math.pow(e.evaluate(i), t.evaluate(i))
  ],
  sqrt: [
    K,
    [K],
    (i, [e]) => Math.sqrt(e.evaluate(i))
  ],
  log10: [
    K,
    [K],
    (i, [e]) => Math.log(e.evaluate(i)) / Math.LN10
  ],
  ln: [
    K,
    [K],
    (i, [e]) => Math.log(e.evaluate(i))
  ],
  log2: [
    K,
    [K],
    (i, [e]) => Math.log(e.evaluate(i)) / Math.LN2
  ],
  sin: [
    K,
    [K],
    (i, [e]) => Math.sin(e.evaluate(i))
  ],
  cos: [
    K,
    [K],
    (i, [e]) => Math.cos(e.evaluate(i))
  ],
  tan: [
    K,
    [K],
    (i, [e]) => Math.tan(e.evaluate(i))
  ],
  asin: [
    K,
    [K],
    (i, [e]) => Math.asin(e.evaluate(i))
  ],
  acos: [
    K,
    [K],
    (i, [e]) => Math.acos(e.evaluate(i))
  ],
  atan: [
    K,
    [K],
    (i, [e]) => Math.atan(e.evaluate(i))
  ],
  min: [
    K,
    Ds(K),
    (i, e) => Math.min(...e.map((t) => t.evaluate(i)))
  ],
  max: [
    K,
    Ds(K),
    (i, e) => Math.max(...e.map((t) => t.evaluate(i)))
  ],
  abs: [
    K,
    [K],
    (i, [e]) => Math.abs(e.evaluate(i))
  ],
  round: [
    K,
    [K],
    (i, [e]) => {
      const t = e.evaluate(i);
      return t < 0 ? -Math.round(-t) : Math.round(t);
    }
  ],
  floor: [
    K,
    [K],
    (i, [e]) => Math.floor(e.evaluate(i))
  ],
  ceil: [
    K,
    [K],
    (i, [e]) => Math.ceil(e.evaluate(i))
  ],
  "filter-==": [
    Ie,
    [Oe, Me],
    (i, [e, t]) => i.properties()[e.value] === t.value
  ],
  "filter-id-==": [
    Ie,
    [Me],
    (i, [e]) => i.id() === e.value
  ],
  "filter-type-==": [
    Ie,
    [Oe],
    (i, [e]) => i.geometryType() === e.value
  ],
  "filter-<": [
    Ie,
    [Oe, Me],
    (i, [e, t]) => {
      const n = i.properties()[e.value], r = t.value;
      return typeof n == typeof r && n < r;
    }
  ],
  "filter-id-<": [
    Ie,
    [Me],
    (i, [e]) => {
      const t = i.id(), n = e.value;
      return typeof t == typeof n && t < n;
    }
  ],
  "filter->": [
    Ie,
    [Oe, Me],
    (i, [e, t]) => {
      const n = i.properties()[e.value], r = t.value;
      return typeof n == typeof r && n > r;
    }
  ],
  "filter-id->": [
    Ie,
    [Me],
    (i, [e]) => {
      const t = i.id(), n = e.value;
      return typeof t == typeof n && t > n;
    }
  ],
  "filter-<=": [
    Ie,
    [Oe, Me],
    (i, [e, t]) => {
      const n = i.properties()[e.value], r = t.value;
      return typeof n == typeof r && n <= r;
    }
  ],
  "filter-id-<=": [
    Ie,
    [Me],
    (i, [e]) => {
      const t = i.id(), n = e.value;
      return typeof t == typeof n && t <= n;
    }
  ],
  "filter->=": [
    Ie,
    [Oe, Me],
    (i, [e, t]) => {
      const n = i.properties()[e.value], r = t.value;
      return typeof n == typeof r && n >= r;
    }
  ],
  "filter-id->=": [
    Ie,
    [Me],
    (i, [e]) => {
      const t = i.id(), n = e.value;
      return typeof t == typeof n && t >= n;
    }
  ],
  "filter-has": [
    Ie,
    [Me],
    (i, [e]) => e.value in i.properties()
  ],
  "filter-has-id": [
    Ie,
    [],
    (i) => i.id() !== null && i.id() !== void 0
  ],
  "filter-type-in": [
    Ie,
    [tn(Oe)],
    (i, [e]) => e.value.indexOf(i.geometryType()) >= 0
  ],
  "filter-id-in": [
    Ie,
    [tn(Me)],
    (i, [e]) => e.value.indexOf(i.id()) >= 0
  ],
  "filter-in-small": [
    Ie,
    [Oe, tn(Me)],
    // assumes v is an array literal
    (i, [e, t]) => t.value.indexOf(i.properties()[e.value]) >= 0
  ],
  "filter-in-large": [
    Ie,
    [Oe, tn(Me)],
    // assumes v is a array literal with values sorted in ascending order and of a single type
    (i, [e, t]) => o5(i.properties()[e.value], t.value, 0, t.value.length - 1)
  ],
  all: {
    type: Ie,
    overloads: [
      [
        [Ie, Ie],
        (i, [e, t]) => e.evaluate(i) && t.evaluate(i)
      ],
      [
        Ds(Ie),
        (i, e) => {
          for (const t of e)
            if (!t.evaluate(i))
              return !1;
          return !0;
        }
      ]
    ]
  },
  any: {
    type: Ie,
    overloads: [
      [
        [Ie, Ie],
        (i, [e, t]) => e.evaluate(i) || t.evaluate(i)
      ],
      [
        Ds(Ie),
        (i, e) => {
          for (const t of e)
            if (t.evaluate(i))
              return !0;
          return !1;
        }
      ]
    ]
  },
  "!": [
    Ie,
    [Ie],
    (i, [e]) => !e.evaluate(i)
  ],
  "is-supported-script": [
    Ie,
    [Oe],
    // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
    (i, [e]) => {
      const t = i.globals && i.globals.isSupportedScript;
      return t ? t(e.evaluate(i)) : !0;
    }
  ],
  upcase: [
    Oe,
    [Oe],
    (i, [e]) => e.evaluate(i).toUpperCase()
  ],
  downcase: [
    Oe,
    [Oe],
    (i, [e]) => e.evaluate(i).toLowerCase()
  ],
  concat: [
    Oe,
    Ds(Me),
    (i, e) => e.map((t) => Ul(t.evaluate(i))).join("")
  ],
  "resolved-locale": [
    Oe,
    [Jf],
    (i, [e]) => e.evaluate(i).resolvedLocale()
  ]
});
function a5(i) {
  return Array.isArray(i) ? `(${i.map(bt).join(", ")})` : `(${bt(i.type)}...)`;
}
function Wc(i) {
  if (i instanceof sd)
    return Wc(i.boundExpression);
  if (i instanceof on && i.name === "error")
    return !1;
  if (i instanceof ad)
    return !1;
  if (i instanceof io)
    return !1;
  if (i instanceof no)
    return !1;
  if (i instanceof Wh)
    return !1;
  const e = i instanceof ms || i instanceof kn;
  let t = !0;
  return i.eachChild((n) => {
    e ? t = t && Wc(n) : t = t && n instanceof La;
  }), t ? i_(i) && r_(i, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]) : !1;
}
function i_(i) {
  if (i instanceof on) {
    if (i.name === "get" && i.args.length === 1)
      return !1;
    if (i.name === "feature-state")
      return !1;
    if (i.name === "has" && i.args.length === 1)
      return !1;
    if (i.name === "properties" || i.name === "geometry-type" || i.name === "id")
      return !1;
    if (/^filter-/.test(i.name))
      return !1;
  }
  if (i instanceof io || i instanceof no)
    return !1;
  let e = !0;
  return i.eachChild((t) => {
    e && !i_(t) && (e = !1);
  }), e;
}
function n_(i) {
  if (i instanceof on && i.name === "feature-state")
    return !1;
  let e = !0;
  return i.eachChild((t) => {
    e && !n_(t) && (e = !1);
  }), e;
}
function r_(i, e) {
  if (i instanceof on && e.indexOf(i.name) >= 0)
    return !1;
  let t = !0;
  return i.eachChild((n) => {
    t && !r_(n, e) && (t = !1);
  }), t;
}
function vp(i) {
  return { result: "success", value: i };
}
function Yo(i) {
  return { result: "error", value: i };
}
function l5(i) {
  return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven";
}
function h5(i) {
  return !!i.expression && i.expression.parameters.indexOf("zoom") > -1;
}
function u5(i) {
  return !!i.expression && i.expression.interpolated;
}
function _S(i) {
  return typeof i == "object" && i !== null && !Array.isArray(i) && Xt(i) === Qs;
}
class c5 {
  constructor(e, t) {
    this.expression = e, this._warningHistory = {}, this._evaluator = new lS(), this._defaultValue = t ? p5(t) : null, this._enumValues = t && t.type === "enum" ? t.values : null;
  }
  evaluateWithoutErrorHandling(e, t, n, r, s, o) {
    return this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = n, this._evaluator.canonical = r, this._evaluator.availableImages = s || null, this._evaluator.formattedSection = o, this.expression.evaluate(this._evaluator);
  }
  evaluate(e, t, n, r, s, o) {
    this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = n || null, this._evaluator.canonical = r, this._evaluator.availableImages = s || null, this._evaluator.formattedSection = o || null;
    try {
      const a = this.expression.evaluate(this._evaluator);
      if (a == null || typeof a == "number" && a !== a)
        return this._defaultValue;
      if (this._enumValues && !(a in this._enumValues))
        throw new Ct(`Expected value to be one of ${Object.keys(this._enumValues).map((l) => JSON.stringify(l)).join(", ")}, but found ${JSON.stringify(a)} instead.`);
      return a;
    } catch (a) {
      return this._warningHistory[a.message] || (this._warningHistory[a.message] = !0, typeof console < "u" && console.warn(a.message)), this._defaultValue;
    }
  }
}
function f5(i) {
  return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in hd;
}
function yS(i, e) {
  const t = new nd(hd, Wc, [], e ? g5(e) : void 0), n = t.parse(i, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
  return n ? vp(new c5(n, e)) : Yo(t.errors);
}
class fx {
  constructor(e, t) {
    this.kind = e, this._styleExpression = t, this.isStateDependent = e !== "constant" && !n_(t.expression), this.globalStateRefs = ud(t.expression);
  }
  evaluateWithoutErrorHandling(e, t, n, r, s, o) {
    return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, r, s, o);
  }
  evaluate(e, t, n, r, s, o) {
    return this._styleExpression.evaluate(e, t, n, r, s, o);
  }
}
class dx {
  constructor(e, t, n, r) {
    this.kind = e, this.zoomStops = n, this._styleExpression = t, this.isStateDependent = e !== "camera" && !n_(t.expression), this.globalStateRefs = ud(t.expression), this.interpolationType = r;
  }
  evaluateWithoutErrorHandling(e, t, n, r, s, o) {
    return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, r, s, o);
  }
  evaluate(e, t, n, r, s, o) {
    return this._styleExpression.evaluate(e, t, n, r, s, o);
  }
  interpolationFactor(e, t, n) {
    return this.interpolationType ? dr.interpolationFactor(this.interpolationType, e, t, n) : 0;
  }
}
function d5(i, e) {
  const t = yS(i, e);
  if (t.result === "error")
    return t;
  const n = t.value.expression, r = i_(n);
  if (!r && !l5(e))
    return Yo([new or("", "data expressions not supported")]);
  const s = r_(n, ["zoom"]);
  if (!s && !h5(e))
    return Yo([new or("", "zoom expressions not supported")]);
  const o = Ku(n);
  if (!o && !s)
    return Yo([new or("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  if (o instanceof or)
    return Yo([o]);
  if (o instanceof dr && !u5(e))
    return Yo([new or("", '"interpolate" expressions cannot be used with this property')]);
  if (!o)
    return vp(r ? new fx("constant", t.value) : new fx("source", t.value));
  const a = o instanceof dr ? o.interpolation : void 0;
  return vp(r ? new dx("camera", t.value, o.labels, a) : new dx("composite", t.value, o.labels, a));
}
function Ku(i) {
  let e = null;
  if (i instanceof rd)
    e = Ku(i.result);
  else if (i instanceof fh) {
    for (const t of i.args)
      if (e = Ku(t), e)
        break;
  } else (i instanceof od || i instanceof dr) && i.input instanceof on && i.input.name === "zoom" && (e = i);
  return e instanceof or || i.eachChild((t) => {
    const n = Ku(t);
    n instanceof or ? e = n : !e && n ? e = new or("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && n && e !== n && (e = new or("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
  }), e;
}
function ud(i, e = /* @__PURE__ */ new Set()) {
  return i instanceof Wh && e.add(i.key), i.eachChild((t) => {
    ud(t, e);
  }), e;
}
function g5(i) {
  const e = {
    color: cr,
    string: Oe,
    number: K,
    enum: Oe,
    boolean: Ie,
    formatted: Qf,
    padding: ed,
    numberArray: td,
    colorArray: lh,
    projectionDefinition: Kf,
    resolvedImage: Xh,
    variableAnchorOffsetCollection: id
  };
  return i.type === "array" ? tn(e[i.value] || Me, i.length) : e[i.type];
}
function p5(i) {
  if (i.type === "color" && _S(i.default))
    return new et(0, 0, 0, 0);
  switch (i.type) {
    case "color":
      return et.parse(i.default) || null;
    case "padding":
      return zn.parse(i.default) || null;
    case "numberArray":
      return Bn.parse(i.default) || null;
    case "colorArray":
      return sn.parse(i.default) || null;
    case "variableAnchorOffsetCollection":
      return fr.parse(i.default) || null;
    case "projectionDefinition":
      return Gn.parse(i.default) || null;
    default:
      return i.default === void 0 ? null : i.default;
  }
}
function xS(i) {
  if (i === !0 || i === !1)
    return !0;
  if (!Array.isArray(i) || i.length === 0)
    return !1;
  switch (i[0]) {
    case "has":
      return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
    case "in":
      return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
    case "!in":
    case "!has":
    case "none":
      return !1;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
    case "any":
    case "all":
      for (const e of i.slice(1))
        if (!xS(e) && typeof e != "boolean")
          return !1;
      return !0;
    default:
      return !0;
  }
}
const m5 = {
  type: "boolean",
  default: !1,
  transition: !1,
  "property-type": "data-driven",
  expression: {
    interpolated: !1,
    parameters: ["zoom", "feature"]
  }
};
function _5(i) {
  if (i == null)
    return { filter: () => !0, needGeometry: !1, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
  xS(i) || (i = Yc(i));
  const e = yS(i, m5);
  if (e.result === "error")
    throw new Error(e.value.map((t) => `${t.key}: ${t.message}`).join(", "));
  {
    const t = ES(i);
    return {
      filter: (n, r, s) => e.value.evaluate(n, r, {}, s),
      needGeometry: t,
      getGlobalStateRefs: () => ud(e.value.expression)
    };
  }
}
function y5(i, e) {
  return i < e ? -1 : i > e ? 1 : 0;
}
function ES(i) {
  if (!Array.isArray(i))
    return !1;
  if (i[0] === "within" || i[0] === "distance")
    return !0;
  for (let e = 1; e < i.length; e++)
    if (ES(i[e]))
      return !0;
  return !1;
}
function Yc(i) {
  if (!i)
    return !0;
  const e = i[0];
  return i.length <= 1 ? e !== "any" : e === "==" ? dg(i[1], i[2], "==") : e === "!=" ? Ou(dg(i[1], i[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? dg(i[1], i[2], e) : e === "any" ? x5(i.slice(1)) : e === "all" ? ["all"].concat(i.slice(1).map(Yc)) : e === "none" ? ["all"].concat(i.slice(1).map(Yc).map(Ou)) : e === "in" ? gx(i[1], i.slice(2)) : e === "!in" ? Ou(gx(i[1], i.slice(2))) : e === "has" ? px(i[1]) : e === "!has" ? Ou(px(i[1])) : !0;
}
function dg(i, e, t) {
  switch (i) {
    case "$type":
      return [`filter-type-${t}`, e];
    case "$id":
      return [`filter-id-${t}`, e];
    default:
      return [`filter-${t}`, i, e];
  }
}
function x5(i) {
  return ["any"].concat(i.map(Yc));
}
function gx(i, e) {
  if (e.length === 0)
    return !1;
  switch (i) {
    case "$type":
      return ["filter-type-in", ["literal", e]];
    case "$id":
      return ["filter-id-in", ["literal", e]];
    default:
      return e.length > 200 && !e.some((t) => typeof t != typeof e[0]) ? ["filter-in-large", i, ["literal", e.sort(y5)]] : ["filter-in-small", i, ["literal", e]];
  }
}
function px(i) {
  switch (i) {
    case "$type":
      return !0;
    case "$id":
      return ["filter-has-id"];
    default:
      return ["filter-has", i];
  }
}
function Ou(i) {
  return ["!", i];
}
function gh(i) {
  return typeof i == "object" ? ["literal", i] : i;
}
function E5(i, e) {
  let t = i.stops;
  if (!t)
    return v5(i, e);
  const n = t && typeof t[0][0] == "object", r = n || i.property !== void 0, s = n || !r;
  return t = t.map((o) => !r && e.tokens && typeof o[1] == "string" ? [o[0], T5(o[1])] : [o[0], gh(o[1])]), n ? w5(i, e, t) : s ? S5(i, e, t) : wp(i, e, t);
}
function v5(i, e) {
  const t = ["get", i.property];
  if (i.default === void 0)
    return e.type === "string" ? ["string", t] : t;
  if (e.type === "enum")
    return [
      "match",
      t,
      Object.keys(e.values),
      t,
      i.default
    ];
  {
    const n = [e.type === "color" ? "to-color" : e.type, t, gh(i.default)];
    return e.type === "array" && n.splice(1, 0, e.value, e.length || null), n;
  }
}
function s_(i) {
  switch (i.colorSpace) {
    case "hcl":
      return "interpolate-hcl";
    case "lab":
      return "interpolate-lab";
    default:
      return "interpolate";
  }
}
function w5(i, e, t) {
  const n = {}, r = {}, s = [];
  for (let a = 0; a < t.length; a++) {
    const l = t[a], h = l[0].zoom;
    n[h] === void 0 && (n[h] = {
      zoom: h,
      type: i.type,
      property: i.property,
      default: i.default
    }, r[h] = [], s.push(h)), r[h].push([l[0].value, l[1]]);
  }
  if (a_({}, e) === "exponential") {
    const a = [s_(i), ["linear"], ["zoom"]];
    for (const l of s) {
      const h = wp(n[l], e, r[l]);
      pa(a, l, h, !1);
    }
    return a;
  } else {
    const a = ["step", ["zoom"]];
    for (const l of s) {
      const h = wp(n[l], e, r[l]);
      pa(a, l, h, !0);
    }
    return o_(a), a;
  }
}
function b5(i, e) {
  if (i !== void 0)
    return i;
  if (e !== void 0)
    return e;
}
function mx(i, e) {
  const t = gh(b5(i.default, e.default));
  return t === void 0 && e.type === "resolvedImage" ? "" : t;
}
function wp(i, e, t) {
  const n = a_(i, e), r = ["get", i.property];
  if (n === "categorical" && typeof t[0][0] == "boolean") {
    const s = ["case"];
    for (const o of t)
      s.push(["==", r, o[0]], o[1]);
    return s.push(mx(i, e)), s;
  } else if (n === "categorical") {
    const s = ["match", r];
    for (const o of t)
      pa(s, o[0], o[1], !1);
    return s.push(mx(i, e)), s;
  } else if (n === "interval") {
    const s = ["step", ["number", r]];
    for (const o of t)
      pa(s, o[0], o[1], !0);
    return o_(s), i.default === void 0 ? s : [
      "case",
      ["==", ["typeof", r], "number"],
      s,
      gh(i.default)
    ];
  } else if (n === "exponential") {
    const s = i.base !== void 0 ? i.base : 1, o = [
      s_(i),
      s === 1 ? ["linear"] : ["exponential", s],
      ["number", r]
    ];
    for (const a of t)
      pa(o, a[0], a[1], !1);
    return i.default === void 0 ? o : [
      "case",
      ["==", ["typeof", r], "number"],
      o,
      gh(i.default)
    ];
  } else
    throw new Error(`Unknown property function type ${n}`);
}
function S5(i, e, t, n = ["zoom"]) {
  const r = a_(i, e);
  let s, o = !1;
  if (r === "interval")
    s = ["step", n], o = !0;
  else if (r === "exponential") {
    const a = i.base !== void 0 ? i.base : 1;
    s = [s_(i), a === 1 ? ["linear"] : ["exponential", a], n];
  } else
    throw new Error(`Unknown zoom function type "${r}"`);
  for (const a of t)
    pa(s, a[0], a[1], o);
  return o_(s), s;
}
function o_(i) {
  i[0] === "step" && i.length === 3 && (i.push(0), i.push(i[3]));
}
function pa(i, e, t, n) {
  i.length > 3 && e === i[i.length - 2] || (n && i.length === 2 || i.push(e), i.push(t));
}
function a_(i, e) {
  return i.type ? i.type : e.expression.interpolated ? "exponential" : "interval";
}
function T5(i) {
  const e = ["concat"], t = /{([^{}]+)}/g;
  let n = 0;
  for (let r = t.exec(i); r !== null; r = t.exec(i)) {
    const s = i.slice(n, t.lastIndex - r[0].length);
    n = t.lastIndex, s.length > 0 && e.push(s), e.push(["get", r[1]]);
  }
  if (e.length === 1)
    return i;
  if (n < i.length)
    e.push(i.slice(n));
  else if (e.length === 2)
    return ["to-string", e[1]];
  return e;
}
const R5 = KG;
var _x = {
  thin: 100,
  hairline: 100,
  "ultra-light": 200,
  "extra-light": 200,
  light: 300,
  book: 300,
  regular: 400,
  normal: 400,
  plain: 400,
  roman: 400,
  standard: 400,
  medium: 500,
  "semi-bold": 600,
  "demi-bold": 600,
  bold: 700,
  "extra-bold": 800,
  "ultra-bold": 800,
  heavy: 900,
  black: 900,
  "heavy-black": 900,
  fat: 900,
  poster: 900,
  "ultra-black": 950,
  "extra-black": 950
}, ul = " ", yx = /(italic|oblique)$/i, xx = {};
function bp(i, e, t) {
  var n = xx[i];
  if (!n) {
    Array.isArray(i) || (i = [i]);
    for (var r = 400, s = "normal", o = [], a, l, h = 0, u = i.length; h < u; ++h) {
      var c = i[h], f = c.split(" "), g = f[f.length - 1].toLowerCase();
      g == "normal" || g == "italic" || g == "oblique" ? (s = l ? s : g, l = !0, f.pop(), g = f[f.length - 1].toLowerCase()) : yx.test(g) && (g = g.replace(yx, ""), s = l ? s : f[f.length - 1].replace(g, ""), l = !0);
      for (var d in _x) {
        var m = f.length > 1 ? f[f.length - 2].toLowerCase() : "";
        if (g == d || g == d.replace("-", "") || m + "-" + g == d) {
          r = a ? r : _x[d], f.pop(), m && d.startsWith(m) && f.pop();
          break;
        }
      }
      !a && typeof g == "number" && (r = g, a = !0);
      var x = f.join(ul).replace("Klokantech Noto Sans", "Noto Sans").replace("DIN Pro", "Barlow").replace("Arial Unicode MS", "Arial");
      x.indexOf(ul) !== -1 && (x = '"' + x + '"'), o.push(x);
    }
    n = xx[i] = [s, r, o];
  }
  return n[0] + ul + n[1] + ul + e + "px" + (t ? "/" + t : "") + ul + n[2];
}
class qo extends In {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(e, t, n) {
    super(e), this.map = t, this.frameState = n !== void 0 ? n : null;
  }
}
class ss extends qo {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(e, t, n, r, s, o) {
    super(e, t, s), this.originalEvent = n, this.pixel_ = null, this.coordinate_ = null, this.dragging = r !== void 0 ? r : !1, this.activePointers = o;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
  }
  set pixel(e) {
    this.pixel_ = e;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
  }
  set coordinate(e) {
    this.coordinate_ = e;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   * @override
   */
  preventDefault() {
    super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   * @override
   */
  stopPropagation() {
    super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }
}
const Ot = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: le.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: le.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
}, Sp = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown"
};
class P5 extends ka {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(e, t) {
    super(e), this.map_ = e, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = t === void 0 ? 1 : t, this.down_ = null;
    const n = this.map_.getViewport();
    this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = n, this.pointerdownListenerKey_ = Ce(
      n,
      Sp.POINTERDOWN,
      this.handlePointerDown_,
      this
    ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = Ce(
      n,
      Sp.POINTERMOVE,
      this.relayMoveEvent_,
      this
    ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
      le.TOUCHMOVE,
      this.boundHandleTouchMove_,
      QE ? { passive: !1 } : !1
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(e) {
    let t = new ss(
      Ot.CLICK,
      this.map_,
      e
    );
    this.dispatchEvent(t), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, t = new ss(
      Ot.DBLCLICK,
      this.map_,
      e
    ), this.dispatchEvent(t)) : this.clickTimeoutId_ = setTimeout(() => {
      this.clickTimeoutId_ = void 0;
      const n = new ss(
        Ot.SINGLECLICK,
        this.map_,
        e
      );
      this.dispatchEvent(n);
    }, 250);
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(e) {
    const t = e, n = t.pointerId;
    if (t.type == Ot.POINTERUP || t.type == Ot.POINTERCANCEL) {
      delete this.trackedTouches_[n];
      for (const r in this.trackedTouches_)
        if (this.trackedTouches_[r].target !== t.target) {
          delete this.trackedTouches_[r];
          break;
        }
    } else (t.type == Ot.POINTERDOWN || t.type == Ot.POINTERMOVE) && (this.trackedTouches_[n] = t);
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(e) {
    this.updateActivePointers_(e);
    const t = new ss(
      Ot.POINTERUP,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(t), this.emulateClicks_ && !t.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(e) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(tt), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(e) {
    return e.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(e) {
    this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(e);
    const t = new ss(
      Ot.POINTERDOWN,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    if (this.dispatchEvent(t), this.down_ = new PointerEvent(e.type, e), Object.defineProperty(this.down_, "target", {
      writable: !1,
      value: e.target
    }), this.dragListenerKeys_.length === 0) {
      const n = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        Ce(
          n,
          Ot.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        Ce(n, Ot.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        Ce(
          this.element_,
          Ot.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      ), this.element_.getRootNode && this.element_.getRootNode() !== n && this.dragListenerKeys_.push(
        Ce(
          this.element_.getRootNode(),
          Ot.POINTERUP,
          this.handlePointerUp_,
          this
        )
      );
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.isMoving_(e)) {
      this.updateActivePointers_(e), this.dragging_ = !0;
      const t = new ss(
        Ot.POINTERDRAG,
        this.map_,
        e,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(t);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(e) {
    this.originalPointerMoveEvent_ = e;
    const t = !!(this.down_ && this.isMoving_(e));
    this.dispatchEvent(
      new ss(
        Ot.POINTERMOVE,
        this.map_,
        e,
        t
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(e) {
    const t = this.originalPointerMoveEvent_;
    (!t || t.defaultPrevented) && (typeof e.cancelable != "boolean" || e.cancelable === !0) && e.preventDefault();
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(e) {
    return this.dragging_ || Math.abs(e.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(e.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.relayedListenerKey_ && (tt(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
      le.TOUCHMOVE,
      this.boundHandleTouchMove_
    ), this.pointerdownListenerKey_ && (tt(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(tt), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
  }
}
const os = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
}, yi = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
}, qc = 1 / 0;
class M5 {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(e, t) {
    this.priorityFunction_ = e, this.keyFunction_ = t, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0, this.priorities_.length = 0, Ga(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const e = this.elements_, t = this.priorities_, n = e[0];
    e.length == 1 ? (e.length = 0, t.length = 0) : (e[0] = /** @type {T} */
    e.pop(), t[0] = /** @type {number} */
    t.pop(), this.siftUp_(0));
    const r = this.keyFunction_(n);
    return delete this.queuedElements_[r], n;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    Te(
      !(this.keyFunction_(e) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const t = this.priorityFunction_(e);
    return t != qc ? (this.elements_.push(e), this.priorities_.push(t), this.queuedElements_[this.keyFunction_(e)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(e) {
    return e * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(e) {
    return e * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(e) {
    return e - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let e;
    for (e = (this.elements_.length >> 1) - 1; e >= 0; e--)
      this.siftUp_(e);
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(e) {
    return e in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(e) {
    return this.isKeyQueued(this.keyFunction_(e));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(e) {
    const t = this.elements_, n = this.priorities_, r = t.length, s = t[e], o = n[e], a = e;
    for (; e < r >> 1; ) {
      const l = this.getLeftChildIndex_(e), h = this.getRightChildIndex_(e), u = h < r && n[h] < n[l] ? h : l;
      t[e] = t[u], n[e] = n[u], e = u;
    }
    t[e] = s, n[e] = o, this.siftDown_(a, e);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(e, t) {
    const n = this.elements_, r = this.priorities_, s = n[t], o = r[t];
    for (; t > e; ) {
      const a = this.getParentIndex_(t);
      if (r[a] > o)
        n[t] = n[a], r[t] = r[a], t = a;
      else
        break;
    }
    n[t] = s, r[t] = o;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const e = this.priorityFunction_, t = this.elements_, n = this.priorities_;
    let r = 0;
    const s = t.length;
    let o, a, l;
    for (a = 0; a < s; ++a)
      o = t[a], l = e(o), l == qc ? delete this.queuedElements_[this.keyFunction_(o)] : (n[r] = l, t[r++] = o);
    t.length = r, n.length = r, this.heapify_();
  }
}
class vS extends M5 {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(e, t) {
    super(
      (n) => e.apply(null, n),
      (n) => n[0].getKey()
    ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = t, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {TileQueueElement} element Element.
   * @return {boolean} The element was added to the queue.
   * @override
   */
  enqueue(e) {
    const t = super.enqueue(e);
    return t && e[0].addEventListener(le.CHANGE, this.boundHandleTileChange_), t;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("./Tile.js").default} */
      e.target
    ), n = t.getState();
    if (n === X.LOADED || n === X.ERROR || n === X.EMPTY) {
      n !== X.ERROR && t.removeEventListener(le.CHANGE, this.boundHandleTileChange_);
      const r = t.getKey();
      r in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[r], --this.tilesLoading_), this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(e, t) {
    let n = 0;
    for (; this.tilesLoading_ < e && n < t && this.getCount() > 0; ) {
      const r = this.dequeue()[0], s = r.getKey();
      r.getState() === X.IDLE && !(s in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[s] = !0, ++this.tilesLoading_, ++n, r.load());
    }
  }
}
function C5(i, e, t, n, r) {
  if (!i || !(t in i.wantedTiles) || !i.wantedTiles[t][e.getKey()])
    return qc;
  const s = i.viewState.center, o = n[0] - s[0], a = n[1] - s[1];
  return 65536 * Math.log(r) + Math.sqrt(o * o + a * a) / r;
}
class l_ extends _r {
  /**
   * @param {Options} options Control options.
   */
  constructor(e) {
    super();
    const t = e.element;
    t && !e.target && !t.style.pointerEvents && (t.style.pointerEvents = "auto"), this.element = t || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], e.render && (this.render = e.render), e.target && this.setTarget(e.target);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.element?.remove(), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.map_ && this.element?.remove();
    for (let t = 0, n = this.listenerKeys.length; t < n; ++t)
      tt(this.listenerKeys[t]);
    if (this.listenerKeys.length = 0, this.map_ = e, e) {
      const t = this.target_ ?? e.getOverlayContainerStopEvent();
      this.element && t.appendChild(this.element), this.render !== Yl && this.listenerKeys.push(
        Ce(e, os.POSTRENDER, this.render, this)
      ), e.render();
    }
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(e) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(e) {
    this.target_ = typeof e == "string" ? document.getElementById(e) : e;
  }
}
class A5 extends l_ {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = e.collapsible !== void 0, this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1), this.attributions_ = e.attributions;
    const t = e.className !== void 0 ? e.className : "ol-attribution", n = e.tipLabel !== void 0 ? e.tipLabel : "Attributions", r = e.expandClassName !== void 0 ? e.expandClassName : t + "-expand", s = e.collapseLabel !== void 0 ? e.collapseLabel : "›", o = e.collapseClassName !== void 0 ? e.collapseClassName : t + "-collapse";
    typeof s == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = s, this.collapseLabel_.className = o) : this.collapseLabel_ = s;
    const a = e.label !== void 0 ? e.label : "i";
    typeof a == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = a, this.label_.className = r) : this.label_ = a;
    const l = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = n, this.toggleButton_.appendChild(l), this.toggleButton_.addEventListener(
      le.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const h = t + " " + Mf + " " + Tm + (this.collapsed_ && this.collapsible_ ? " " + ty : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), u = this.element;
    u.className = h, u.appendChild(this.toggleButton_), u.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(e) {
    const t = this.getMap().getAllLayers(), n = new Set(
      t.flatMap((r) => r.getAttributions(e))
    );
    if (this.attributions_ !== void 0 && (Array.isArray(this.attributions_) ? this.attributions_.forEach((r) => n.add(r)) : n.add(this.attributions_)), !this.overrideCollapsible_) {
      const r = !t.some(
        (s) => s.getSource()?.getAttributionsCollapsible() === !1
      );
      this.setCollapsible(r);
    }
    return Array.from(n);
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  async updateElement_(e) {
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = await Promise.all(
      this.collectSourceAttributions_(e).map(
        (r) => ro(() => r)
      )
    ), n = t.length > 0;
    if (this.renderedVisible_ != n && (this.element.style.display = n ? "" : "none", this.renderedVisible_ = n), !Xr(t, this.renderedAttributions_)) {
      fP(this.ulElement_);
      for (let r = 0, s = t.length; r < s; ++r) {
        const o = document.createElement("li");
        o.innerHTML = t[r], this.ulElement_.appendChild(o);
      }
      this.renderedAttributions_ = t;
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(ty), this.collapsed_ ? K_(this.collapseLabel_, this.label_) : K_(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(e) {
    this.collapsible_ !== e && (this.collapsible_ = e, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(e) {
    this.userCollapsed_ = e, !(!this.collapsible_ || this.collapsed_ === e) && this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    this.updateElement_(e.frameState);
  }
}
class I5 extends l_ {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-rotate", n = e.label !== void 0 ? e.label : "⇧", r = e.compassClassName !== void 0 ? e.compassClassName : "ol-compass";
    this.label_ = null, typeof n == "string" ? (this.label_ = document.createElement("span"), this.label_.className = r, this.label_.textContent = n) : (this.label_ = n, this.label_.classList.add(r));
    const s = e.tipLabel ? e.tipLabel : "Reset rotation", o = document.createElement("button");
    o.className = t + "-reset", o.setAttribute("type", "button"), o.title = s, o.appendChild(this.label_), o.addEventListener(
      le.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const a = t + " " + Mf + " " + Tm, l = this.element;
    l.className = a, l.appendChild(o), this.callResetNorth_ = e.resetNorth ? e.resetNorth : void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.autoHide_ = e.autoHide !== void 0 ? e.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(hu);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
  }
  /**
   * @private
   */
  resetNorth_() {
    const t = this.getMap().getView();
    if (!t)
      return;
    const n = t.getRotation();
    n !== void 0 && (this.duration_ > 0 && n % (2 * Math.PI) !== 0 ? t.animate({
      rotation: 0,
      duration: this.duration_,
      easing: qa
    }) : t.setRotation(0));
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    if (!t)
      return;
    const n = t.viewState.rotation;
    if (n != this.rotation_) {
      const r = "rotate(" + n + "rad)";
      if (this.autoHide_) {
        const s = this.element.classList.contains(hu);
        !s && n === 0 ? this.element.classList.add(hu) : s && n !== 0 && this.element.classList.remove(hu);
      }
      this.label_.style.transform = r;
    }
    this.rotation_ = n;
  }
}
class L5 extends l_ {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-zoom", n = e.delta !== void 0 ? e.delta : 1, r = e.zoomInClassName !== void 0 ? e.zoomInClassName : t + "-in", s = e.zoomOutClassName !== void 0 ? e.zoomOutClassName : t + "-out", o = e.zoomInLabel !== void 0 ? e.zoomInLabel : "+", a = e.zoomOutLabel !== void 0 ? e.zoomOutLabel : "–", l = e.zoomInTipLabel !== void 0 ? e.zoomInTipLabel : "Zoom in", h = e.zoomOutTipLabel !== void 0 ? e.zoomOutTipLabel : "Zoom out", u = document.createElement("button");
    u.className = r, u.setAttribute("type", "button"), u.title = l, u.appendChild(
      typeof o == "string" ? document.createTextNode(o) : o
    ), u.addEventListener(
      le.CLICK,
      this.handleClick_.bind(this, n),
      !1
    );
    const c = document.createElement("button");
    c.className = s, c.setAttribute("type", "button"), c.title = h, c.appendChild(
      typeof a == "string" ? document.createTextNode(a) : a
    ), c.addEventListener(
      le.CLICK,
      this.handleClick_.bind(this, -n),
      !1
    );
    const f = t + " " + Mf + " " + Tm, g = this.element;
    g.className = f, g.appendChild(u), g.appendChild(c), this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e, t) {
    t.preventDefault(), this.zoomByDelta_(e);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(e) {
    const n = this.getMap().getView();
    if (!n)
      return;
    const r = n.getZoom();
    if (r !== void 0) {
      const s = n.getConstrainedZoom(r + e);
      this.duration_ > 0 ? (n.getAnimating() && n.cancelAnimations(), n.animate({
        zoom: s,
        duration: this.duration_,
        easing: qa
      })) : n.setZoom(s);
    }
  }
}
function F5(i) {
  i = i || {};
  const e = new rn();
  return (i.zoom !== void 0 ? i.zoom : !0) && e.push(new L5(i.zoomOptions)), (i.rotate !== void 0 ? i.rotate : !0) && e.push(new I5(i.rotateOptions)), (i.attribution !== void 0 ? i.attribution : !0) && e.push(new A5(i.attributionOptions)), e;
}
class O5 {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(e, t, n) {
    this.decay_ = e, this.minVelocity_ = t, this.delay_ = n, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(e, t) {
    this.points_.push(e, t, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6)
      return !1;
    const e = Date.now() - this.delay_, t = this.points_.length - 3;
    if (this.points_[t + 2] < e)
      return !1;
    let n = t - 3;
    for (; n > 0 && this.points_[n + 2] > e; )
      n -= 3;
    const r = this.points_[t + 2] - this.points_[n + 2];
    if (r < 1e3 / 60)
      return !1;
    const s = this.points_[t] - this.points_[n], o = this.points_[t + 1] - this.points_[n + 1];
    return this.angle_ = Math.atan2(o, s), this.initialVelocity_ = Math.sqrt(s * s + o * o) / r, this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}
const Ex = {
  ACTIVE: "active"
};
class Yh extends _r {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e && e.handleEvent && (this.handleEvent = e.handleEvent), this.map_ = null, this.setActive(!0);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(Ex.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    return !0;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.set(Ex.ACTIVE, e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    this.map_ = e;
  }
}
function N5(i, e, t) {
  const n = i.getCenterInternal();
  if (n) {
    const r = [n[0] + e[0], n[1] + e[1]];
    i.animateInternal({
      duration: t !== void 0 ? t : 250,
      easing: vF,
      center: i.getConstrainedCenter(r)
    });
  }
}
function h_(i, e, t, n) {
  const r = i.getZoom();
  if (r === void 0)
    return;
  const s = i.getConstrainedZoom(r + e), o = i.getResolutionForZoom(s);
  i.getAnimating() && i.cancelAnimations(), i.animate({
    resolution: o,
    anchor: t,
    duration: n !== void 0 ? n : 250,
    easing: qa
  });
}
class D5 extends Yh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == Ot.DBLCLICK) {
      const n = (
        /** @type {MouseEvent} */
        e.originalEvent
      ), r = e.map, s = e.coordinate, o = n.shiftKey ? -this.delta_ : this.delta_, a = r.getView();
      h_(a, o, s, this.duration_), n.preventDefault(), t = !0;
    }
    return !t;
  }
}
function Tp(i) {
  const e = arguments;
  return function(t) {
    let n = !0;
    for (let r = 0, s = e.length; r < s && (n = n && e[r](t), !!n); ++r)
      ;
    return n;
  };
}
const G5 = function(i) {
  const e = i.originalEvent;
  return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, k5 = function(i) {
  const e = i.map.getTargetElement(), t = e.getRootNode(), n = i.map.getOwnerDocument().activeElement;
  return t instanceof ShadowRoot ? t.host.contains(n) : e.contains(n);
}, wS = function(i) {
  const e = i.map.getTargetElement(), t = e.getRootNode();
  return (t instanceof ShadowRoot ? t.host : e).hasAttribute("tabindex") ? k5(i) : !0;
}, U5 = Wl, bS = function(i) {
  const e = i.originalEvent;
  return "pointerId" in e && e.button == 0 && !(uP && KE && e.ctrlKey);
}, SS = function(i) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    i.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, z5 = function(i) {
  const e = i.originalEvent;
  return KE ? e.metaKey : e.ctrlKey;
}, B5 = function(i) {
  const e = i.originalEvent;
  return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, TS = function(i) {
  const e = i.originalEvent, t = (
    /** @type {Element} */
    e.target.tagName
  );
  return t !== "INPUT" && t !== "SELECT" && t !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !e.target.isContentEditable;
}, gg = function(i) {
  const e = i.originalEvent;
  return "pointerId" in e && e.pointerType == "mouse";
}, $5 = function(i) {
  const e = i.originalEvent;
  return "pointerId" in e && e.isPrimary && e.button === 0;
};
class qh extends Yh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), e.handleDownEvent && (this.handleDownEvent = e.handleDownEvent), e.handleDragEvent && (this.handleDragEvent = e.handleDragEvent), e.handleMoveEvent && (this.handleMoveEvent = e.handleMoveEvent), e.handleUpEvent && (this.handleUpEvent = e.handleUpEvent), e.stopDown && (this.stopDown = e.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(e) {
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(e) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   * @override
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    let t = !1;
    if (this.updateTrackedPointers_(e), this.handlingDownUpSequence) {
      if (e.type == Ot.POINTERDRAG)
        this.handleDragEvent(e), e.originalEvent.preventDefault();
      else if (e.type == Ot.POINTERUP) {
        const n = this.handleUpEvent(e);
        this.handlingDownUpSequence = n && this.targetPointers.length > 0;
      }
    } else if (e.type == Ot.POINTERDOWN) {
      const n = this.handleDownEvent(e);
      this.handlingDownUpSequence = n, t = this.stopDown(n);
    } else e.type == Ot.POINTERMOVE && this.handleMoveEvent(e);
    return !t;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(e) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(e) {
    return !1;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(e) {
    return e;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(e) {
    e.activePointers && (this.targetPointers = e.activePointers);
  }
}
function u_(i) {
  const e = i.length;
  let t = 0, n = 0;
  for (let r = 0; r < e; r++)
    t += i[r].clientX, n += i[r].clientY;
  return { clientX: t / e, clientY: n / e };
}
class j5 extends qh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super({
      stopDown: df
    }), e = e || {}, this.kinetic_ = e.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
    const t = e.condition ? e.condition : Tp(SS, $5);
    this.condition_ = e.onFocusOnly ? Tp(wS, t) : t, this.noKinetic_ = !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(e) {
    const t = e.map;
    this.panning_ || (this.panning_ = !0, t.getView().beginInteraction());
    const n = this.targetPointers, r = t.getEventPixel(u_(n));
    if (n.length == this.lastPointersCount_) {
      if (this.kinetic_ && this.kinetic_.update(r[0], r[1]), this.lastCentroid) {
        const s = [
          this.lastCentroid[0] - r[0],
          r[1] - this.lastCentroid[1]
        ], a = e.map.getView();
        bE(s, a.getResolution()), qp(s, a.getRotation()), a.adjustCenterInternal(s);
      }
    } else this.kinetic_ && this.kinetic_.begin();
    this.lastCentroid = r, this.lastPointersCount_ = n.length, e.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(e) {
    const t = e.map, n = t.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const r = this.kinetic_.getDistance(), s = this.kinetic_.getAngle(), o = n.getCenterInternal(), a = t.getPixelFromCoordinateInternal(o), l = t.getCoordinateFromPixelInternal([
          a[0] - r * Math.cos(s),
          a[1] - r * Math.sin(s)
        ]);
        n.animateInternal({
          center: n.getConstrainedCenter(l),
          duration: 500,
          easing: qa
        });
      }
      return this.panning_ && (this.panning_ = !1, n.endInteraction()), !1;
    }
    return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(e) {
    if (this.targetPointers.length > 0 && this.condition_(e)) {
      const n = e.map.getView();
      return this.lastCentroid = null, n.getAnimating() && n.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
    }
    return !1;
  }
}
class X5 extends qh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      stopDown: df
    }), this.condition_ = e.condition ? e.condition : G5, this.lastAngle_ = void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(e) {
    if (!gg(e))
      return;
    const t = e.map, n = t.getView();
    if (n.getConstraints().rotation === Ym)
      return;
    const r = t.getSize(), s = e.pixel, o = Math.atan2(r[1] / 2 - s[1], s[0] - r[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const a = o - this.lastAngle_;
      n.adjustRotationInternal(-a);
    }
    this.lastAngle_ = o;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(e) {
    return gg(e) ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(e) {
    return gg(e) && bS(e) && this.condition_(e) ? (e.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
  }
}
class V5 extends Da {
  /**
   * @param {string} className CSS class name.
   */
  constructor(e) {
    super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + e, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const e = this.startPixel_, t = this.endPixel_, n = "px", r = this.element_.style;
    r.left = Math.min(e[0], t[0]) + n, r.top = Math.min(e[1], t[1]) + n, r.width = Math.abs(t[0] - e[0]) + n, r.height = Math.abs(t[1] - e[1]) + n;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const t = this.element_.style;
      t.left = "inherit", t.top = "inherit", t.width = "inherit", t.height = "inherit";
    }
    this.map_ = e, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(e, t) {
    this.startPixel_ = e, this.endPixel_ = t, this.createOrUpdateGeometry(), this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    if (!this.map_)
      return;
    const e = this.startPixel_, t = this.endPixel_, r = [
      e,
      [e[0], t[1]],
      t,
      [t[0], e[1]]
    ].map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    r[4] = r[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([r]) : this.geometry_ = new ei([r]);
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}
const ko = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
class cl extends In {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(e, t, n) {
    super(e), this.coordinate = t, this.mapBrowserEvent = n;
  }
}
class W5 extends qh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e ?? {}, this.box_ = new V5(e.className || "ol-dragbox"), this.minArea_ = e.minArea ?? 64, e.onBoxEnd && (this.onBoxEnd = e.onBoxEnd), this.startPixel_ = null, this.condition_ = e.condition ?? bS, this.boxEndCondition_ = e.boxEndCondition ?? this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(e, t, n) {
    const r = n[0] - t[0], s = n[1] - t[1];
    return r * r + s * s >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(e) {
    this.startPixel_ && (this.box_.setPixels(this.startPixel_, e.pixel), this.dispatchEvent(
      new cl(
        ko.BOXDRAG,
        e.coordinate,
        e
      )
    ));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(e) {
    if (!this.startPixel_)
      return !1;
    const t = this.boxEndCondition_(
      e,
      this.startPixel_,
      e.pixel
    );
    return t && this.onBoxEnd(e), this.dispatchEvent(
      new cl(
        t ? ko.BOXEND : ko.BOXCANCEL,
        e.coordinate,
        e
      )
    ), this.box_.setMap(null), this.startPixel_ = null, !1;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(e) {
    return this.condition_(e) ? (this.startPixel_ = e.pixel, this.box_.setMap(e.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
      new cl(
        ko.BOXSTART,
        e.coordinate,
        e
      )
    ), !0) : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   * @override
   */
  setActive(e) {
    e || (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
      new cl(ko.BOXCANCEL, this.startPixel_, null)
    ), this.startPixel_ = null)), super.setActive(e);
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   * @override
   */
  setMap(e) {
    this.getMap() && (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
      new cl(ko.BOXCANCEL, this.startPixel_, null)
    ), this.startPixel_ = null)), super.setMap(e);
  }
}
class Y5 extends W5 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.condition ? e.condition : B5;
    super({
      condition: t,
      className: e.className || "ol-dragzoom",
      minArea: e.minArea
    }), this.duration_ = e.duration !== void 0 ? e.duration : 200, this.out_ = e.out !== void 0 ? e.out : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @override
   */
  onBoxEnd(e) {
    const n = (
      /** @type {!import("../View.js").default} */
      this.getMap().getView()
    );
    let r = this.getGeometry();
    if (this.out_) {
      const s = n.rotatedExtentForGeometry(r), o = n.getResolutionForExtentInternal(s), a = n.getResolution() / o;
      r = r.clone(), r.scale(a * a);
    }
    n.fitInternal(r, {
      duration: this.duration_,
      easing: qa
    });
  }
}
const Gs = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};
class q5 extends Yh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.defaultCondition_ = function(t) {
      return SS(t) && TS(t);
    }, this.condition_ = e.condition !== void 0 ? e.condition : this.defaultCondition_, this.duration_ = e.duration !== void 0 ? e.duration : 100, this.pixelDelta_ = e.pixelDelta !== void 0 ? e.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == le.KEYDOWN) {
      const n = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), r = n.key;
      if (this.condition_(e) && (r == Gs.DOWN || r == Gs.LEFT || r == Gs.RIGHT || r == Gs.UP)) {
        const o = e.map.getView(), a = o.getResolution() * this.pixelDelta_;
        let l = 0, h = 0;
        r == Gs.DOWN ? h = -a : r == Gs.LEFT ? l = -a : r == Gs.RIGHT ? l = a : h = a;
        const u = [l, h];
        qp(u, o.getRotation()), N5(o, u, this.duration_), n.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
class Z5 extends Yh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.condition_ = e.condition ? e.condition : function(t) {
      return !z5(t) && TS(t);
    }, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == le.KEYDOWN || e.type == le.KEYPRESS) {
      const n = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), r = n.key;
      if (this.condition_(e) && (r === "+" || r === "-")) {
        const s = e.map, o = r === "+" ? this.delta_ : -this.delta_, a = s.getView();
        h_(a, o, void 0, this.duration_), n.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
const H5 = 40, K5 = 300;
class J5 extends Yh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = e.maxDelta !== void 0 ? e.maxDelta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.timeout_ = e.timeout !== void 0 ? e.timeout : 80, this.useAnchor_ = e.useAnchor !== void 0 ? e.useAnchor : !0, this.constrainResolution_ = e.constrainResolution !== void 0 ? e.constrainResolution : !1;
    const t = e.condition ? e.condition : U5;
    this.condition_ = e.onFocusOnly ? Tp(wS, t) : t, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const e = this.getMap();
    if (!e)
      return;
    e.getView().endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_ ? e.getCoordinateFromPixel(this.lastAnchor_) : null
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(e) {
    if (!this.condition_(e) || e.type !== le.WHEEL)
      return !0;
    const n = e.map, r = (
      /** @type {WheelEvent} */
      e.originalEvent
    );
    r.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = e.pixel);
    let s = r.deltaY;
    switch (r.deltaMode) {
      case WheelEvent.DOM_DELTA_LINE:
        s *= H5;
        break;
      case WheelEvent.DOM_DELTA_PAGE:
        s *= K5;
        break;
    }
    if (s === 0)
      return !1;
    this.lastDelta_ = s;
    const o = Date.now();
    this.startTime_ === void 0 && (this.startTime_ = o), (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(s) < 4 ? "trackpad" : "wheel");
    const a = n.getView();
    if (this.mode_ === "trackpad" && !(a.getConstrainResolution() || this.constrainResolution_))
      return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (a.getAnimating() && a.cancelAnimations(), a.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      ), a.adjustZoom(
        -s / this.deltaPerZoom_,
        this.lastAnchor_ ? n.getCoordinateFromPixel(this.lastAnchor_) : null
      ), this.startTime_ = o, !1;
    this.totalDelta_ += s;
    const l = Math.max(this.timeout_ - (o - this.startTime_), 0);
    return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, n),
      l
    ), !1;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(e) {
    const t = e.getView();
    t.getAnimating() && t.cancelAnimations();
    let n = -ve(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    (t.getConstrainResolution() || this.constrainResolution_) && (n = n ? n > 0 ? 1 : -1 : 0), h_(
      t,
      n,
      this.lastAnchor_ ? e.getCoordinateFromPixel(this.lastAnchor_) : null,
      this.duration_
    ), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(e) {
    this.useAnchor_ = e, e || (this.lastAnchor_ = null);
  }
}
class Q5 extends qh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = df), super(t), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = e.threshold !== void 0 ? e.threshold : 0.3, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(e) {
    let t = 0;
    const n = this.targetPointers[0], r = this.targetPointers[1], s = Math.atan2(
      r.clientY - n.clientY,
      r.clientX - n.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const l = s - this.lastAngle_;
      this.rotationDelta_ += l, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), t = l;
    }
    this.lastAngle_ = s;
    const o = e.map, a = o.getView();
    a.getConstraints().rotation !== Ym && (this.anchor_ = o.getCoordinateFromPixelInternal(
      o.getEventPixel(u_(this.targetPointers))
    ), this.rotating_ && (o.render(), a.adjustRotationInternal(t, this.anchor_)));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(e) {
    return this.targetPointers.length < 2 ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
class e6 extends qh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = df), super(t), this.anchor_ = null, this.duration_ = e.duration !== void 0 ? e.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(e) {
    let t = 1;
    const n = this.targetPointers[0], r = this.targetPointers[1], s = n.clientX - r.clientX, o = n.clientY - r.clientY, a = Math.sqrt(s * s + o * o);
    this.lastDistance_ !== void 0 && (t = this.lastDistance_ / a), this.lastDistance_ = a;
    const l = e.map, h = l.getView();
    t != 1 && (this.lastScaleDelta_ = t), this.anchor_ = l.getCoordinateFromPixelInternal(
      l.getEventPixel(u_(this.targetPointers))
    ), l.render(), h.adjustResolutionInternal(t, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(e) {
    if (this.targetPointers.length < 2) {
      const n = e.map.getView(), r = this.lastScaleDelta_ > 1 ? 1 : -1;
      return n.endInteraction(this.duration_, r), !1;
    }
    return !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
function t6(i) {
  i = i || {};
  const e = new rn(), t = new O5(-5e-3, 0.05, 100);
  return (i.altShiftDragRotate !== void 0 ? i.altShiftDragRotate : !0) && e.push(new X5()), (i.doubleClickZoom !== void 0 ? i.doubleClickZoom : !0) && e.push(
    new D5({
      delta: i.zoomDelta,
      duration: i.zoomDuration
    })
  ), (i.dragPan !== void 0 ? i.dragPan : !0) && e.push(
    new j5({
      onFocusOnly: i.onFocusOnly,
      kinetic: t
    })
  ), (i.pinchRotate !== void 0 ? i.pinchRotate : !0) && e.push(new Q5()), (i.pinchZoom !== void 0 ? i.pinchZoom : !0) && e.push(
    new e6({
      duration: i.zoomDuration
    })
  ), (i.keyboard !== void 0 ? i.keyboard : !0) && (e.push(new q5()), e.push(
    new Z5({
      delta: i.zoomDelta,
      duration: i.zoomDuration
    })
  )), (i.mouseWheelZoom !== void 0 ? i.mouseWheelZoom : !0) && e.push(
    new J5({
      onFocusOnly: i.onFocusOnly,
      duration: i.zoomDuration
    })
  ), (i.shiftDragZoom !== void 0 ? i.shiftDragZoom : !0) && e.push(
    new Y5({
      duration: i.zoomDuration
    })
  ), e;
}
class i6 extends Da {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(), this.map_ = e;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, t) {
    de();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(e) {
    const t = e.viewState, n = e.coordinateToPixelTransform, r = e.pixelToCoordinateTransform;
    un(
      n,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / t.resolution,
      -1 / t.resolution,
      -t.rotation,
      -t.center[0],
      -t.center[1]
    ), lo(r, n);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(e, t, n, r, s, o, a, l) {
    let h;
    const u = t.viewState;
    function c(E, b, T, R) {
      return s.call(o, b, E ? T : null, R);
    }
    const f = u.projection, g = Zp(e.slice(), f), d = [[0, 0]];
    if (f.canWrapX() && r) {
      const E = f.getExtent(), b = _e(E);
      d.push([-b, 0], [b, 0]);
    }
    const m = t.layerStatesArray, x = m.length, v = (
      /** @type {Array<HitMatch<T>>} */
      []
    ), p = [];
    for (let E = 0; E < d.length; E++)
      for (let b = x - 1; b >= 0; --b) {
        const T = m[b], R = T.layer;
        if (R.hasRenderer() && qm(T, u) && a.call(l, R)) {
          const M = R.getRenderer(), C = R.getSource();
          if (M && C) {
            const I = C.getWrapX() ? g : e, O = c.bind(
              null,
              T.managed
            );
            p[0] = I[0] + d[E][0], p[1] = I[1] + d[E][1], h = M.forEachFeatureAtCoordinate(
              p,
              t,
              n,
              O,
              v
            );
          }
          if (h)
            return h;
        }
      }
    if (v.length === 0)
      return;
    const y = 1 / v.length;
    return v.forEach((E, b) => E.distanceSq += b * y), v.sort((E, b) => E.distanceSq - b.distanceSq), v.some((E) => h = E.callback(E.feature, E.layer, E.geometry)), h;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(e, t, n, r, s, o) {
    return this.forEachFeatureAtCoordinate(
      e,
      t,
      n,
      r,
      Wl,
      this,
      s,
      o
    ) !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    de();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(e) {
    wn.canExpireCache() && e.postRenderFunctions.push(n6);
  }
}
function n6(i, e) {
  wn.expire();
}
class r6 extends i6 {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(e), this.fontChangeListenerKey_ = Ce(
      js,
      xa.PROPERTYCHANGE,
      e.redrawText,
      e
    ), this.element_ = di ? ev() : document.createElement("div");
    const t = this.element_.style;
    t.position = "absolute", t.width = "100%", t.height = "100%", t.zIndex = "0", this.element_.className = Mf + " ol-layers";
    const n = e.getViewport();
    n && n.insertBefore(this.element_, n.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  dispatchRenderEvent(e, t) {
    const n = this.getMap();
    if (n.hasListener(e)) {
      const r = new Fl(e, void 0, t);
      n.dispatchEvent(r);
    }
  }
  /**
   * @override
   */
  disposeInternal() {
    tt(this.fontChangeListenerKey_), this.element_.remove(), super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderFrame(e) {
    if (!e) {
      this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    this.calculateMatrices2D(e), this.dispatchRenderEvent(Ht.PRECOMPOSE, e);
    const t = e.layerStatesArray.sort(
      (h, u) => h.zIndex - u.zIndex
    );
    t.some(
      (h) => h.layer instanceof bo && h.layer.getDeclutter()
    ) && (e.declutter = {});
    const r = e.viewState;
    this.children_.length = 0;
    const s = [];
    let o = null;
    for (let h = 0, u = t.length; h < u; ++h) {
      const c = t[h];
      e.layerIndex = h;
      const f = c.layer, g = f.getSourceState();
      if (!qm(c, r) || g != "ready" && g != "undefined") {
        f.unrender();
        continue;
      }
      const d = f.render(e, o);
      d && (d !== o && (this.children_.push(d), o = d), s.push(c));
    }
    this.declutter(e, s), dP(this.element_, this.children_);
    const l = this.getMap().getTargetElement();
    if (fs(l)) {
      const h = l.getContext("2d");
      for (const u of this.children_) {
        const c = u.firstElementChild || u, f = u.style.backgroundColor;
        if (f && (!fs(c) || c.width > 0) && (h.fillStyle = f, h.fillRect(0, 0, l.width, l.height)), fs(c) && c.width > 0) {
          const g = u.style.opacity || c.style.opacity;
          h.globalAlpha = g === "" ? 1 : Number(g);
          const d = c.style.transform;
          if (d)
            h.setTransform(
              .../** @type {[number, number, number, number, number, number]} */
              Fg(d)
            );
          else {
            const m = parseFloat(c.style.width) / c.width, x = parseFloat(c.style.height) / c.height;
            h.setTransform(m, 0, 0, x, 0, 0);
          }
          h.drawImage(c, 0, 0);
        }
      }
      h.globalAlpha = 1, h.setTransform(1, 0, 0, 1, 0, 0);
    }
    this.dispatchRenderEvent(Ht.POSTCOMPOSE, e), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(e);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */
  declutter(e, t) {
    if (e.declutter) {
      for (let n = t.length - 1; n >= 0; --n) {
        const r = t[n], s = r.layer;
        s.getDeclutter() && s.renderDeclutter(e, r);
      }
      t.forEach(
        (n) => n.layer.renderDeferred(e)
      );
    }
  }
}
function RS(i) {
  if (i instanceof Yr) {
    i.setMapInternal(null);
    return;
  }
  i instanceof Zr && i.getLayers().forEach(RS);
}
function PS(i, e) {
  if (i instanceof Yr) {
    i.setMapInternal(e);
    return;
  }
  if (i instanceof Zr) {
    const t = i.getLayers().getArray();
    for (let n = 0, r = t.length; n < r; ++n)
      PS(t[n], e);
  }
}
let Zc = class extends _r {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(e) {
    super(), e = e || {}, this.on, this.once, this.un;
    const t = s6(e);
    this.renderComplete_ = !1, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = e.maxTilesLoading !== void 0 ? e.maxTilesLoading : 16, this.pixelRatio_ = e.pixelRatio !== void 0 ? e.pixelRatio : cP, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = st(), this.pixelToCoordinateTransform_ = st(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, di || (this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_)), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = e.moveTolerance, this.keyboardEventTarget_ = t.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, di || (this.resizeObserver_ = new ResizeObserver(() => this.updateSize())), this.controls = t.controls || (di ? new rn() : F5()), this.interactions = t.interactions || (di ? new rn() : t6({
      onFocusOnly: !0
    })), this.overlays_ = t.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new vS(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    ), this.addChangeListener(
      yi.LAYERGROUP,
      this.handleLayerGroupChanged_
    ), this.addChangeListener(yi.VIEW, this.handleViewChanged_), this.addChangeListener(yi.SIZE, this.handleSizeChanged_), this.addChangeListener(yi.TARGET, this.handleTargetChanged_), this.setProperties(t.values);
    const n = this;
    e.view && !(e.view instanceof sr) && e.view.then(function(r) {
      n.setView(new sr(r));
    }), this.controls.addEventListener(
      ki.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (r) => {
        r.element.setMap(this);
      }
    ), this.controls.addEventListener(
      ki.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (r) => {
        r.element.setMap(null);
      }
    ), this.interactions.addEventListener(
      ki.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (r) => {
        r.element.setMap(this);
      }
    ), this.interactions.addEventListener(
      ki.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (r) => {
        r.element.setMap(null);
      }
    ), this.overlays_.addEventListener(
      ki.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (r) => {
        this.addOverlayInternal_(r.element);
      }
    ), this.overlays_.addEventListener(
      ki.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (r) => {
        const s = r.element.getId();
        s !== void 0 && delete this.overlayIdIndex_[s.toString()], r.element.setMap(null);
      }
    ), this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (r) => {
        r.setMap(this);
      }
    ), this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (r) => {
        r.setMap(this);
      }
    ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(e) {
    this.getControls().push(e);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(e) {
    this.getInteractions().push(e);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(e) {
    this.getLayerGroup().getLayers().push(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(e) {
    PS(e.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(e) {
    this.getOverlays().push(e);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(e) {
    const t = e.getId();
    t !== void 0 && (this.overlayIdIndex_[t.toString()] = e), e.setMap(this);
  }
  /**
   *
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_?.disconnect(), this.setTarget(null), super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * For polygons without a fill, only the stroke will be used for hit detection.
   * Polygons must have a fill style applied to ensure that pixels inside a polygon are detected.
   * The fill can be transparent.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(e, t, n) {
    if (!this.frameState_ || !this.renderer_)
      return;
    const r = this.getCoordinateFromPixelInternal(e);
    n = n !== void 0 ? n : {};
    const s = n.hitTolerance !== void 0 ? n.hitTolerance : 0, o = n.layerFilter !== void 0 ? n.layerFilter : Wl, a = n.checkWrapped !== !1;
    return this.renderer_.forEachFeatureAtCoordinate(
      r,
      this.frameState_,
      s,
      a,
      t,
      null,
      o,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * For polygons without a fill, only the stroke will be used for hit detection.
   * Polygons must have a fill style applied to ensure that pixels inside a polygon are detected.
   * The fill can be transparent.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(e, t) {
    const n = [];
    return this.forEachFeatureAtPixel(
      e,
      function(r) {
        n.push(r);
      },
      t
    ), n;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const e = [];
    function t(n) {
      n.forEach(function(r) {
        r instanceof Zr ? t(r.getLayers()) : e.push(r);
      });
    }
    return t(this.getLayers()), e;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * For polygons without a fill, only the stroke will be used for hit detection.
   * Polygons must have a fill style applied to ensure that pixels inside a polygon are detected.
   * The fill can be transparent.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(e, t) {
    if (!this.frameState_ || !this.renderer_)
      return !1;
    const n = this.getCoordinateFromPixelInternal(e);
    t = t !== void 0 ? t : {};
    const r = t.layerFilter !== void 0 ? t.layerFilter : Wl, s = t.hitTolerance !== void 0 ? t.hitTolerance : 0, o = t.checkWrapped !== !1;
    return this.renderer_.hasFeatureAtCoordinate(
      n,
      this.frameState_,
      s,
      o,
      r,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(e) {
    return this.getCoordinateFromPixel(this.getEventPixel(e));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(e) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(e));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(e) {
    const n = this.viewport_.getBoundingClientRect(), r = this.getSize(), s = n.width / r[0], o = n.height / r[1], a = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in e ? (
        /** @type {TouchEvent} */
        e.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        e
      )
    );
    return [
      (a.clientX - n.left) / s,
      (a.clientY - n.top) / o
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(yi.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(e) {
    return uc(
      this.getCoordinateFromPixelInternal(e),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(e) {
    const t = this.frameState_;
    return t ? rt(t.pixelToCoordinateTransform, e.slice()) : null;
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */
  getOverlayById(e) {
    const t = this.overlayIdIndex_[e.toString()];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(yi.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(e) {
    const t = this.getLayerGroup();
    if (e instanceof rn) {
      t.setLayers(e);
      return;
    }
    const n = t.getLayers();
    n.clear(), n.extend(e);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    return this.getLayerGroup().getLayers();
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let t = 0, n = e.length; t < n; ++t) {
      const r = e[t];
      if (!r.visible)
        continue;
      const s = r.layer.getRenderer();
      if (s && !s.ready)
        return !0;
      const o = r.layer.getSource();
      if (o && o.loading)
        return !0;
    }
    return !1;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(e) {
    const t = Pr(
      e,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(t);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(e) {
    const t = this.frameState_;
    return t ? rt(
      t.coordinateToPixelTransform,
      e.slice(0, 2)
    ) : null;
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(yi.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(yi.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const e = this.getTargetElement();
    return e ? e.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(e, t, n, r) {
    return C5(
      this.frameState_,
      e,
      t,
      n,
      r
    );
  }
  /**
   * @param {PointerEvent|KeyboardEvent|WheelEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(e, t) {
    t = t || e.type;
    const n = new ss(t, this, e);
    this.handleMapBrowserEvent(n);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(e) {
    if (!this.frameState_)
      return;
    const t = e.originalEvent, n = t.type;
    if (n === Sp.POINTERDOWN || n === le.WHEEL || n === le.KEYDOWN) {
      const r = this.getOwnerDocument(), s = this.viewport_.getRootNode ? this.viewport_.getRootNode() : r, o = (
        /** @type {Node} */
        t.target
      ), a = s instanceof ShadowRoot ? s.host === o ? s.host.ownerDocument : s : s === r ? r.documentElement : s;
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(o) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !a.contains(o)
      )
        return;
    }
    if (e.frameState = this.frameState_, this.dispatchEvent(e) !== !1) {
      const r = this.getInteractions().getArray().slice();
      for (let s = r.length - 1; s >= 0; s--) {
        const o = r[s];
        if (o.getMap() !== this || !o.getActive() || !this.getTargetElement())
          continue;
        if (!o.handleEvent(e) || e.propagationStopped)
          break;
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const e = this.frameState_, t = this.tileQueue_;
    if (!t.isEmpty()) {
      let r = this.maxTilesLoading_, s = r;
      if (e) {
        const o = e.viewHints;
        if (o[Xe.ANIMATING] || o[Xe.INTERACTING]) {
          const a = Date.now() - e.time > 8;
          r = a ? 0 : 8, s = a ? 0 : 2;
        }
      }
      t.getTilesLoading() < r && (t.reprioritize(), t.loadMoreTiles(r, s));
    }
    e && this.renderer_ && !e.animate && (this.renderComplete_ ? (this.hasListener(Ht.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
      Ht.RENDERCOMPLETE,
      e
    ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
      new qo(os.LOADEND, this, e)
    ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
      new qo(os.LOADSTART, this, e)
    )));
    const n = this.postRenderFunctions_;
    if (e)
      for (let r = 0, s = n.length; r < s; ++r)
        n[r](this, e);
    n.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let n = 0, r = this.targetChangeHandlerKeys_.length; n < r; ++n)
        tt(this.targetChangeHandlerKeys_[n]);
      this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
        le.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      ), this.viewport_.removeEventListener(
        le.WHEEL,
        this.boundHandleBrowserEvent_
      ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, this.viewport_.remove();
    }
    if (this.targetElement_ && !fs(this.targetElement_)) {
      this.resizeObserver_?.unobserve(this.targetElement_);
      const n = this.targetElement_.getRootNode();
      n instanceof ShadowRoot && this.resizeObserver_.unobserve(n.host), this.setSize(void 0);
    }
    const e = this.getTarget(), t = typeof e == "string" ? document.getElementById(e) : e;
    if (this.targetElement_ = t, !t)
      this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
    else {
      if (fs(t) || t.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new r6(this)), !fs(t)) {
        this.mapBrowserEventHandler_ = new P5(
          this,
          this.moveTolerance_
        );
        for (const r in Ot)
          this.mapBrowserEventHandler_.addEventListener(
            Ot[r],
            this.handleMapBrowserEvent.bind(this)
          );
        this.viewport_.addEventListener(
          le.CONTEXTMENU,
          this.boundHandleBrowserEvent_,
          !1
        ), this.viewport_.addEventListener(
          le.WHEEL,
          this.boundHandleBrowserEvent_,
          QE ? { passive: !1 } : !1
        );
        let n;
        if (this.keyboardEventTarget_)
          n = this.keyboardEventTarget_;
        else {
          const r = t.getRootNode();
          n = r instanceof ShadowRoot ? r.host : t;
        }
        if (this.targetChangeHandlerKeys_ = [
          Ce(
            n,
            le.KEYDOWN,
            this.handleBrowserEvent,
            this
          ),
          Ce(
            n,
            le.KEYPRESS,
            this.handleBrowserEvent,
            this
          )
        ], t instanceof HTMLElement) {
          const r = t.getRootNode();
          r instanceof ShadowRoot && this.resizeObserver_.observe(r.host), this.resizeObserver_?.observe(t);
        }
      }
      this.updateSize();
    }
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    this.viewPropertyListenerKey_ && (tt(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (tt(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
    const e = this.getView();
    e && (this.updateViewportSize_(this.getSize()), this.viewPropertyListenerKey_ = Ce(
      e,
      xa.PROPERTYCHANGE,
      this.handleViewPropertyChanged_,
      this
    ), this.viewChangeListenerKey_ = Ce(
      e,
      le.CHANGE,
      this.handleViewPropertyChanged_,
      this
    ), e.resolveConstraints(0)), this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(tt), this.layerGroupPropertyListenerKeys_ = null);
    const e = this.getLayerGroup();
    e && (this.handleLayerAdd_(new ls("addlayer", e)), this.layerGroupPropertyListenerKeys_ = [
      Ce(e, xa.PROPERTYCHANGE, this.render, this),
      Ce(e, le.CHANGE, this.render, this),
      Ce(e, "addlayer", this.handleLayerAdd_, this),
      Ce(e, "removelayer", this.handleLayerRemove_, this)
    ]), this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    if (!this.frameState_)
      return;
    const e = this.frameState_.layerStatesArray;
    for (let t = 0, n = e.length; t < n; ++t) {
      const r = e[t].layer;
      r.hasRenderer() && r.getRenderer().handleFontsChanged();
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(e) {
    return this.getControls().remove(e);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(e) {
    return this.getInteractions().remove(e);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(e) {
    return this.getLayerGroup().getLayers().remove(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(e) {
    RS(e.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(e) {
    return this.getOverlays().remove(e);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(e) {
    const t = this.getSize(), n = this.getView(), r = this.frameState_;
    let s = null;
    if (t !== void 0 && Q_(t) && n && n.isDef()) {
      const o = n.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      ), a = n.getState();
      if (s = {
        animate: !1,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutter: null,
        extent: nc(
          a.center,
          a.resolution,
          a.rotation,
          t
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: t,
        tileQueue: this.tileQueue_,
        time: e,
        usedTiles: {},
        viewState: a,
        viewHints: o,
        wantedTiles: {},
        mapId: ie(this),
        renderTargets: {}
      }, a.nextCenter && a.nextResolution) {
        const l = isNaN(a.nextRotation) ? a.rotation : a.nextRotation;
        s.nextExtent = nc(
          a.nextCenter,
          a.nextResolution,
          l,
          t
        );
      }
    }
    this.frameState_ = s, this.renderer_.renderFrame(s), s && (s.animate && this.render(), Array.prototype.push.apply(
      this.postRenderFunctions_,
      s.postRenderFunctions
    ), r && (!this.previousExtent_ || !qn(this.previousExtent_) && !Pn(s.extent, this.previousExtent_)) && (this.dispatchEvent(
      new qo(os.MOVESTART, this, r)
    ), this.previousExtent_ = Ua(this.previousExtent_)), this.previousExtent_ && !s.viewHints[Xe.ANIMATING] && !s.viewHints[Xe.INTERACTING] && !Pn(s.extent, this.previousExtent_) && (this.dispatchEvent(
      new qo(os.MOVEEND, this, s)
    ), mE(s.extent, this.previousExtent_))), this.dispatchEvent(new qo(os.POSTRENDER, this, s)), this.renderComplete_ = (this.hasListener(os.LOADSTART) || this.hasListener(os.LOADEND) || this.hasListener(Ht.RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady(), this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
      this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
    }, 0));
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(e) {
    const t = this.getLayerGroup();
    t && this.handleLayerRemove_(new ls("removelayer", t)), this.set(yi.LAYERGROUP, e);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(e) {
    this.set(yi.SIZE, e);
  }
  /**
   * Set the target element to render this map into.
   * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
   *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
   *  `tabindex` atribute must be set on the custom element's host element.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(e) {
    this.set(yi.TARGET, e);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>|null} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(e) {
    if (!e || e instanceof sr) {
      this.set(yi.VIEW, e);
      return;
    }
    this.set(yi.VIEW, new sr());
    const t = this;
    e.then(function(n) {
      t.setView(new sr(n));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const e = this.getTargetElement();
    let t;
    if (e) {
      let r, s;
      if (fs(e))
        r = e.width, s = e.height;
      else {
        const o = getComputedStyle(e);
        r = e.offsetWidth - parseFloat(o.borderLeftWidth) - parseFloat(o.paddingLeft) - parseFloat(o.paddingRight) - parseFloat(o.borderRightWidth), s = e.offsetHeight - parseFloat(o.borderTopWidth) - parseFloat(o.paddingTop) - parseFloat(o.paddingBottom) - parseFloat(o.borderBottomWidth);
      }
      !isNaN(r) && !isNaN(s) && (t = [Math.max(0, r), Math.max(0, s)], !Q_(t) && (e.offsetWidth || e.offsetHeight || e.getClientRects().length) && EE(
        "No map visible because the map container's width or height are 0."
      ));
    }
    const n = this.getSize();
    t && (!n || !Xr(t, n)) && (this.setSize(t), this.updateViewportSize_(t));
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(e) {
    const t = this.getView();
    t && t.setViewportSize(e);
  }
};
function s6(i) {
  let e = null;
  i.keyboardEventTarget !== void 0 && (e = typeof i.keyboardEventTarget == "string" ? document.getElementById(i.keyboardEventTarget) : i.keyboardEventTarget);
  const t = {}, n = i.layers && typeof /** @type {?} */
  i.layers.getLayers == "function" ? (
    /** @type {LayerGroup} */
    i.layers
  ) : new Zr({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      i.layers
    )
  });
  t[yi.LAYERGROUP] = n, t[yi.TARGET] = i.target, t[yi.VIEW] = i.view instanceof sr ? i.view : new sr();
  let r;
  i.controls !== void 0 && (Array.isArray(i.controls) ? r = new rn(i.controls.slice()) : (Te(
    typeof /** @type {?} */
    i.controls.getArray == "function",
    "Expected `controls` to be an array or an `ol/Collection.js`"
  ), r = i.controls));
  let s;
  i.interactions !== void 0 && (Array.isArray(i.interactions) ? s = new rn(i.interactions.slice()) : (Te(
    typeof /** @type {?} */
    i.interactions.getArray == "function",
    "Expected `interactions` to be an array or an `ol/Collection.js`"
  ), s = i.interactions));
  let o;
  return i.overlays !== void 0 ? Array.isArray(i.overlays) ? o = new rn(i.overlays.slice()) : (Te(
    typeof /** @type {?} */
    i.overlays.getArray == "function",
    "Expected `overlays` to be an array or an `ol/Collection.js`"
  ), o = i.overlays) : o = new rn(), {
    controls: r,
    interactions: s,
    keyboardEventTarget: e,
    overlays: o,
    values: t
  };
}
const MS = "https://api.mapbox.com";
function c_(i) {
  const e = "mapbox://";
  return i.indexOf(e) !== 0 ? "" : i.slice(e.length);
}
function o6(i, e, t) {
  if (typeof i == "string")
    return [
      {
        id: "default",
        url: vx(i, e, t)
      }
    ];
  for (const n of i)
    n.url = vx(n.url, e, t);
  return i;
}
function vx(i, e, t) {
  const n = c_(i);
  if (!n)
    return decodeURI(new URL(i, t).href);
  const r = "sprites/";
  if (n.indexOf(r) !== 0)
    throw new Error(`unexpected sprites url: ${i}`);
  const s = n.slice(r.length);
  return `${MS}/styles/v1/${s}/sprite?access_token=${e}`;
}
function Hc(i, e) {
  const t = c_(i);
  if (!t)
    return decodeURI(new URL(i, location.href).href);
  const n = "styles/";
  if (t.indexOf(n) !== 0)
    throw new Error(`unexpected style url: ${i}`);
  const r = t.slice(n.length);
  return `${MS}/styles/v1/${r}?&access_token=${e}`;
}
const a6 = ["a", "b", "c", "d"];
function Ju(i, e, t, n) {
  const r = new URL(i, n || location.href), s = c_(i);
  if (!s)
    return e ? (r.searchParams.has(t) || r.searchParams.set(t, e), [decodeURI(r.href)]) : [decodeURI(r.href)];
  if (s === "mapbox.satellite") {
    const o = window.devicePixelRatio >= 1.5 ? "@2x" : "";
    return [
      `https://api.mapbox.com/v4/${s}/{z}/{x}/{y}${o}.webp?access_token=${e}`
    ];
  }
  return a6.map(
    (o) => `https://${o}.tiles.mapbox.com/v4/${s}/{z}/{x}/{y}.vector.pbf?access_token=${e}`
  );
}
const Un = Object.freeze({}), wx = {}, bx = {};
let l6 = 0;
function f_(i) {
  return i.id || (i.id = l6++), i.id;
}
function h6(i, e) {
  return f_(i) + "." + ie(e);
}
function CS(i) {
  let e = wx[i.id];
  return e || (e = {}, wx[f_(i)] = e), e;
}
function u6(i) {
  let e = bx[i.id];
  return e || (e = {}, bx[f_(i)] = e), e;
}
function pg(i) {
  return i * Math.PI / 180;
}
const pr = (function() {
  const i = [];
  for (let e = 78271.51696402048; i.length <= 24; e /= 2)
    i.push(e);
  return i;
})();
function cd(i, e) {
  if (typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof OffscreenCanvas < "u")
    return (
      /** @type {?} */
      new OffscreenCanvas(i, e)
    );
  const t = document.createElement("canvas");
  return t.width = i, t.height = e, t;
}
function d_(i, e) {
  let t = 0;
  const n = e.length;
  for (; t < n; ++t)
    if (e[t] < i && t + 1 < n) {
      const s = e[t] / e[t + 1];
      return t + Math.log(e[t] / i) / Math.log(s);
    }
  return n - 1;
}
function bl(i, e) {
  const t = Math.floor(i), n = Math.pow(2, i - t);
  return e[t] / n;
}
const Uo = {};
function Fa(i, e, t = {}, n) {
  if (e in Uo)
    return n && (n.url = Uo[e][0].url), Uo[e][1];
  const r = t.transformRequest && t.transformRequest(e, i) || e, s = function(l) {
    return delete Uo[e], Promise.reject(new Error("Error fetching source " + e));
  }, o = function(l) {
    return delete Uo[e], l.ok ? l.json() : Promise.reject(new Error("Error fetching source " + e));
  }, a = ro(() => r).then((l) => l instanceof Response ? (n && (n.url = l.url), o(l)) : (l instanceof Request || (l = new Request(l)), l.headers.get("Accept") || l.headers.set("Accept", "application/json"), n && (n.url = l.url), fetch(l).then(o).catch(s))).catch(s);
  return Uo[e] = [r, a], a;
}
function AS(i, e) {
  if (typeof i == "string")
    if (i.trim().startsWith("{"))
      try {
        const t = JSON.parse(i);
        return Promise.resolve(t);
      } catch (t) {
        return Promise.reject(t);
      }
    else
      return i = Hc(i, e.accessToken), Fa("Style", i, e);
  else
    return Promise.resolve(i);
}
const Sx = {};
function IS(i, e, t = {}) {
  const n = [e, JSON.stringify(i)].toString();
  let r = Sx[n];
  if (!r || t.transformRequest) {
    let s;
    t.transformRequest && (s = (a, l) => {
      const h = t.transformRequest && t.transformRequest(l, "Tiles") || l;
      if (a instanceof Cb)
        a.setLoader((u, c, f) => {
          const g = function(d) {
            d.arrayBuffer().then((m) => {
              const v = a.getFormat().readFeatures(m, {
                extent: u,
                featureProjection: f
              });
              a.setFeatures(v);
            });
          };
          ro(() => h).then((d) => {
            if (d instanceof Response)
              return g(d);
            fetch(d).then(g).catch((m) => a.setState(X.ERROR));
          }).catch((d) => a.setState(X.ERROR));
        });
      else {
        const u = a.getImage();
        ro(() => h).then((c) => {
          if (typeof c == "string") {
            u.src = c;
            return;
          }
          const f = (g) => g.blob().then((d) => {
            const m = URL.createObjectURL(d);
            u.addEventListener("load", () => URL.revokeObjectURL(m)), u.addEventListener("error", () => URL.revokeObjectURL(m)), u.src = m;
          });
          if (c instanceof Response)
            return f(c);
          fetch(c).then(f).catch((g) => a.setState(X.ERROR));
        }).catch((c) => a.setState(X.ERROR));
      }
    });
    const o = i.url;
    if (o && !i.tiles) {
      const a = Ju(
        o,
        t.accessToken,
        t.accessTokenParam || "access_token",
        e || location.href
      );
      if (o.startsWith("mapbox://"))
        r = Promise.resolve({
          tileJson: Object.assign({}, i, {
            url: void 0,
            tiles: a
          }),
          tileLoadFunction: s
        });
      else {
        const l = {};
        r = Fa(
          "Source",
          a[0],
          t,
          l
        ).then(function(h) {
          return h.tiles = h.tiles.map(function(u) {
            return h.scheme === "tms" && (u = u.replace("{y}", "{-y}")), Ju(
              u,
              t.accessToken,
              t.accessTokenParam || "access_token",
              l.url
            )[0];
          }), Promise.resolve({ tileJson: h, tileLoadFunction: s });
        });
      }
    } else i.tiles ? (i = Object.assign({}, i, {
      tiles: i.tiles.map(function(a) {
        return i.scheme === "tms" && (a = a.replace("{y}", "{-y}")), Ju(
          a,
          t.accessToken,
          t.accessTokenParam || "access_token",
          e || location.href
        )[0];
      })
    }), r = Promise.resolve({
      tileJson: Object.assign({}, i),
      tileLoadFunction: s
    })) : r = Promise.reject(new Error("source has no `tiles` nor `url`"));
    Sx[n] = r;
  }
  return r;
}
function Tx(i, e, t, n) {
  const r = [
    2 * t * e.pixelRatio + e.width,
    2 * t * e.pixelRatio + e.height
  ], s = cd(r[0], r[1]), o = s.getContext("2d");
  o.drawImage(
    i,
    e.x,
    e.y,
    e.width,
    e.height,
    t * e.pixelRatio,
    t * e.pixelRatio,
    e.width,
    e.height
  );
  const a = o.getImageData(0, 0, r[0], r[1]);
  o.globalCompositeOperation = "destination-over", o.fillStyle = `rgba(${n.r * 255},${n.g * 255},${n.b * 255},${n.a})`;
  const l = a.data;
  for (let h = 0, u = a.width; h < u; ++h)
    for (let c = 0, f = a.height; c < f; ++c) {
      const g = (c * u + h) * 4;
      l[g + 3] > 0 && o.arc(
        h,
        c,
        t * e.pixelRatio,
        0,
        2 * Math.PI
      );
    }
  return o.fill(), s;
}
function c6(i, e, t) {
  const n = Math.max(0, Math.min(1, (t - i) / (e - i)));
  return n * n * (3 - 2 * n);
}
function Rx(i, e, t) {
  const n = cd(e.width, e.height), r = n.getContext("2d");
  r.drawImage(
    i,
    e.x,
    e.y,
    e.width,
    e.height,
    0,
    0,
    e.width,
    e.height
  );
  const s = r.getImageData(0, 0, e.width, e.height), o = s.data;
  for (let a = 0, l = s.width; a < l; ++a)
    for (let h = 0, u = s.height; h < u; ++h) {
      const c = (h * l + a) * 4, f = o[c + 3] / 255, g = 0.75, d = 0.1, m = c6(g - d, g + d, f);
      m > 0 ? (o[c + 0] = Math.round(255 * t.r * m), o[c + 1] = Math.round(255 * t.g * m), o[c + 2] = Math.round(255 * t.b * m), o[c + 3] = Math.round(255 * m)) : o[c + 3] = 0;
    }
  return r.putImageData(s, 0, 0), n;
}
const f6 = Array(256).join(" ");
function Rp(i, e) {
  if (e >= 0.05) {
    let t = "";
    const n = i.split(`
`), r = f6.slice(
      0,
      Math.round(e / 0.1)
    );
    for (let s = 0, o = n.length; s < o; ++s)
      s > 0 && (t += `
`), t += n[s].split("").join(r);
    return t;
  }
  return i;
}
let mg;
function LS() {
  return mg || (mg = cd(1, 1).getContext("2d")), mg;
}
function ks(i, e) {
  return LS().measureText(i).width + (i.length - 1) * e;
}
const Kc = {};
js.on("propertychange", () => {
  for (const i in Kc)
    delete Kc[i];
});
function Pp(i, e, t, n) {
  if (i.indexOf(`
`) !== -1) {
    const o = i.split(`
`), a = [];
    for (let l = 0, h = o.length; l < h; ++l)
      a.push(Pp(o[l], e, t, n));
    return a.join(`
`);
  }
  const r = t + "," + e + "," + i + "," + n;
  let s = Kc[r];
  if (!s) {
    const o = i.split(" ");
    if (o.length > 1) {
      const a = LS();
      a.font = e;
      const h = a.measureText("M").width * t;
      let u = "";
      const c = [];
      for (let f = 0, g = o.length; f < g; ++f) {
        const d = o[f], m = u + (u ? " " : "") + d;
        ks(m, n) <= h ? u = m : (u && c.push(u), u = d);
      }
      u && c.push(u);
      for (let f = 0, g = c.length; f < g && g > 1; ++f) {
        const d = c[f];
        if (ks(d, n) < h * 0.35) {
          const m = f > 0 ? ks(c[f - 1], n) : 1 / 0, x = f < g - 1 ? ks(c[f + 1], n) : 1 / 0;
          c.splice(f, 1), g -= 1, m < x ? (c[f - 1] += " " + d, f -= 1) : c[f] = d + " " + c[f];
        }
      }
      for (let f = 0, g = c.length - 1; f < g; ++f) {
        const d = c[f], m = c[f + 1];
        if (ks(d, n) > h * 0.7 && ks(m, n) < h * 0.6) {
          const x = d.split(" "), v = x.pop();
          ks(v, n) < h * 0.2 && (c[f] = x.join(" "), c[f + 1] = v + " " + m), g -= 1;
        }
      }
      s = c.join(`
`);
    } else
      s = i;
    s = Rp(s, n), Kc[r] = s;
  }
  return s;
}
const d6 = [
  "Arial",
  "Courier New",
  "Times New Roman",
  "Verdana",
  "sans-serif",
  "serif",
  "monospace",
  "cursive",
  "fantasy"
], Px = {};
function g6(i, e = "https://cdn.jsdelivr.net/npm/@fontsource/{font-family}/{fontweight}{-fontstyle}.css") {
  if (di)
    return i;
  let t;
  for (let n = 0, r = i.length; n < r; ++n) {
    const s = i[n];
    if (s in Px)
      continue;
    Px[s] = !0;
    const a = bp(s, 16).split(" ");
    t || (t = []), t.push([
      a.slice(3).join(" ").replace(/"/g, ""),
      a[1],
      a[0]
    ]);
  }
  return t && (async () => {
    await document.fonts.ready;
    for (let n = 0, r = t.length; n < r; ++n) {
      const s = t[n], o = s[0];
      if (d6.includes(o))
        continue;
      const a = s[1], l = s[2];
      if (!(await document.fonts.load(
        `${l} ${a} 16px "${o}"`
      )).some(
        (u) => u.family.replace(/^['"]|['"]$/g, "").toLowerCase() === o.toLowerCase() && u.weight == a && u.style === l
      )) {
        const u = e.replace("{font-family}", o.replace(/ /g, "-").toLowerCase()).replace("{Font+Family}", o.replace(/ /g, "+")).replace("{fontweight}", a).replace(
          "{-fontstyle}",
          l.replace("normal", "").replace(/(.+)/, "-$1")
        ).replace("{fontstyle}", l);
        if (!document.querySelector('link[href="' + u + '"]')) {
          const c = document.createElement("link");
          c.href = u, c.rel = "stylesheet", document.head.appendChild(c);
        }
      }
    }
  })(), i;
}
const p6 = {
  Point: 1,
  MultiPoint: 1,
  LineString: 2,
  MultiLineString: 2,
  Polygon: 3,
  MultiPolygon: 3
}, m6 = {
  center: [0.5, 0.5],
  left: [0, 0.5],
  right: [1, 0.5],
  top: [0.5, 0],
  bottom: [0.5, 1],
  "top-left": [0, 0],
  "top-right": [1, 0],
  "bottom-left": [0, 1],
  "bottom-right": [1, 1]
}, _6 = function(i, e) {
  const t = d5(
    i,
    e
  );
  if (t.result === "error")
    throw new Error(
      t.value.map((n) => `${n.key}: ${n.message}`).join(", ")
    );
  return t.value;
}, hn = { zoom: 0, distanceFromCenter: 0 };
on.register(hd, {
  ...on.definitions,
  pitch: [{ kind: "number" }, [], (i) => hn.pitch || 90],
  "distance-from-center": [
    { kind: "number" },
    [],
    (i) => hn.distanceFromCenter || 0
  ]
});
let Nu, _g;
function ce(i, e, t, n, r, s) {
  const o = i.id;
  r || (r = {}, console.warn("No functionCache provided to getValue()")), r[o] || (r[o] = {});
  const a = r[o];
  if (!a[t]) {
    let l = (i[e] || Un)[t];
    const h = R5[`${e}_${i.type}`][t];
    l === void 0 && (l = h.default);
    let u = f5(l);
    if (!u && _S(l) && (l = E5(l, h), u = !0), u) {
      const c = _6(l, h);
      a[t] = c.evaluate.bind(c);
    } else
      h.type == "color" && (l = et.parse(l)), a[t] = function() {
        return l;
      };
  }
  return a[t](hn, n, s);
}
function Mx(i, e, t, n) {
  return ce(
    i,
    "layout",
    `${t}-allow-overlap`,
    e,
    n
  ) ? ce(
    i,
    "layout",
    `${t}-ignore-placement`,
    e,
    n
  ) ? "none" : "obstacle" : "declutter";
}
function y6(i, e, t, n) {
  if (n || console.warn("No filterCache provided to evaluateFilter()"), !(i in n))
    try {
      n[i] = _5(e).filter;
    } catch (r) {
      console.warn("Filter will evaluate to false: " + r.message), n[i] = function() {
        return !1;
      };
    }
  return n[i](hn, t);
}
function as(i, e) {
  if (i) {
    if (i.a === 0 || e === 0)
      return;
    const t = i.a;
    return e = e === void 0 ? 1 : e, t === 0 ? "transparent" : "rgba(" + Math.round(i.r * 255 / t) + "," + Math.round(i.g * 255 / t) + "," + Math.round(i.b * 255 / t) + "," + t * e + ")";
  }
  return i;
}
const x6 = /\{[^{}}]*\}/g;
function yg(i, e) {
  return i.replace(x6, function(t) {
    return e[t.slice(1, -1)] || "";
  });
}
function Cx(i, e) {
  let t = i.split(":")[0];
  return t === i && (t = "default"), e[t];
}
const E6 = {};
function v6(i, e, t, n = pr, r = void 0, s = void 0, o = void 0, a = void 0) {
  if (typeof e == "string" && (e = JSON.parse(e)), e.version != 8)
    throw new Error("glStyle version 8 required.");
  E6[h6(e, i)] = Array.from(arguments);
  const l = {};
  (typeof s == "string" || s instanceof Request || s instanceof Response || s instanceof Promise) && (s = { default: s });
  for (const b in s) {
    const T = s[b];
    ro(() => T).then(async (R) => {
      let M;
      if (typeof Image < "u") {
        const C = new Image();
        if (typeof R == "string")
          C.crossOrigin = "anonymous", C.src = R;
        else {
          let I;
          R instanceof Request ? I = await fetch(R) : R instanceof Response && (I = R);
          const O = await I.blob();
          M = URL.createObjectURL(O), C.src = M;
        }
        C.addEventListener("load", function I() {
          C.removeEventListener("load", I), l[b] = {
            image: C,
            size: [C.width, C.height]
          }, i.changed(), M && URL.revokeObjectURL(M);
        }), C.addEventListener("error", function I() {
          URL.revokeObjectURL(M), C.removeEventListener("error", I);
        });
      } else if (typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope) {
        const C = (
          /** @type {*} */
          self
        );
        C.postMessage({
          action: "loadImage",
          src: R
        }), C.addEventListener("message", function(O) {
          O.data.action === "imageLoaded" && O.data.src === R && (l[b] = {
            image: O.data.image,
            size: [O.data.image.width, O.data.image.height]
          });
        });
      }
    });
  }
  const h = Kb(e.layers), u = {}, c = [], f = {}, g = {}, d = CS(e), m = u6(e);
  let x;
  for (let b = 0, T = h.length; b < T; ++b) {
    const R = h[b], M = R.id;
    if (typeof t == "string" && R.source == t || Array.isArray(t) && t.indexOf(M) !== -1) {
      const C = R["source-layer"];
      if (x) {
        if (R.source !== x)
          throw new Error(
            `Layer "${M}" does not use source "${x}`
          );
      } else {
        x = R.source;
        const O = e.sources[x];
        if (!O)
          throw new Error(`Source "${x}" is not defined`);
        const z = O.type;
        if (z !== "vector" && z !== "geojson")
          throw new Error(
            `Source "${x}" is not of type "vector" or "geojson", but "${z}"`
          );
      }
      let I = u[C];
      I || (I = [], u[C] = I), I.push({
        layer: R,
        index: b
      }), c.push(M);
    }
  }
  const v = new Ri(), p = new gi(), y = [], E = function(b, T, R) {
    const M = (
      //@ts-ignore
      i.getSource?.()?.format_?.layerName_ ?? "mvt:layer"
    ), C = b.getProperties(), I = u[C[M]];
    if (!I)
      return;
    let O = n.indexOf(T);
    O == -1 && (O = d_(T, n)), hn.zoom = O, hn.distanceFromCenter = 0;
    const z = b.getGeometry(), _ = p6[z.getType()], w = i.get("map");
    if (w && w instanceof Zc && _ === 1) {
      const D = w.getSize();
      if (D) {
        const k = w.getView().getCenter(), U = Vt(z.getExtent());
        hn.distanceFromCenter = DT(k, U) / T / D[1];
      }
    }
    const S = {
      id: b.getId(),
      properties: C,
      type: _
    }, P = i.get("mapbox-featurestate")[b.getId()];
    let A = -1;
    for (let D = 0, k = I.length; D < k; ++D) {
      const U = I[D], G = U.layer, $ = G.id;
      if (R !== void 0 && R !== $)
        continue;
      const H = G.layout || Un, ne = G.paint || Un;
      if (H.visibility === "none" || "minzoom" in G && O < G.minzoom || "maxzoom" in G && O >= G.maxzoom)
        continue;
      const te = G.filter;
      if (!te || y6($, te, S, m)) {
        let re, ae, Re, xe, Ae, Z;
        const at = U.index;
        if (_ == 3 && (G.type == "fill" || G.type == "fill-extrusion"))
          if (ae = ce(
            G,
            "paint",
            G.type + "-opacity",
            S,
            d,
            P
          ), G.type + "-pattern" in ne) {
            const ct = ce(
              G,
              "paint",
              G.type + "-pattern",
              S,
              d,
              P
            );
            if (ct) {
              const nt = typeof ct == "string" ? yg(ct, C) : ct.toString(), Ve = Cx(nt, l);
              if (r && r[nt] && Ve) {
                ++A, Z = y[A], (!Z || !Z.getFill() || Z.getStroke() || Z.getText()) && (Z = new Mt({
                  fill: new gi()
                }), y[A] = Z), Re = Z.getFill(), Z.setZIndex(at);
                const He = nt + "." + ae;
                let Lt = g[He];
                if (!Lt) {
                  const Ge = r[nt], Ue = cd(
                    Ge.width,
                    Ge.height
                  ), Ut = (
                    /** @type {CanvasRenderingContext2D} */
                    Ue.getContext("2d")
                  );
                  Ut.globalAlpha = ae, Ut.drawImage(
                    Ve.image,
                    Ge.x,
                    Ge.y,
                    Ge.width,
                    Ge.height,
                    0,
                    0,
                    Ge.width,
                    Ge.height
                  ), Lt = Ut.createPattern(Ue, "repeat"), g[He] = Lt;
                }
                Re.setColor(Lt);
              }
            }
          } else
            re = as(
              ce(
                G,
                "paint",
                G.type + "-color",
                S,
                d,
                P
              ),
              ae
            ), G.type + "-outline-color" in ne && (Ae = as(
              ce(
                G,
                "paint",
                G.type + "-outline-color",
                S,
                d,
                P
              ),
              ae
            )), Ae || (Ae = re), (re || Ae) && (++A, Z = y[A], (!Z || re && !Z.getFill() || !re && Z.getFill() || Ae && !Z.getStroke() || !Ae && Z.getStroke() || Z.getText()) && (Z = new Mt({
              fill: re ? new gi() : void 0,
              stroke: Ae ? new Ri() : void 0
            }), y[A] = Z), re && (Re = Z.getFill(), Re.setColor(re)), Ae && (xe = Z.getStroke(), xe.setColor(Ae), xe.setWidth(0.5)), Z.setZIndex(at));
        if (_ != 1 && G.type == "line") {
          "line-pattern" in ne ? re = void 0 : re = as(
            ce(
              G,
              "paint",
              "line-color",
              S,
              d,
              P
            ),
            ce(
              G,
              "paint",
              "line-opacity",
              S,
              d,
              P
            )
          );
          const ct = ce(
            G,
            "paint",
            "line-width",
            S,
            d,
            P
          );
          re && ct > 0 && (++A, Z = y[A], (!Z || !Z.getStroke() || Z.getFill() || Z.getText()) && (Z = new Mt({
            stroke: new Ri()
          }), y[A] = Z), xe = Z.getStroke(), xe.setLineCap(
            ce(
              G,
              "layout",
              "line-cap",
              S,
              d,
              P
            )
          ), xe.setLineJoin(
            ce(
              G,
              "layout",
              "line-join",
              S,
              d,
              P
            )
          ), xe.setMiterLimit(
            ce(
              G,
              "layout",
              "line-miter-limit",
              S,
              d,
              P
            )
          ), xe.setColor(re), xe.setWidth(ct), xe.setLineDash(
            ne["line-dasharray"] ? ce(
              G,
              "paint",
              "line-dasharray",
              S,
              d,
              P
            ).map(function(nt) {
              return nt * ct;
            }) : null
          ), Z.setZIndex(at));
        }
        let ut = !1, Ee = null, gt = 0, St, It, Kn;
        if ((_ == 1 || _ == 2) && "icon-image" in H) {
          const ct = ce(
            G,
            "layout",
            "icon-image",
            S,
            d,
            P
          );
          if (ct) {
            St = typeof ct == "string" ? yg(ct, C) : ct.toString();
            let nt;
            const Ve = a ? a(i, St) : void 0, He = Cx(St, l);
            if (r && r[St] && He || Ve) {
              const Lt = ce(
                G,
                "layout",
                "icon-rotation-alignment",
                S,
                d,
                P
              );
              if (_ == 2) {
                const Ge = (
                  /** @type {*} */
                  b.getGeometry()
                );
                if (Ge.getFlatMidpoint || Ge.getFlatMidpoints) {
                  const Ue = Ge.getExtent();
                  if (Math.sqrt(
                    Math.max(
                      Math.pow((Ue[2] - Ue[0]) / T, 2),
                      Math.pow((Ue[3] - Ue[1]) / T, 2)
                    )
                  ) > 150) {
                    const Yt = Ge.getType() === "MultiLineString" ? Ge.getFlatMidpoints() : Ge.getFlatMidpoint();
                    if (_g || (Nu = [NaN, NaN], _g = new fi(
                      "Point",
                      Nu,
                      [],
                      2,
                      {},
                      void 0
                    )), nt = _g, Nu[0] = Yt[0], Nu[1] = Yt[1], ce(
                      G,
                      "layout",
                      "symbol-placement",
                      S,
                      d,
                      P
                    ) === "line" && Lt === "map") {
                      const Ai = Ge.getStride(), qt = Ge.getFlatCoordinates();
                      for (let mi = 0, vt = qt.length - Ai; mi < vt; mi += Ai) {
                        const zt = qt[mi], ii = qt[mi + 1], lt = qt[mi + Ai], Ii = qt[mi + Ai + 1], iu = Math.min(zt, lt), nu = Math.max(zt, lt), _i = Yt[0], Er = Yt[1], Li = (Ii - ii) * (_i - zt) - (lt - zt) * (Er - ii);
                        if (Math.abs(Li) < 1e-3 && //midpoint is aligned with the segment
                        _i <= nu && _i >= iu) {
                          gt = Math.atan2(ii - Ii, lt - zt);
                          break;
                        }
                      }
                    }
                  }
                }
              }
              if (_ !== 2 || nt) {
                const Ge = ce(
                  G,
                  "layout",
                  "icon-size",
                  S,
                  d,
                  P
                ), Ue = ne["icon-color"] !== void 0 ? ce(
                  G,
                  "paint",
                  "icon-color",
                  S,
                  d,
                  P
                ) : null;
                if (!Ue || Ue.a !== 0) {
                  const Ut = ce(
                    G,
                    "paint",
                    "icon-halo-color",
                    S,
                    d,
                    P
                  ), Yt = ce(
                    G,
                    "paint",
                    "icon-halo-width",
                    S,
                    d,
                    P
                  );
                  let Hi = `${St}.${Ge}.${Yt}.${Ut}`;
                  if (Ue !== null && (Hi += `.${Ue}`), It = f[Hi], !It) {
                    const Ai = Mx(
                      G,
                      S,
                      "icon",
                      d
                    );
                    let qt;
                    "icon-offset" in H && (qt = ce(
                      G,
                      "layout",
                      "icon-offset",
                      S,
                      d,
                      P
                    ).slice(0), qt[0] *= Ge, qt[1] *= -Ge);
                    let mi = Ue ? [
                      Ue.r * 255,
                      Ue.g * 255,
                      Ue.b * 255,
                      Ue.a
                    ] : void 0;
                    if (Ve) {
                      const vt = {
                        color: mi,
                        rotateWithView: Lt === "map",
                        displacement: qt,
                        declutterMode: Ai,
                        scale: Ge
                      };
                      typeof Ve == "string" ? vt.src = Ve : (vt.img = Ve, vt.imgSize = [
                        Ve.width,
                        Ve.height
                      ]), It = new Ts(vt);
                    } else {
                      const vt = r[St];
                      let zt, ii, lt;
                      if (Yt)
                        vt.sdf ? (zt = Tx(
                          Rx(
                            He.image,
                            vt,
                            Ue || [0, 0, 0, 1]
                          ),
                          {
                            x: 0,
                            y: 0,
                            width: vt.width,
                            height: vt.height,
                            pixelRatio: vt.pixelRatio
                          },
                          Yt,
                          Ut
                        ), mi = void 0) : zt = Tx(
                          He.image,
                          vt,
                          Yt,
                          Ut
                        );
                      else {
                        if (vt.sdf && !He.unSDFed) {
                          const Ii = Rx(
                            He.image,
                            {
                              x: 0,
                              y: 0,
                              width: He.size[0],
                              height: He.size[1]
                            },
                            { r: 1, g: 1, b: 1 }
                          );
                          He.image = Ii, He.unSDFed = !0;
                        }
                        zt = He.image, ii = [vt.width, vt.height], lt = [vt.x, vt.y];
                      }
                      It = new Ts({
                        color: mi,
                        img: zt,
                        // @ts-ignore
                        imgSize: He.size,
                        size: ii,
                        offset: lt,
                        rotateWithView: Lt === "map",
                        scale: Ge / vt.pixelRatio,
                        displacement: qt,
                        declutterMode: Ai
                      });
                    }
                    f[Hi] = It;
                  }
                }
                It && (++A, Z = y[A], (!Z || !Z.getImage() || Z.getFill() || Z.getStroke()) && (Z = new Mt(), y[A] = Z), Z.setGeometry(nt), It.setRotation(
                  gt + pg(
                    ce(
                      G,
                      "layout",
                      "icon-rotate",
                      S,
                      d,
                      P
                    )
                  )
                ), It.setOpacity(
                  ce(
                    G,
                    "paint",
                    "icon-opacity",
                    S,
                    d,
                    P
                  )
                ), It.setAnchor(
                  m6[ce(
                    G,
                    "layout",
                    "icon-anchor",
                    S,
                    d,
                    P
                  )]
                ), Z.setImage(It), Ee = Z.getText(), Z.setText(void 0), Z.setZIndex(at), ut = !0, Kn = !1);
              } else
                Kn = !0;
            }
          }
        }
        if (_ == 1 && G.type === "circle") {
          ++A, Z = y[A], (!Z || !Z.getImage() || Z.getFill() || Z.getStroke()) && (Z = new Mt(), y[A] = Z);
          const ct = "circle-radius" in ne ? ce(
            G,
            "paint",
            "circle-radius",
            S,
            d,
            P
          ) : 5, nt = as(
            ce(
              G,
              "paint",
              "circle-stroke-color",
              S,
              d,
              P
            ),
            ce(
              G,
              "paint",
              "circle-stroke-opacity",
              S,
              d,
              P
            )
          ), Ve = ce(
            G,
            "paint",
            "circle-translate",
            S,
            d,
            P
          ), He = as(
            ce(
              G,
              "paint",
              "circle-color",
              S,
              d,
              P
            ),
            ce(
              G,
              "paint",
              "circle-opacity",
              S,
              d,
              P
            )
          ), Lt = ce(
            G,
            "paint",
            "circle-stroke-width",
            S,
            d,
            P
          ), Ge = ct + "." + nt + "." + He + "." + Lt + "." + Ve[0] + "." + Ve[1];
          It = f[Ge], It || (It = new Xa({
            radius: ct,
            displacement: [Ve[0], -Ve[1]],
            stroke: nt && Lt > 0 ? new Ri({
              width: Lt,
              color: nt
            }) : void 0,
            fill: He ? new gi({
              color: He
            }) : void 0,
            declutterMode: "none"
          }), f[Ge] = It), Z.setImage(It), Ee = Z.getText(), Z.setText(void 0), Z.setGeometry(void 0), Z.setZIndex(at), ut = !0;
        }
        let Tt, Zi, cn, wi, Et, Os;
        if ("text-field" in H) {
          wi = Math.round(
            ce(
              G,
              "layout",
              "text-size",
              S,
              d,
              P
            )
          );
          const ct = ce(
            G,
            "layout",
            "text-font",
            S,
            d,
            P
          );
          cn = ce(
            G,
            "layout",
            "text-line-height",
            S,
            d,
            P
          ), Zi = bp(
            o ? o(
              ct,
              e.metadata ? e.metadata["ol:webfonts"] : void 0
            ) : ct,
            wi,
            cn
          ), Zi.includes("sans-serif") || (Zi += ",sans-serif"), Et = ce(
            G,
            "layout",
            "text-letter-spacing",
            S,
            d,
            P
          ), Os = ce(
            G,
            "layout",
            "text-max-width",
            S,
            d,
            P
          );
          const nt = ce(
            G,
            "layout",
            "text-field",
            S,
            d,
            P
          );
          typeof nt == "object" && nt.sections ? nt.sections.length === 1 ? Tt = nt.toString() : Tt = nt.sections.reduce((Ve, He, Lt) => {
            const Ge = He.fontStack ? He.fontStack.split(",") : ct, Ue = bp(
              o ? o(Ge) : Ge,
              wi * (He.scale || 1),
              cn
            );
            let Ut = He.text;
            if (Ut === `
`)
              return Ve.push(`
`, ""), Ve;
            if (_ == 2)
              return Ve.push(Rp(Ut, Et), Ue), Ve;
            Ut = Pp(
              Ut,
              Ue,
              Os,
              Et
            ).split(`
`);
            for (let Yt = 0, Hi = Ut.length; Yt < Hi; ++Yt)
              Yt > 0 && Ve.push(`
`, ""), Ve.push(Ut[Yt], Ue);
            return Ve;
          }, []) : Tt = yg(nt, C).trim(), ae = ce(
            G,
            "paint",
            "text-opacity",
            S,
            d,
            P
          );
        }
        if (Tt && ae && !Kn) {
          ut || (++A, Z = y[A], (!Z || !Z.getText() || Z.getFill() || Z.getStroke()) && (Z = new Mt(), y[A] = Z), Z.setImage(void 0), Z.setGeometry(void 0));
          const ct = Mx(
            G,
            S,
            "text",
            d
          );
          Z.getText() || Z.setText(Ee), Ee = Z.getText(), (!Ee || "getDeclutterMode" in Ee && Ee.getDeclutterMode() !== ct) && (Ee = new Rs({
            padding: [2, 2, 2, 2],
            // @ts-ignore
            declutterMode: ct
          }), Z.setText(Ee));
          const nt = ce(
            G,
            "layout",
            "text-transform",
            S,
            d,
            P
          );
          nt == "uppercase" ? Tt = Array.isArray(Tt) ? Tt.map((lt, Ii) => Ii % 2 ? lt : lt.toUpperCase()) : Tt.toUpperCase() : nt == "lowercase" && (Tt = Array.isArray(Tt) ? Tt.map((lt, Ii) => Ii % 2 ? lt : lt.toLowerCase()) : Tt.toLowerCase());
          const Ve = Array.isArray(Tt) ? Tt : _ == 2 ? Rp(Tt, Et) : Pp(Tt, Zi, Os, Et);
          if (Ee.setText(Ve), Ee.setFont(Zi), Ee.setRotation(
            pg(
              ce(
                G,
                "layout",
                "text-rotate",
                S,
                d,
                P
              )
            )
          ), typeof Ee.setKeepUpright == "function") {
            const lt = ce(
              G,
              "layout",
              "text-keep-upright",
              S,
              d,
              P
            );
            Ee.setKeepUpright(lt);
          }
          const He = ce(
            G,
            "layout",
            "text-anchor",
            S,
            d,
            P
          ), Lt = ut || _ == 1 ? "point" : ce(
            G,
            "layout",
            "symbol-placement",
            S,
            d,
            P
          );
          let Ge;
          if (Lt === "line-center" ? (Ee.setPlacement("line"), Ge = "center") : Ee.setPlacement(Lt), Lt === "line" && typeof Ee.setRepeat == "function") {
            const lt = ce(
              G,
              "layout",
              "symbol-spacing",
              S,
              d,
              P
            );
            Ee.setRepeat(lt * 2);
          }
          Ee.setOverflow(Lt === "point");
          let Ue = ce(
            G,
            "paint",
            "text-halo-width",
            S,
            d,
            P
          );
          const Ut = ce(
            G,
            "layout",
            "text-offset",
            S,
            d,
            P
          ), Yt = ce(
            G,
            "paint",
            "text-translate",
            S,
            d,
            P
          );
          let Hi = 0, Ai = 0;
          if (Lt == "point") {
            Ge = "center", He.indexOf("left") !== -1 ? (Ge = "left", Ai = Ue) : He.indexOf("right") !== -1 && (Ge = "right", Ai = -Ue);
            const lt = ce(
              G,
              "layout",
              "text-rotation-alignment",
              S,
              d,
              P
            );
            Ee.setRotateWithView(lt == "map");
          } else
            Ee.setMaxAngle(
              pg(
                ce(
                  G,
                  "layout",
                  "text-max-angle",
                  S,
                  d,
                  P
                )
              ) * Tt.length / Ve.length
            ), Ee.setRotateWithView(!1);
          Ee.setTextAlign(Ge);
          let qt = "middle";
          He.indexOf("bottom") == 0 ? (qt = "bottom", Hi = -Ue - 0.5 * (cn - 1) * wi) : He.indexOf("top") == 0 && (qt = "top", Hi = Ue + 0.5 * (cn - 1) * wi), Ee.setTextBaseline(qt);
          const mi = ce(
            G,
            "layout",
            "text-justify",
            S,
            d,
            P
          );
          Ee.setJustify(mi === "auto" ? void 0 : mi), Ee.setOffsetX(
            Ut[0] * wi + Ai + Yt[0]
          ), Ee.setOffsetY(
            Ut[1] * wi + Hi + Yt[1]
          ), p.setColor(
            as(
              ce(
                G,
                "paint",
                "text-color",
                S,
                d,
                P
              ),
              ae
            )
          ), Ee.setFill(p);
          const vt = as(
            ce(
              G,
              "paint",
              "text-halo-color",
              S,
              d,
              P
            ),
            ae
          );
          if (vt && Ue > 0) {
            v.setColor(vt), Ue *= 2;
            const lt = 0.5 * wi;
            v.setWidth(
              Ue <= lt ? Ue : lt
            ), Ee.setStroke(v);
          } else
            Ee.setStroke(void 0);
          const zt = ce(
            G,
            "layout",
            "text-padding",
            S,
            d,
            P
          ), ii = Ee.getPadding();
          zt !== ii[0] && (ii[0] = zt, ii[1] = zt, ii[2] = zt, ii[3] = zt), Z.setZIndex(at);
        }
      }
    }
    if (A > -1)
      return y.length = A + 1, y;
  };
  return i.setStyle(E), i.set("mapbox-layers", c), i.set("mapbox-source", x), i.set("mapbox-featurestate", i.get("mapbox-featurestate") || {}), E;
}
function FS(i) {
  return function(e) {
    const t = e.buffers, n = e.meta, r = e.imageOps, s = e.width, o = e.height, a = t.length, l = t[0].byteLength;
    if (r) {
      const f = new Array(a);
      for (let d = 0; d < a; ++d)
        f[d] = new ImageData(
          new Uint8ClampedArray(t[d]),
          s,
          o
        );
      return i(f, n).data.buffer;
    }
    const h = new Uint8ClampedArray(l), u = new Array(a), c = new Array(a);
    for (let f = 0; f < a; ++f)
      u[f] = new Uint8ClampedArray(t[f]), c[f] = [0, 0, 0, 0];
    for (let f = 0; f < l; f += 4) {
      for (let d = 0; d < a; ++d) {
        const m = u[d];
        c[d][0] = m[f], c[d][1] = m[f + 1], c[d][2] = m[f + 2], c[d][3] = m[f + 3];
      }
      const g = i(c, n);
      h[f] = g[0], h[f + 1] = g[1], h[f + 2] = g[2], h[f + 3] = g[3];
    }
    return h.buffer;
  };
}
function w6(i, e) {
  const n = Object.keys(i.lib || {}).map(function(s) {
    return "const " + s + " = " + i.lib[s].toString() + ";";
  }).concat([
    "const __minion__ = (" + FS.toString() + ")(",
    i.operation.toString(),
    ");",
    'self.addEventListener("message", function(event) {',
    "  const buffer = __minion__(event.data);",
    "  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);",
    "});"
  ]), r = new Worker(
    typeof Blob > "u" ? "data:text/javascript;base64," + Buffer.from(n.join(`
`), "binary").toString("base64") : URL.createObjectURL(new Blob(n, { type: "text/javascript" }))
  );
  return r.addEventListener("message", e), r;
}
function b6(i, e) {
  const t = FS(i.operation);
  let n = !1;
  return {
    postMessage: function(r) {
      setTimeout(function() {
        n || e({ data: { buffer: t(r), meta: r.meta } });
      }, 0);
    },
    terminate: function() {
      n = !0;
    }
  };
}
class S6 extends Da {
  /**
   * @param {ProcessorOptions} config Configuration.
   */
  constructor(e) {
    super(), this.imageOps_ = !!e.imageOps;
    let t;
    e.threads === 0 ? t = 0 : this.imageOps_ ? t = 1 : t = e.threads || 1;
    const n = new Array(t);
    if (t)
      for (let r = 0; r < t; ++r)
        n[r] = w6(e, this.onWorkerMessage_.bind(this, r));
    else
      n[0] = b6(
        e,
        this.onWorkerMessage_.bind(this, 0)
      );
    this.workers_ = n, this.queue_ = [], this.maxQueueLength_ = e.queue || 1 / 0, this.running_ = 0, this.dataLookup_ = {}, this.job_ = null;
  }
  /**
   * Run operation on input data.
   * @param {Array<ImageData>} inputs Array of image data.
   * @param {Object} meta A user data object.  This is passed to all operations
   *     and must be serializable.
   * @param {function(Error, ImageData, Object): void} callback Called when work
   *     completes.  The first argument is any error.  The second is the ImageData
   *     generated by operations.  The third is the user data object.
   */
  process(e, t, n) {
    this.enqueue_({
      inputs: e,
      meta: t,
      callback: n
    }), this.dispatch_();
  }
  /**
   * Add a job to the queue.
   * @param {Job} job The job.
   */
  enqueue_(e) {
    for (this.queue_.push(e); this.queue_.length > this.maxQueueLength_; )
      this.queue_.shift().callback(null, null);
  }
  /**
   * Dispatch a job.
   */
  dispatch_() {
    if (this.running_ || this.queue_.length === 0)
      return;
    const e = this.queue_.shift();
    this.job_ = e;
    const t = e.inputs[0].width, n = e.inputs[0].height, r = e.inputs.map(function(l) {
      return l.data.buffer;
    }), s = this.workers_.length;
    if (this.running_ = s, s === 1) {
      this.workers_[0].postMessage(
        {
          buffers: r,
          meta: e.meta,
          imageOps: this.imageOps_,
          width: t,
          height: n
        },
        r
      );
      return;
    }
    const o = e.inputs[0].data.length, a = 4 * Math.ceil(o / 4 / s);
    for (let l = 0; l < s; ++l) {
      const h = l * a, u = [];
      for (let c = 0, f = r.length; c < f; ++c)
        u.push(r[c].slice(h, h + a));
      this.workers_[l].postMessage(
        {
          buffers: u,
          meta: e.meta,
          imageOps: this.imageOps_,
          width: t,
          height: n
        },
        u
      );
    }
  }
  /**
   * Handle messages from the worker.
   * @param {number} index The worker index.
   * @param {MessageEvent} event The message event.
   */
  onWorkerMessage_(e, t) {
    this.disposed || (this.dataLookup_[e] = t.data, --this.running_, this.running_ === 0 && this.resolveJob_());
  }
  /**
   * Resolve a job.  If there are no more worker threads, the processor callback
   * will be called.
   */
  resolveJob_() {
    const e = this.job_, t = this.workers_.length;
    let n, r;
    if (t === 1)
      n = new Uint8ClampedArray(this.dataLookup_[0].buffer), r = this.dataLookup_[0].meta;
    else {
      const s = e.inputs[0].data.length;
      n = new Uint8ClampedArray(s), r = new Array(t);
      const o = 4 * Math.ceil(s / 4 / t);
      for (let a = 0; a < t; ++a) {
        const l = this.dataLookup_[a].buffer, h = a * o;
        n.set(new Uint8ClampedArray(l), h), r[a] = this.dataLookup_[a].meta;
      }
    }
    this.job_ = null, this.dataLookup_ = {}, e.callback(
      null,
      new ImageData(n, e.inputs[0].width, e.inputs[0].height),
      r
    ), this.dispatch_();
  }
  /**
   * Terminate all workers associated with the processor.
   * @override
   */
  disposeInternal() {
    for (let e = 0; e < this.workers_.length; ++e)
      this.workers_[e].terminate();
    this.workers_.length = 0;
  }
}
const Ax = {
  /**
   * Triggered before operations are run.  Listeners will receive an event object with
   * a `data` property that can be used to make data available to operations.
   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations
   * @api
   */
  BEFOREOPERATIONS: "beforeoperations",
  /**
   * Triggered after operations are run.  Listeners will receive an event object with
   * a `data` property.  If more than one thread is used, `data` will be an array of
   * objects.  If a single thread is used, `data` will be a single object.
   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations
   * @api
   */
  AFTEROPERATIONS: "afteroperations"
};
class Ix extends In {
  /**
   * @param {string} type Type.
   * @param {import("../Map.js").FrameState} frameState The frame state.
   * @param {Object|Array<Object>} data An object made available to operations.  For "afteroperations" evenets
   * this will be an array of objects if more than one thread is used.
   */
  constructor(e, t, n) {
    super(e), this.extent = t.extent, this.resolution = t.viewState.resolution / t.pixelRatio, this.data = n;
  }
}
class g_ extends To {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    super({
      projection: null
    }), this.on, this.once, this.un, this.processor_ = null, this.operationType_ = e.operationType !== void 0 ? e.operationType : "pixel", this.threads_ = e.threads !== void 0 ? e.threads : 1, this.layers_ = P6(e.sources);
    const t = this.changed.bind(this);
    for (let n = 0, r = this.layers_.length; n < r; ++n)
      this.layers_[n].addEventListener(le.CHANGE, t);
    this.useResolutions_ = e.resolutions !== null, this.tileQueue_ = new vS(function() {
      return 1;
    }, this.processSources_.bind(this)), this.requestedFrameState_, this.renderedImageCanvas_ = null, this.renderedRevision_, this.frameState_ = {
      animate: !1,
      coordinateToPixelTransform: st(),
      declutter: null,
      extent: null,
      index: 0,
      layerIndex: 0,
      layerStatesArray: R6(this.layers_),
      pixelRatio: 1,
      pixelToCoordinateTransform: st(),
      postRenderFunctions: [],
      size: [0, 0],
      tileQueue: this.tileQueue_,
      time: Date.now(),
      usedTiles: {},
      viewState: (
        /** @type {import("../View.js").State} */
        {
          rotation: 0
        }
      ),
      viewHints: [],
      wantedTiles: {},
      mapId: ie(this),
      renderTargets: {}
    }, this.setAttributions(function(n) {
      const r = [];
      for (let s = 0, o = e.sources.length; s < o; ++s) {
        const a = e.sources[s], l = a instanceof vo ? a : a.getSource();
        if (!l)
          continue;
        const h = l.getAttributions()?.(n);
        typeof h == "string" ? r.push(h) : h !== void 0 && r.push(...h);
      }
      return r;
    }), e.operation !== void 0 && this.setOperation(e.operation, e.lib);
  }
  /**
   * Set the operation.
   * @param {Operation} operation New operation.
   * @param {Object} [lib] Functions that will be available to operations run
   *     in a worker.
   * @api
   */
  setOperation(e, t) {
    this.processor_ && this.processor_.dispose(), this.processor_ = new S6({
      operation: e,
      imageOps: this.operationType_ === "image",
      queue: 1,
      lib: t,
      threads: this.threads_
    }), this.changed();
  }
  /**
   * Update the stored frame state.
   * @param {import("../extent.js").Extent} extent The view extent (in map units).
   * @param {number} resolution The view resolution.
   * @param {import("../proj/Projection.js").default} projection The view projection.
   * @return {import("../Map.js").FrameState} The updated frame state.
   * @private
   */
  updateFrameState_(e, t, n) {
    const r = (
      /** @type {import("../Map.js").FrameState} */
      Object.assign({}, this.frameState_)
    );
    r.viewState = /** @type {import("../View.js").State} */
    Object.assign({}, r.viewState);
    const s = Vt(e);
    r.size[0] = Math.ceil(_e(e) / t), r.size[1] = Math.ceil(it(e) / t), r.extent = [
      s[0] - r.size[0] * t / 2,
      s[1] - r.size[1] * t / 2,
      s[0] + r.size[0] * t / 2,
      s[1] + r.size[1] * t / 2
    ], r.time = Date.now();
    const o = r.viewState;
    return o.center = s, o.projection = n, o.resolution = t, r;
  }
  /**
   * Determine if all sources are ready.
   * @return {boolean} All sources are ready.
   * @private
   */
  allSourcesReady_() {
    let e = !0, t;
    for (let n = 0, r = this.layers_.length; n < r; ++n)
      if (t = this.layers_[n].getSource(), !t || t.getState() !== "ready") {
        e = !1;
        break;
      }
    return e;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageCanvas.js").default} Single image.
   * @override
   */
  getImage(e, t, n, r) {
    if (!this.allSourcesReady_())
      return null;
    this.tileQueue_.loadMoreTiles(16, 16), t = this.findNearestResolution(t);
    const s = this.updateFrameState_(e, t, r);
    if (this.requestedFrameState_ = s, this.renderedImageCanvas_) {
      const o = this.renderedImageCanvas_.getResolution(), a = this.renderedImageCanvas_.getExtent();
      (t !== o || !Pn(s.extent, a)) && (this.renderedImageCanvas_ = null);
    }
    return (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) && this.processSources_(), s.animate && requestAnimationFrame(this.changed.bind(this)), this.renderedImageCanvas_;
  }
  /**
   * Start processing source data.
   * @private
   */
  processSources_() {
    const e = this.requestedFrameState_, t = this.layers_.length, n = new Array(t);
    for (let s = 0; s < t; ++s) {
      e.layerIndex = s, e.renderTargets = {};
      const o = T6(this.layers_[s], e);
      if (o)
        n[s] = o;
      else
        return;
    }
    const r = {};
    this.dispatchEvent(
      new Ix(Ax.BEFOREOPERATIONS, e, r)
    ), this.processor_.process(
      n,
      r,
      this.onWorkerComplete_.bind(this, e)
    );
  }
  /**
   * Called when pixel processing is complete.
   * @param {import("../Map.js").FrameState} frameState The frame state.
   * @param {Error} err Any error during processing.
   * @param {ImageData} output The output image data.
   * @param {Object|Array<Object>} data The user data (or an array if more than one thread).
   * @private
   */
  onWorkerComplete_(e, t, n, r) {
    if (t || !n)
      return;
    const s = e.extent, o = e.viewState.resolution;
    if (o !== this.requestedFrameState_.viewState.resolution || !Pn(s, this.requestedFrameState_.extent))
      return;
    let a;
    if (this.renderedImageCanvas_)
      a = /** @type {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} */
      this.renderedImageCanvas_.getImage().getContext("2d");
    else {
      const l = Math.round(_e(s) / o), h = Math.round(it(s) / o);
      a = ot(l, h), this.renderedImageCanvas_ = new h0(
        s,
        o,
        1,
        a.canvas
      );
    }
    a.putImageData(n, 0, 0), e.animate ? requestAnimationFrame(this.changed.bind(this)) : this.changed(), this.renderedRevision_ = this.getRevision(), this.dispatchEvent(
      new Ix(Ax.AFTEROPERATIONS, e, r)
    );
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   * @override
   */
  getResolutions(e) {
    if (!this.useResolutions_)
      return null;
    let t = super.getResolutions();
    if (!t)
      for (let n = 0, r = this.layers_.length; n < r && (t = this.layers_[n].getSource().getResolutions(e), !t); ++n)
        ;
    return t;
  }
  /**
   * @override
   */
  disposeInternal() {
    this.processor_ && this.processor_.dispose(), super.disposeInternal();
  }
}
g_.prototype.dispose;
let Us = null;
function T6(i, e) {
  const t = i.getRenderer();
  if (!t)
    throw new Error("Unsupported layer type: " + i);
  if (!t.prepareFrame(e))
    return null;
  const n = e.size[0], r = e.size[1];
  if (n === 0 || r === 0)
    return null;
  const s = t.renderFrame(e, null);
  let o;
  if (s instanceof HTMLCanvasElement)
    o = s;
  else {
    if (s && (o = s.firstElementChild), !(o instanceof HTMLCanvasElement))
      throw new Error("Unsupported rendered element: " + o);
    if (o.width === n && o.height === r)
      return o.getContext("2d").getImageData(0, 0, n, r);
  }
  if (!Us)
    Us = ot(n, r, void 0, {
      willReadFrequently: !0
    });
  else {
    const a = Us.canvas;
    a.width !== n || a.height !== r ? Us = ot(n, r, void 0, {
      willReadFrequently: !0
    }) : Us.clearRect(0, 0, n, r);
  }
  return Us.drawImage(o, 0, 0, n, r), Us.getImageData(0, 0, n, r);
}
function R6(i) {
  return i.map(function(e) {
    return e.getLayerState();
  });
}
function P6(i) {
  const e = i.length, t = new Array(e);
  for (let n = 0; n < e; ++n)
    t[n] = M6(i[n]);
  return t;
}
function M6(i) {
  let e;
  return i instanceof vo ? i instanceof Wf ? e = new Gc({ source: i }) : i instanceof To && (e = new P0({ source: i })) : e = i, e;
}
function C6(i, e) {
  const t = i[0], n = t.width, r = t.height, s = t.data, o = new Uint8ClampedArray(s.length), a = e.resolution * 2, l = n - 1, h = r - 1, u = [0, 0, 0, 0], c = 2 * Math.PI, f = Math.PI / 2, g = Math.PI * e.sunEl / 180, d = Math.PI * e.sunAz / 180, m = Math.cos(g), x = Math.sin(g), v = e.highlightColor, p = e.shadowColor, y = e.accentColor, E = e.encoding;
  let b, T, R, M, C, I, O, z, _, w, S, P, A, D, k, U, G, $, H, ne, te, re;
  function ae(Re, xe = "mapbox") {
    if (xe === "mapbox")
      return (Re[0] * 256 * 256 + Re[1] * 256 + Re[2]) * 0.1 - 1e4;
    if (xe === "terrarium")
      return Re[0] * 256 + Re[1] + Re[2] / 256 - 32768;
  }
  for (T = 0; T <= h; ++T)
    for (C = T === 0 ? 0 : T - 1, I = T === h ? h : T + 1, b = 0; b <= l; ++b)
      R = b === 0 ? 0 : b - 1, M = b === l ? l : b + 1, O = (T * n + R) * 4, u[0] = s[O], u[1] = s[O + 1], u[2] = s[O + 2], u[3] = s[O + 3], z = e.vert * ae(u, E), O = (T * n + M) * 4, u[0] = s[O], u[1] = s[O + 1], u[2] = s[O + 2], u[3] = s[O + 3], _ = e.vert * ae(u, E), w = (_ - z) / a, O = (C * n + b) * 4, u[0] = s[O], u[1] = s[O + 1], u[2] = s[O + 2], u[3] = s[O + 3], z = e.vert * ae(u, E), O = (I * n + b) * 4, u[0] = s[O], u[1] = s[O + 1], u[2] = s[O + 2], u[3] = s[O + 3], _ = e.vert * ae(u, E), S = (_ - z) / a, A = Math.atan2(S, -w), A < 0 ? A = f - A : A > f ? A = c - A + f : A = f - A, P = Math.atan(Math.sqrt(w * w + S * S)), re = x * Math.cos(P) + m * Math.sin(P) * Math.cos(d - A), D = Math.cos(P), k = 255 * re, H = Math.min(Math.max(2 * e.sunEl, 0), 1), ne = 1.875 - e.opacity * 1.75, te = e.opacity !== 0.5 ? f * ((Math.pow(ne, P) - 1) / (Math.pow(ne, f) - 1)) : P, G = {
        r: (1 - D) * y.r * H * 255,
        g: (1 - D) * y.g * H * 255,
        b: (1 - D) * y.b * H * 255,
        a: (1 - D) * y.a * H * 255
      }, U = Math.abs(((A + d) / Math.PI + 0.5) % 2 - 1), $ = {
        r: (v.r * (1 - U) + p.r * U) * k,
        g: (v.g * (1 - U) + p.g * U) * k,
        b: (v.b * (1 - U) + p.b * U) * k,
        a: (v.a * (1 - U) + p.a * U) * k
      }, O = (T * n + b) * 4, o[O] = G.r * (1 - U) + $.r, o[O + 1] = G.g * (1 - U) + $.g, o[O + 2] = G.b * (1 - U) + $.b, o[O + 3] = s[O + 3] * e.opacity * H * Math.sin(te);
  return new ImageData(o, n, r);
}
function A6(i, e = 512) {
  return i.getExtent() ? xr({
    extent: i.getExtent(),
    tileSize: e,
    maxZoom: 22
  }).getResolutions() : pr;
}
function OS(i, e) {
  return e.accessToken || (e = Object.assign({}, e), new URL(i).searchParams.forEach((n, r) => {
    e.accessToken = n, e.accessTokenParam = r;
  })), e;
}
function I6(i, e, t = "", n = {}, r = void 0) {
  let s, o, a, l, h = !0;
  return typeof t != "string" && !Array.isArray(t) ? (a = t, l = a.source || a.layers, n = a) : l = t, typeof n == "string" ? (s = n, a = {}) : (s = n.styleUrl, a = n), a.updateSource === !1 && (h = !1), r || (r = a.resolutions), !s && typeof e == "string" && !e.trim().startsWith("{") && (s = e), s && (s = s.startsWith("data:") ? location.href : Hc(s, a.accessToken), a = OS(s, a)), new Promise(function(u, c) {
    AS(e, a).then(function(f) {
      if (f.version != 8)
        return c(new Error("glStyle version 8 required."));
      if (!(i instanceof Nh || i instanceof da))
        return c(
          new Error("Can only apply to VectorLayer or VectorTileLayer")
        );
      const g = i instanceof da ? "vector" : "geojson";
      if (l ? Array.isArray(l) ? o = f.layers.find(function(E) {
        return E.id === l[0];
      }).source : o = l : (o = f.layers.find(function(E) {
        return E.source && f.sources[E.source].type === g;
      }).source, l = o), !o)
        return c(new Error(`No ${g} source found in the glStyle.`));
      function d() {
        if (!h)
          return Promise.resolve();
        if (i instanceof da)
          return GS(
            f.sources[o],
            s,
            a
          ).then(function(R) {
            const M = i.getSource();
            M ? R !== M && (M.setTileUrlFunction(R.getTileUrlFunction()), typeof M.setUrls == "function" && typeof R.getUrls == "function" && M.setUrls(R.getUrls()), M.format_ || (M.format_ = R.format_), M.getAttributions() || M.setAttributions(R.getAttributions()), M.getTileLoadFunction() === Ab && M.setTileLoadFunction(
              R.getTileLoadFunction()
            ), wt(
              M.getProjection(),
              R.getProjection()
            ) && (M.tileGrid = R.getTileGrid())) : i.setSource(R);
            const C = i.getSource().getTileGrid();
            !isFinite(i.getMaxResolution()) && !isFinite(i.getMinZoom()) && C.getMinZoom() > 0 && i.setMaxResolution(
              bl(
                Math.max(0, C.getMinZoom() - 1e-12),
                C.getResolutions()
              )
            );
          });
        const E = f.sources[o];
        let b = i.getSource();
        (!b || b.get("mapbox-source") !== E) && (b = zS(E, s, a));
        const T = (
          /** @type {VectorSource} */
          i.getSource()
        );
        return T ? b !== T && (T.getAttributions() || T.setAttributions(b.getAttributions()), T.format_ || (T.format_ = b.getFormat()), T.url_ = b.getUrl()) : i.setSource(b), Promise.resolve();
      }
      let m, x;
      const v = {}, p = {};
      function y() {
        if (!x && (!f.sprite || v)) {
          if (a.projection && !r) {
            const R = ee(a.projection).getUnits();
            R !== "m" && (r = pr.map(
              (M) => M / ws[R]
            ));
          }
          let E;
          const b = i.getSource();
          b instanceof Ja && b.format_ instanceof k0 && (E = b.format_.layerName_), x = v6(
            i,
            f,
            l,
            r,
            v,
            p,
            (T, R = a.webfonts) => g6(T, R),
            a.getImage,
            E
          ), i.getStyle() ? d().then(u).catch(c) : c(new Error(`Nothing to show for source [${o}]`));
        } else x ? (i.setStyle(x), d().then(u).catch(c)) : c(new Error("Something went wrong trying to apply style."));
      }
      if (f.sprite) {
        const E = o6(
          f.sprite,
          a.accessToken,
          s || location.href
        );
        m = di ? 1 : window.devicePixelRatio >= 1.5 ? 0.5 : 1;
        const b = m == 0.5 ? "@2x" : "";
        Promise.all(
          E.map(function(T) {
            const R = new URL(T.url);
            let M = R.origin + R.pathname + b + ".json" + R.search;
            return new Promise(function(C, I) {
              Fa("Sprite", M, a).then(C).catch(function(O) {
                M = R.origin + R.pathname + ".json" + R.search, Fa("Sprite", M, a).then(C).catch(I);
              });
            }).then(function(C) {
              C === void 0 && c(new Error("No sprites found."));
              let I;
              if (I = R.origin + R.pathname + b + ".png" + R.search, a.transformRequest) {
                const O = a.transformRequest(I, "SpriteImage") || I;
                (O instanceof Request || O instanceof Promise) && (I = O);
              }
              p[T.id] = I;
              for (const O in C) {
                const z = T.id == "default" ? O : `${T.id}:${O}`;
                v[z] = C[O];
              }
            }).catch(function(C) {
              c(
                new Error(
                  `Sprites cannot be loaded: ${M}: ${C.message}`
                )
              );
            });
          })
        ).then(y).catch(c);
      } else
        y();
    }).catch(c);
  });
}
function NS(i, e) {
  let t;
  return i.some(function(n) {
    if (n.id == e)
      return t = n.source, !0;
  }), t;
}
function L6(i, e) {
  const t = i.bounds;
  if (t) {
    const n = Ig([t[0], t[1]], e), r = Ig([t[2], t[3]], e);
    return [n[0], n[1], r[0], r[1]];
  }
  return ee(e).getExtent();
}
function DS(i, e, t) {
  const n = new qf({
    tileJSON: e,
    tileSize: i.tileSize || e.tileSize || 512
  }), r = n.getTileJSON(), s = n.getTileGrid(), o = ee(t.projection || "EPSG:3857"), a = L6(r, o), l = o.getExtent(), h = r.minzoom || 0, u = r.maxzoom || 22, c = {
    attributions: n.getAttributions(),
    projection: o,
    tileGrid: new qr({
      origin: l ? Mn(l) : s.getOrigin(0),
      extent: a || s.getExtent(),
      minZoom: h,
      resolutions: A6(o, e.tileSize).slice(
        0,
        u + 1
      ),
      tileSize: s.getTileSize(0)
    })
  };
  return Array.isArray(r.tiles) ? c.urls = r.tiles : c.url = r.tiles, c;
}
function F6(i, e, t, n) {
  const r = {
    id: i.id,
    type: i.type
  }, s = i.layout || {}, o = i.paint || {};
  r.paint = o, hn.zoom = d_(
    e,
    t.resolutions || pr
  ), hn.distanceFromCenter = 0;
  let a;
  const l = ce(
    r,
    "paint",
    "background-color",
    Un,
    n
  );
  return o["background-opacity"] !== void 0 && (a = ce(
    r,
    "paint",
    "background-opacity",
    Un,
    n
  )), s.visibility == "none" ? void 0 : as(l, a);
}
function O6(i, e, t) {
  const n = di ? (
    /** @type { HTMLDivElement } */
    { style: {} }
  ) : document.createElement("div");
  return n.className = "ol-mapbox-style-background", n.style.position = "absolute", n.style.width = "100%", n.style.height = "100%", new Yr({
    source: new vo({}),
    render(r) {
      const s = F6(
        i,
        r.viewState.resolution,
        e,
        t
      );
      return n.style.backgroundColor = s, n;
    }
  });
}
function GS(i, e, t) {
  return new Promise(function(n, r) {
    IS(i, e, t).then(function({ tileJson: s, tileLoadFunction: o }) {
      const a = DS(
        i,
        s,
        t
      );
      a.tileLoadFunction = o, a.format = new k0({ layerName: "mvt:layer" });
      const l = new Ja(a);
      l.set("mapbox-source", i), n(l);
    }).catch(r);
  });
}
function N6(i, e, t) {
  const n = new da({
    declutter: !0,
    visible: !1
  });
  return GS(i, e, t).then(function(r) {
    n.setSource(r);
  }).catch(function(r) {
    n.setSource(void 0);
  }), n;
}
function kS(i) {
  return `{bbox-${(i ? i.getCode() : "EPSG:3857").toLowerCase().replace(/[^a-z0-9]/g, "-")}}`;
}
function D6(i, e, t) {
  return new Promise(function(n, r) {
    IS(i, e, t).then(function({ tileJson: s, tileLoadFunction: o }) {
      const a = new qf({
        interpolate: t.interpolate === void 0 ? !0 : t.interpolate,
        transition: 0,
        crossOrigin: "anonymous",
        tileJSON: s
      });
      a.tileGrid = DS(
        i,
        s,
        t
      ).tileGrid, t.projection && (a.projection = ee(t.projection));
      const l = a.getTileUrlFunction();
      o && a.setTileLoadFunction(o), a.setTileUrlFunction(function(h, u, c) {
        const f = kS(c);
        let g = l(h, u, c);
        if (g.indexOf(f) != -1) {
          const d = a.getTileGrid().getTileCoordExtent(h);
          g = g.replace(f, d.toString());
        }
        return g;
      }), a.set("mapbox-source", i), n(a);
    }).catch(function(s) {
      r(s);
    });
  });
}
function US(i, e, t) {
  const n = new Gc();
  return D6(i, e, t).then(function(r) {
    n.setSource(r);
  }).catch(function() {
    n.setSource(void 0);
  }), n;
}
function G6(i, e, t) {
  const n = US(i, e, t);
  return new P0({
    source: new g_({
      operationType: "image",
      operation: C6,
      sources: [n]
    })
  });
}
function zS(i, e, t) {
  const n = t.projection ? new Dc({ dataProjection: t.projection }) : new Dc(), r = i.data, s = {};
  if (typeof r == "string") {
    const [a] = Ju(
      r,
      t.accessToken,
      t.accessTokenParam || "access_token",
      e || location.href
    );
    if (/\{bbox-[0-9a-z-]+\}/.test(a)) {
      const h = (c, f, g) => {
        const d = kS(g);
        return a.replace(d, `${c.join(",")}`);
      }, u = new ys({
        attributions: i.attribution,
        format: n,
        loader: (c, f, g, d, m) => {
          const x = typeof h == "function" ? h(c, f, g) : h;
          Fa("GeoJSON", x, t).then((v) => {
            const p = (
              /** @type {*} */
              u.getFormat().readFeatures(v, { featureProjection: g })
            );
            u.addFeatures(p), d(p);
          }).catch((v) => {
            u.removeLoadedExtent(c), m();
          });
        },
        strategy: rw
      });
      return u.set("mapbox-source", i), u;
    }
    const l = new ys({
      attributions: i.attribution,
      format: n,
      url: a,
      loader: (h, u, c, f, g) => {
        Fa("GeoJSON", a, t).then((d) => {
          const m = (
            /** @type {*} */
            l.getFormat().readFeatures(d, { featureProjection: c })
          );
          l.addFeatures(m), f(m);
        }).catch((d) => {
          l.removeLoadedExtent(h), g();
        });
      }
    });
    return l;
  }
  s.features = n.readFeatures(r, {
    featureProjection: "EPSG:3857"
  });
  const o = new ys(
    Object.assign(
      {
        attributions: i.attribution,
        format: n
      },
      s
    )
  );
  return o.set("mapbox-source", i), /** @type {VectorSource} */
  o;
}
function k6(i, e, t) {
  return new Nh({
    declutter: !0,
    source: zS(i, e, t),
    visible: !1
  });
}
function U6(i, e, t) {
  let n = null;
  return function(r) {
    i.paint && "raster-opacity" in i.paint && r.frameState.viewState.zoom !== n && (n = r.frameState.viewState.zoom, delete t[i.id], z6(i, e, n, t));
  };
}
function z6(i, e, t, n) {
  hn.zoom = t, hn.distanceFromCenter = 0;
  const r = ce(
    i,
    "paint",
    "raster-opacity",
    Un,
    n
  );
  e.setOpacity(r);
}
function B6(i, e) {
  function t() {
    const n = e.get("mapbox-style");
    if (!n)
      return;
    const r = Kb(n.layers), s = i.get("mapbox-layers"), o = r.filter(function(a) {
      return s.includes(a.id);
    }).some(function(a) {
      return !a.layout || !a.layout.visibility || a.layout.visibility === "visible";
    });
    i.get("visible") !== o && i.setVisible(o);
  }
  i.on("change", t), t();
}
function $6(i, e, t, n) {
  const r = CS(i), s = i.layers, o = t.type, a = t.source || NS(s, t.ref), l = i.sources[a];
  let h;
  if (o == "background")
    h = O6(t, n, r);
  else if (l.type == "vector")
    h = N6(l, e, n);
  else if (l.type == "raster")
    h = US(l, e, n), h.setVisible(
      t.layout ? t.layout.visibility !== "none" : !0
    ), h.on("prerender", U6(t, h, r));
  else if (l.type == "geojson")
    h = k6(l, e, n);
  else if (l.type == "raster-dem" && t.type == "hillshade") {
    const c = G6(l, e, n);
    h = c, c.getSource().on("beforeoperations", function(f) {
      const g = f.data;
      g.resolution = Cg(
        n.projection || "EPSG:3857",
        f.resolution,
        Vt(f.extent),
        "m"
      ), hn.zoom = d_(
        f.resolution,
        n.resolutions || pr
      ), hn.distanceFromCenter = 0, g.encoding = l.encoding, g.vert = 5 * ce(
        t,
        "paint",
        "hillshade-exaggeration",
        Un,
        r
      ), g.sunAz = ce(
        t,
        "paint",
        "hillshade-illumination-direction",
        Un,
        r
      ), g.sunEl = 35, g.opacity = 0.3, g.highlightColor = ce(
        t,
        "paint",
        "hillshade-highlight-color",
        Un,
        r
      ), g.shadowColor = ce(
        t,
        "paint",
        "hillshade-shadow-color",
        Un,
        r
      ), g.accentColor = ce(
        t,
        "paint",
        "hillshade-accent-color",
        Un,
        r
      );
    }), h.setVisible(
      t.layout ? t.layout.visibility !== "none" : !0
    );
  }
  const u = a;
  return h && h.set("mapbox-source", u), h;
}
function Lx(i, e, t, n) {
  const r = [];
  let s = null;
  if (e instanceof Zc) {
    if (s = e.getView(), !s.isDef() && !s.getRotation() && !s.getResolutions()) {
      const c = n.projection ? ee(n.projection) : s.getProjection();
      s = new sr(
        Object.assign(s.getProperties(), {
          maxResolution: pr[0] / ws[c.getUnits()],
          projection: n.projection || s.getProjection()
        })
      ), e.setView(s);
    }
    "center" in i && !s.getCenter() && s.setCenter(Ig(i.center, s.getProjection())), "zoom" in i && s.getZoom() === void 0 && s.setResolution(
      pr[0] / ws[s.getProjection().getUnits()] / Math.pow(2, i.zoom)
    ), (!s.getCenter() || s.getZoom() === void 0) && s.fit(s.getProjection().getExtent(), {
      nearest: !0,
      size: e.getSize()
    });
  }
  e.set("mapbox-style", i), e.set("mapbox-metadata", { styleUrl: t, options: n });
  const o = i.layers;
  let a = [], l, h, u;
  for (let c = 0, f = o.length; c < f; ++c) {
    const g = o[c], d = g.type;
    if (d == "heatmap") {
      console.debug(`layers[${c}].type "${d}" not supported`);
      continue;
    } else
      u = g.source || NS(o, g.ref), (!u || u != h) && (a.length && (r.push(
        Fx(
          l,
          a,
          i,
          t,
          e,
          n
        )
      ), a = []), l = $6(i, t, g, n), l instanceof Nh || l instanceof da || (a = []), h = l.get("mapbox-source")), a.push(g.id);
  }
  return r.push(
    Fx(l, a, i, t, e, n)
  ), Promise.all(r);
}
function j6(i, e, t = {}) {
  let n, r;
  if (di) {
    if (!(i instanceof Zc) && !(i instanceof Zr))
      throw new Error(
        "ol-mapbox-style in a web worker requires a Map or a LayerGroup as first argument"
      );
    r = i;
  } else
    typeof i == "string" || i instanceof HTMLElement ? r = new Zc({
      target: i
    }) : r = i;
  if (typeof e == "string") {
    const s = e.startsWith("data:") ? location.href : Hc(e, t.accessToken);
    t = OS(s, t), n = new Promise(function(o, a) {
      AS(e, t).then(function(l) {
        Lx(l, r, s, t).then(function() {
          o(r);
        }).catch(a);
      }).catch(function(l) {
        a(new Error(`Could not load ${e}: ${l.message}`));
      });
    });
  } else
    n = new Promise(function(s, o) {
      Lx(
        e,
        r,
        !t.styleUrl || t.styleUrl.startsWith("data:") ? location.href : Hc(t.styleUrl, t.accessToken),
        t
      ).then(function() {
        s(r);
      }).catch(o);
    });
  return n;
}
function Fx(i, e, t, n, r, s = {}) {
  let o = 24, a = 0;
  const l = t.layers;
  for (let h = 0, u = l.length; h < u; ++h) {
    const c = l[h];
    e.indexOf(c.id) !== -1 && (o = Math.min("minzoom" in c ? c.minzoom : 0, o), a = Math.max("maxzoom" in c ? c.maxzoom : 24, a));
  }
  return new Promise(function(h, u) {
    const c = function() {
      const g = i.getSource();
      if (!g || g.getState() === "error") {
        u(
          new Error(
            "Error accessing data for source " + i.get("mapbox-source")
          )
        );
        return;
      }
      if ("getTileGrid" in g) {
        const d = (
          /** @type {import("ol/source/Tile.js").default|import("ol/source/VectorTile.js").default} */
          g.getTileGrid()
        );
        if (d) {
          const m = d.getMinZoom();
          (o > 0 || m > 0) && i.setMaxResolution(
            Math.min(
              bl(
                Math.max(0, o - 1e-12),
                pr
              ),
              bl(
                Math.max(0, m - 1e-12),
                d.getResolutions()
              )
            )
          ), a < 24 && i.setMinResolution(
            bl(a, pr)
          );
        }
      } else
        o > 0 && i.setMaxResolution(
          bl(
            Math.max(0, o - 1e-12),
            pr
          )
        );
      g instanceof ys || g instanceof Ja ? I6(
        /** @type {import("ol/layer/Vector").default|import("ol/layer/VectorTile").default} */
        i,
        t,
        e,
        Object.assign({ styleUrl: n }, s)
      ).then(function() {
        B6(i, r), h();
      }).catch(u) : h();
    };
    i.set("mapbox-layers", e);
    const f = r.getLayers();
    f.getArray().indexOf(i) === -1 && f.push(i), i.getSource() ? c() : i.once("change:source", c);
  });
}
class X6 extends Zr {
  constructor(e = {}) {
    const { mapboxStyle: t, applyOptions: n, ...r } = e;
    super(r), t && this.applyMapboxStyle(t, n);
  }
  /**
   *
   * @param {*} mapboxStyle mapbox style definition
   * @param {import("ol-mapbox-style/dist/apply").Options} applyOptions ol-mapbox-style apply options
   * @returns
   */
  applyMapboxStyle(e, t) {
    return j6(this, e, t);
  }
}
function V6(i) {
  i("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), i("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), i("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  for (var e = 1; e <= 60; ++e)
    i("EPSG:" + (32600 + e), "+proj=utm +zone=" + e + " +datum=WGS84 +units=m"), i("EPSG:" + (32700 + e), "+proj=utm +zone=" + e + " +south +datum=WGS84 +units=m");
  i("EPSG:5041", "+title=WGS 84 / UPS North (E,N) +proj=stere +lat_0=90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +datum=WGS84 +units=m"), i("EPSG:5042", "+title=WGS 84 / UPS South (E,N) +proj=stere +lat_0=-90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +datum=WGS84 +units=m"), i.WGS84 = i["EPSG:4326"], i["EPSG:3785"] = i["EPSG:3857"], i.GOOGLE = i["EPSG:3857"], i["EPSG:900913"] = i["EPSG:3857"], i["EPSG:102113"] = i["EPSG:3857"];
}
var po = 1, mo = 2, ma = 3, W6 = 4, Mp = 5, Ox = 6378137, Y6 = 6356752314e-3, Nx = 0.0066943799901413165, zl = 484813681109536e-20, Y = Math.PI / 2, q6 = 0.16666666666666666, Z6 = 0.04722222222222222, H6 = 0.022156084656084655, J = 1e-10, Nt = 0.017453292519943295, $i = 57.29577951308232, Je = Math.PI / 4, ph = Math.PI * 2, Gt = 3.14159265359, qi = {};
qi.greenwich = 0;
qi.lisbon = -9.131906111111;
qi.paris = 2.337229166667;
qi.bogota = -74.080916666667;
qi.madrid = -3.687938888889;
qi.rome = 12.452333333333;
qi.bern = 7.439583333333;
qi.jakarta = 106.807719444444;
qi.ferro = -17.666666666667;
qi.brussels = 4.367975;
qi.stockholm = 18.058277777778;
qi.athens = 23.7163375;
qi.oslo = 10.722916666667;
const K6 = {
  mm: { to_meter: 1e-3 },
  cm: { to_meter: 0.01 },
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 },
  fath: { to_meter: 1.8288 },
  kmi: { to_meter: 1852 },
  "us-ch": { to_meter: 20.1168402336805 },
  "us-mi": { to_meter: 1609.34721869444 },
  km: { to_meter: 1e3 },
  "ind-ft": { to_meter: 0.30479841 },
  "ind-yd": { to_meter: 0.91439523 },
  mi: { to_meter: 1609.344 },
  yd: { to_meter: 0.9144 },
  ch: { to_meter: 20.1168 },
  link: { to_meter: 0.201168 },
  dm: { to_meter: 0.1 },
  in: { to_meter: 0.0254 },
  "ind-ch": { to_meter: 20.11669506 },
  "us-in": { to_meter: 0.025400050800101 },
  "us-yd": { to_meter: 0.914401828803658 }
};
var Dx = /[\s_\-\/\(\)]/g;
function Ms(i, e) {
  if (i[e])
    return i[e];
  for (var t = Object.keys(i), n = e.toLowerCase().replace(Dx, ""), r = -1, s, o; ++r < t.length; )
    if (s = t[r], o = s.toLowerCase().replace(Dx, ""), o === n)
      return i[s];
}
function Cp(i) {
  var e = {}, t = i.split("+").map(function(a) {
    return a.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(a, l) {
    var h = l.split("=");
    return h.push(!0), a[h[0].toLowerCase()] = h[1], a;
  }, {}), n, r, s, o = {
    proj: "projName",
    datum: "datumCode",
    rf: function(a) {
      e.rf = parseFloat(a);
    },
    lat_0: function(a) {
      e.lat0 = a * Nt;
    },
    lat_1: function(a) {
      e.lat1 = a * Nt;
    },
    lat_2: function(a) {
      e.lat2 = a * Nt;
    },
    lat_ts: function(a) {
      e.lat_ts = a * Nt;
    },
    lon_0: function(a) {
      e.long0 = a * Nt;
    },
    lon_1: function(a) {
      e.long1 = a * Nt;
    },
    lon_2: function(a) {
      e.long2 = a * Nt;
    },
    alpha: function(a) {
      e.alpha = parseFloat(a) * Nt;
    },
    gamma: function(a) {
      e.rectified_grid_angle = parseFloat(a) * Nt;
    },
    lonc: function(a) {
      e.longc = a * Nt;
    },
    x_0: function(a) {
      e.x0 = parseFloat(a);
    },
    y_0: function(a) {
      e.y0 = parseFloat(a);
    },
    k_0: function(a) {
      e.k0 = parseFloat(a);
    },
    k: function(a) {
      e.k0 = parseFloat(a);
    },
    a: function(a) {
      e.a = parseFloat(a);
    },
    b: function(a) {
      e.b = parseFloat(a);
    },
    r: function(a) {
      e.a = e.b = parseFloat(a);
    },
    r_a: function() {
      e.R_A = !0;
    },
    zone: function(a) {
      e.zone = parseInt(a, 10);
    },
    south: function() {
      e.utmSouth = !0;
    },
    towgs84: function(a) {
      e.datum_params = a.split(",").map(function(l) {
        return parseFloat(l);
      });
    },
    to_meter: function(a) {
      e.to_meter = parseFloat(a);
    },
    units: function(a) {
      e.units = a;
      var l = Ms(K6, a);
      l && (e.to_meter = l.to_meter);
    },
    from_greenwich: function(a) {
      e.from_greenwich = a * Nt;
    },
    pm: function(a) {
      var l = Ms(qi, a);
      e.from_greenwich = (l || parseFloat(a)) * Nt;
    },
    nadgrids: function(a) {
      a === "@null" ? e.datumCode = "none" : e.nadgrids = a;
    },
    axis: function(a) {
      var l = "ewnsud";
      a.length === 3 && l.indexOf(a.substr(0, 1)) !== -1 && l.indexOf(a.substr(1, 1)) !== -1 && l.indexOf(a.substr(2, 1)) !== -1 && (e.axis = a);
    },
    approx: function() {
      e.approx = !0;
    },
    over: function() {
      e.over = !0;
    }
  };
  for (n in t)
    r = t[n], n in o ? (s = o[n], typeof s == "function" ? s(r) : e[s] = r) : e[n] = r;
  return typeof e.datumCode == "string" && e.datumCode !== "WGS84" && (e.datumCode = e.datumCode.toLowerCase()), e.projStr = i, e;
}
class BS {
  static getId(e) {
    const t = e.find((n) => Array.isArray(n) && n[0] === "ID");
    return t && t.length >= 3 ? {
      authority: t[1],
      code: parseInt(t[2], 10)
    } : null;
  }
  static convertUnit(e, t = "unit") {
    if (!e || e.length < 3)
      return { type: t, name: "unknown", conversion_factor: null };
    const n = e[1], r = parseFloat(e[2]) || null, s = e.find((a) => Array.isArray(a) && a[0] === "ID"), o = s ? {
      authority: s[1],
      code: parseInt(s[2], 10)
    } : null;
    return {
      type: t,
      name: n,
      conversion_factor: r,
      id: o
    };
  }
  static convertAxis(e) {
    const t = e[1] || "Unknown";
    let n;
    const r = t.match(/^\((.)\)$/);
    if (r) {
      const h = r[1].toUpperCase();
      if (h === "E") n = "east";
      else if (h === "N") n = "north";
      else if (h === "U") n = "up";
      else throw new Error(`Unknown axis abbreviation: ${h}`);
    } else
      n = e[2] ? e[2].toLowerCase() : "unknown";
    const s = e.find((h) => Array.isArray(h) && h[0] === "ORDER"), o = s ? parseInt(s[1], 10) : null, a = e.find(
      (h) => Array.isArray(h) && (h[0] === "LENGTHUNIT" || h[0] === "ANGLEUNIT" || h[0] === "SCALEUNIT")
    ), l = this.convertUnit(a);
    return {
      name: t,
      direction: n,
      // Use the valid PROJJSON direction value
      unit: l,
      order: o
    };
  }
  static extractAxes(e) {
    return e.filter((t) => Array.isArray(t) && t[0] === "AXIS").map((t) => this.convertAxis(t)).sort((t, n) => (t.order || 0) - (n.order || 0));
  }
  static convert(e, t = {}) {
    switch (e[0]) {
      case "PROJCRS":
        t.type = "ProjectedCRS", t.name = e[1], t.base_crs = e.find((f) => Array.isArray(f) && f[0] === "BASEGEOGCRS") ? this.convert(e.find((f) => Array.isArray(f) && f[0] === "BASEGEOGCRS")) : null, t.conversion = e.find((f) => Array.isArray(f) && f[0] === "CONVERSION") ? this.convert(e.find((f) => Array.isArray(f) && f[0] === "CONVERSION")) : null;
        const n = e.find((f) => Array.isArray(f) && f[0] === "CS");
        n && (t.coordinate_system = {
          type: n[1],
          axis: this.extractAxes(e)
        });
        const r = e.find((f) => Array.isArray(f) && f[0] === "LENGTHUNIT");
        if (r) {
          const f = this.convertUnit(r);
          t.coordinate_system.unit = f;
        }
        t.id = this.getId(e);
        break;
      case "BASEGEOGCRS":
      case "GEOGCRS":
        t.type = "GeographicCRS", t.name = e[1];
        const s = e.find(
          (f) => Array.isArray(f) && (f[0] === "DATUM" || f[0] === "ENSEMBLE")
        );
        if (s) {
          const f = this.convert(s);
          s[0] === "ENSEMBLE" ? t.datum_ensemble = f : t.datum = f;
          const g = e.find((d) => Array.isArray(d) && d[0] === "PRIMEM");
          g && g[1] !== "Greenwich" && (f.prime_meridian = {
            name: g[1],
            longitude: parseFloat(g[2])
          });
        }
        t.coordinate_system = {
          type: "ellipsoidal",
          axis: this.extractAxes(e)
        }, t.id = this.getId(e);
        break;
      case "DATUM":
        t.type = "GeodeticReferenceFrame", t.name = e[1], t.ellipsoid = e.find((f) => Array.isArray(f) && f[0] === "ELLIPSOID") ? this.convert(e.find((f) => Array.isArray(f) && f[0] === "ELLIPSOID")) : null;
        break;
      case "ENSEMBLE":
        t.type = "DatumEnsemble", t.name = e[1], t.members = e.filter((f) => Array.isArray(f) && f[0] === "MEMBER").map((f) => ({
          type: "DatumEnsembleMember",
          name: f[1],
          id: this.getId(f)
          // Extract ID as { authority, code }
        }));
        const o = e.find((f) => Array.isArray(f) && f[0] === "ENSEMBLEACCURACY");
        o && (t.accuracy = parseFloat(o[1]));
        const a = e.find((f) => Array.isArray(f) && f[0] === "ELLIPSOID");
        a && (t.ellipsoid = this.convert(a)), t.id = this.getId(e);
        break;
      case "ELLIPSOID":
        t.type = "Ellipsoid", t.name = e[1], t.semi_major_axis = parseFloat(e[2]), t.inverse_flattening = parseFloat(e[3]), e.find((f) => Array.isArray(f) && f[0] === "LENGTHUNIT") && this.convert(e.find((f) => Array.isArray(f) && f[0] === "LENGTHUNIT"), t);
        break;
      case "CONVERSION":
        t.type = "Conversion", t.name = e[1], t.method = e.find((f) => Array.isArray(f) && f[0] === "METHOD") ? this.convert(e.find((f) => Array.isArray(f) && f[0] === "METHOD")) : null, t.parameters = e.filter((f) => Array.isArray(f) && f[0] === "PARAMETER").map((f) => this.convert(f));
        break;
      case "METHOD":
        t.type = "Method", t.name = e[1], t.id = this.getId(e);
        break;
      case "PARAMETER":
        t.type = "Parameter", t.name = e[1], t.value = parseFloat(e[2]), t.unit = this.convertUnit(
          e.find(
            (f) => Array.isArray(f) && (f[0] === "LENGTHUNIT" || f[0] === "ANGLEUNIT" || f[0] === "SCALEUNIT")
          )
        ), t.id = this.getId(e);
        break;
      case "BOUNDCRS":
        t.type = "BoundCRS";
        const l = e.find((f) => Array.isArray(f) && f[0] === "SOURCECRS");
        if (l) {
          const f = l.find((g) => Array.isArray(g));
          t.source_crs = f ? this.convert(f) : null;
        }
        const h = e.find((f) => Array.isArray(f) && f[0] === "TARGETCRS");
        if (h) {
          const f = h.find((g) => Array.isArray(g));
          t.target_crs = f ? this.convert(f) : null;
        }
        const u = e.find((f) => Array.isArray(f) && f[0] === "ABRIDGEDTRANSFORMATION");
        u ? t.transformation = this.convert(u) : t.transformation = null;
        break;
      case "ABRIDGEDTRANSFORMATION":
        if (t.type = "Transformation", t.name = e[1], t.method = e.find((f) => Array.isArray(f) && f[0] === "METHOD") ? this.convert(e.find((f) => Array.isArray(f) && f[0] === "METHOD")) : null, t.parameters = e.filter((f) => Array.isArray(f) && (f[0] === "PARAMETER" || f[0] === "PARAMETERFILE")).map((f) => {
          if (f[0] === "PARAMETER")
            return this.convert(f);
          if (f[0] === "PARAMETERFILE")
            return {
              name: f[1],
              value: f[2],
              id: {
                authority: "EPSG",
                code: 8656
              }
            };
        }), t.parameters.length === 7) {
          const f = t.parameters[6];
          f.name === "Scale difference" && (f.value = Math.round((f.value - 1) * 1e12) / 1e6);
        }
        t.id = this.getId(e);
        break;
      case "AXIS":
        t.coordinate_system || (t.coordinate_system = { type: "unspecified", axis: [] }), t.coordinate_system.axis.push(this.convertAxis(e));
        break;
      case "LENGTHUNIT":
        const c = this.convertUnit(e, "LinearUnit");
        t.coordinate_system && t.coordinate_system.axis && t.coordinate_system.axis.forEach((f) => {
          f.unit || (f.unit = c);
        }), c.conversion_factor && c.conversion_factor !== 1 && t.semi_major_axis && (t.semi_major_axis = {
          value: t.semi_major_axis,
          unit: c
        });
        break;
      default:
        t.keyword = e[0];
        break;
    }
    return t;
  }
}
class J6 extends BS {
  static convert(e, t = {}) {
    return super.convert(e, t), t.coordinate_system && t.coordinate_system.subtype === "Cartesian" && delete t.coordinate_system, t.usage && delete t.usage, t;
  }
}
class Q6 extends BS {
  static convert(e, t = {}) {
    super.convert(e, t);
    const n = e.find((s) => Array.isArray(s) && s[0] === "CS");
    n && (t.coordinate_system = {
      subtype: n[1],
      axis: this.extractAxes(e)
    });
    const r = e.find((s) => Array.isArray(s) && s[0] === "USAGE");
    if (r) {
      const s = r.find((l) => Array.isArray(l) && l[0] === "SCOPE"), o = r.find((l) => Array.isArray(l) && l[0] === "AREA"), a = r.find((l) => Array.isArray(l) && l[0] === "BBOX");
      t.usage = {}, s && (t.usage.scope = s[1]), o && (t.usage.area = o[1]), a && (t.usage.bbox = a.slice(1));
    }
    return t;
  }
}
function ek(i) {
  return i.find((e) => Array.isArray(e) && e[0] === "USAGE") ? "2019" : (i.find((e) => Array.isArray(e) && e[0] === "CS") || i[0] === "BOUNDCRS" || i[0] === "PROJCRS" || i[0] === "GEOGCRS", "2015");
}
function tk(i) {
  return (ek(i) === "2019" ? Q6 : J6).convert(i);
}
function ik(i) {
  const e = i.toUpperCase();
  return e.includes("PROJCRS") || e.includes("GEOGCRS") || e.includes("BOUNDCRS") || e.includes("VERTCRS") || e.includes("LENGTHUNIT") || e.includes("ANGLEUNIT") || e.includes("SCALEUNIT") ? "WKT2" : (e.includes("PROJCS") || e.includes("GEOGCS") || e.includes("LOCAL_CS") || e.includes("VERT_CS") || e.includes("UNIT"), "WKT1");
}
var mh = 1, $S = 2, jS = 3, Jc = 4, XS = 5, p_ = -1, nk = /\s/, rk = /[A-Za-z]/, sk = /[A-Za-z84_]/, fd = /[,\]]/, VS = /[\d\.E\-\+]/;
function Hr(i) {
  if (typeof i != "string")
    throw new Error("not a string");
  this.text = i.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = mh;
}
Hr.prototype.readCharicter = function() {
  var i = this.text[this.place++];
  if (this.state !== Jc)
    for (; nk.test(i); ) {
      if (this.place >= this.text.length)
        return;
      i = this.text[this.place++];
    }
  switch (this.state) {
    case mh:
      return this.neutral(i);
    case $S:
      return this.keyword(i);
    case Jc:
      return this.quoted(i);
    case XS:
      return this.afterquote(i);
    case jS:
      return this.number(i);
    case p_:
      return;
  }
};
Hr.prototype.afterquote = function(i) {
  if (i === '"') {
    this.word += '"', this.state = Jc;
    return;
  }
  if (fd.test(i)) {
    this.word = this.word.trim(), this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in afterquote yet, index ' + this.place);
};
Hr.prototype.afterItem = function(i) {
  if (i === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = mh;
    return;
  }
  if (i === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = mh, this.currentObject = this.stack.pop(), this.currentObject || (this.state = p_);
    return;
  }
};
Hr.prototype.number = function(i) {
  if (VS.test(i)) {
    this.word += i;
    return;
  }
  if (fd.test(i)) {
    this.word = parseFloat(this.word), this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in number yet, index ' + this.place);
};
Hr.prototype.quoted = function(i) {
  if (i === '"') {
    this.state = XS;
    return;
  }
  this.word += i;
};
Hr.prototype.keyword = function(i) {
  if (sk.test(i)) {
    this.word += i;
    return;
  }
  if (i === "[") {
    var e = [];
    e.push(this.word), this.level++, this.root === null ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, this.state = mh;
    return;
  }
  if (fd.test(i)) {
    this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in keyword yet, index ' + this.place);
};
Hr.prototype.neutral = function(i) {
  if (rk.test(i)) {
    this.word = i, this.state = $S;
    return;
  }
  if (i === '"') {
    this.word = "", this.state = Jc;
    return;
  }
  if (VS.test(i)) {
    this.word = i, this.state = jS;
    return;
  }
  if (fd.test(i)) {
    this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in neutral yet, index ' + this.place);
};
Hr.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === p_)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function ok(i) {
  var e = new Hr(i);
  return e.output();
}
function xg(i, e, t) {
  Array.isArray(e) && (t.unshift(e), e = null);
  var n = e ? {} : i, r = t.reduce(function(s, o) {
    return ea(o, s), s;
  }, n);
  e && (i[e] = r);
}
function ea(i, e) {
  if (!Array.isArray(i)) {
    e[i] = !0;
    return;
  }
  var t = i.shift();
  if (t === "PARAMETER" && (t = i.shift()), i.length === 1) {
    if (Array.isArray(i[0])) {
      e[t] = {}, ea(i[0], e[t]);
      return;
    }
    e[t] = i[0];
    return;
  }
  if (!i.length) {
    e[t] = !0;
    return;
  }
  if (t === "TOWGS84") {
    e[t] = i;
    return;
  }
  if (t === "AXIS") {
    t in e || (e[t] = []), e[t].push(i);
    return;
  }
  Array.isArray(t) || (e[t] = {});
  var n;
  switch (t) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      e[t] = {
        name: i[0].toLowerCase(),
        convert: i[1]
      }, i.length === 3 && ea(i[2], e[t]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      e[t] = {
        name: i[0],
        a: i[1],
        rf: i[2]
      }, i.length === 4 && ea(i[3], e[t]);
      return;
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "LOCAL_DATUM":
    case "DATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
      i[0] = ["name", i[0]], xg(e, t, i);
      return;
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "FITTED_CS":
    // the followings are the crs defined in
    // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "ENGCRS":
    case "ENGINEERINGCRS":
      i[0] = ["name", i[0]], xg(e, t, i), e[t].type = t;
      return;
    default:
      for (n = -1; ++n < i.length; )
        if (!Array.isArray(i[n]))
          return ea(i, e[t]);
      return xg(e, t, i);
  }
}
var ak = 0.017453292519943295;
function Nn(i) {
  return i * ak;
}
function WS(i) {
  const e = (i.projName || "").toLowerCase().replace(/_/g, " ");
  !i.long0 && i.longc && (e === "albers conic equal area" || e === "lambert azimuthal equal area") && (i.long0 = i.longc), !i.lat_ts && i.lat1 && (e === "stereographic south pole" || e === "polar stereographic (variant b)") ? (i.lat0 = Nn(i.lat1 > 0 ? 90 : -90), i.lat_ts = i.lat1, delete i.lat1) : !i.lat_ts && i.lat0 && (e === "polar stereographic" || e === "polar stereographic (variant a)") && (i.lat_ts = i.lat0, i.lat0 = Nn(i.lat0 > 0 ? 90 : -90), delete i.lat1);
}
function Gx(i) {
  let e = { units: null, to_meter: void 0 };
  return typeof i == "string" ? (e.units = i.toLowerCase(), e.units === "metre" && (e.units = "meter"), e.units === "meter" && (e.to_meter = 1)) : i && i.name && (e.units = i.name.toLowerCase(), e.units === "metre" && (e.units = "meter"), e.to_meter = i.conversion_factor), e;
}
function kx(i) {
  return typeof i == "object" ? i.value * i.unit.conversion_factor : i;
}
function Ux(i, e) {
  i.ellipsoid.radius ? (e.a = i.ellipsoid.radius, e.rf = 0) : (e.a = kx(i.ellipsoid.semi_major_axis), i.ellipsoid.inverse_flattening !== void 0 ? e.rf = i.ellipsoid.inverse_flattening : i.ellipsoid.semi_major_axis !== void 0 && i.ellipsoid.semi_minor_axis !== void 0 && (e.rf = e.a / (e.a - kx(i.ellipsoid.semi_minor_axis))));
}
function Qc(i, e = {}) {
  return !i || typeof i != "object" ? i : i.type === "BoundCRS" ? (Qc(i.source_crs, e), i.transformation && (i.transformation.method && i.transformation.method.name === "NTv2" ? e.nadgrids = i.transformation.parameters[0].value : e.datum_params = i.transformation.parameters.map((t) => t.value)), e) : (Object.keys(i).forEach((t) => {
    const n = i[t];
    if (n !== null)
      switch (t) {
        case "name":
          if (e.srsCode)
            break;
          e.name = n, e.srsCode = n;
          break;
        case "type":
          n === "GeographicCRS" ? e.projName = "longlat" : n === "ProjectedCRS" && i.conversion && i.conversion.method && (e.projName = i.conversion.method.name);
          break;
        case "datum":
        case "datum_ensemble":
          n.ellipsoid && (e.ellps = n.ellipsoid.name, Ux(n, e)), n.prime_meridian && (e.from_greenwich = n.prime_meridian.longitude * Math.PI / 180);
          break;
        case "ellipsoid":
          e.ellps = n.name, Ux(n, e);
          break;
        case "prime_meridian":
          e.long0 = (n.longitude || 0) * Math.PI / 180;
          break;
        case "coordinate_system":
          if (n.axis) {
            if (e.axis = n.axis.map((r) => {
              const s = r.direction;
              if (s === "east") return "e";
              if (s === "north") return "n";
              if (s === "west") return "w";
              if (s === "south") return "s";
              throw new Error(`Unknown axis direction: ${s}`);
            }).join("") + "u", n.unit) {
              const { units: r, to_meter: s } = Gx(n.unit);
              e.units = r, e.to_meter = s;
            } else if (n.axis[0] && n.axis[0].unit) {
              const { units: r, to_meter: s } = Gx(n.axis[0].unit);
              e.units = r, e.to_meter = s;
            }
          }
          break;
        case "id":
          n.authority && n.code && (e.title = n.authority + ":" + n.code);
          break;
        case "conversion":
          n.method && n.method.name && (e.projName = n.method.name), n.parameters && n.parameters.forEach((r) => {
            const s = r.name.toLowerCase().replace(/\s+/g, "_"), o = r.value;
            r.unit && r.unit.conversion_factor ? e[s] = o * r.unit.conversion_factor : r.unit === "degree" ? e[s] = o * Math.PI / 180 : e[s] = o;
          });
          break;
        case "unit":
          n.name && (e.units = n.name.toLowerCase(), e.units === "metre" && (e.units = "meter")), n.conversion_factor && (e.to_meter = n.conversion_factor);
          break;
        case "base_crs":
          Qc(n, e), e.datumCode = n.id ? n.id.authority + "_" + n.id.code : n.name;
          break;
      }
  }), e.latitude_of_false_origin !== void 0 && (e.lat0 = e.latitude_of_false_origin), e.longitude_of_false_origin !== void 0 && (e.long0 = e.longitude_of_false_origin), e.latitude_of_standard_parallel !== void 0 && (e.lat0 = e.latitude_of_standard_parallel, e.lat1 = e.latitude_of_standard_parallel), e.latitude_of_1st_standard_parallel !== void 0 && (e.lat1 = e.latitude_of_1st_standard_parallel), e.latitude_of_2nd_standard_parallel !== void 0 && (e.lat2 = e.latitude_of_2nd_standard_parallel), e.latitude_of_projection_centre !== void 0 && (e.lat0 = e.latitude_of_projection_centre), e.longitude_of_projection_centre !== void 0 && (e.longc = e.longitude_of_projection_centre), e.easting_at_false_origin !== void 0 && (e.x0 = e.easting_at_false_origin), e.northing_at_false_origin !== void 0 && (e.y0 = e.northing_at_false_origin), e.latitude_of_natural_origin !== void 0 && (e.lat0 = e.latitude_of_natural_origin), e.longitude_of_natural_origin !== void 0 && (e.long0 = e.longitude_of_natural_origin), e.longitude_of_origin !== void 0 && (e.long0 = e.longitude_of_origin), e.false_easting !== void 0 && (e.x0 = e.false_easting), e.easting_at_projection_centre && (e.x0 = e.easting_at_projection_centre), e.false_northing !== void 0 && (e.y0 = e.false_northing), e.northing_at_projection_centre && (e.y0 = e.northing_at_projection_centre), e.standard_parallel_1 !== void 0 && (e.lat1 = e.standard_parallel_1), e.standard_parallel_2 !== void 0 && (e.lat2 = e.standard_parallel_2), e.scale_factor_at_natural_origin !== void 0 && (e.k0 = e.scale_factor_at_natural_origin), e.scale_factor_at_projection_centre !== void 0 && (e.k0 = e.scale_factor_at_projection_centre), e.scale_factor_on_pseudo_standard_parallel !== void 0 && (e.k0 = e.scale_factor_on_pseudo_standard_parallel), e.azimuth !== void 0 && (e.alpha = e.azimuth), e.azimuth_at_projection_centre !== void 0 && (e.alpha = e.azimuth_at_projection_centre), e.angle_from_rectified_to_skew_grid && (e.rectified_grid_angle = e.angle_from_rectified_to_skew_grid), WS(e), e);
}
var lk = [
  "PROJECTEDCRS",
  "PROJCRS",
  "GEOGCS",
  "GEOCCS",
  "PROJCS",
  "LOCAL_CS",
  "GEODCRS",
  "GEODETICCRS",
  "GEODETICDATUM",
  "ENGCRS",
  "ENGINEERINGCRS"
];
function hk(i, e) {
  var t = e[0], n = e[1];
  !(t in i) && n in i && (i[t] = i[n], e.length === 3 && (i[t] = e[2](i[t])));
}
function YS(i) {
  for (var e = Object.keys(i), t = 0, n = e.length; t < n; ++t) {
    var r = e[t];
    lk.indexOf(r) !== -1 && uk(i[r]), typeof i[r] == "object" && YS(i[r]);
  }
}
function uk(i) {
  if (i.AUTHORITY) {
    var e = Object.keys(i.AUTHORITY)[0];
    e && e in i.AUTHORITY && (i.title = e + ":" + i.AUTHORITY[e]);
  }
  if (i.type === "GEOGCS" ? i.projName = "longlat" : i.type === "LOCAL_CS" ? (i.projName = "identity", i.local = !0) : typeof i.PROJECTION == "object" ? i.projName = Object.keys(i.PROJECTION)[0] : i.projName = i.PROJECTION, i.AXIS) {
    for (var t = "", n = 0, r = i.AXIS.length; n < r; ++n) {
      var s = [i.AXIS[n][0].toLowerCase(), i.AXIS[n][1].toLowerCase()];
      s[0].indexOf("north") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "north" ? t += "n" : s[0].indexOf("south") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "south" ? t += "s" : s[0].indexOf("east") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "east" ? t += "e" : (s[0].indexOf("west") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "west") && (t += "w");
    }
    t.length === 2 && (t += "u"), t.length === 3 && (i.axis = t);
  }
  i.UNIT && (i.units = i.UNIT.name.toLowerCase(), i.units === "metre" && (i.units = "meter"), i.UNIT.convert && (i.type === "GEOGCS" ? i.DATUM && i.DATUM.SPHEROID && (i.to_meter = i.UNIT.convert * i.DATUM.SPHEROID.a) : i.to_meter = i.UNIT.convert));
  var o = i.GEOGCS;
  i.type === "GEOGCS" && (o = i), o && (o.DATUM ? i.datumCode = o.DATUM.name.toLowerCase() : i.datumCode = o.name.toLowerCase(), i.datumCode.slice(0, 2) === "d_" && (i.datumCode = i.datumCode.slice(2)), i.datumCode === "new_zealand_1949" && (i.datumCode = "nzgd49"), (i.datumCode === "wgs_1984" || i.datumCode === "world_geodetic_system_1984") && (i.PROJECTION === "Mercator_Auxiliary_Sphere" && (i.sphere = !0), i.datumCode = "wgs84"), i.datumCode === "belge_1972" && (i.datumCode = "rnb72"), o.DATUM && o.DATUM.SPHEROID && (i.ellps = o.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), i.ellps.toLowerCase().slice(0, 13) === "international" && (i.ellps = "intl"), i.a = o.DATUM.SPHEROID.a, i.rf = parseFloat(o.DATUM.SPHEROID.rf, 10)), o.DATUM && o.DATUM.TOWGS84 && (i.datum_params = o.DATUM.TOWGS84), ~i.datumCode.indexOf("osgb_1936") && (i.datumCode = "osgb36"), ~i.datumCode.indexOf("osni_1952") && (i.datumCode = "osni52"), (~i.datumCode.indexOf("tm65") || ~i.datumCode.indexOf("geodetic_datum_of_1965")) && (i.datumCode = "ire65"), i.datumCode === "ch1903+" && (i.datumCode = "ch1903"), ~i.datumCode.indexOf("israel") && (i.datumCode = "isr93")), i.b && !isFinite(i.b) && (i.b = i.a), i.rectified_grid_angle && (i.rectified_grid_angle = Nn(i.rectified_grid_angle));
  function a(u) {
    var c = i.to_meter || 1;
    return u * c;
  }
  var l = function(u) {
    return hk(i, u);
  }, h = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", Nn],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", Nn],
    ["x0", "false_easting", a],
    ["y0", "false_northing", a],
    ["long0", "central_meridian", Nn],
    ["lat0", "latitude_of_origin", Nn],
    ["lat0", "standard_parallel_1", Nn],
    ["lat1", "standard_parallel_1", Nn],
    ["lat2", "standard_parallel_2", Nn],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", Nn],
    ["srsCode", "name"]
  ];
  h.forEach(l), WS(i);
}
function ef(i) {
  if (typeof i == "object")
    return Qc(i);
  const e = ik(i);
  var t = ok(i);
  if (e === "WKT2") {
    const s = tk(t);
    return Qc(s);
  }
  var n = t[0], r = {};
  return ea(t, r), YS(r), r[n];
}
function ci(i) {
  var e = this;
  if (arguments.length === 2) {
    var t = arguments[1];
    typeof t == "string" ? t.charAt(0) === "+" ? ci[
      /** @type {string} */
      i
    ] = Cp(arguments[1]) : ci[
      /** @type {string} */
      i
    ] = ef(arguments[1]) : t && typeof t == "object" && !("projName" in t) ? ci[
      /** @type {string} */
      i
    ] = ef(arguments[1]) : (ci[
      /** @type {string} */
      i
    ] = t, t || delete ci[
      /** @type {string} */
      i
    ]);
  } else if (arguments.length === 1) {
    if (Array.isArray(i))
      return i.map(function(n) {
        return Array.isArray(n) ? ci.apply(e, n) : ci(n);
      });
    if (typeof i == "string") {
      if (i in ci)
        return ci[i];
    } else "EPSG" in i ? ci["EPSG:" + i.EPSG] = i : "ESRI" in i ? ci["ESRI:" + i.ESRI] = i : "IAU2000" in i ? ci["IAU2000:" + i.IAU2000] = i : console.log(i);
    return;
  }
}
V6(ci);
function ck(i) {
  return typeof i == "string";
}
function fk(i) {
  return i in ci;
}
function dk(i) {
  return i.indexOf("+") !== 0 && i.indexOf("[") !== -1 || typeof i == "object" && !("srsCode" in i);
}
var gk = ["3857", "900913", "3785", "102113"];
function pk(i) {
  var e = Ms(i, "authority");
  if (e) {
    var t = Ms(e, "epsg");
    return t && gk.indexOf(t) > -1;
  }
}
function mk(i) {
  var e = Ms(i, "extension");
  if (e)
    return Ms(e, "proj4");
}
function _k(i) {
  return i[0] === "+";
}
function yk(i) {
  if (ck(i)) {
    if (fk(i))
      return ci[i];
    if (dk(i)) {
      var e = ef(i);
      if (pk(e))
        return ci["EPSG:3857"];
      var t = mk(e);
      return t ? Cp(t) : e;
    }
    if (_k(i))
      return Cp(i);
  } else return "projName" in i ? i : ef(i);
}
function zx(i, e) {
  i = i || {};
  var t, n;
  if (!e)
    return i;
  for (n in e)
    t = e[n], t !== void 0 && (i[n] = t);
  return i;
}
function mr(i, e, t) {
  var n = i * e;
  return t / Math.sqrt(1 - n * n);
}
function Zh(i) {
  return i < 0 ? -1 : 1;
}
function Q(i, e) {
  return e || Math.abs(i) <= Gt ? i : i - Zh(i) * ph;
}
function jn(i, e, t) {
  var n = i * t, r = 0.5 * i;
  return n = Math.pow((1 - n) / (1 + n), r), Math.tan(0.5 * (Y - e)) / n;
}
function _h(i, e) {
  for (var t = 0.5 * i, n, r, s = Y - 2 * Math.atan(e), o = 0; o <= 15; o++)
    if (n = i * Math.sin(s), r = Y - 2 * Math.atan(e * Math.pow((1 - n) / (1 + n), t)) - s, s += r, Math.abs(r) <= 1e-10)
      return s;
  return -9999;
}
function xk() {
  var i = this.b / this.a;
  this.es = 1 - i * i, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = mr(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function Ek(i) {
  var e = i.x, t = i.y;
  if (t * $i > 90 && t * $i < -90 && e * $i > 180 && e * $i < -180)
    return null;
  var n, r;
  if (Math.abs(Math.abs(t) - Y) <= J)
    return null;
  if (this.sphere)
    n = this.x0 + this.a * this.k0 * Q(e - this.long0, this.over), r = this.y0 + this.a * this.k0 * Math.log(Math.tan(Je + 0.5 * t));
  else {
    var s = Math.sin(t), o = jn(this.e, t, s);
    n = this.x0 + this.a * this.k0 * Q(e - this.long0, this.over), r = this.y0 - this.a * this.k0 * Math.log(o);
  }
  return i.x = n, i.y = r, i;
}
function vk(i) {
  var e = i.x - this.x0, t = i.y - this.y0, n, r;
  if (this.sphere)
    r = Y - 2 * Math.atan(Math.exp(-t / (this.a * this.k0)));
  else {
    var s = Math.exp(-t / (this.a * this.k0));
    if (r = _h(this.e, s), r === -9999)
      return null;
  }
  return n = Q(this.long0 + e / (this.a * this.k0), this.over), i.x = n, i.y = r, i;
}
var wk = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "Mercator_Variant_A", "merc"];
const bk = {
  init: xk,
  forward: Ek,
  inverse: vk,
  names: wk
};
function Sk() {
}
function Bx(i) {
  return i;
}
var qS = ["longlat", "identity"];
const Tk = {
  init: Sk,
  forward: Bx,
  inverse: Bx,
  names: qS
};
var Rk = [bk, Tk], Bs = {}, ta = [];
function ZS(i, e) {
  var t = ta.length;
  return i.names ? (ta[t] = i, i.names.forEach(function(n) {
    Bs[n.toLowerCase()] = t;
  }), this) : (console.log(e), !0);
}
function HS(i) {
  return i.replace(/[-\(\)\s]+/g, " ").trim().replace(/ /g, "_");
}
function Pk(i) {
  if (!i)
    return !1;
  var e = i.toLowerCase();
  if (typeof Bs[e] < "u" && ta[Bs[e]] || (e = HS(e), e in Bs && ta[Bs[e]]))
    return ta[Bs[e]];
}
function Mk() {
  Rk.forEach(ZS);
}
const Ck = {
  start: Mk,
  add: ZS,
  get: Pk
};
var KS = {
  MERIT: {
    a: 6378137,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  },
  SGS85: {
    a: 6378136,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  },
  GRS80: {
    a: 6378137,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  },
  IAU76: {
    a: 6378140,
    rf: 298.257,
    ellipseName: "IAU 1976"
  },
  airy: {
    a: 6377563396e-3,
    b: 635625691e-2,
    ellipseName: "Airy 1830"
  },
  APL4: {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  },
  NWL9D: {
    a: 6378145,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  },
  mod_airy: {
    a: 6377340189e-3,
    b: 6356034446e-3,
    ellipseName: "Modified Airy"
  },
  andrae: {
    a: 637710443e-2,
    rf: 300,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  },
  aust_SA: {
    a: 6378160,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  },
  GRS67: {
    a: 6378160,
    rf: 298.247167427,
    ellipseName: "GRS 67(IUGG 1967)"
  },
  bessel: {
    a: 6377397155e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  },
  bess_nam: {
    a: 6377483865e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  },
  clrk66: {
    a: 63782064e-1,
    b: 63565838e-1,
    ellipseName: "Clarke 1866"
  },
  clrk80: {
    a: 6378249145e-3,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  },
  clrk80ign: {
    a: 63782492e-1,
    b: 6356515,
    rf: 293.4660213,
    ellipseName: "Clarke 1880 (IGN)"
  },
  clrk58: {
    a: 6378293645208759e-9,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  },
  CPM: {
    a: 63757387e-1,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  },
  delmbr: {
    a: 6376428,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  },
  engelis: {
    a: 637813605e-2,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  },
  evrst30: {
    a: 6377276345e-3,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  },
  evrst48: {
    a: 6377304063e-3,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  },
  evrst56: {
    a: 6377301243e-3,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  },
  evrst69: {
    a: 6377295664e-3,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  },
  evrstSS: {
    a: 6377298556e-3,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  },
  fschr60: {
    a: 6378166,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  },
  fschr60m: {
    a: 6378155,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  },
  fschr68: {
    a: 6378150,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  },
  helmert: {
    a: 6378200,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  },
  hough: {
    a: 6378270,
    rf: 297,
    ellipseName: "Hough"
  },
  intl: {
    a: 6378388,
    rf: 297,
    ellipseName: "International 1909 (Hayford)"
  },
  kaula: {
    a: 6378163,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  },
  lerch: {
    a: 6378139,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  },
  mprts: {
    a: 6397300,
    rf: 191,
    ellipseName: "Maupertius 1738"
  },
  new_intl: {
    a: 63781575e-1,
    b: 63567722e-1,
    ellipseName: "New International 1967"
  },
  plessis: {
    a: 6376523,
    rf: 6355863,
    ellipseName: "Plessis 1817 (France)"
  },
  krass: {
    a: 6378245,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  },
  SEasia: {
    a: 6378155,
    b: 63567733205e-4,
    ellipseName: "Southeast Asia"
  },
  walbeck: {
    a: 6376896,
    b: 63558348467e-4,
    ellipseName: "Walbeck"
  },
  WGS60: {
    a: 6378165,
    rf: 298.3,
    ellipseName: "WGS 60"
  },
  WGS66: {
    a: 6378145,
    rf: 298.25,
    ellipseName: "WGS 66"
  },
  WGS7: {
    a: 6378135,
    rf: 298.26,
    ellipseName: "WGS 72"
  },
  WGS84: {
    a: 6378137,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  },
  sphere: {
    a: 6370997,
    b: 6370997,
    ellipseName: "Normal Sphere (r=6370997)"
  }
};
const Ak = KS.WGS84;
function Ik(i, e, t, n) {
  var r = i * i, s = e * e, o = (r - s) / r, a = 0;
  n ? (i *= 1 - o * (q6 + o * (Z6 + o * H6)), r = i * i, o = 0) : a = Math.sqrt(o);
  var l = (r - s) / s;
  return {
    es: o,
    e: a,
    ep2: l
  };
}
function Lk(i, e, t, n, r) {
  if (!i) {
    var s = Ms(KS, n);
    s || (s = Ak), i = s.a, e = s.b, t = s.rf;
  }
  return t && !e && (e = (1 - 1 / t) * i), (t === 0 || Math.abs(i - e) < J) && (r = !0, e = i), {
    a: i,
    b: e,
    rf: t,
    sphere: r
  };
}
var Qu = {
  wgs84: {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  },
  ch1903: {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  },
  ggrs87: {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  },
  nad83: {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  },
  nad27: {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  },
  potsdam: {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  },
  carthage: {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  },
  hermannskogel: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  },
  mgi: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Militar-Geographische Institut"
  },
  osni52: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  },
  ire65: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  },
  rassadiran: {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  },
  nzgd49: {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  },
  osgb36: {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Ordnance Survey of Great Britain 1936"
  },
  s_jtsk: {
    towgs84: "589,76,480",
    ellipse: "bessel",
    datumName: "S-JTSK (Ferro)"
  },
  beduaram: {
    towgs84: "-106,-87,188",
    ellipse: "clrk80",
    datumName: "Beduaram"
  },
  gunung_segara: {
    towgs84: "-403,684,41",
    ellipse: "bessel",
    datumName: "Gunung Segara Jakarta"
  },
  rnb72: {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  },
  EPSG_5451: {
    towgs84: "6.41,-49.05,-11.28,1.5657,0.5242,6.9718,-5.7649"
  },
  IGNF_LURESG: {
    towgs84: "-192.986,13.673,-39.309,-0.4099,-2.9332,2.6881,0.43"
  },
  EPSG_4614: {
    towgs84: "-119.4248,-303.65872,-11.00061,1.164298,0.174458,1.096259,3.657065"
  },
  EPSG_4615: {
    towgs84: "-494.088,-312.129,279.877,-1.423,-1.013,1.59,-0.748"
  },
  ESRI_37241: {
    towgs84: "-76.822,257.457,-12.817,2.136,-0.033,-2.392,-0.031"
  },
  ESRI_37249: {
    towgs84: "-440.296,58.548,296.265,1.128,10.202,4.559,-0.438"
  },
  ESRI_37245: {
    towgs84: "-511.151,-181.269,139.609,1.05,2.703,1.798,3.071"
  },
  EPSG_4178: {
    towgs84: "24.9,-126.4,-93.2,-0.063,-0.247,-0.041,1.01"
  },
  EPSG_4622: {
    towgs84: "-472.29,-5.63,-304.12,0.4362,-0.8374,0.2563,1.8984"
  },
  EPSG_4625: {
    towgs84: "126.93,547.94,130.41,-2.7867,5.1612,-0.8584,13.8227"
  },
  EPSG_5252: {
    towgs84: "0.023,0.036,-0.068,0.00176,0.00912,-0.01136,0.00439"
  },
  EPSG_4314: {
    towgs84: "597.1,71.4,412.1,0.894,0.068,-1.563,7.58"
  },
  EPSG_4282: {
    towgs84: "-178.3,-316.7,-131.5,5.278,6.077,10.979,19.166"
  },
  EPSG_4231: {
    towgs84: "-83.11,-97.38,-117.22,0.0276,-0.2167,0.2147,0.1218"
  },
  EPSG_4274: {
    towgs84: "-230.994,102.591,25.199,0.633,-0.239,0.9,1.95"
  },
  EPSG_4134: {
    towgs84: "-180.624,-225.516,173.919,-0.81,-1.898,8.336,16.71006"
  },
  EPSG_4254: {
    towgs84: "18.38,192.45,96.82,0.056,-0.142,-0.2,-0.0013"
  },
  EPSG_4159: {
    towgs84: "-194.513,-63.978,-25.759,-3.4027,3.756,-3.352,-0.9175"
  },
  EPSG_4687: {
    towgs84: "0.072,-0.507,-0.245,0.0183,-0.0003,0.007,-0.0093"
  },
  EPSG_4227: {
    towgs84: "-83.58,-397.54,458.78,-17.595,-2.847,4.256,3.225"
  },
  EPSG_4746: {
    towgs84: "599.4,72.4,419.2,-0.062,-0.022,-2.723,6.46"
  },
  EPSG_4745: {
    towgs84: "612.4,77,440.2,-0.054,0.057,-2.797,2.55"
  },
  EPSG_6311: {
    towgs84: "8.846,-4.394,-1.122,-0.00237,-0.146528,0.130428,0.783926"
  },
  EPSG_4289: {
    towgs84: "565.7381,50.4018,465.2904,-1.91514,1.60363,-9.09546,4.07244"
  },
  EPSG_4230: {
    towgs84: "-68.863,-134.888,-111.49,-0.53,-0.14,0.57,-3.4"
  },
  EPSG_4154: {
    towgs84: "-123.02,-158.95,-168.47"
  },
  EPSG_4156: {
    towgs84: "570.8,85.7,462.8,4.998,1.587,5.261,3.56"
  },
  EPSG_4299: {
    towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
  },
  EPSG_4179: {
    towgs84: "33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84"
  },
  EPSG_4313: {
    towgs84: "-106.8686,52.2978,-103.7239,0.3366,-0.457,1.8422,-1.2747"
  },
  EPSG_4194: {
    towgs84: "163.511,127.533,-159.789"
  },
  EPSG_4195: {
    towgs84: "105,326,-102.5"
  },
  EPSG_4196: {
    towgs84: "-45,417,-3.5"
  },
  EPSG_4611: {
    towgs84: "-162.619,-276.959,-161.764,0.067753,-2.243649,-1.158827,-1.094246"
  },
  EPSG_4633: {
    towgs84: "137.092,131.66,91.475,-1.9436,-11.5993,-4.3321,-7.4824"
  },
  EPSG_4641: {
    towgs84: "-408.809,366.856,-412.987,1.8842,-0.5308,2.1655,-121.0993"
  },
  EPSG_4643: {
    towgs84: "-480.26,-438.32,-643.429,16.3119,20.1721,-4.0349,-111.7002"
  },
  EPSG_4300: {
    towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
  },
  EPSG_4188: {
    towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
  },
  EPSG_4660: {
    towgs84: "982.6087,552.753,-540.873,32.39344,-153.25684,-96.2266,16.805"
  },
  EPSG_4662: {
    towgs84: "97.295,-263.247,310.882,-1.5999,0.8386,3.1409,13.3259"
  },
  EPSG_3906: {
    towgs84: "577.88891,165.22205,391.18289,4.9145,-0.94729,-13.05098,7.78664"
  },
  EPSG_4307: {
    towgs84: "-209.3622,-87.8162,404.6198,0.0046,3.4784,0.5805,-1.4547"
  },
  EPSG_6892: {
    towgs84: "-76.269,-16.683,68.562,-6.275,10.536,-4.286,-13.686"
  },
  EPSG_4690: {
    towgs84: "221.597,152.441,176.523,2.403,1.3893,0.884,11.4648"
  },
  EPSG_4691: {
    towgs84: "218.769,150.75,176.75,3.5231,2.0037,1.288,10.9817"
  },
  EPSG_4629: {
    towgs84: "72.51,345.411,79.241,-1.5862,-0.8826,-0.5495,1.3653"
  },
  EPSG_4630: {
    towgs84: "165.804,216.213,180.26,-0.6251,-0.4515,-0.0721,7.4111"
  },
  EPSG_4692: {
    towgs84: "217.109,86.452,23.711,0.0183,-0.0003,0.007,-0.0093"
  },
  EPSG_9333: {
    towgs84: "0,0,0,-8.393,0.749,-10.276,0"
  },
  EPSG_9059: {
    towgs84: "0,0,0"
  },
  EPSG_4312: {
    towgs84: "601.705,84.263,485.227,4.7354,1.3145,5.393,-2.3887"
  },
  EPSG_4123: {
    towgs84: "-96.062,-82.428,-121.753,4.801,0.345,-1.376,1.496"
  },
  EPSG_4309: {
    towgs84: "-124.45,183.74,44.64,-0.4384,0.5446,-0.9706,-2.1365"
  },
  ESRI_104106: {
    towgs84: "-283.088,-70.693,117.445,-1.157,0.059,-0.652,-4.058"
  },
  EPSG_4281: {
    towgs84: "-219.247,-73.802,269.529"
  },
  EPSG_4322: {
    towgs84: "0,0,4.5"
  },
  EPSG_4324: {
    towgs84: "0,0,1.9"
  },
  EPSG_4284: {
    towgs84: "43.822,-108.842,-119.585,1.455,-0.761,0.737,0.549"
  },
  EPSG_4277: {
    towgs84: "446.448,-125.157,542.06,0.15,0.247,0.842,-20.489"
  },
  EPSG_4207: {
    towgs84: "-282.1,-72.2,120,-1.529,0.145,-0.89,-4.46"
  },
  EPSG_4688: {
    towgs84: "347.175,1077.618,2623.677,33.9058,-70.6776,9.4013,186.0647"
  },
  EPSG_4689: {
    towgs84: "410.793,54.542,80.501,-2.5596,-2.3517,-0.6594,17.3218"
  },
  EPSG_4720: {
    towgs84: "0,0,4.5"
  },
  EPSG_4273: {
    towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
  },
  EPSG_4240: {
    towgs84: "204.64,834.74,293.8"
  },
  EPSG_4817: {
    towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
  },
  ESRI_104131: {
    towgs84: "426.62,142.62,460.09,4.98,4.49,-12.42,-17.1"
  },
  EPSG_4265: {
    towgs84: "-104.1,-49.1,-9.9,0.971,-2.917,0.714,-11.68"
  },
  EPSG_4263: {
    towgs84: "-111.92,-87.85,114.5,1.875,0.202,0.219,0.032"
  },
  EPSG_4298: {
    towgs84: "-689.5937,623.84046,-65.93566,-0.02331,1.17094,-0.80054,5.88536"
  },
  EPSG_4270: {
    towgs84: "-253.4392,-148.452,386.5267,0.15605,0.43,-0.1013,-0.0424"
  },
  EPSG_4229: {
    towgs84: "-121.8,98.1,-10.7"
  },
  EPSG_4220: {
    towgs84: "-55.5,-348,-229.2"
  },
  EPSG_4214: {
    towgs84: "12.646,-155.176,-80.863"
  },
  EPSG_4232: {
    towgs84: "-345,3,223"
  },
  EPSG_4238: {
    towgs84: "-1.977,-13.06,-9.993,0.364,0.254,0.689,-1.037"
  },
  EPSG_4168: {
    towgs84: "-170,33,326"
  },
  EPSG_4131: {
    towgs84: "199,931,318.9"
  },
  EPSG_4152: {
    towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
  },
  EPSG_5228: {
    towgs84: "572.213,85.334,461.94,4.9732,1.529,5.2484,3.5378"
  },
  EPSG_8351: {
    towgs84: "485.021,169.465,483.839,7.786342,4.397554,4.102655,0"
  },
  EPSG_4683: {
    towgs84: "-127.62,-67.24,-47.04,-3.068,4.903,1.578,-1.06"
  },
  EPSG_4133: {
    towgs84: "0,0,0"
  },
  EPSG_7373: {
    towgs84: "0.819,-0.5762,-1.6446,-0.00378,-0.03317,0.00318,0.0693"
  },
  EPSG_9075: {
    towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
  },
  EPSG_9072: {
    towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
  },
  EPSG_9294: {
    towgs84: "1.16835,-1.42001,-2.24431,-0.00822,-0.05508,0.01818,0.23388"
  },
  EPSG_4212: {
    towgs84: "-267.434,173.496,181.814,-13.4704,8.7154,7.3926,14.7492"
  },
  EPSG_4191: {
    towgs84: "-44.183,-0.58,-38.489,2.3867,2.7072,-3.5196,-8.2703"
  },
  EPSG_4237: {
    towgs84: "52.684,-71.194,-13.975,-0.312,-0.1063,-0.3729,1.0191"
  },
  EPSG_4740: {
    towgs84: "-1.08,-0.27,-0.9"
  },
  EPSG_4124: {
    towgs84: "419.3836,99.3335,591.3451,0.850389,1.817277,-7.862238,-0.99496"
  },
  EPSG_5681: {
    towgs84: "584.9636,107.7175,413.8067,1.1155,0.2824,-3.1384,7.9922"
  },
  EPSG_4141: {
    towgs84: "23.772,17.49,17.859,-0.3132,-1.85274,1.67299,-5.4262"
  },
  EPSG_4204: {
    towgs84: "-85.645,-273.077,-79.708,2.289,-1.421,2.532,3.194"
  },
  EPSG_4319: {
    towgs84: "226.702,-193.337,-35.371,-2.229,-4.391,9.238,0.9798"
  },
  EPSG_4200: {
    towgs84: "24.82,-131.21,-82.66"
  },
  EPSG_4130: {
    towgs84: "0,0,0"
  },
  EPSG_4127: {
    towgs84: "-82.875,-57.097,-156.768,-2.158,1.524,-0.982,-0.359"
  },
  EPSG_4149: {
    towgs84: "674.374,15.056,405.346"
  },
  EPSG_4617: {
    towgs84: "-0.991,1.9072,0.5129,1.25033e-7,4.6785e-8,5.6529e-8,0"
  },
  EPSG_4663: {
    towgs84: "-210.502,-66.902,-48.476,2.094,-15.067,-5.817,0.485"
  },
  EPSG_4664: {
    towgs84: "-211.939,137.626,58.3,-0.089,0.251,0.079,0.384"
  },
  EPSG_4665: {
    towgs84: "-105.854,165.589,-38.312,-0.003,-0.026,0.024,-0.048"
  },
  EPSG_4666: {
    towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
  },
  EPSG_4756: {
    towgs84: "-192.873,-39.382,-111.202,-0.00205,-0.0005,0.00335,0.0188"
  },
  EPSG_4723: {
    towgs84: "-179.483,-69.379,-27.584,-7.862,8.163,6.042,-13.925"
  },
  EPSG_4726: {
    towgs84: "8.853,-52.644,180.304,-0.393,-2.323,2.96,-24.081"
  },
  EPSG_4267: {
    towgs84: "-8.0,160.0,176.0"
  },
  EPSG_5365: {
    towgs84: "-0.16959,0.35312,0.51846,0.03385,-0.16325,0.03446,0.03693"
  },
  EPSG_4218: {
    towgs84: "304.5,306.5,-318.1"
  },
  EPSG_4242: {
    towgs84: "-33.722,153.789,94.959,-8.581,-4.478,4.54,8.95"
  },
  EPSG_4216: {
    towgs84: "-292.295,248.758,429.447,4.9971,2.99,6.6906,1.0289"
  },
  ESRI_104105: {
    towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
  },
  ESRI_104129: {
    towgs84: "0,0,0"
  },
  EPSG_4673: {
    towgs84: "174.05,-25.49,112.57"
  },
  EPSG_4202: {
    towgs84: "-124,-60,154"
  },
  EPSG_4203: {
    towgs84: "-117.763,-51.51,139.061,0.292,0.443,0.277,-0.191"
  },
  EPSG_3819: {
    towgs84: "595.48,121.69,515.35,4.115,-2.9383,0.853,-3.408"
  },
  EPSG_8694: {
    towgs84: "-93.799,-132.737,-219.073,-1.844,0.648,-6.37,-0.169"
  },
  EPSG_4145: {
    towgs84: "275.57,676.78,229.6"
  },
  EPSG_4283: {
    towgs84: "61.55,-10.87,-40.19,39.4924,32.7221,32.8979,-9.994"
  },
  EPSG_4317: {
    towgs84: "2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266"
  },
  EPSG_4272: {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993"
  },
  EPSG_4248: {
    towgs84: "-307.7,265.3,-363.5"
  },
  EPSG_5561: {
    towgs84: "24,-121,-76"
  },
  EPSG_5233: {
    towgs84: "-0.293,766.95,87.713,0.195704,1.695068,3.473016,-0.039338"
  },
  ESRI_104130: {
    towgs84: "-86,-98,-119"
  },
  ESRI_104102: {
    towgs84: "682,-203,480"
  },
  ESRI_37207: {
    towgs84: "7,-10,-26"
  },
  EPSG_4675: {
    towgs84: "59.935,118.4,-10.871"
  },
  ESRI_104109: {
    towgs84: "-89.121,-348.182,260.871"
  },
  ESRI_104112: {
    towgs84: "-185.583,-230.096,281.361"
  },
  ESRI_104113: {
    towgs84: "25.1,-275.6,222.6"
  },
  IGNF_WGS72G: {
    towgs84: "0,12,6"
  },
  IGNF_NTFG: {
    towgs84: "-168,-60,320"
  },
  IGNF_EFATE57G: {
    towgs84: "-127,-769,472"
  },
  IGNF_PGP50G: {
    towgs84: "324.8,153.6,172.1"
  },
  IGNF_REUN47G: {
    towgs84: "94,-948,-1262"
  },
  IGNF_CSG67G: {
    towgs84: "-186,230,110"
  },
  IGNF_GUAD48G: {
    towgs84: "-467,-16,-300"
  },
  IGNF_TAHI51G: {
    towgs84: "162,117,154"
  },
  IGNF_TAHAAG: {
    towgs84: "65,342,77"
  },
  IGNF_NUKU72G: {
    towgs84: "84,274,65"
  },
  IGNF_PETRELS72G: {
    towgs84: "365,194,166"
  },
  IGNF_WALL78G: {
    towgs84: "253,-133,-127"
  },
  IGNF_MAYO50G: {
    towgs84: "-382,-59,-262"
  },
  IGNF_TANNAG: {
    towgs84: "-139,-967,436"
  },
  IGNF_IGN72G: {
    towgs84: "-13,-348,292"
  },
  IGNF_ATIGG: {
    towgs84: "1118,23,66"
  },
  IGNF_FANGA84G: {
    towgs84: "150.57,158.33,118.32"
  },
  IGNF_RUSAT84G: {
    towgs84: "202.13,174.6,-15.74"
  },
  IGNF_KAUE70G: {
    towgs84: "126.74,300.1,-75.49"
  },
  IGNF_MOP90G: {
    towgs84: "-10.8,-1.8,12.77"
  },
  IGNF_MHPF67G: {
    towgs84: "338.08,212.58,-296.17"
  },
  IGNF_TAHI79G: {
    towgs84: "160.61,116.05,153.69"
  },
  IGNF_ANAA92G: {
    towgs84: "1.5,3.84,4.81"
  },
  IGNF_MARQUI72G: {
    towgs84: "330.91,-13.92,58.56"
  },
  IGNF_APAT86G: {
    towgs84: "143.6,197.82,74.05"
  },
  IGNF_TUBU69G: {
    towgs84: "237.17,171.61,-77.84"
  },
  IGNF_STPM50G: {
    towgs84: "11.363,424.148,373.13"
  },
  EPSG_4150: {
    towgs84: "674.374,15.056,405.346"
  },
  EPSG_4754: {
    towgs84: "-208.4058,-109.8777,-2.5764"
  },
  ESRI_104101: {
    towgs84: "374,150,588"
  },
  EPSG_4693: {
    towgs84: "0,-0.15,0.68"
  },
  EPSG_6207: {
    towgs84: "293.17,726.18,245.36"
  },
  EPSG_4153: {
    towgs84: "-133.63,-157.5,-158.62"
  },
  EPSG_4132: {
    towgs84: "-241.54,-163.64,396.06"
  },
  EPSG_4221: {
    towgs84: "-154.5,150.7,100.4"
  },
  EPSG_4266: {
    towgs84: "-80.7,-132.5,41.1"
  },
  EPSG_4193: {
    towgs84: "-70.9,-151.8,-41.4"
  },
  EPSG_5340: {
    towgs84: "-0.41,0.46,-0.35"
  },
  EPSG_4246: {
    towgs84: "-294.7,-200.1,525.5"
  },
  EPSG_4318: {
    towgs84: "-3.2,-5.7,2.8"
  },
  EPSG_4121: {
    towgs84: "-199.87,74.79,246.62"
  },
  EPSG_4223: {
    towgs84: "-260.1,5.5,432.2"
  },
  EPSG_4158: {
    towgs84: "-0.465,372.095,171.736"
  },
  EPSG_4285: {
    towgs84: "-128.16,-282.42,21.93"
  },
  EPSG_4613: {
    towgs84: "-404.78,685.68,45.47"
  },
  EPSG_4607: {
    towgs84: "195.671,332.517,274.607"
  },
  EPSG_4475: {
    towgs84: "-381.788,-57.501,-256.673"
  },
  EPSG_4208: {
    towgs84: "-157.84,308.54,-146.6"
  },
  EPSG_4743: {
    towgs84: "70.995,-335.916,262.898"
  },
  EPSG_4710: {
    towgs84: "-323.65,551.39,-491.22"
  },
  EPSG_7881: {
    towgs84: "-0.077,0.079,0.086"
  },
  EPSG_4682: {
    towgs84: "283.729,735.942,261.143"
  },
  EPSG_4739: {
    towgs84: "-156,-271,-189"
  },
  EPSG_4679: {
    towgs84: "-80.01,253.26,291.19"
  },
  EPSG_4750: {
    towgs84: "-56.263,16.136,-22.856"
  },
  EPSG_4644: {
    towgs84: "-10.18,-350.43,291.37"
  },
  EPSG_4695: {
    towgs84: "-103.746,-9.614,-255.95"
  },
  EPSG_4292: {
    towgs84: "-355,21,72"
  },
  EPSG_4302: {
    towgs84: "-61.702,284.488,472.052"
  },
  EPSG_4143: {
    towgs84: "-124.76,53,466.79"
  },
  EPSG_4606: {
    towgs84: "-153,153,307"
  },
  EPSG_4699: {
    towgs84: "-770.1,158.4,-498.2"
  },
  EPSG_4247: {
    towgs84: "-273.5,110.6,-357.9"
  },
  EPSG_4160: {
    towgs84: "8.88,184.86,106.69"
  },
  EPSG_4161: {
    towgs84: "-233.43,6.65,173.64"
  },
  EPSG_9251: {
    towgs84: "-9.5,122.9,138.2"
  },
  EPSG_9253: {
    towgs84: "-78.1,101.6,133.3"
  },
  EPSG_4297: {
    towgs84: "-198.383,-240.517,-107.909"
  },
  EPSG_4269: {
    towgs84: "0,0,0"
  },
  EPSG_4301: {
    towgs84: "-147,506,687"
  },
  EPSG_4618: {
    towgs84: "-59,-11,-52"
  },
  EPSG_4612: {
    towgs84: "0,0,0"
  },
  EPSG_4678: {
    towgs84: "44.585,-131.212,-39.544"
  },
  EPSG_4250: {
    towgs84: "-130,29,364"
  },
  EPSG_4144: {
    towgs84: "214,804,268"
  },
  EPSG_4147: {
    towgs84: "-17.51,-108.32,-62.39"
  },
  EPSG_4259: {
    towgs84: "-254.1,-5.36,-100.29"
  },
  EPSG_4164: {
    towgs84: "-76,-138,67"
  },
  EPSG_4211: {
    towgs84: "-378.873,676.002,-46.255"
  },
  EPSG_4182: {
    towgs84: "-422.651,-172.995,84.02"
  },
  EPSG_4224: {
    towgs84: "-143.87,243.37,-33.52"
  },
  EPSG_4225: {
    towgs84: "-205.57,168.77,-4.12"
  },
  EPSG_5527: {
    towgs84: "-67.35,3.88,-38.22"
  },
  EPSG_4752: {
    towgs84: "98,390,-22"
  },
  EPSG_4310: {
    towgs84: "-30,190,89"
  },
  EPSG_9248: {
    towgs84: "-192.26,65.72,132.08"
  },
  EPSG_4680: {
    towgs84: "124.5,-63.5,-281"
  },
  EPSG_4701: {
    towgs84: "-79.9,-158,-168.9"
  },
  EPSG_4706: {
    towgs84: "-146.21,112.63,4.05"
  },
  EPSG_4805: {
    towgs84: "682,-203,480"
  },
  EPSG_4201: {
    towgs84: "-165,-11,206"
  },
  EPSG_4210: {
    towgs84: "-157,-2,-299"
  },
  EPSG_4183: {
    towgs84: "-104,167,-38"
  },
  EPSG_4139: {
    towgs84: "11,72,-101"
  },
  EPSG_4668: {
    towgs84: "-86,-98,-119"
  },
  EPSG_4717: {
    towgs84: "-2,151,181"
  },
  EPSG_4732: {
    towgs84: "102,52,-38"
  },
  EPSG_4280: {
    towgs84: "-377,681,-50"
  },
  EPSG_4209: {
    towgs84: "-138,-105,-289"
  },
  EPSG_4261: {
    towgs84: "31,146,47"
  },
  EPSG_4658: {
    towgs84: "-73,46,-86"
  },
  EPSG_4721: {
    towgs84: "265.025,384.929,-194.046"
  },
  EPSG_4222: {
    towgs84: "-136,-108,-292"
  },
  EPSG_4601: {
    towgs84: "-255,-15,71"
  },
  EPSG_4602: {
    towgs84: "725,685,536"
  },
  EPSG_4603: {
    towgs84: "72,213.7,93"
  },
  EPSG_4605: {
    towgs84: "9,183,236"
  },
  EPSG_4621: {
    towgs84: "137,248,-430"
  },
  EPSG_4657: {
    towgs84: "-28,199,5"
  },
  EPSG_4316: {
    towgs84: "103.25,-100.4,-307.19"
  },
  EPSG_4642: {
    towgs84: "-13,-348,292"
  },
  EPSG_4698: {
    towgs84: "145,-187,103"
  },
  EPSG_4192: {
    towgs84: "-206.1,-174.7,-87.7"
  },
  EPSG_4311: {
    towgs84: "-265,120,-358"
  },
  EPSG_4135: {
    towgs84: "58,-283,-182"
  },
  ESRI_104138: {
    towgs84: "198,-226,-347"
  },
  EPSG_4245: {
    towgs84: "-11,851,5"
  },
  EPSG_4142: {
    towgs84: "-125,53,467"
  },
  EPSG_4213: {
    towgs84: "-106,-87,188"
  },
  EPSG_4253: {
    towgs84: "-133,-77,-51"
  },
  EPSG_4129: {
    towgs84: "-132,-110,-335"
  },
  EPSG_4713: {
    towgs84: "-77,-128,142"
  },
  EPSG_4239: {
    towgs84: "217,823,299"
  },
  EPSG_4146: {
    towgs84: "295,736,257"
  },
  EPSG_4155: {
    towgs84: "-83,37,124"
  },
  EPSG_4165: {
    towgs84: "-173,253,27"
  },
  EPSG_4672: {
    towgs84: "175,-38,113"
  },
  EPSG_4236: {
    towgs84: "-637,-549,-203"
  },
  EPSG_4251: {
    towgs84: "-90,40,88"
  },
  EPSG_4271: {
    towgs84: "-2,374,172"
  },
  EPSG_4175: {
    towgs84: "-88,4,101"
  },
  EPSG_4716: {
    towgs84: "298,-304,-375"
  },
  EPSG_4315: {
    towgs84: "-23,259,-9"
  },
  EPSG_4744: {
    towgs84: "-242.2,-144.9,370.3"
  },
  EPSG_4244: {
    towgs84: "-97,787,86"
  },
  EPSG_4293: {
    towgs84: "616,97,-251"
  },
  EPSG_4714: {
    towgs84: "-127,-769,472"
  },
  EPSG_4736: {
    towgs84: "260,12,-147"
  },
  EPSG_6883: {
    towgs84: "-235,-110,393"
  },
  EPSG_6894: {
    towgs84: "-63,176,185"
  },
  EPSG_4205: {
    towgs84: "-43,-163,45"
  },
  EPSG_4256: {
    towgs84: "41,-220,-134"
  },
  EPSG_4262: {
    towgs84: "639,405,60"
  },
  EPSG_4604: {
    towgs84: "174,359,365"
  },
  EPSG_4169: {
    towgs84: "-115,118,426"
  },
  EPSG_4620: {
    towgs84: "-106,-129,165"
  },
  EPSG_4184: {
    towgs84: "-203,141,53"
  },
  EPSG_4616: {
    towgs84: "-289,-124,60"
  },
  EPSG_9403: {
    towgs84: "-307,-92,127"
  },
  EPSG_4684: {
    towgs84: "-133,-321,50"
  },
  EPSG_4708: {
    towgs84: "-491,-22,435"
  },
  EPSG_4707: {
    towgs84: "114,-116,-333"
  },
  EPSG_4709: {
    towgs84: "145,75,-272"
  },
  EPSG_4712: {
    towgs84: "-205,107,53"
  },
  EPSG_4711: {
    towgs84: "124,-234,-25"
  },
  EPSG_4718: {
    towgs84: "230,-199,-752"
  },
  EPSG_4719: {
    towgs84: "211,147,111"
  },
  EPSG_4724: {
    towgs84: "208,-435,-229"
  },
  EPSG_4725: {
    towgs84: "189,-79,-202"
  },
  EPSG_4735: {
    towgs84: "647,1777,-1124"
  },
  EPSG_4722: {
    towgs84: "-794,119,-298"
  },
  EPSG_4728: {
    towgs84: "-307,-92,127"
  },
  EPSG_4734: {
    towgs84: "-632,438,-609"
  },
  EPSG_4727: {
    towgs84: "912,-58,1227"
  },
  EPSG_4729: {
    towgs84: "185,165,42"
  },
  EPSG_4730: {
    towgs84: "170,42,84"
  },
  EPSG_4733: {
    towgs84: "276,-57,149"
  },
  ESRI_37218: {
    towgs84: "230,-199,-752"
  },
  ESRI_37240: {
    towgs84: "-7,215,225"
  },
  ESRI_37221: {
    towgs84: "252,-209,-751"
  },
  ESRI_4305: {
    towgs84: "-123,-206,219"
  },
  ESRI_104139: {
    towgs84: "-73,-247,227"
  },
  EPSG_4748: {
    towgs84: "51,391,-36"
  },
  EPSG_4219: {
    towgs84: "-384,664,-48"
  },
  EPSG_4255: {
    towgs84: "-333,-222,114"
  },
  EPSG_4257: {
    towgs84: "-587.8,519.75,145.76"
  },
  EPSG_4646: {
    towgs84: "-963,510,-359"
  },
  EPSG_6881: {
    towgs84: "-24,-203,268"
  },
  EPSG_6882: {
    towgs84: "-183,-15,273"
  },
  EPSG_4715: {
    towgs84: "-104,-129,239"
  },
  IGNF_RGF93GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGM04GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGSPM06GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGTAAF07GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGFG95GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGNCG: {
    towgs84: "0,0,0"
  },
  IGNF_RGPFGDD: {
    towgs84: "0,0,0"
  },
  IGNF_ETRS89G: {
    towgs84: "0,0,0"
  },
  IGNF_RGR92GDD: {
    towgs84: "0,0,0"
  },
  EPSG_4173: {
    towgs84: "0,0,0"
  },
  EPSG_4180: {
    towgs84: "0,0,0"
  },
  EPSG_4619: {
    towgs84: "0,0,0"
  },
  EPSG_4667: {
    towgs84: "0,0,0"
  },
  EPSG_4075: {
    towgs84: "0,0,0"
  },
  EPSG_6706: {
    towgs84: "0,0,0"
  },
  EPSG_7798: {
    towgs84: "0,0,0"
  },
  EPSG_4661: {
    towgs84: "0,0,0"
  },
  EPSG_4669: {
    towgs84: "0,0,0"
  },
  EPSG_8685: {
    towgs84: "0,0,0"
  },
  EPSG_4151: {
    towgs84: "0,0,0"
  },
  EPSG_9702: {
    towgs84: "0,0,0"
  },
  EPSG_4758: {
    towgs84: "0,0,0"
  },
  EPSG_4761: {
    towgs84: "0,0,0"
  },
  EPSG_4765: {
    towgs84: "0,0,0"
  },
  EPSG_8997: {
    towgs84: "0,0,0"
  },
  EPSG_4023: {
    towgs84: "0,0,0"
  },
  EPSG_4670: {
    towgs84: "0,0,0"
  },
  EPSG_4694: {
    towgs84: "0,0,0"
  },
  EPSG_4148: {
    towgs84: "0,0,0"
  },
  EPSG_4163: {
    towgs84: "0,0,0"
  },
  EPSG_4167: {
    towgs84: "0,0,0"
  },
  EPSG_4189: {
    towgs84: "0,0,0"
  },
  EPSG_4190: {
    towgs84: "0,0,0"
  },
  EPSG_4176: {
    towgs84: "0,0,0"
  },
  EPSG_4659: {
    towgs84: "0,0,0"
  },
  EPSG_3824: {
    towgs84: "0,0,0"
  },
  EPSG_3889: {
    towgs84: "0,0,0"
  },
  EPSG_4046: {
    towgs84: "0,0,0"
  },
  EPSG_4081: {
    towgs84: "0,0,0"
  },
  EPSG_4558: {
    towgs84: "0,0,0"
  },
  EPSG_4483: {
    towgs84: "0,0,0"
  },
  EPSG_5013: {
    towgs84: "0,0,0"
  },
  EPSG_5264: {
    towgs84: "0,0,0"
  },
  EPSG_5324: {
    towgs84: "0,0,0"
  },
  EPSG_5354: {
    towgs84: "0,0,0"
  },
  EPSG_5371: {
    towgs84: "0,0,0"
  },
  EPSG_5373: {
    towgs84: "0,0,0"
  },
  EPSG_5381: {
    towgs84: "0,0,0"
  },
  EPSG_5393: {
    towgs84: "0,0,0"
  },
  EPSG_5489: {
    towgs84: "0,0,0"
  },
  EPSG_5593: {
    towgs84: "0,0,0"
  },
  EPSG_6135: {
    towgs84: "0,0,0"
  },
  EPSG_6365: {
    towgs84: "0,0,0"
  },
  EPSG_5246: {
    towgs84: "0,0,0"
  },
  EPSG_7886: {
    towgs84: "0,0,0"
  },
  EPSG_8431: {
    towgs84: "0,0,0"
  },
  EPSG_8427: {
    towgs84: "0,0,0"
  },
  EPSG_8699: {
    towgs84: "0,0,0"
  },
  EPSG_8818: {
    towgs84: "0,0,0"
  },
  EPSG_4757: {
    towgs84: "0,0,0"
  },
  EPSG_9140: {
    towgs84: "0,0,0"
  },
  EPSG_8086: {
    towgs84: "0,0,0"
  },
  EPSG_4686: {
    towgs84: "0,0,0"
  },
  EPSG_4737: {
    towgs84: "0,0,0"
  },
  EPSG_4702: {
    towgs84: "0,0,0"
  },
  EPSG_4747: {
    towgs84: "0,0,0"
  },
  EPSG_4749: {
    towgs84: "0,0,0"
  },
  EPSG_4674: {
    towgs84: "0,0,0"
  },
  EPSG_4755: {
    towgs84: "0,0,0"
  },
  EPSG_4759: {
    towgs84: "0,0,0"
  },
  EPSG_4762: {
    towgs84: "0,0,0"
  },
  EPSG_4763: {
    towgs84: "0,0,0"
  },
  EPSG_4764: {
    towgs84: "0,0,0"
  },
  EPSG_4166: {
    towgs84: "0,0,0"
  },
  EPSG_4170: {
    towgs84: "0,0,0"
  },
  EPSG_5546: {
    towgs84: "0,0,0"
  },
  EPSG_7844: {
    towgs84: "0,0,0"
  },
  EPSG_4818: {
    towgs84: "589,76,480"
  }
};
for (var Fk in Qu) {
  var Eg = Qu[Fk];
  Eg.datumName && (Qu[Eg.datumName] = Eg);
}
function Ok(i, e, t, n, r, s, o) {
  var a = {};
  return i === void 0 || i === "none" ? a.datum_type = Mp : a.datum_type = W6, e && (a.datum_params = e.map(parseFloat), (a.datum_params[0] !== 0 || a.datum_params[1] !== 0 || a.datum_params[2] !== 0) && (a.datum_type = po), a.datum_params.length > 3 && (a.datum_params[3] !== 0 || a.datum_params[4] !== 0 || a.datum_params[5] !== 0 || a.datum_params[6] !== 0) && (a.datum_type = mo, a.datum_params[3] *= zl, a.datum_params[4] *= zl, a.datum_params[5] *= zl, a.datum_params[6] = a.datum_params[6] / 1e6 + 1)), o && (a.datum_type = ma, a.grids = o), a.a = t, a.b = n, a.es = r, a.ep2 = s, a;
}
var m_ = {};
function Nk(i, e, t) {
  return e instanceof ArrayBuffer ? Dk(i, e, t) : { ready: Gk(i, e) };
}
function Dk(i, e, t) {
  var n = !0;
  t !== void 0 && t.includeErrorFields === !1 && (n = !1);
  var r = new DataView(e), s = zk(r), o = Bk(r, s), a = $k(r, o, s, n), l = { header: o, subgrids: a };
  return m_[i] = l, l;
}
async function Gk(i, e) {
  for (var t = [], n = await e.getImageCount(), r = n - 1; r >= 0; r--) {
    var s = await e.getImage(r), o = await s.readRasters(), a = o, l = [s.getWidth(), s.getHeight()], h = s.getBoundingBox().map($x), u = [s.fileDirectory.ModelPixelScale[0], s.fileDirectory.ModelPixelScale[1]].map($x), c = h[0] + (l[0] - 1) * u[0], f = h[3] - (l[1] - 1) * u[1], g = a[0], d = a[1], m = [];
    for (let p = l[1] - 1; p >= 0; p--)
      for (let y = l[0] - 1; y >= 0; y--) {
        var x = p * l[0] + y;
        m.push([-_s(d[x]), _s(g[x])]);
      }
    t.push({
      del: u,
      lim: l,
      ll: [-c, f],
      cvs: m
    });
  }
  var v = {
    header: {
      nSubgrids: n
    },
    subgrids: t
  };
  return m_[i] = v, v;
}
function kk(i) {
  if (i === void 0)
    return null;
  var e = i.split(",");
  return e.map(Uk);
}
function Uk(i) {
  if (i.length === 0)
    return null;
  var e = i[0] === "@";
  return e && (i = i.slice(1)), i === "null" ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : {
    name: i,
    mandatory: !e,
    grid: m_[i] || null,
    isNull: !1
  };
}
function $x(i) {
  return i * Math.PI / 180;
}
function _s(i) {
  return i / 3600 * Math.PI / 180;
}
function zk(i) {
  var e = i.getInt32(8, !1);
  return e === 11 ? !1 : (e = i.getInt32(8, !0), e !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function Bk(i, e) {
  return {
    nFields: i.getInt32(8, e),
    nSubgridFields: i.getInt32(24, e),
    nSubgrids: i.getInt32(40, e),
    shiftType: Ap(i, 56, 64).trim(),
    fromSemiMajorAxis: i.getFloat64(120, e),
    fromSemiMinorAxis: i.getFloat64(136, e),
    toSemiMajorAxis: i.getFloat64(152, e),
    toSemiMinorAxis: i.getFloat64(168, e)
  };
}
function Ap(i, e, t) {
  return String.fromCharCode.apply(null, new Uint8Array(i.buffer.slice(e, t)));
}
function $k(i, e, t, n) {
  for (var r = 176, s = [], o = 0; o < e.nSubgrids; o++) {
    var a = Xk(i, r, t), l = Vk(i, r, a, t, n), h = Math.round(
      1 + (a.upperLongitude - a.lowerLongitude) / a.longitudeInterval
    ), u = Math.round(
      1 + (a.upperLatitude - a.lowerLatitude) / a.latitudeInterval
    );
    s.push({
      ll: [_s(a.lowerLongitude), _s(a.lowerLatitude)],
      del: [_s(a.longitudeInterval), _s(a.latitudeInterval)],
      lim: [h, u],
      count: a.gridNodeCount,
      cvs: jk(l)
    });
    var c = 16;
    n === !1 && (c = 8), r += 176 + a.gridNodeCount * c;
  }
  return s;
}
function jk(i) {
  return i.map(function(e) {
    return [_s(e.longitudeShift), _s(e.latitudeShift)];
  });
}
function Xk(i, e, t) {
  return {
    name: Ap(i, e + 8, e + 16).trim(),
    parent: Ap(i, e + 24, e + 24 + 8).trim(),
    lowerLatitude: i.getFloat64(e + 72, t),
    upperLatitude: i.getFloat64(e + 88, t),
    lowerLongitude: i.getFloat64(e + 104, t),
    upperLongitude: i.getFloat64(e + 120, t),
    latitudeInterval: i.getFloat64(e + 136, t),
    longitudeInterval: i.getFloat64(e + 152, t),
    gridNodeCount: i.getInt32(e + 168, t)
  };
}
function Vk(i, e, t, n, r) {
  var s = e + 176, o = 16;
  r === !1 && (o = 8);
  for (var a = [], l = 0; l < t.gridNodeCount; l++) {
    var h = {
      latitudeShift: i.getFloat32(s + l * o, n),
      longitudeShift: i.getFloat32(s + l * o + 4, n)
    };
    r !== !1 && (h.latitudeAccuracy = i.getFloat32(s + l * o + 8, n), h.longitudeAccuracy = i.getFloat32(s + l * o + 12, n)), a.push(h);
  }
  return a;
}
function Rn(i, e) {
  if (!(this instanceof Rn))
    return new Rn(i);
  this.forward = null, this.inverse = null, this.init = null, this.name, this.names = null, this.title, e = e || function(h) {
    if (h)
      throw h;
  };
  var t = yk(i);
  if (typeof t != "object") {
    e("Could not parse to valid json: " + i);
    return;
  }
  var n = Rn.projections.get(t.projName);
  if (!n) {
    e("Could not get projection name from: " + i);
    return;
  }
  if (t.datumCode && t.datumCode !== "none") {
    var r = Ms(Qu, t.datumCode);
    r && (t.datum_params = t.datum_params || (r.towgs84 ? r.towgs84.split(",") : null), t.ellps = r.ellipse, t.datumName = r.datumName ? r.datumName : t.datumCode);
  }
  t.k0 = t.k0 || 1, t.axis = t.axis || "enu", t.ellps = t.ellps || "wgs84", t.lat1 = t.lat1 || t.lat0;
  var s = Lk(t.a, t.b, t.rf, t.ellps, t.sphere), o = Ik(s.a, s.b, s.rf, t.R_A), a = kk(t.nadgrids), l = t.datum || Ok(
    t.datumCode,
    t.datum_params,
    s.a,
    s.b,
    o.es,
    o.ep2,
    a
  );
  zx(this, t), zx(this, n), this.a = s.a, this.b = s.b, this.rf = s.rf, this.sphere = s.sphere, this.es = o.es, this.e = o.e, this.ep2 = o.ep2, this.datum = l, "init" in this && typeof this.init == "function" && this.init(), e(null, this);
}
Rn.projections = Ck;
Rn.projections.start();
function Wk(i, e) {
  return i.datum_type !== e.datum_type || i.a !== e.a || Math.abs(i.es - e.es) > 5e-11 ? !1 : i.datum_type === po ? i.datum_params[0] === e.datum_params[0] && i.datum_params[1] === e.datum_params[1] && i.datum_params[2] === e.datum_params[2] : i.datum_type === mo ? i.datum_params[0] === e.datum_params[0] && i.datum_params[1] === e.datum_params[1] && i.datum_params[2] === e.datum_params[2] && i.datum_params[3] === e.datum_params[3] && i.datum_params[4] === e.datum_params[4] && i.datum_params[5] === e.datum_params[5] && i.datum_params[6] === e.datum_params[6] : !0;
}
function JS(i, e, t) {
  var n = i.x, r = i.y, s = i.z ? i.z : 0, o, a, l, h;
  if (r < -Y && r > -1.001 * Y)
    r = -Y;
  else if (r > Y && r < 1.001 * Y)
    r = Y;
  else {
    if (r < -Y)
      return { x: -1 / 0, y: -1 / 0, z: i.z };
    if (r > Y)
      return { x: 1 / 0, y: 1 / 0, z: i.z };
  }
  return n > Math.PI && (n -= 2 * Math.PI), a = Math.sin(r), h = Math.cos(r), l = a * a, o = t / Math.sqrt(1 - e * l), {
    x: (o + s) * h * Math.cos(n),
    y: (o + s) * h * Math.sin(n),
    z: (o * (1 - e) + s) * a
  };
}
function QS(i, e, t, n) {
  var r = 1e-12, s = r * r, o = 30, a, l, h, u, c, f, g, d, m, x, v, p, y, E = i.x, b = i.y, T = i.z ? i.z : 0, R, M, C;
  if (a = Math.sqrt(E * E + b * b), l = Math.sqrt(E * E + b * b + T * T), a / t < r) {
    if (R = 0, l / t < r)
      return M = Y, C = -n, {
        x: i.x,
        y: i.y,
        z: i.z
      };
  } else
    R = Math.atan2(b, E);
  h = T / l, u = a / l, c = 1 / Math.sqrt(1 - e * (2 - e) * u * u), d = u * (1 - e) * c, m = h * c, y = 0;
  do
    y++, g = t / Math.sqrt(1 - e * m * m), C = a * d + T * m - g * (1 - e * m * m), f = e * g / (g + C), c = 1 / Math.sqrt(1 - f * (2 - f) * u * u), x = u * (1 - f) * c, v = h * c, p = v * d - x * m, d = x, m = v;
  while (p * p > s && y < o);
  return M = Math.atan(v / Math.abs(x)), {
    x: R,
    y: M,
    z: C
  };
}
function Yk(i, e, t) {
  if (e === po)
    return {
      x: i.x + t[0],
      y: i.y + t[1],
      z: i.z + t[2]
    };
  if (e === mo) {
    var n = t[0], r = t[1], s = t[2], o = t[3], a = t[4], l = t[5], h = t[6];
    return {
      x: h * (i.x - l * i.y + a * i.z) + n,
      y: h * (l * i.x + i.y - o * i.z) + r,
      z: h * (-a * i.x + o * i.y + i.z) + s
    };
  }
}
function qk(i, e, t) {
  if (e === po)
    return {
      x: i.x - t[0],
      y: i.y - t[1],
      z: i.z - t[2]
    };
  if (e === mo) {
    var n = t[0], r = t[1], s = t[2], o = t[3], a = t[4], l = t[5], h = t[6], u = (i.x - n) / h, c = (i.y - r) / h, f = (i.z - s) / h;
    return {
      x: u + l * c - a * f,
      y: -l * u + c + o * f,
      z: a * u - o * c + f
    };
  }
}
function Du(i) {
  return i === po || i === mo;
}
function Zk(i, e, t) {
  if (Wk(i, e) || i.datum_type === Mp || e.datum_type === Mp)
    return t;
  var n = i.a, r = i.es;
  if (i.datum_type === ma) {
    var s = jx(i, !1, t);
    if (s !== 0)
      return;
    n = Ox, r = Nx;
  }
  var o = e.a, a = e.b, l = e.es;
  if (e.datum_type === ma && (o = Ox, a = Y6, l = Nx), r === l && n === o && !Du(i.datum_type) && !Du(e.datum_type))
    return t;
  if (t = JS(t, r, n), Du(i.datum_type) && (t = Yk(t, i.datum_type, i.datum_params)), Du(e.datum_type) && (t = qk(t, e.datum_type, e.datum_params)), t = QS(t, l, o, a), e.datum_type === ma) {
    var h = jx(e, !0, t);
    if (h !== 0)
      return;
  }
  return t;
}
function jx(i, e, t) {
  if (i.grids === null || i.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  var n = { x: -t.x, y: t.y }, r = { x: Number.NaN, y: Number.NaN }, s = [];
  e:
    for (var o = 0; o < i.grids.length; o++) {
      var a = i.grids[o];
      if (s.push(a.name), a.isNull) {
        r = n;
        break;
      }
      if (a.grid === null) {
        if (a.mandatory)
          return console.log("Unable to find mandatory grid '" + a.name + "'"), -1;
        continue;
      }
      for (var l = a.grid.subgrids, h = 0, u = l.length; h < u; h++) {
        var c = l[h], f = (Math.abs(c.del[1]) + Math.abs(c.del[0])) / 1e4, g = c.ll[0] - f, d = c.ll[1] - f, m = c.ll[0] + (c.lim[0] - 1) * c.del[0] + f, x = c.ll[1] + (c.lim[1] - 1) * c.del[1] + f;
        if (!(d > n.y || g > n.x || x < n.y || m < n.x) && (r = Hk(n, e, c), !isNaN(r.x)))
          break e;
      }
    }
  return isNaN(r.x) ? (console.log("Failed to find a grid shift table for location '" + -n.x * $i + " " + n.y * $i + " tried: '" + s + "'"), -1) : (t.x = -r.x, t.y = r.y, 0);
}
function Hk(i, e, t) {
  var n = { x: Number.NaN, y: Number.NaN };
  if (isNaN(i.x))
    return n;
  var r = { x: i.x, y: i.y };
  r.x -= t.ll[0], r.y -= t.ll[1], r.x = Q(r.x - Math.PI) + Math.PI;
  var s = Xx(r, t);
  if (e) {
    if (isNaN(s.x))
      return n;
    s.x = r.x - s.x, s.y = r.y - s.y;
    var o = 9, a = 1e-12, l, h;
    do {
      if (h = Xx(s, t), isNaN(h.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      l = { x: r.x - (h.x + s.x), y: r.y - (h.y + s.y) }, s.x += l.x, s.y += l.y;
    } while (o-- && Math.abs(l.x) > a && Math.abs(l.y) > a);
    if (o < 0)
      return console.log("Inverse grid shift iterator failed to converge."), n;
    n.x = Q(s.x + t.ll[0]), n.y = s.y + t.ll[1];
  } else
    isNaN(s.x) || (n.x = i.x + s.x, n.y = i.y + s.y);
  return n;
}
function Xx(i, e) {
  var t = { x: i.x / e.del[0], y: i.y / e.del[1] }, n = { x: Math.floor(t.x), y: Math.floor(t.y) }, r = { x: t.x - 1 * n.x, y: t.y - 1 * n.y }, s = { x: Number.NaN, y: Number.NaN }, o;
  if (n.x < 0 || n.x >= e.lim[0] || n.y < 0 || n.y >= e.lim[1])
    return s;
  o = n.y * e.lim[0] + n.x;
  var a = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o++;
  var l = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o += e.lim[0];
  var h = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o--;
  var u = { x: e.cvs[o][0], y: e.cvs[o][1] }, c = r.x * r.y, f = r.x * (1 - r.y), g = (1 - r.x) * (1 - r.y), d = (1 - r.x) * r.y;
  return s.x = g * a.x + f * l.x + d * u.x + c * h.x, s.y = g * a.y + f * l.y + d * u.y + c * h.y, s;
}
function Vx(i, e, t) {
  var n = t.x, r = t.y, s = t.z || 0, o, a, l, h = {};
  for (l = 0; l < 3; l++)
    if (!(e && l === 2 && t.z === void 0))
      switch (l === 0 ? (o = n, "ew".indexOf(i.axis[l]) !== -1 ? a = "x" : a = "y") : l === 1 ? (o = r, "ns".indexOf(i.axis[l]) !== -1 ? a = "y" : a = "x") : (o = s, a = "z"), i.axis[l]) {
        case "e":
          h[a] = o;
          break;
        case "w":
          h[a] = -o;
          break;
        case "n":
          h[a] = o;
          break;
        case "s":
          h[a] = -o;
          break;
        case "u":
          t[a] !== void 0 && (h.z = o);
          break;
        case "d":
          t[a] !== void 0 && (h.z = -o);
          break;
        default:
          return null;
      }
  return h;
}
function eT(i) {
  var e = {
    x: i[0],
    y: i[1]
  };
  return i.length > 2 && (e.z = i[2]), i.length > 3 && (e.m = i[3]), e;
}
function Kk(i) {
  Wx(i.x), Wx(i.y);
}
function Wx(i) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(i))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof i != "number" || i !== i || !isFinite(i))
    throw new TypeError("coordinates must be finite numbers");
}
function Jk(i, e) {
  return (i.datum.datum_type === po || i.datum.datum_type === mo || i.datum.datum_type === ma) && e.datumCode !== "WGS84" || (e.datum.datum_type === po || e.datum.datum_type === mo || e.datum.datum_type === ma) && i.datumCode !== "WGS84";
}
function tf(i, e, t, n) {
  var r;
  Array.isArray(t) ? t = eT(t) : t = {
    x: t.x,
    y: t.y,
    z: t.z,
    m: t.m
  };
  var s = t.z !== void 0;
  if (Kk(t), i.datum && e.datum && Jk(i, e) && (r = new Rn("WGS84"), t = tf(i, r, t, n), i = r), n && i.axis !== "enu" && (t = Vx(i, !1, t)), i.projName === "longlat")
    t = {
      x: t.x * Nt,
      y: t.y * Nt,
      z: t.z || 0
    };
  else if (i.to_meter && (t = {
    x: t.x * i.to_meter,
    y: t.y * i.to_meter,
    z: t.z || 0
  }), t = i.inverse(t), !t)
    return;
  if (i.from_greenwich && (t.x += i.from_greenwich), t = Zk(i.datum, e.datum, t), !!t)
    return t = /** @type {import('./core').InterfaceCoordinates} */
    t, e.from_greenwich && (t = {
      x: t.x - e.from_greenwich,
      y: t.y,
      z: t.z || 0
    }), e.projName === "longlat" ? t = {
      x: t.x * $i,
      y: t.y * $i,
      z: t.z || 0
    } : (t = e.forward(t), e.to_meter && (t = {
      x: t.x / e.to_meter,
      y: t.y / e.to_meter,
      z: t.z || 0
    })), n && e.axis !== "enu" ? Vx(e, !0, t) : (t && !s && delete t.z, t);
}
var Yx = Rn("WGS84");
function vg(i, e, t, n) {
  var r, s, o;
  return Array.isArray(t) ? (r = tf(i, e, t, n) || { x: NaN, y: NaN }, t.length > 2 ? typeof i.name < "u" && i.name === "geocent" || typeof e.name < "u" && e.name === "geocent" ? typeof r.z == "number" ? (
    /** @type {T} */
    [r.x, r.y, r.z].concat(t.slice(3))
  ) : (
    /** @type {T} */
    [r.x, r.y, t[2]].concat(t.slice(3))
  ) : (
    /** @type {T} */
    [r.x, r.y].concat(t.slice(2))
  ) : (
    /** @type {T} */
    [r.x, r.y]
  )) : (s = tf(i, e, t, n), o = Object.keys(t), o.length === 2 || o.forEach(function(a) {
    if (typeof i.name < "u" && i.name === "geocent" || typeof e.name < "u" && e.name === "geocent") {
      if (a === "x" || a === "y" || a === "z")
        return;
    } else if (a === "x" || a === "y")
      return;
    s[a] = t[a];
  }), /** @type {T} */
  s);
}
function Gu(i) {
  return i instanceof Rn ? i : typeof i == "object" && "oProj" in i ? i.oProj : Rn(
    /** @type {string | PROJJSONDefinition} */
    i
  );
}
function Qk(i, e, t) {
  var n, r, s = !1, o;
  return typeof e > "u" ? (r = Gu(i), n = Yx, s = !0) : (typeof /** @type {?} */
  e.x < "u" || Array.isArray(e)) && (t = /** @type {T} */
  /** @type {?} */
  e, r = Gu(i), n = Yx, s = !0), n || (n = Gu(i)), r || (r = Gu(
    /** @type {string | PROJJSONDefinition | proj } */
    e
  )), t ? vg(n, r, t) : (o = {
    /**
     * @template {TemplateCoordinates} T
     * @param {T} coords
     * @param {boolean=} enforceAxis
     * @returns {T}
     */
    forward: function(a, l) {
      return vg(n, r, a, l);
    },
    /**
     * @template {TemplateCoordinates} T
     * @param {T} coords
     * @param {boolean=} enforceAxis
     * @returns {T}
     */
    inverse: function(a, l) {
      return vg(r, n, a, l);
    }
  }, s && (o.oProj = r), o);
}
var qx = 6, tT = "AJSAJS", iT = "AFAFAF", ia = 65, Oi = 73, mn = 79, Sl = 86, Tl = 90;
const eU = {
  forward: nT,
  inverse: tU,
  toPoint: rT
};
function nT(i, e) {
  return e = e || 5, rU(iU({
    lat: i[1],
    lon: i[0]
  }), e);
}
function tU(i) {
  var e = __(oT(i.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top];
}
function rT(i) {
  var e = __(oT(i.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
}
function wg(i) {
  return i * (Math.PI / 180);
}
function Zx(i) {
  return 180 * (i / Math.PI);
}
function iU(i) {
  var e = i.lat, t = i.lon, n = 6378137, r = 669438e-8, s = 0.9996, o, a, l, h, u, c, f, g = wg(e), d = wg(t), m, x;
  x = Math.floor((t + 180) / 6) + 1, t === 180 && (x = 60), e >= 56 && e < 64 && t >= 3 && t < 12 && (x = 32), e >= 72 && e < 84 && (t >= 0 && t < 9 ? x = 31 : t >= 9 && t < 21 ? x = 33 : t >= 21 && t < 33 ? x = 35 : t >= 33 && t < 42 && (x = 37)), o = (x - 1) * 6 - 180 + 3, m = wg(o), a = r / (1 - r), l = n / Math.sqrt(1 - r * Math.sin(g) * Math.sin(g)), h = Math.tan(g) * Math.tan(g), u = a * Math.cos(g) * Math.cos(g), c = Math.cos(g) * (d - m), f = n * ((1 - r / 4 - 3 * r * r / 64 - 5 * r * r * r / 256) * g - (3 * r / 8 + 3 * r * r / 32 + 45 * r * r * r / 1024) * Math.sin(2 * g) + (15 * r * r / 256 + 45 * r * r * r / 1024) * Math.sin(4 * g) - 35 * r * r * r / 3072 * Math.sin(6 * g));
  var v = s * l * (c + (1 - h + u) * c * c * c / 6 + (5 - 18 * h + h * h + 72 * u - 58 * a) * c * c * c * c * c / 120) + 5e5, p = s * (f + l * Math.tan(g) * (c * c / 2 + (5 - h + 9 * u + 4 * u * u) * c * c * c * c / 24 + (61 - 58 * h + h * h + 600 * u - 330 * a) * c * c * c * c * c * c / 720));
  return e < 0 && (p += 1e7), {
    northing: Math.round(p),
    easting: Math.round(v),
    zoneNumber: x,
    zoneLetter: nU(e)
  };
}
function __(i) {
  var e = i.northing, t = i.easting, n = i.zoneLetter, r = i.zoneNumber;
  if (r < 0 || r > 60)
    return null;
  var s = 0.9996, o = 6378137, a = 669438e-8, l, h = (1 - Math.sqrt(1 - a)) / (1 + Math.sqrt(1 - a)), u, c, f, g, d, m, x, v, p, y = t - 5e5, E = e;
  n < "N" && (E -= 1e7), x = (r - 1) * 6 - 180 + 3, l = a / (1 - a), m = E / s, v = m / (o * (1 - a / 4 - 3 * a * a / 64 - 5 * a * a * a / 256)), p = v + (3 * h / 2 - 27 * h * h * h / 32) * Math.sin(2 * v) + (21 * h * h / 16 - 55 * h * h * h * h / 32) * Math.sin(4 * v) + 151 * h * h * h / 96 * Math.sin(6 * v), u = o / Math.sqrt(1 - a * Math.sin(p) * Math.sin(p)), c = Math.tan(p) * Math.tan(p), f = l * Math.cos(p) * Math.cos(p), g = o * (1 - a) / Math.pow(1 - a * Math.sin(p) * Math.sin(p), 1.5), d = y / (u * s);
  var b = p - u * Math.tan(p) / g * (d * d / 2 - (5 + 3 * c + 10 * f - 4 * f * f - 9 * l) * d * d * d * d / 24 + (61 + 90 * c + 298 * f + 45 * c * c - 252 * l - 3 * f * f) * d * d * d * d * d * d / 720);
  b = Zx(b);
  var T = (d - (1 + 2 * c + f) * d * d * d / 6 + (5 - 2 * f + 28 * c - 3 * f * f + 8 * l + 24 * c * c) * d * d * d * d * d / 120) / Math.cos(p);
  T = x + Zx(T);
  var R;
  if (i.accuracy) {
    var M = __({
      northing: i.northing + i.accuracy,
      easting: i.easting + i.accuracy,
      zoneLetter: i.zoneLetter,
      zoneNumber: i.zoneNumber
    });
    R = {
      top: M.lat,
      right: M.lon,
      bottom: b,
      left: T
    };
  } else
    R = {
      lat: b,
      lon: T
    };
  return R;
}
function nU(i) {
  var e = "Z";
  return 84 >= i && i >= 72 ? e = "X" : 72 > i && i >= 64 ? e = "W" : 64 > i && i >= 56 ? e = "V" : 56 > i && i >= 48 ? e = "U" : 48 > i && i >= 40 ? e = "T" : 40 > i && i >= 32 ? e = "S" : 32 > i && i >= 24 ? e = "R" : 24 > i && i >= 16 ? e = "Q" : 16 > i && i >= 8 ? e = "P" : 8 > i && i >= 0 ? e = "N" : 0 > i && i >= -8 ? e = "M" : -8 > i && i >= -16 ? e = "L" : -16 > i && i >= -24 ? e = "K" : -24 > i && i >= -32 ? e = "J" : -32 > i && i >= -40 ? e = "H" : -40 > i && i >= -48 ? e = "G" : -48 > i && i >= -56 ? e = "F" : -56 > i && i >= -64 ? e = "E" : -64 > i && i >= -72 ? e = "D" : -72 > i && i >= -80 && (e = "C"), e;
}
function rU(i, e) {
  var t = "00000" + i.easting, n = "00000" + i.northing;
  return i.zoneNumber + i.zoneLetter + sU(i.easting, i.northing, i.zoneNumber) + t.substr(t.length - 5, e) + n.substr(n.length - 5, e);
}
function sU(i, e, t) {
  var n = sT(t), r = Math.floor(i / 1e5), s = Math.floor(e / 1e5) % 20;
  return oU(r, s, n);
}
function sT(i) {
  var e = i % qx;
  return e === 0 && (e = qx), e;
}
function oU(i, e, t) {
  var n = t - 1, r = tT.charCodeAt(n), s = iT.charCodeAt(n), o = r + i - 1, a = s + e, l = !1;
  o > Tl && (o = o - Tl + ia - 1, l = !0), (o === Oi || r < Oi && o > Oi || (o > Oi || r < Oi) && l) && o++, (o === mn || r < mn && o > mn || (o > mn || r < mn) && l) && (o++, o === Oi && o++), o > Tl && (o = o - Tl + ia - 1), a > Sl ? (a = a - Sl + ia - 1, l = !0) : l = !1, (a === Oi || s < Oi && a > Oi || (a > Oi || s < Oi) && l) && a++, (a === mn || s < mn && a > mn || (a > mn || s < mn) && l) && (a++, a === Oi && a++), a > Sl && (a = a - Sl + ia - 1);
  var h = String.fromCharCode(o) + String.fromCharCode(a);
  return h;
}
function oT(i) {
  if (i && i.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var e = i.length, t = null, n = "", r, s = 0; !/[A-Z]/.test(r = i.charAt(s)); ) {
    if (s >= 2)
      throw "MGRSPoint bad conversion from: " + i;
    n += r, s++;
  }
  var o = parseInt(n, 10);
  if (s === 0 || s + 3 > e)
    throw "MGRSPoint bad conversion from: " + i;
  var a = i.charAt(s++);
  if (a <= "A" || a === "B" || a === "Y" || a >= "Z" || a === "I" || a === "O")
    throw "MGRSPoint zone letter " + a + " not handled: " + i;
  t = i.substring(s, s += 2);
  for (var l = sT(o), h = aU(t.charAt(0), l), u = lU(t.charAt(1), l); u < hU(a); )
    u += 2e6;
  var c = e - s;
  if (c % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + i;
  var f = c / 2, g = 0, d = 0, m, x, v, p, y;
  return f > 0 && (m = 1e5 / Math.pow(10, f), x = i.substring(s, s + f), g = parseFloat(x) * m, v = i.substring(s + f), d = parseFloat(v) * m), p = g + h, y = d + u, {
    easting: p,
    northing: y,
    zoneLetter: a,
    zoneNumber: o,
    accuracy: m
  };
}
function aU(i, e) {
  for (var t = tT.charCodeAt(e - 1), n = 1e5, r = !1; t !== i.charCodeAt(0); ) {
    if (t++, t === Oi && t++, t === mn && t++, t > Tl) {
      if (r)
        throw "Bad character: " + i;
      t = ia, r = !0;
    }
    n += 1e5;
  }
  return n;
}
function lU(i, e) {
  if (i > "V")
    throw "MGRSPoint given invalid Northing " + i;
  for (var t = iT.charCodeAt(e - 1), n = 0, r = !1; t !== i.charCodeAt(0); ) {
    if (t++, t === Oi && t++, t === mn && t++, t > Sl) {
      if (r)
        throw "Bad character: " + i;
      t = ia, r = !0;
    }
    n += 1e5;
  }
  return n;
}
function hU(i) {
  var e;
  switch (i) {
    case "C":
      e = 11e5;
      break;
    case "D":
      e = 2e6;
      break;
    case "E":
      e = 28e5;
      break;
    case "F":
      e = 37e5;
      break;
    case "G":
      e = 46e5;
      break;
    case "H":
      e = 55e5;
      break;
    case "J":
      e = 64e5;
      break;
    case "K":
      e = 73e5;
      break;
    case "L":
      e = 82e5;
      break;
    case "M":
      e = 91e5;
      break;
    case "N":
      e = 0;
      break;
    case "P":
      e = 8e5;
      break;
    case "Q":
      e = 17e5;
      break;
    case "R":
      e = 26e5;
      break;
    case "S":
      e = 35e5;
      break;
    case "T":
      e = 44e5;
      break;
    case "U":
      e = 53e5;
      break;
    case "V":
      e = 62e5;
      break;
    case "W":
      e = 7e6;
      break;
    case "X":
      e = 79e5;
      break;
    default:
      e = -1;
  }
  if (e >= 0)
    return e;
  throw "Invalid zone letter: " + i;
}
function Oa(i, e, t) {
  if (!(this instanceof Oa))
    return new Oa(i, e, t);
  if (Array.isArray(i))
    this.x = i[0], this.y = i[1], this.z = i[2] || 0;
  else if (typeof i == "object")
    this.x = i.x, this.y = i.y, this.z = i.z || 0;
  else if (typeof i == "string" && typeof e > "u") {
    var n = i.split(",");
    this.x = parseFloat(n[0]), this.y = parseFloat(n[1]), this.z = parseFloat(n[2]) || 0;
  } else
    this.x = i, this.y = e, this.z = t || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Oa.fromMGRS = function(i) {
  return new Oa(rT(i));
};
Oa.prototype.toMGRS = function(i) {
  return nT([this.x, this.y], i);
};
var uU = 1, cU = 0.25, Hx = 0.046875, Kx = 0.01953125, Jx = 0.01068115234375, fU = 0.75, dU = 0.46875, gU = 0.013020833333333334, pU = 0.007120768229166667, mU = 0.3645833333333333, _U = 0.005696614583333333, yU = 0.3076171875;
function y_(i) {
  var e = [];
  e[0] = uU - i * (cU + i * (Hx + i * (Kx + i * Jx))), e[1] = i * (fU - i * (Hx + i * (Kx + i * Jx)));
  var t = i * i;
  return e[2] = t * (dU - i * (gU + i * pU)), t *= i, e[3] = t * (mU - i * _U), e[4] = t * i * yU, e;
}
function il(i, e, t, n) {
  return t *= e, e *= e, n[0] * i - t * (n[1] + e * (n[2] + e * (n[3] + e * n[4])));
}
var xU = 20;
function x_(i, e, t) {
  for (var n = 1 / (1 - e), r = i, s = xU; s; --s) {
    var o = Math.sin(r), a = 1 - e * o * o;
    if (a = (il(r, o, Math.cos(r), t) - i) * (a * Math.sqrt(a)) * n, r -= a, Math.abs(a) < J)
      return r;
  }
  return r;
}
function EU() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = y_(this.es), this.ml0 = il(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function vU(i) {
  var e = i.x, t = i.y, n = Q(e - this.long0, this.over), r, s, o, a = Math.sin(t), l = Math.cos(t);
  if (this.es) {
    var u = l * n, c = Math.pow(u, 2), f = this.ep2 * Math.pow(l, 2), g = Math.pow(f, 2), d = Math.abs(l) > J ? Math.tan(t) : 0, m = Math.pow(d, 2), x = Math.pow(m, 2);
    r = 1 - this.es * Math.pow(a, 2), u = u / Math.sqrt(r);
    var v = il(t, a, l, this.en);
    s = this.a * (this.k0 * u * (1 + c / 6 * (1 - m + f + c / 20 * (5 - 18 * m + x + 14 * f - 58 * m * f + c / 42 * (61 + 179 * x - x * m - 479 * m))))) + this.x0, o = this.a * (this.k0 * (v - this.ml0 + a * n * u / 2 * (1 + c / 12 * (5 - m + 9 * f + 4 * g + c / 30 * (61 + x - 58 * m + 270 * f - 330 * m * f + c / 56 * (1385 + 543 * x - x * m - 3111 * m)))))) + this.y0;
  } else {
    var h = l * Math.sin(n);
    if (Math.abs(Math.abs(h) - 1) < J)
      return 93;
    if (s = 0.5 * this.a * this.k0 * Math.log((1 + h) / (1 - h)) + this.x0, o = l * Math.cos(n) / Math.sqrt(1 - Math.pow(h, 2)), h = Math.abs(o), h >= 1) {
      if (h - 1 > J)
        return 93;
      o = 0;
    } else
      o = Math.acos(o);
    t < 0 && (o = -o), o = this.a * this.k0 * (o - this.lat0) + this.y0;
  }
  return i.x = s, i.y = o, i;
}
function wU(i) {
  var e, t, n, r, s = (i.x - this.x0) * (1 / this.a), o = (i.y - this.y0) * (1 / this.a);
  if (this.es)
    if (e = this.ml0 + o / this.k0, t = x_(e, this.es, this.en), Math.abs(t) < Y) {
      var c = Math.sin(t), f = Math.cos(t), g = Math.abs(f) > J ? Math.tan(t) : 0, d = this.ep2 * Math.pow(f, 2), m = Math.pow(d, 2), x = Math.pow(g, 2), v = Math.pow(x, 2);
      e = 1 - this.es * Math.pow(c, 2);
      var p = s * Math.sqrt(e) / this.k0, y = Math.pow(p, 2);
      e = e * g, n = t - e * y / (1 - this.es) * 0.5 * (1 - y / 12 * (5 + 3 * x - 9 * d * x + d - 4 * m - y / 30 * (61 + 90 * x - 252 * d * x + 45 * v + 46 * d - y / 56 * (1385 + 3633 * x + 4095 * v + 1574 * v * x)))), r = Q(this.long0 + p * (1 - y / 6 * (1 + 2 * x + d - y / 20 * (5 + 28 * x + 24 * v + 8 * d * x + 6 * d - y / 42 * (61 + 662 * x + 1320 * v + 720 * v * x)))) / f, this.over);
    } else
      n = Y * Zh(o), r = 0;
  else {
    var a = Math.exp(s / this.k0), l = 0.5 * (a - 1 / a), h = this.lat0 + o / this.k0, u = Math.cos(h);
    e = Math.sqrt((1 - Math.pow(u, 2)) / (1 + Math.pow(l, 2))), n = Math.asin(e), o < 0 && (n = -n), l === 0 && u === 0 ? r = 0 : r = Q(Math.atan2(l, u) + this.long0, this.over);
  }
  return i.x = r, i.y = n, i;
}
var bU = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const ec = {
  init: EU,
  forward: vU,
  inverse: wU,
  names: bU
};
function aT(i) {
  var e = Math.exp(i);
  return e = (e - 1 / e) / 2, e;
}
function zi(i, e) {
  i = Math.abs(i), e = Math.abs(e);
  var t = Math.max(i, e), n = Math.min(i, e) / (t || 1);
  return t * Math.sqrt(1 + Math.pow(n, 2));
}
function SU(i) {
  var e = 1 + i, t = e - 1;
  return t === 0 ? i : i * Math.log(e) / t;
}
function TU(i) {
  var e = Math.abs(i);
  return e = SU(e * (1 + e / (zi(1, e) + 1))), i < 0 ? -e : e;
}
function E_(i, e) {
  for (var t = 2 * Math.cos(2 * e), n = i.length - 1, r = i[n], s = 0, o; --n >= 0; )
    o = -s + t * r + i[n], s = r, r = o;
  return e + o * Math.sin(2 * e);
}
function RU(i, e) {
  for (var t = 2 * Math.cos(e), n = i.length - 1, r = i[n], s = 0, o; --n >= 0; )
    o = -s + t * r + i[n], s = r, r = o;
  return Math.sin(e) * o;
}
function PU(i) {
  var e = Math.exp(i);
  return e = (e + 1 / e) / 2, e;
}
function lT(i, e, t) {
  for (var n = Math.sin(e), r = Math.cos(e), s = aT(t), o = PU(t), a = 2 * r * o, l = -2 * n * s, h = i.length - 1, u = i[h], c = 0, f = 0, g = 0, d, m; --h >= 0; )
    d = f, m = c, f = u, c = g, u = -d + a * f - l * c + i[h], g = -m + l * f + a * c;
  return a = n * o, l = r * s, [a * u - l * g, a * g + l * u];
}
function MU() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (ec.init.apply(this), this.forward = ec.forward, this.inverse = ec.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var i = this.es / (1 + Math.sqrt(1 - this.es)), e = i / (2 - i), t = e;
  this.cgb[0] = e * (2 + e * (-2 / 3 + e * (-2 + e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675)))))), this.cbg[0] = e * (-2 + e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725)))))), t = t * e, this.cgb[1] = t * (7 / 3 + e * (-8 / 5 + e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))))), this.cbg[1] = t * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), t = t * e, this.cgb[2] = t * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = t * (-26 / 15 + e * (34 / 21 + e * (8 / 5 + e * (-12686 / 2835)))), t = t * e, this.cgb[3] = t * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = t * (1237 / 630 + e * (-12 / 5 + e * (-24832 / 14175))), t = t * e, this.cgb[4] = t * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = t * (-734 / 315 + e * (109598 / 31185)), t = t * e, this.cgb[5] = t * (601676 / 22275), this.cbg[5] = t * (444337 / 155925), t = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + t * (1 / 4 + t * (1 / 64 + t / 256))), this.utg[0] = e * (-0.5 + e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800)))))), this.gtu[0] = e * (0.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = t * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = t * (13 / 48 + e * (-3 / 5 + e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))))), t = t * e, this.utg[2] = t * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = t * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), t = t * e, this.utg[3] = t * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = t * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), t = t * e, this.utg[4] = t * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = t * (34729 / 80640 + e * (-3418889 / 1995840)), t = t * e, this.utg[5] = t * (-20648693 / 638668800), this.gtu[5] = t * (212378941 / 319334400);
  var n = E_(this.cbg, this.lat0);
  this.Zb = -this.Qn * (n + RU(this.gtu, 2 * n));
}
function CU(i) {
  var e = Q(i.x - this.long0, this.over), t = i.y;
  t = E_(this.cbg, t);
  var n = Math.sin(t), r = Math.cos(t), s = Math.sin(e), o = Math.cos(e);
  t = Math.atan2(n, o * r), e = Math.atan2(s * r, zi(n, r * o)), e = TU(Math.tan(e));
  var a = lT(this.gtu, 2 * t, 2 * e);
  t = t + a[0], e = e + a[1];
  var l, h;
  return Math.abs(e) <= 2.623395162778 ? (l = this.a * (this.Qn * e) + this.x0, h = this.a * (this.Qn * t + this.Zb) + this.y0) : (l = 1 / 0, h = 1 / 0), i.x = l, i.y = h, i;
}
function AU(i) {
  var e = (i.x - this.x0) * (1 / this.a), t = (i.y - this.y0) * (1 / this.a);
  t = (t - this.Zb) / this.Qn, e = e / this.Qn;
  var n, r;
  if (Math.abs(e) <= 2.623395162778) {
    var s = lT(this.utg, 2 * t, 2 * e);
    t = t + s[0], e = e + s[1], e = Math.atan(aT(e));
    var o = Math.sin(t), a = Math.cos(t), l = Math.sin(e), h = Math.cos(e);
    t = Math.atan2(o * h, zi(l, h * a)), e = Math.atan2(l, h * a), n = Q(e + this.long0, this.over), r = E_(this.cgb, t);
  } else
    n = 1 / 0, r = 1 / 0;
  return i.x = n, i.y = r, i;
}
var IU = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
const tc = {
  init: MU,
  forward: CU,
  inverse: AU,
  names: IU
};
function LU(i, e) {
  if (i === void 0) {
    if (i = Math.floor((Q(e) + Math.PI) * 30 / Math.PI) + 1, i < 0)
      return 0;
    if (i > 60)
      return 60;
  }
  return i;
}
var FU = "etmerc";
function OU() {
  var i = LU(this.zone, this.long0);
  if (i === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(i) - 183) * Nt, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, tc.init.apply(this), this.forward = tc.forward, this.inverse = tc.inverse;
}
var NU = ["Universal Transverse Mercator System", "utm"];
const DU = {
  init: OU,
  names: NU,
  dependsOn: FU
};
function v_(i, e) {
  return Math.pow((1 - i) / (1 + i), e);
}
var GU = 20;
function kU() {
  var i = Math.sin(this.lat0), e = Math.cos(this.lat0);
  e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * i * i), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(i / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + Je) / (Math.pow(Math.tan(0.5 * this.lat0 + Je), this.C) * v_(this.e * i, this.ratexp));
}
function UU(i) {
  var e = i.x, t = i.y;
  return i.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * t + Je), this.C) * v_(this.e * Math.sin(t), this.ratexp)) - Y, i.x = this.C * e, i;
}
function zU(i) {
  for (var e = 1e-14, t = i.x / this.C, n = i.y, r = Math.pow(Math.tan(0.5 * n + Je) / this.K, 1 / this.C), s = GU; s > 0 && (n = 2 * Math.atan(r * v_(this.e * Math.sin(i.y), -0.5 * this.e)) - Y, !(Math.abs(n - i.y) < e)); --s)
    i.y = n;
  return s ? (i.x = t, i.y = n, i) : null;
}
const w_ = {
  init: kU,
  forward: UU,
  inverse: zU
};
function BU() {
  w_.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function $U(i) {
  var e, t, n, r;
  return i.x = Q(i.x - this.long0, this.over), w_.forward.apply(this, [i]), e = Math.sin(i.y), t = Math.cos(i.y), n = Math.cos(i.x), r = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * t * n), i.x = r * t * Math.sin(i.x), i.y = r * (this.cosc0 * e - this.sinc0 * t * n), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
}
function jU(i) {
  var e, t, n, r, s;
  if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, s = zi(i.x, i.y)) {
    var o = 2 * Math.atan2(s, this.R2);
    e = Math.sin(o), t = Math.cos(o), r = Math.asin(t * this.sinc0 + i.y * e * this.cosc0 / s), n = Math.atan2(i.x * e, s * this.cosc0 * t - i.y * this.sinc0 * e);
  } else
    r = this.phic0, n = 0;
  return i.x = n, i.y = r, w_.inverse.apply(this, [i]), i.x = Q(i.x + this.long0, this.over), i;
}
var XU = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const VU = {
  init: BU,
  forward: $U,
  inverse: jU,
  names: XU
};
function b_(i, e, t) {
  return e *= t, Math.tan(0.5 * (Y + i)) * Math.pow((1 - e) / (1 + e), 0.5 * t);
}
function WU() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= J && (this.k0 = 0.5 * (1 + Zh(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= J && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= J && Math.abs(Math.cos(this.lat_ts)) > J && (this.k0 = 0.5 * this.cons * mr(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / jn(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = mr(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(b_(this.lat0, this.sinlat0, this.e)) - Y, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function YU(i) {
  var e = i.x, t = i.y, n = Math.sin(t), r = Math.cos(t), s, o, a, l, h, u, c = Q(e - this.long0, this.over);
  return Math.abs(Math.abs(e - this.long0) - Math.PI) <= J && Math.abs(t + this.lat0) <= J ? (i.x = NaN, i.y = NaN, i) : this.sphere ? (s = 2 * this.k0 / (1 + this.sinlat0 * n + this.coslat0 * r * Math.cos(c)), i.x = this.a * s * r * Math.sin(c) + this.x0, i.y = this.a * s * (this.coslat0 * n - this.sinlat0 * r * Math.cos(c)) + this.y0, i) : (o = 2 * Math.atan(b_(t, n, this.e)) - Y, l = Math.cos(o), a = Math.sin(o), Math.abs(this.coslat0) <= J ? (h = jn(this.e, t * this.con, this.con * n), u = 2 * this.a * this.k0 * h / this.cons, i.x = this.x0 + u * Math.sin(e - this.long0), i.y = this.y0 - this.con * u * Math.cos(e - this.long0), i) : (Math.abs(this.sinlat0) < J ? (s = 2 * this.a * this.k0 / (1 + l * Math.cos(c)), i.y = s * a) : (s = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * a + this.cosX0 * l * Math.cos(c))), i.y = s * (this.cosX0 * a - this.sinX0 * l * Math.cos(c)) + this.y0), i.x = s * l * Math.sin(c) + this.x0, i));
}
function qU(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e, t, n, r, s, o = Math.sqrt(i.x * i.x + i.y * i.y);
  if (this.sphere) {
    var a = 2 * Math.atan(o / (2 * this.a * this.k0));
    return e = this.long0, t = this.lat0, o <= J ? (i.x = e, i.y = t, i) : (t = Math.asin(Math.cos(a) * this.sinlat0 + i.y * Math.sin(a) * this.coslat0 / o), Math.abs(this.coslat0) < J ? this.lat0 > 0 ? e = Q(this.long0 + Math.atan2(i.x, -1 * i.y), this.over) : e = Q(this.long0 + Math.atan2(i.x, i.y), this.over) : e = Q(this.long0 + Math.atan2(i.x * Math.sin(a), o * this.coslat0 * Math.cos(a) - i.y * this.sinlat0 * Math.sin(a)), this.over), i.x = e, i.y = t, i);
  } else if (Math.abs(this.coslat0) <= J) {
    if (o <= J)
      return t = this.lat0, e = this.long0, i.x = e, i.y = t, i;
    i.x *= this.con, i.y *= this.con, n = o * this.cons / (2 * this.a * this.k0), t = this.con * _h(this.e, n), e = this.con * Q(this.con * this.long0 + Math.atan2(i.x, -1 * i.y), this.over);
  } else
    r = 2 * Math.atan(o * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, o <= J ? s = this.X0 : (s = Math.asin(Math.cos(r) * this.sinX0 + i.y * Math.sin(r) * this.cosX0 / o), e = Q(this.long0 + Math.atan2(i.x * Math.sin(r), o * this.cosX0 * Math.cos(r) - i.y * this.sinX0 * Math.sin(r)), this.over)), t = -1 * _h(this.e, Math.tan(0.5 * (Y + s)));
  return i.x = e, i.y = t, i;
}
var ZU = ["stere", "Stereographic_South_Pole", "Polar_Stereographic_variant_A", "Polar_Stereographic_variant_B", "Polar_Stereographic"];
const HU = {
  init: WU,
  forward: YU,
  inverse: qU,
  names: ZU,
  ssfn_: b_
};
function KU() {
  var i = this.lat0;
  this.lambda0 = this.long0;
  var e = Math.sin(i), t = this.a, n = this.rf, r = 1 / n, s = 2 * r - Math.pow(r, 2), o = this.e = Math.sqrt(s);
  this.R = this.k0 * t * Math.sqrt(1 - s) / (1 - s * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + s / (1 - s) * Math.pow(Math.cos(i), 4)), this.b0 = Math.asin(e / this.alpha);
  var a = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), l = Math.log(Math.tan(Math.PI / 4 + i / 2)), h = Math.log((1 + o * e) / (1 - o * e));
  this.K = a - this.alpha * l + this.alpha * o / 2 * h;
}
function JU(i) {
  var e = Math.log(Math.tan(Math.PI / 4 - i.y / 2)), t = this.e / 2 * Math.log((1 + this.e * Math.sin(i.y)) / (1 - this.e * Math.sin(i.y))), n = -this.alpha * (e + t) + this.K, r = 2 * (Math.atan(Math.exp(n)) - Math.PI / 4), s = this.alpha * (i.x - this.lambda0), o = Math.atan(Math.sin(s) / (Math.sin(this.b0) * Math.tan(r) + Math.cos(this.b0) * Math.cos(s))), a = Math.asin(Math.cos(this.b0) * Math.sin(r) - Math.sin(this.b0) * Math.cos(r) * Math.cos(s));
  return i.y = this.R / 2 * Math.log((1 + Math.sin(a)) / (1 - Math.sin(a))) + this.y0, i.x = this.R * o + this.x0, i;
}
function QU(i) {
  for (var e = i.x - this.x0, t = i.y - this.y0, n = e / this.R, r = 2 * (Math.atan(Math.exp(t / this.R)) - Math.PI / 4), s = Math.asin(Math.cos(this.b0) * Math.sin(r) + Math.sin(this.b0) * Math.cos(r) * Math.cos(n)), o = Math.atan(Math.sin(n) / (Math.cos(this.b0) * Math.cos(n) - Math.sin(this.b0) * Math.tan(r))), a = this.lambda0 + o / this.alpha, l = 0, h = s, u = -1e3, c = 0; Math.abs(h - u) > 1e-7; ) {
    if (++c > 20)
      return;
    l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + s / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(h)) / 2)), u = h, h = 2 * Math.atan(Math.exp(l)) - Math.PI / 2;
  }
  return i.x = a, i.y = h, i;
}
var ez = ["somerc"];
const tz = {
  init: KU,
  forward: JU,
  inverse: QU,
  names: ez
};
var Zo = 1e-7;
function iz(i) {
  var e = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], t = typeof i.projName == "object" ? Object.keys(i.projName)[0] : i.projName;
  return "no_uoff" in i || "no_off" in i || e.indexOf(t) !== -1 || e.indexOf(HS(t)) !== -1;
}
function nz() {
  var i, e, t, n, r, s, o, a, l, h, u = 0, c, f = 0, g = 0, d = 0, m = 0, x = 0, v = 0;
  this.no_off = iz(this), this.no_rot = "no_rot" in this;
  var p = !1;
  "alpha" in this && (p = !0);
  var y = !1;
  if ("rectified_grid_angle" in this && (y = !0), p && (v = this.alpha), y && (u = this.rectified_grid_angle), p || y)
    f = this.longc;
  else if (g = this.long1, m = this.lat1, d = this.long2, x = this.lat2, Math.abs(m - x) <= Zo || (i = Math.abs(m)) <= Zo || Math.abs(i - Y) <= Zo || Math.abs(Math.abs(this.lat0) - Y) <= Zo || Math.abs(Math.abs(x) - Y) <= Zo)
    throw new Error();
  var E = 1 - this.es;
  e = Math.sqrt(E), Math.abs(this.lat0) > J ? (a = Math.sin(this.lat0), t = Math.cos(this.lat0), i = 1 - this.es * a * a, this.B = t * t, this.B = Math.sqrt(1 + this.es * this.B * this.B / E), this.A = this.B * this.k0 * e / i, n = this.B * e / (t * Math.sqrt(i)), r = n * n - 1, r <= 0 ? r = 0 : (r = Math.sqrt(r), this.lat0 < 0 && (r = -r)), this.E = r += n, this.E *= Math.pow(jn(this.e, this.lat0, a), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = n = r = 1), p || y ? (p ? (c = Math.asin(Math.sin(v) / n), y || (u = v)) : (c = u, v = Math.asin(n * Math.sin(c))), this.lam0 = f - Math.asin(0.5 * (r - 1 / r) * Math.tan(c)) / this.B) : (s = Math.pow(jn(this.e, m, Math.sin(m)), this.B), o = Math.pow(jn(this.e, x, Math.sin(x)), this.B), r = this.E / s, l = (o - s) / (o + s), h = this.E * this.E, h = (h - o * s) / (h + o * s), i = g - d, i < -Math.PI ? d -= ph : i > Math.PI && (d += ph), this.lam0 = Q(0.5 * (g + d) - Math.atan(h * Math.tan(0.5 * this.B * (g - d)) / l) / this.B, this.over), c = Math.atan(2 * Math.sin(this.B * Q(g - this.lam0, this.over)) / (r - 1 / r)), u = v = Math.asin(n * Math.sin(c))), this.singam = Math.sin(c), this.cosgam = Math.cos(c), this.sinrot = Math.sin(u), this.cosrot = Math.cos(u), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(n * n - 1) / Math.cos(v))), this.lat0 < 0 && (this.u_0 = -this.u_0)), r = 0.5 * c, this.v_pole_n = this.ArB * Math.log(Math.tan(Je - r)), this.v_pole_s = this.ArB * Math.log(Math.tan(Je + r));
}
function rz(i) {
  var e = {}, t, n, r, s, o, a, l, h;
  if (i.x = i.x - this.lam0, Math.abs(Math.abs(i.y) - Y) > J) {
    if (o = this.E / Math.pow(jn(this.e, i.y, Math.sin(i.y)), this.B), a = 1 / o, t = 0.5 * (o - a), n = 0.5 * (o + a), s = Math.sin(this.B * i.x), r = (t * this.singam - s * this.cosgam) / n, Math.abs(Math.abs(r) - 1) < J)
      throw new Error();
    h = 0.5 * this.ArB * Math.log((1 - r) / (1 + r)), a = Math.cos(this.B * i.x), Math.abs(a) < Zo ? l = this.A * i.x : l = this.ArB * Math.atan2(t * this.cosgam + s * this.singam, a);
  } else
    h = i.y > 0 ? this.v_pole_n : this.v_pole_s, l = this.ArB * i.y;
  return this.no_rot ? (e.x = l, e.y = h) : (l -= this.u_0, e.x = h * this.cosrot + l * this.sinrot, e.y = l * this.cosrot - h * this.sinrot), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function sz(i) {
  var e, t, n, r, s, o, a, l = {};
  if (i.x = (i.x - this.x0) * (1 / this.a), i.y = (i.y - this.y0) * (1 / this.a), this.no_rot ? (t = i.y, e = i.x) : (t = i.x * this.cosrot - i.y * this.sinrot, e = i.y * this.cosrot + i.x * this.sinrot + this.u_0), n = Math.exp(-this.BrA * t), r = 0.5 * (n - 1 / n), s = 0.5 * (n + 1 / n), o = Math.sin(this.BrA * e), a = (o * this.cosgam + r * this.singam) / s, Math.abs(Math.abs(a) - 1) < J)
    l.x = 0, l.y = a < 0 ? -Y : Y;
  else {
    if (l.y = this.E / Math.sqrt((1 + a) / (1 - a)), l.y = _h(this.e, Math.pow(l.y, 1 / this.B)), l.y === 1 / 0)
      throw new Error();
    l.x = -this.rB * Math.atan2(r * this.cosgam - o * this.singam, Math.cos(this.BrA * e));
  }
  return l.x += this.lam0, l;
}
var oz = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Variant_B", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const az = {
  init: nz,
  forward: rz,
  inverse: sz,
  names: oz
};
function lz() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < J)) {
    var i = this.b / this.a;
    this.e = Math.sqrt(1 - i * i);
    var e = Math.sin(this.lat1), t = Math.cos(this.lat1), n = mr(this.e, e, t), r = jn(this.e, this.lat1, e), s = Math.sin(this.lat2), o = Math.cos(this.lat2), a = mr(this.e, s, o), l = jn(this.e, this.lat2, s), h = Math.abs(Math.abs(this.lat0) - Y) < J ? 0 : jn(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > J ? this.ns = Math.log(n / a) / Math.log(r / l) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = n / (this.ns * Math.pow(r, this.ns)), this.rh = this.a * this.f0 * Math.pow(h, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function hz(i) {
  var e = i.x, t = i.y;
  Math.abs(2 * Math.abs(t) - Math.PI) <= J && (t = Zh(t) * (Y - 2 * J));
  var n = Math.abs(Math.abs(t) - Y), r, s;
  if (n > J)
    r = jn(this.e, t, Math.sin(t)), s = this.a * this.f0 * Math.pow(r, this.ns);
  else {
    if (n = t * this.ns, n <= 0)
      return null;
    s = 0;
  }
  var o = this.ns * Q(e - this.long0, this.over);
  return i.x = this.k0 * (s * Math.sin(o)) + this.x0, i.y = this.k0 * (this.rh - s * Math.cos(o)) + this.y0, i;
}
function uz(i) {
  var e, t, n, r, s, o = (i.x - this.x0) / this.k0, a = this.rh - (i.y - this.y0) / this.k0;
  this.ns > 0 ? (e = Math.sqrt(o * o + a * a), t = 1) : (e = -Math.sqrt(o * o + a * a), t = -1);
  var l = 0;
  if (e !== 0 && (l = Math.atan2(t * o, t * a)), e !== 0 || this.ns > 0) {
    if (t = 1 / this.ns, n = Math.pow(e / (this.a * this.f0), t), r = _h(this.e, n), r === -9999)
      return null;
  } else
    r = -Y;
  return s = Q(l / this.ns + this.long0, this.over), i.x = s, i.y = r, i;
}
var cz = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const fz = {
  init: lz,
  forward: hz,
  inverse: uz,
  names: cz
};
function dz() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function gz(i) {
  var e, t, n, r, s, o, a, l = i.x, h = i.y, u = Q(l - this.long0, this.over);
  return e = Math.pow((1 + this.e * Math.sin(h)) / (1 - this.e * Math.sin(h)), this.alfa * this.e / 2), t = 2 * (Math.atan(this.k * Math.pow(Math.tan(h / 2 + this.s45), this.alfa) / e) - this.s45), n = -u * this.alfa, r = Math.asin(Math.cos(this.ad) * Math.sin(t) + Math.sin(this.ad) * Math.cos(t) * Math.cos(n)), s = Math.asin(Math.cos(t) * Math.sin(n) / Math.cos(r)), o = this.n * s, a = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(r / 2 + this.s45), this.n), i.y = a * Math.cos(o) / 1, i.x = a * Math.sin(o) / 1, this.czech || (i.y *= -1, i.x *= -1), i;
}
function pz(i) {
  var e, t, n, r, s, o, a, l, h = i.x;
  i.x = i.y, i.y = h, this.czech || (i.y *= -1, i.x *= -1), o = Math.sqrt(i.x * i.x + i.y * i.y), s = Math.atan2(i.y, i.x), r = s / Math.sin(this.s0), n = 2 * (Math.atan(Math.pow(this.ro0 / o, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(n) - Math.sin(this.ad) * Math.cos(n) * Math.cos(r)), t = Math.asin(Math.cos(n) * Math.sin(r) / Math.cos(e)), i.x = this.long0 - t / this.alfa, a = e, l = 0;
  var u = 0;
  do
    i.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(a)) / (1 - this.e * Math.sin(a)), this.e / 2)) - this.s45), Math.abs(a - i.y) < 1e-10 && (l = 1), a = i.y, u += 1;
  while (l === 0 && u < 15);
  return u >= 15 ? null : i;
}
var mz = ["Krovak", "krovak"];
const _z = {
  init: dz,
  forward: gz,
  inverse: pz,
  names: mz
};
function Pi(i, e, t, n, r) {
  return i * r - e * Math.sin(2 * r) + t * Math.sin(4 * r) - n * Math.sin(6 * r);
}
function Hh(i) {
  return 1 - 0.25 * i * (1 + i / 16 * (3 + 1.25 * i));
}
function Kh(i) {
  return 0.375 * i * (1 + 0.25 * i * (1 + 0.46875 * i));
}
function Jh(i) {
  return 0.05859375 * i * i * (1 + 0.75 * i);
}
function Qh(i) {
  return i * i * i * (35 / 3072);
}
function S_(i, e, t) {
  var n = e * t;
  return i / Math.sqrt(1 - n * n);
}
function Fs(i) {
  return Math.abs(i) < Y ? i : i - Zh(i) * Math.PI;
}
function nf(i, e, t, n, r) {
  var s, o;
  s = i / e;
  for (var a = 0; a < 15; a++)
    if (o = (i - (e * s - t * Math.sin(2 * s) + n * Math.sin(4 * s) - r * Math.sin(6 * s))) / (e - 2 * t * Math.cos(2 * s) + 4 * n * Math.cos(4 * s) - 6 * r * Math.cos(6 * s)), s += o, Math.abs(o) <= 1e-10)
      return s;
  return NaN;
}
function yz() {
  this.sphere || (this.e0 = Hh(this.es), this.e1 = Kh(this.es), this.e2 = Jh(this.es), this.e3 = Qh(this.es), this.ml0 = this.a * Pi(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function xz(i) {
  var e, t, n = i.x, r = i.y;
  if (n = Q(n - this.long0, this.over), this.sphere)
    e = this.a * Math.asin(Math.cos(r) * Math.sin(n)), t = this.a * (Math.atan2(Math.tan(r), Math.cos(n)) - this.lat0);
  else {
    var s = Math.sin(r), o = Math.cos(r), a = S_(this.a, this.e, s), l = Math.tan(r) * Math.tan(r), h = n * Math.cos(r), u = h * h, c = this.es * o * o / (1 - this.es), f = this.a * Pi(this.e0, this.e1, this.e2, this.e3, r);
    e = a * h * (1 - u * l * (1 / 6 - (8 - l + 8 * c) * u / 120)), t = f - this.ml0 + a * s / o * u * (0.5 + (5 - l + 6 * c) * u / 24);
  }
  return i.x = e + this.x0, i.y = t + this.y0, i;
}
function Ez(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e = i.x / this.a, t = i.y / this.a, n, r;
  if (this.sphere) {
    var s = t + this.lat0;
    n = Math.asin(Math.sin(s) * Math.cos(e)), r = Math.atan2(Math.tan(e), Math.cos(s));
  } else {
    var o = this.ml0 / this.a + t, a = nf(o, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(a) - Y) <= J)
      return i.x = this.long0, i.y = Y, t < 0 && (i.y *= -1), i;
    var l = S_(this.a, this.e, Math.sin(a)), h = l * l * l / this.a / this.a * (1 - this.es), u = Math.pow(Math.tan(a), 2), c = e * this.a / l, f = c * c;
    n = a - l * Math.tan(a) / h * c * c * (0.5 - (1 + 3 * u) * c * c / 24), r = c * (1 - f * (u / 3 + (1 + 3 * u) * u * f / 15)) / Math.cos(a);
  }
  return i.x = Q(r + this.long0, this.over), i.y = Fs(n), i;
}
var vz = ["Cassini", "Cassini_Soldner", "cass"];
const wz = {
  init: yz,
  forward: xz,
  inverse: Ez,
  names: vz
};
function vs(i, e) {
  var t;
  return i > 1e-7 ? (t = i * e, (1 - i * i) * (e / (1 - t * t) - 0.5 / i * Math.log((1 - t) / (1 + t)))) : 2 * e;
}
var Ip = 1, Lp = 2, Fp = 3, ic = 4;
function bz() {
  var i = Math.abs(this.lat0);
  if (Math.abs(i - Y) < J ? this.mode = this.lat0 < 0 ? Ip : Lp : Math.abs(i) < J ? this.mode = Fp : this.mode = ic, this.es > 0) {
    var e;
    switch (this.qp = vs(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = Lz(this.es), this.mode) {
      case Lp:
        this.dd = 1;
        break;
      case Ip:
        this.dd = 1;
        break;
      case Fp:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case ic:
        this.rq = Math.sqrt(0.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = vs(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === ic && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function Sz(i) {
  var e, t, n, r, s, o, a, l, h, u, c = i.x, f = i.y;
  if (c = Q(c - this.long0, this.over), this.sphere) {
    if (s = Math.sin(f), u = Math.cos(f), n = Math.cos(c), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (t = this.mode === this.EQUIT ? 1 + u * n : 1 + this.sinph0 * s + this.cosph0 * u * n, t <= J)
        return null;
      t = Math.sqrt(2 / t), e = t * u * Math.sin(c), t *= this.mode === this.EQUIT ? s : this.cosph0 * s - this.sinph0 * u * n;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (n = -n), Math.abs(f + this.lat0) < J)
        return null;
      t = Je - f * 0.5, t = 2 * (this.mode === this.S_POLE ? Math.cos(t) : Math.sin(t)), e = t * Math.sin(c), t *= n;
    }
  } else {
    switch (a = 0, l = 0, h = 0, n = Math.cos(c), r = Math.sin(c), s = Math.sin(f), o = vs(this.e, s), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (a = o / this.qp, l = Math.sqrt(1 - a * a)), this.mode) {
      case this.OBLIQ:
        h = 1 + this.sinb1 * a + this.cosb1 * l * n;
        break;
      case this.EQUIT:
        h = 1 + l * n;
        break;
      case this.N_POLE:
        h = Y + f, o = this.qp - o;
        break;
      case this.S_POLE:
        h = f - Y, o = this.qp + o;
        break;
    }
    if (Math.abs(h) < J)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        h = Math.sqrt(2 / h), this.mode === this.OBLIQ ? t = this.ymf * h * (this.cosb1 * a - this.sinb1 * l * n) : t = (h = Math.sqrt(2 / (1 + l * n))) * a * this.ymf, e = this.xmf * h * l * r;
        break;
      case this.N_POLE:
      case this.S_POLE:
        o >= 0 ? (e = (h = Math.sqrt(o)) * r, t = n * (this.mode === this.S_POLE ? h : -h)) : e = t = 0;
        break;
    }
  }
  return i.x = this.a * e + this.x0, i.y = this.a * t + this.y0, i;
}
function Tz(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e = i.x / this.a, t = i.y / this.a, n, r, s, o, a, l, h;
  if (this.sphere) {
    var u = 0, c, f = 0;
    if (c = Math.sqrt(e * e + t * t), r = c * 0.5, r > 1)
      return null;
    switch (r = 2 * Math.asin(r), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (f = Math.sin(r), u = Math.cos(r)), this.mode) {
      case this.EQUIT:
        r = Math.abs(c) <= J ? 0 : Math.asin(t * f / c), e *= f, t = u * c;
        break;
      case this.OBLIQ:
        r = Math.abs(c) <= J ? this.lat0 : Math.asin(u * this.sinph0 + t * f * this.cosph0 / c), e *= f * this.cosph0, t = (u - Math.sin(r) * this.sinph0) * c;
        break;
      case this.N_POLE:
        t = -t, r = Y - r;
        break;
      case this.S_POLE:
        r -= Y;
        break;
    }
    n = t === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(e, t);
  } else {
    if (h = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (e /= this.dd, t *= this.dd, l = Math.sqrt(e * e + t * t), l < J)
        return i.x = this.long0, i.y = this.lat0, i;
      o = 2 * Math.asin(0.5 * l / this.rq), s = Math.cos(o), e *= o = Math.sin(o), this.mode === this.OBLIQ ? (h = s * this.sinb1 + t * o * this.cosb1 / l, a = this.qp * h, t = l * this.cosb1 * s - t * this.sinb1 * o) : (h = t * o / l, a = this.qp * h, t = l * s);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (t = -t), a = e * e + t * t, !a)
        return i.x = this.long0, i.y = this.lat0, i;
      h = 1 - a / this.qp, this.mode === this.S_POLE && (h = -h);
    }
    n = Math.atan2(e, t), r = Fz(Math.asin(h), this.apa);
  }
  return i.x = Q(this.long0 + n, this.over), i.y = r, i;
}
var Rz = 0.3333333333333333, Pz = 0.17222222222222222, Mz = 0.10257936507936508, Cz = 0.06388888888888888, Az = 0.0664021164021164, Iz = 0.016415012942191543;
function Lz(i) {
  var e, t = [];
  return t[0] = i * Rz, e = i * i, t[0] += e * Pz, t[1] = e * Cz, e *= i, t[0] += e * Mz, t[1] += e * Az, t[2] = e * Iz, t;
}
function Fz(i, e) {
  var t = i + i;
  return i + e[0] * Math.sin(t) + e[1] * Math.sin(t + t) + e[2] * Math.sin(t + t + t);
}
var Oz = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const Nz = {
  init: bz,
  forward: Sz,
  inverse: Tz,
  names: Oz,
  S_POLE: Ip,
  N_POLE: Lp,
  EQUIT: Fp,
  OBLIQ: ic
};
function Cs(i) {
  return Math.abs(i) > 1 && (i = i > 1 ? 1 : -1), Math.asin(i);
}
function Dz() {
  Math.abs(this.lat1 + this.lat2) < J || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = mr(this.e3, this.sin_po, this.cos_po), this.qs1 = vs(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = mr(this.e3, this.sin_po, this.cos_po), this.qs2 = vs(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = vs(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > J ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function Gz(i) {
  var e = i.x, t = i.y;
  this.sin_phi = Math.sin(t), this.cos_phi = Math.cos(t);
  var n = vs(this.e3, this.sin_phi), r = this.a * Math.sqrt(this.c - this.ns0 * n) / this.ns0, s = this.ns0 * Q(e - this.long0, this.over), o = r * Math.sin(s) + this.x0, a = this.rh - r * Math.cos(s) + this.y0;
  return i.x = o, i.y = a, i;
}
function kz(i) {
  var e, t, n, r, s, o;
  return i.x -= this.x0, i.y = this.rh - i.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(i.x * i.x + i.y * i.y), n = 1) : (e = -Math.sqrt(i.x * i.x + i.y * i.y), n = -1), r = 0, e !== 0 && (r = Math.atan2(n * i.x, n * i.y)), n = e * this.ns0 / this.a, this.sphere ? o = Math.asin((this.c - n * n) / (2 * this.ns0)) : (t = (this.c - n * n) / this.ns0, o = this.phi1z(this.e3, t)), s = Q(r / this.ns0 + this.long0, this.over), i.x = s, i.y = o, i;
}
function Uz(i, e) {
  var t, n, r, s, o, a = Cs(0.5 * e);
  if (i < J)
    return a;
  for (var l = i * i, h = 1; h <= 25; h++)
    if (t = Math.sin(a), n = Math.cos(a), r = i * t, s = 1 - r * r, o = 0.5 * s * s / n * (e / (1 - l) - t / s + 0.5 / i * Math.log((1 - r) / (1 + r))), a = a + o, Math.abs(o) <= 1e-7)
      return a;
  return null;
}
var zz = ["Albers_Conic_Equal_Area", "Albers_Equal_Area", "Albers", "aea"];
const Bz = {
  init: Dz,
  forward: Gz,
  inverse: kz,
  names: zz,
  phi1z: Uz
};
function $z() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function jz(i) {
  var e, t, n, r, s, o, a, l, h = i.x, u = i.y;
  return n = Q(h - this.long0, this.over), e = Math.sin(u), t = Math.cos(u), r = Math.cos(n), o = this.sin_p14 * e + this.cos_p14 * t * r, s = 1, o > 0 || Math.abs(o) <= J ? (a = this.x0 + this.a * s * t * Math.sin(n) / o, l = this.y0 + this.a * s * (this.cos_p14 * e - this.sin_p14 * t * r) / o) : (a = this.x0 + this.infinity_dist * t * Math.sin(n), l = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * t * r)), i.x = a, i.y = l, i;
}
function Xz(i) {
  var e, t, n, r, s, o;
  return i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, (e = Math.sqrt(i.x * i.x + i.y * i.y)) ? (r = Math.atan2(e, this.rc), t = Math.sin(r), n = Math.cos(r), o = Cs(n * this.sin_p14 + i.y * t * this.cos_p14 / e), s = Math.atan2(i.x * t, e * this.cos_p14 * n - i.y * this.sin_p14 * t), s = Q(this.long0 + s, this.over)) : (o = this.phic0, s = 0), i.x = s, i.y = o, i;
}
var Vz = ["gnom"];
const Wz = {
  init: $z,
  forward: jz,
  inverse: Xz,
  names: Vz
};
function Yz(i, e) {
  var t = 1 - (1 - i * i) / (2 * i) * Math.log((1 - i) / (1 + i));
  if (Math.abs(Math.abs(e) - t) < 1e-6)
    return e < 0 ? -1 * Y : Y;
  for (var n = Math.asin(0.5 * e), r, s, o, a, l = 0; l < 30; l++)
    if (s = Math.sin(n), o = Math.cos(n), a = i * s, r = Math.pow(1 - a * a, 2) / (2 * o) * (e / (1 - i * i) - s / (1 - a * a) + 0.5 / i * Math.log((1 - a) / (1 + a))), n += r, Math.abs(r) <= 1e-10)
      return n;
  return NaN;
}
function qz() {
  this.sphere || (this.k0 = mr(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function Zz(i) {
  var e = i.x, t = i.y, n, r, s = Q(e - this.long0, this.over);
  if (this.sphere)
    n = this.x0 + this.a * s * Math.cos(this.lat_ts), r = this.y0 + this.a * Math.sin(t) / Math.cos(this.lat_ts);
  else {
    var o = vs(this.e, Math.sin(t));
    n = this.x0 + this.a * this.k0 * s, r = this.y0 + this.a * o * 0.5 / this.k0;
  }
  return i.x = n, i.y = r, i;
}
function Hz(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e, t;
  return this.sphere ? (e = Q(this.long0 + i.x / this.a / Math.cos(this.lat_ts), this.over), t = Math.asin(i.y / this.a * Math.cos(this.lat_ts))) : (t = Yz(this.e, 2 * i.y * this.k0 / this.a), e = Q(this.long0 + i.x / (this.a * this.k0), this.over)), i.x = e, i.y = t, i;
}
var Kz = ["cea"];
const Jz = {
  init: qz,
  forward: Zz,
  inverse: Hz,
  names: Kz
};
function Qz() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function eB(i) {
  var e = i.x, t = i.y, n = Q(e - this.long0, this.over), r = Fs(t - this.lat0);
  return i.x = this.x0 + this.a * n * this.rc, i.y = this.y0 + this.a * r, i;
}
function tB(i) {
  var e = i.x, t = i.y;
  return i.x = Q(this.long0 + (e - this.x0) / (this.a * this.rc), this.over), i.y = Fs(this.lat0 + (t - this.y0) / this.a), i;
}
var iB = ["Equirectangular", "Equidistant_Cylindrical", "Equidistant_Cylindrical_Spherical", "eqc"];
const nB = {
  init: Qz,
  forward: eB,
  inverse: tB,
  names: iB
};
var Qx = 20;
function rB() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Hh(this.es), this.e1 = Kh(this.es), this.e2 = Jh(this.es), this.e3 = Qh(this.es), this.ml0 = this.a * Pi(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function sB(i) {
  var e = i.x, t = i.y, n, r, s, o = Q(e - this.long0, this.over);
  if (s = o * Math.sin(t), this.sphere)
    Math.abs(t) <= J ? (n = this.a * o, r = -1 * this.a * this.lat0) : (n = this.a * Math.sin(s) / Math.tan(t), r = this.a * (Fs(t - this.lat0) + (1 - Math.cos(s)) / Math.tan(t)));
  else if (Math.abs(t) <= J)
    n = this.a * o, r = -1 * this.ml0;
  else {
    var a = S_(this.a, this.e, Math.sin(t)) / Math.tan(t);
    n = a * Math.sin(s), r = this.a * Pi(this.e0, this.e1, this.e2, this.e3, t) - this.ml0 + a * (1 - Math.cos(s));
  }
  return i.x = n + this.x0, i.y = r + this.y0, i;
}
function oB(i) {
  var e, t, n, r, s, o, a, l, h;
  if (n = i.x - this.x0, r = i.y - this.y0, this.sphere)
    if (Math.abs(r + this.a * this.lat0) <= J)
      e = Q(n / this.a + this.long0, this.over), t = 0;
    else {
      o = this.lat0 + r / this.a, a = n * n / this.a / this.a + o * o, l = o;
      var u;
      for (s = Qx; s; --s)
        if (u = Math.tan(l), h = -1 * (o * (l * u + 1) - l - 0.5 * (l * l + a) * u) / ((l - o) / u - 1), l += h, Math.abs(h) <= J) {
          t = l;
          break;
        }
      e = Q(this.long0 + Math.asin(n * Math.tan(l) / this.a) / Math.sin(t), this.over);
    }
  else if (Math.abs(r + this.ml0) <= J)
    t = 0, e = Q(this.long0 + n / this.a, this.over);
  else {
    o = (this.ml0 + r) / this.a, a = n * n / this.a / this.a + o * o, l = o;
    var c, f, g, d, m;
    for (s = Qx; s; --s)
      if (m = this.e * Math.sin(l), c = Math.sqrt(1 - m * m) * Math.tan(l), f = this.a * Pi(this.e0, this.e1, this.e2, this.e3, l), g = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), d = f / this.a, h = (o * (c * d + 1) - d - 0.5 * c * (d * d + a)) / (this.es * Math.sin(2 * l) * (d * d + a - 2 * o * d) / (4 * c) + (o - d) * (c * g - 2 / Math.sin(2 * l)) - g), l -= h, Math.abs(h) <= J) {
        t = l;
        break;
      }
    c = Math.sqrt(1 - this.es * Math.pow(Math.sin(t), 2)) * Math.tan(t), e = Q(this.long0 + Math.asin(n * c / this.a) / Math.sin(t), this.over);
  }
  return i.x = e, i.y = t, i;
}
var aB = ["Polyconic", "American_Polyconic", "poly"];
const lB = {
  init: rB,
  forward: sB,
  inverse: oB,
  names: aB
};
function hB() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function uB(i) {
  var e, t = i.x, n = i.y, r = n - this.lat0, s = t - this.long0, o = r / zl * 1e-5, a = s, l = 1, h = 0;
  for (e = 1; e <= 10; e++)
    l = l * o, h = h + this.A[e] * l;
  var u = h, c = a, f = 1, g = 0, d, m, x = 0, v = 0;
  for (e = 1; e <= 6; e++)
    d = f * u - g * c, m = g * u + f * c, f = d, g = m, x = x + this.B_re[e] * f - this.B_im[e] * g, v = v + this.B_im[e] * f + this.B_re[e] * g;
  return i.x = v * this.a + this.x0, i.y = x * this.a + this.y0, i;
}
function cB(i) {
  var e, t = i.x, n = i.y, r = t - this.x0, s = n - this.y0, o = s / this.a, a = r / this.a, l = 1, h = 0, u, c, f = 0, g = 0;
  for (e = 1; e <= 6; e++)
    u = l * o - h * a, c = h * o + l * a, l = u, h = c, f = f + this.C_re[e] * l - this.C_im[e] * h, g = g + this.C_im[e] * l + this.C_re[e] * h;
  for (var d = 0; d < this.iterations; d++) {
    var m = f, x = g, v, p, y = o, E = a;
    for (e = 2; e <= 6; e++)
      v = m * f - x * g, p = x * f + m * g, m = v, x = p, y = y + (e - 1) * (this.B_re[e] * m - this.B_im[e] * x), E = E + (e - 1) * (this.B_im[e] * m + this.B_re[e] * x);
    m = 1, x = 0;
    var b = this.B_re[1], T = this.B_im[1];
    for (e = 2; e <= 6; e++)
      v = m * f - x * g, p = x * f + m * g, m = v, x = p, b = b + e * (this.B_re[e] * m - this.B_im[e] * x), T = T + e * (this.B_im[e] * m + this.B_re[e] * x);
    var R = b * b + T * T;
    f = (y * b + E * T) / R, g = (E * b - y * T) / R;
  }
  var M = f, C = g, I = 1, O = 0;
  for (e = 1; e <= 9; e++)
    I = I * M, O = O + this.D[e] * I;
  var z = this.lat0 + O * zl * 1e5, _ = this.long0 + C;
  return i.x = _, i.y = z, i;
}
var fB = ["New_Zealand_Map_Grid", "nzmg"];
const dB = {
  init: hB,
  forward: uB,
  inverse: cB,
  names: fB
};
function gB() {
}
function pB(i) {
  var e = i.x, t = i.y, n = Q(e - this.long0, this.over), r = this.x0 + this.a * n, s = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + t / 2.5)) * 1.25;
  return i.x = r, i.y = s, i;
}
function mB(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e = Q(this.long0 + i.x / this.a, this.over), t = 2.5 * (Math.atan(Math.exp(0.8 * i.y / this.a)) - Math.PI / 4);
  return i.x = e, i.y = t, i;
}
var _B = ["Miller_Cylindrical", "mill"];
const yB = {
  init: gB,
  forward: pB,
  inverse: mB,
  names: _B
};
var xB = 20;
function EB() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = y_(this.es);
}
function vB(i) {
  var e, t, n = i.x, r = i.y;
  if (n = Q(n - this.long0, this.over), this.sphere) {
    if (!this.m)
      r = this.n !== 1 ? Math.asin(this.n * Math.sin(r)) : r;
    else
      for (var s = this.n * Math.sin(r), o = xB; o; --o) {
        var a = (this.m * r + Math.sin(r) - s) / (this.m + Math.cos(r));
        if (r -= a, Math.abs(a) < J)
          break;
      }
    e = this.a * this.C_x * n * (this.m + Math.cos(r)), t = this.a * this.C_y * r;
  } else {
    var l = Math.sin(r), h = Math.cos(r);
    t = this.a * il(r, l, h, this.en), e = this.a * n * h / Math.sqrt(1 - this.es * l * l);
  }
  return i.x = e, i.y = t, i;
}
function wB(i) {
  var e, t, n, r;
  return i.x -= this.x0, n = i.x / this.a, i.y -= this.y0, e = i.y / this.a, this.sphere ? (e /= this.C_y, n = n / (this.C_x * (this.m + Math.cos(e))), this.m ? e = Cs((this.m * e + Math.sin(e)) / this.n) : this.n !== 1 && (e = Cs(Math.sin(e) / this.n)), n = Q(n + this.long0, this.over), e = Fs(e)) : (e = x_(i.y / this.a, this.es, this.en), r = Math.abs(e), r < Y ? (r = Math.sin(e), t = this.long0 + i.x * Math.sqrt(1 - this.es * r * r) / (this.a * Math.cos(e)), n = Q(t, this.over)) : r - J < Y && (n = this.long0)), i.x = n, i.y = e, i;
}
var bB = ["Sinusoidal", "sinu"];
const SB = {
  init: EB,
  forward: vB,
  inverse: wB,
  names: bB
};
function TB() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0;
}
function RB(i) {
  for (var e = i.x, t = i.y, n = Q(e - this.long0, this.over), r = t, s = Math.PI * Math.sin(t); ; ) {
    var o = -(r + Math.sin(r) - s) / (1 + Math.cos(r));
    if (r += o, Math.abs(o) < J)
      break;
  }
  r /= 2, Math.PI / 2 - Math.abs(t) < J && (n = 0);
  var a = 0.900316316158 * this.a * n * Math.cos(r) + this.x0, l = 1.4142135623731 * this.a * Math.sin(r) + this.y0;
  return i.x = a, i.y = l, i;
}
function PB(i) {
  var e, t;
  i.x -= this.x0, i.y -= this.y0, t = i.y / (1.4142135623731 * this.a), Math.abs(t) > 0.999999999999 && (t = 0.999999999999), e = Math.asin(t);
  var n = Q(this.long0 + i.x / (0.900316316158 * this.a * Math.cos(e)), this.over);
  n < -Math.PI && (n = -Math.PI), n > Math.PI && (n = Math.PI), t = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(t) > 1 && (t = 1);
  var r = Math.asin(t);
  return i.x = n, i.y = r, i;
}
var MB = ["Mollweide", "moll"];
const CB = {
  init: TB,
  forward: RB,
  inverse: PB,
  names: MB
};
function AB() {
  Math.abs(this.lat1 + this.lat2) < J || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Hh(this.es), this.e1 = Kh(this.es), this.e2 = Jh(this.es), this.e3 = Qh(this.es), this.sin_phi = Math.sin(this.lat1), this.cos_phi = Math.cos(this.lat1), this.ms1 = mr(this.e, this.sin_phi, this.cos_phi), this.ml1 = Pi(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < J ? this.ns = this.sin_phi : (this.sin_phi = Math.sin(this.lat2), this.cos_phi = Math.cos(this.lat2), this.ms2 = mr(this.e, this.sin_phi, this.cos_phi), this.ml2 = Pi(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Pi(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function IB(i) {
  var e = i.x, t = i.y, n;
  if (this.sphere)
    n = this.a * (this.g - t);
  else {
    var r = Pi(this.e0, this.e1, this.e2, this.e3, t);
    n = this.a * (this.g - r);
  }
  var s = this.ns * Q(e - this.long0, this.over), o = this.x0 + n * Math.sin(s), a = this.y0 + this.rh - n * Math.cos(s);
  return i.x = o, i.y = a, i;
}
function LB(i) {
  i.x -= this.x0, i.y = this.rh - i.y + this.y0;
  var e, t, n, r;
  this.ns >= 0 ? (t = Math.sqrt(i.x * i.x + i.y * i.y), e = 1) : (t = -Math.sqrt(i.x * i.x + i.y * i.y), e = -1);
  var s = 0;
  if (t !== 0 && (s = Math.atan2(e * i.x, e * i.y)), this.sphere)
    return r = Q(this.long0 + s / this.ns, this.over), n = Fs(this.g - t / this.a), i.x = r, i.y = n, i;
  var o = this.g - t / this.a;
  return n = nf(o, this.e0, this.e1, this.e2, this.e3), r = Q(this.long0 + s / this.ns, this.over), i.x = r, i.y = n, i;
}
var FB = ["Equidistant_Conic", "eqdc"];
const OB = {
  init: AB,
  forward: IB,
  inverse: LB,
  names: FB
};
function NB() {
  this.R = this.a;
}
function DB(i) {
  var e = i.x, t = i.y, n = Q(e - this.long0, this.over), r, s;
  Math.abs(t) <= J && (r = this.x0 + this.R * n, s = this.y0);
  var o = Cs(2 * Math.abs(t / Math.PI));
  (Math.abs(n) <= J || Math.abs(Math.abs(t) - Y) <= J) && (r = this.x0, t >= 0 ? s = this.y0 + Math.PI * this.R * Math.tan(0.5 * o) : s = this.y0 + Math.PI * this.R * -Math.tan(0.5 * o));
  var a = 0.5 * Math.abs(Math.PI / n - n / Math.PI), l = a * a, h = Math.sin(o), u = Math.cos(o), c = u / (h + u - 1), f = c * c, g = c * (2 / h - 1), d = g * g, m = Math.PI * this.R * (a * (c - d) + Math.sqrt(l * (c - d) * (c - d) - (d + l) * (f - d))) / (d + l);
  n < 0 && (m = -m), r = this.x0 + m;
  var x = l + c;
  return m = Math.PI * this.R * (g * x - a * Math.sqrt((d + l) * (l + 1) - x * x)) / (d + l), t >= 0 ? s = this.y0 + m : s = this.y0 - m, i.x = r, i.y = s, i;
}
function GB(i) {
  var e, t, n, r, s, o, a, l, h, u, c, f, g;
  return i.x -= this.x0, i.y -= this.y0, c = Math.PI * this.R, n = i.x / c, r = i.y / c, s = n * n + r * r, o = -Math.abs(r) * (1 + s), a = o - 2 * r * r + n * n, l = -2 * o + 1 + 2 * r * r + s * s, g = r * r / l + (2 * a * a * a / l / l / l - 9 * o * a / l / l) / 27, h = (o - a * a / 3 / l) / l, u = 2 * Math.sqrt(-h / 3), c = 3 * g / h / u, Math.abs(c) > 1 && (c >= 0 ? c = 1 : c = -1), f = Math.acos(c) / 3, i.y >= 0 ? t = (-u * Math.cos(f + Math.PI / 3) - a / 3 / l) * Math.PI : t = -(-u * Math.cos(f + Math.PI / 3) - a / 3 / l) * Math.PI, Math.abs(n) < J ? e = this.long0 : e = Q(this.long0 + Math.PI * (s - 1 + Math.sqrt(1 + 2 * (n * n - r * r) + s * s)) / 2 / n, this.over), i.x = e, i.y = t, i;
}
var kB = ["Van_der_Grinten_I", "VanDerGrinten", "Van_der_Grinten", "vandg"];
const UB = {
  init: NB,
  forward: DB,
  inverse: GB,
  names: kB
};
function zB(i, e, t, n, r, s) {
  const o = n - e, a = Math.atan((1 - s) * Math.tan(i)), l = Math.atan((1 - s) * Math.tan(t)), h = Math.sin(a), u = Math.cos(a), c = Math.sin(l), f = Math.cos(l);
  let g = o, d, m = 100, x, v, p, y, E, b, T, R, M, C, I, O, z, _;
  do {
    if (x = Math.sin(g), v = Math.cos(g), p = Math.sqrt(
      f * x * (f * x) + (u * c - h * f * v) * (u * c - h * f * v)
    ), p === 0)
      return { azi1: 0, s12: 0 };
    y = h * c + u * f * v, E = Math.atan2(p, y), b = u * f * x / p, T = 1 - b * b, R = T !== 0 ? y - 2 * h * c / T : 0, M = s / 16 * T * (4 + s * (4 - 3 * T)), d = g, g = o + (1 - M) * s * b * (E + M * p * (R + M * y * (-1 + 2 * R * R)));
  } while (Math.abs(g - d) > 1e-12 && --m > 0);
  return m === 0 ? { azi1: NaN, s12: NaN } : (C = T * (r * r - r * (1 - s) * (r * (1 - s))) / (r * (1 - s) * (r * (1 - s))), I = 1 + C / 16384 * (4096 + C * (-768 + C * (320 - 175 * C))), O = C / 1024 * (256 + C * (-128 + C * (74 - 47 * C))), z = O * p * (R + O / 4 * (y * (-1 + 2 * R * R) - O / 6 * R * (-3 + 4 * p * p) * (-3 + 4 * R * R))), _ = r * (1 - s) * I * (E - z), { azi1: Math.atan2(f * x, u * c - h * f * v), s12: _ });
}
function BB(i, e, t, n, r, s) {
  const o = Math.atan((1 - s) * Math.tan(i)), a = Math.sin(o), l = Math.cos(o), h = Math.sin(t), u = Math.cos(t), c = Math.atan2(a, l * u), f = l * h, g = 1 - f * f, d = g * (r * r - r * (1 - s) * (r * (1 - s))) / (r * (1 - s) * (r * (1 - s))), m = 1 + d / 16384 * (4096 + d * (-768 + d * (320 - 175 * d))), x = d / 1024 * (256 + d * (-128 + d * (74 - 47 * d)));
  let v = n / (r * (1 - s) * m), p, y = 100, E, b, T, R;
  do
    E = Math.cos(2 * c + v), b = Math.sin(v), T = Math.cos(v), R = x * b * (E + x / 4 * (T * (-1 + 2 * E * E) - x / 6 * E * (-3 + 4 * b * b) * (-3 + 4 * E * E))), p = v, v = n / (r * (1 - s) * m) + R;
  while (Math.abs(v - p) > 1e-12 && --y > 0);
  if (y === 0)
    return { lat2: NaN, lon2: NaN };
  const M = a * b - l * T * u, C = Math.atan2(
    a * T + l * b * u,
    (1 - s) * Math.sqrt(f * f + M * M)
  ), I = Math.atan2(
    b * h,
    l * T - a * b * u
  ), O = s / 16 * g * (4 + s * (4 - 3 * g)), z = I - (1 - O) * s * f * (v + O * b * (E + O * T * (-1 + 2 * E * E))), _ = e + z;
  return { lat2: C, lon2: _ };
}
function $B() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0), this.f = this.es / (1 + Math.sqrt(1 - this.es));
}
function jB(i) {
  var e = i.x, t = i.y, n = Math.sin(i.y), r = Math.cos(i.y), s = Q(e - this.long0, this.over), o, a, l, h, u, c, f, g, d, m, x;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= J ? (i.x = this.x0 + this.a * (Y - t) * Math.sin(s), i.y = this.y0 - this.a * (Y - t) * Math.cos(s), i) : Math.abs(this.sin_p12 + 1) <= J ? (i.x = this.x0 + this.a * (Y + t) * Math.sin(s), i.y = this.y0 + this.a * (Y + t) * Math.cos(s), i) : (d = this.sin_p12 * n + this.cos_p12 * r * Math.cos(s), f = Math.acos(d), g = f ? f / Math.sin(f) : 1, i.x = this.x0 + this.a * g * r * Math.sin(s), i.y = this.y0 + this.a * g * (this.cos_p12 * n - this.sin_p12 * r * Math.cos(s)), i) : (o = Hh(this.es), a = Kh(this.es), l = Jh(this.es), h = Qh(this.es), Math.abs(this.sin_p12 - 1) <= J ? (u = this.a * Pi(o, a, l, h, Y), c = this.a * Pi(o, a, l, h, t), i.x = this.x0 + (u - c) * Math.sin(s), i.y = this.y0 - (u - c) * Math.cos(s), i) : Math.abs(this.sin_p12 + 1) <= J ? (u = this.a * Pi(o, a, l, h, Y), c = this.a * Pi(o, a, l, h, t), i.x = this.x0 + (u + c) * Math.sin(s), i.y = this.y0 + (u + c) * Math.cos(s), i) : Math.abs(e) < J && Math.abs(t - this.lat0) < J ? (i.x = i.y = 0, i) : (m = zB(this.lat0, this.long0, t, e, this.a, this.f), x = m.azi1, i.x = m.s12 * Math.sin(x), i.y = m.s12 * Math.cos(x), i));
}
function XB(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e, t, n, r, s, o, a, l, h, u, c, f, g, d, m, x;
  return this.sphere ? (e = Math.sqrt(i.x * i.x + i.y * i.y), e > 2 * Y * this.a ? void 0 : (t = e / this.a, n = Math.sin(t), r = Math.cos(t), s = this.long0, Math.abs(e) <= J ? o = this.lat0 : (o = Cs(r * this.sin_p12 + i.y * n * this.cos_p12 / e), a = Math.abs(this.lat0) - Y, Math.abs(a) <= J ? this.lat0 >= 0 ? s = Q(this.long0 + Math.atan2(i.x, -i.y), this.over) : s = Q(this.long0 - Math.atan2(-i.x, i.y), this.over) : s = Q(this.long0 + Math.atan2(i.x * n, e * this.cos_p12 * r - i.y * this.sin_p12 * n), this.over)), i.x = s, i.y = o, i)) : (l = Hh(this.es), h = Kh(this.es), u = Jh(this.es), c = Qh(this.es), Math.abs(this.sin_p12 - 1) <= J ? (f = this.a * Pi(l, h, u, c, Y), e = Math.sqrt(i.x * i.x + i.y * i.y), g = f - e, o = nf(g / this.a, l, h, u, c), s = Q(this.long0 + Math.atan2(i.x, -1 * i.y), this.over), i.x = s, i.y = o, i) : Math.abs(this.sin_p12 + 1) <= J ? (f = this.a * Pi(l, h, u, c, Y), e = Math.sqrt(i.x * i.x + i.y * i.y), g = e - f, o = nf(g / this.a, l, h, u, c), s = Q(this.long0 + Math.atan2(i.x, i.y), this.over), i.x = s, i.y = o, i) : (d = Math.atan2(i.x, i.y), m = Math.sqrt(i.x * i.x + i.y * i.y), x = BB(this.lat0, this.long0, d, m, this.a, this.f), i.x = x.lon2, i.y = x.lat2, i));
}
var VB = ["Azimuthal_Equidistant", "aeqd"];
const WB = {
  init: $B,
  forward: jB,
  inverse: XB,
  names: VB
};
function YB() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function qB(i) {
  var e, t, n, r, s, o, a, l, h = i.x, u = i.y;
  return n = Q(h - this.long0, this.over), e = Math.sin(u), t = Math.cos(u), r = Math.cos(n), o = this.sin_p14 * e + this.cos_p14 * t * r, s = 1, (o > 0 || Math.abs(o) <= J) && (a = this.a * s * t * Math.sin(n), l = this.y0 + this.a * s * (this.cos_p14 * e - this.sin_p14 * t * r)), i.x = a, i.y = l, i;
}
function ZB(i) {
  var e, t, n, r, s, o, a;
  return i.x -= this.x0, i.y -= this.y0, e = Math.sqrt(i.x * i.x + i.y * i.y), t = Cs(e / this.a), n = Math.sin(t), r = Math.cos(t), o = this.long0, Math.abs(e) <= J ? (a = this.lat0, i.x = o, i.y = a, i) : (a = Cs(r * this.sin_p14 + i.y * n * this.cos_p14 / e), s = Math.abs(this.lat0) - Y, Math.abs(s) <= J ? (this.lat0 >= 0 ? o = Q(this.long0 + Math.atan2(i.x, -i.y), this.over) : o = Q(this.long0 - Math.atan2(-i.x, i.y), this.over), i.x = o, i.y = a, i) : (o = Q(this.long0 + Math.atan2(i.x * n, e * this.cos_p14 * r - i.y * this.sin_p14 * n), this.over), i.x = o, i.y = a, i));
}
var HB = ["ortho"];
const KB = {
  init: YB,
  forward: qB,
  inverse: ZB,
  names: HB
};
var Pt = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, Qe = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function JB() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= Y - Je / 2 ? this.face = Pt.TOP : this.lat0 <= -(Y - Je / 2) ? this.face = Pt.BOTTOM : Math.abs(this.long0) <= Je ? this.face = Pt.FRONT : Math.abs(this.long0) <= Y + Je ? this.face = this.long0 > 0 ? Pt.RIGHT : Pt.LEFT : this.face = Pt.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function QB(i) {
  var e = { x: 0, y: 0 }, t, n, r, s, o, a, l = { value: 0 };
  if (i.x -= this.long0, this.es !== 0 ? t = Math.atan(this.one_minus_f_squared * Math.tan(i.y)) : t = i.y, n = i.x, this.face === Pt.TOP)
    s = Y - t, n >= Je && n <= Y + Je ? (l.value = Qe.AREA_0, r = n - Y) : n > Y + Je || n <= -(Y + Je) ? (l.value = Qe.AREA_1, r = n > 0 ? n - Gt : n + Gt) : n > -(Y + Je) && n <= -Je ? (l.value = Qe.AREA_2, r = n + Y) : (l.value = Qe.AREA_3, r = n);
  else if (this.face === Pt.BOTTOM)
    s = Y + t, n >= Je && n <= Y + Je ? (l.value = Qe.AREA_0, r = -n + Y) : n < Je && n >= -Je ? (l.value = Qe.AREA_1, r = -n) : n < -Je && n >= -(Y + Je) ? (l.value = Qe.AREA_2, r = -n - Y) : (l.value = Qe.AREA_3, r = n > 0 ? -n + Gt : -n - Gt);
  else {
    var h, u, c, f, g, d, m;
    this.face === Pt.RIGHT ? n = _a(n, +Y) : this.face === Pt.BACK ? n = _a(n, +Gt) : this.face === Pt.LEFT && (n = _a(n, -Y)), f = Math.sin(t), g = Math.cos(t), d = Math.sin(n), m = Math.cos(n), h = g * m, u = g * d, c = f, this.face === Pt.FRONT ? (s = Math.acos(h), r = ku(s, c, u, l)) : this.face === Pt.RIGHT ? (s = Math.acos(u), r = ku(s, c, -h, l)) : this.face === Pt.BACK ? (s = Math.acos(-h), r = ku(s, c, -u, l)) : this.face === Pt.LEFT ? (s = Math.acos(-u), r = ku(s, c, h, l)) : (s = r = 0, l.value = Qe.AREA_0);
  }
  return a = Math.atan(12 / Gt * (r + Math.acos(Math.sin(r) * Math.cos(Je)) - Y)), o = Math.sqrt((1 - Math.cos(s)) / (Math.cos(a) * Math.cos(a)) / (1 - Math.cos(Math.atan(1 / Math.cos(r))))), l.value === Qe.AREA_1 ? a += Y : l.value === Qe.AREA_2 ? a += Gt : l.value === Qe.AREA_3 && (a += 1.5 * Gt), e.x = o * Math.cos(a), e.y = o * Math.sin(a), e.x = e.x * this.a + this.x0, e.y = e.y * this.a + this.y0, i.x = e.x, i.y = e.y, i;
}
function e7(i) {
  var e = { lam: 0, phi: 0 }, t, n, r, s, o, a, l, h, u, c = { value: 0 };
  if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, n = Math.atan(Math.sqrt(i.x * i.x + i.y * i.y)), t = Math.atan2(i.y, i.x), i.x >= 0 && i.x >= Math.abs(i.y) ? c.value = Qe.AREA_0 : i.y >= 0 && i.y >= Math.abs(i.x) ? (c.value = Qe.AREA_1, t -= Y) : i.x < 0 && -i.x >= Math.abs(i.y) ? (c.value = Qe.AREA_2, t = t < 0 ? t + Gt : t - Gt) : (c.value = Qe.AREA_3, t += Y), u = Gt / 12 * Math.tan(t), o = Math.sin(u) / (Math.cos(u) - 1 / Math.sqrt(2)), a = Math.atan(o), r = Math.cos(t), s = Math.tan(n), l = 1 - r * r * s * s * (1 - Math.cos(Math.atan(1 / Math.cos(a)))), l < -1 ? l = -1 : l > 1 && (l = 1), this.face === Pt.TOP)
    h = Math.acos(l), e.phi = Y - h, c.value === Qe.AREA_0 ? e.lam = a + Y : c.value === Qe.AREA_1 ? e.lam = a < 0 ? a + Gt : a - Gt : c.value === Qe.AREA_2 ? e.lam = a - Y : e.lam = a;
  else if (this.face === Pt.BOTTOM)
    h = Math.acos(l), e.phi = h - Y, c.value === Qe.AREA_0 ? e.lam = -a + Y : c.value === Qe.AREA_1 ? e.lam = -a : c.value === Qe.AREA_2 ? e.lam = -a - Y : e.lam = a < 0 ? -a - Gt : -a + Gt;
  else {
    var f, g, d;
    f = l, u = f * f, u >= 1 ? d = 0 : d = Math.sqrt(1 - u) * Math.sin(a), u += d * d, u >= 1 ? g = 0 : g = Math.sqrt(1 - u), c.value === Qe.AREA_1 ? (u = g, g = -d, d = u) : c.value === Qe.AREA_2 ? (g = -g, d = -d) : c.value === Qe.AREA_3 && (u = g, g = d, d = -u), this.face === Pt.RIGHT ? (u = f, f = -g, g = u) : this.face === Pt.BACK ? (f = -f, g = -g) : this.face === Pt.LEFT && (u = f, f = g, g = -u), e.phi = Math.acos(-d) - Y, e.lam = Math.atan2(g, f), this.face === Pt.RIGHT ? e.lam = _a(e.lam, -Y) : this.face === Pt.BACK ? e.lam = _a(e.lam, -Gt) : this.face === Pt.LEFT && (e.lam = _a(e.lam, +Y));
  }
  if (this.es !== 0) {
    var m, x, v;
    m = e.phi < 0 ? 1 : 0, x = Math.tan(e.phi), v = this.b / Math.sqrt(x * x + this.one_minus_f_squared), e.phi = Math.atan(Math.sqrt(this.a * this.a - v * v) / (this.one_minus_f * v)), m && (e.phi = -e.phi);
  }
  return e.lam += this.long0, i.x = e.lam, i.y = e.phi, i;
}
function ku(i, e, t, n) {
  var r;
  return i < J ? (n.value = Qe.AREA_0, r = 0) : (r = Math.atan2(e, t), Math.abs(r) <= Je ? n.value = Qe.AREA_0 : r > Je && r <= Y + Je ? (n.value = Qe.AREA_1, r -= Y) : r > Y + Je || r <= -(Y + Je) ? (n.value = Qe.AREA_2, r = r >= 0 ? r - Gt : r + Gt) : (n.value = Qe.AREA_3, r += Y)), r;
}
function _a(i, e) {
  var t = i + e;
  return t < -Gt ? t += ph : t > +Gt && (t -= ph), t;
}
var t7 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const i7 = {
  init: JB,
  forward: QB,
  inverse: e7,
  names: t7
};
var Op = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], Rl = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], hT = 0.8487, uT = 1.3523, cT = $i / 5, n7 = 1 / cT, na = 18, rf = function(i, e) {
  return i[0] + e * (i[1] + e * (i[2] + e * i[3]));
}, r7 = function(i, e) {
  return i[1] + e * (2 * i[2] + e * 3 * i[3]);
};
function s7(i, e, t, n) {
  for (var r = e; n; --n) {
    var s = i(r);
    if (r -= s, Math.abs(s) < t)
      break;
  }
  return r;
}
function o7() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function a7(i) {
  var e = Q(i.x - this.long0, this.over), t = Math.abs(i.y), n = Math.floor(t * cT);
  n < 0 ? n = 0 : n >= na && (n = na - 1), t = $i * (t - n7 * n);
  var r = {
    x: rf(Op[n], t) * e,
    y: rf(Rl[n], t)
  };
  return i.y < 0 && (r.y = -r.y), r.x = r.x * this.a * hT + this.x0, r.y = r.y * this.a * uT + this.y0, r;
}
function l7(i) {
  var e = {
    x: (i.x - this.x0) / (this.a * hT),
    y: Math.abs(i.y - this.y0) / (this.a * uT)
  };
  if (e.y >= 1)
    e.x /= Op[na][0], e.y = i.y < 0 ? -Y : Y;
  else {
    var t = Math.floor(e.y * na);
    for (t < 0 ? t = 0 : t >= na && (t = na - 1); ; )
      if (Rl[t][0] > e.y)
        --t;
      else if (Rl[t + 1][0] <= e.y)
        ++t;
      else
        break;
    var n = Rl[t], r = 5 * (e.y - n[0]) / (Rl[t + 1][0] - n[0]);
    r = s7(function(s) {
      return (rf(n, s) - e.y) / r7(n, s);
    }, r, J, 100), e.x /= rf(Op[t], r), e.y = (5 * t + r) * Nt, i.y < 0 && (e.y = -e.y);
  }
  return e.x = Q(e.x + this.long0, this.over), e;
}
var h7 = ["Robinson", "robin"];
const u7 = {
  init: o7,
  forward: a7,
  inverse: l7,
  names: h7
};
function c7() {
  this.name = "geocent";
}
function f7(i) {
  var e = JS(i, this.es, this.a);
  return e;
}
function d7(i) {
  var e = QS(i, this.es, this.a, this.b);
  return e;
}
var g7 = ["Geocentric", "geocentric", "geocent", "Geocent"];
const p7 = {
  init: c7,
  forward: f7,
  inverse: d7,
  names: g7
};
var Ei = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, fl = {
  h: { def: 1e5, num: !0 },
  // default is Karman line, no default in PROJ.7
  azi: { def: 0, num: !0, degrees: !0 },
  // default is North
  tilt: { def: 0, num: !0, degrees: !0 },
  // default is Nadir
  long0: { def: 0, num: !0 },
  // default is Greenwich, conversion to rad is automatic
  lat0: { def: 0, num: !0 }
  // default is Equator, conversion to rad is automatic
};
function m7() {
  if (Object.keys(fl).forEach((function(t) {
    if (typeof this[t] > "u")
      this[t] = fl[t].def;
    else {
      if (fl[t].num && isNaN(this[t]))
        throw new Error("Invalid parameter value, must be numeric " + t + " = " + this[t]);
      fl[t].num && (this[t] = parseFloat(this[t]));
    }
    fl[t].degrees && (this[t] = this[t] * Nt);
  }).bind(this)), Math.abs(Math.abs(this.lat0) - Y) < J ? this.mode = this.lat0 < 0 ? Ei.S_POLE : Ei.N_POLE : Math.abs(this.lat0) < J ? this.mode = Ei.EQUIT : (this.mode = Ei.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var i = this.tilt, e = this.azi;
  this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(i), this.sw = Math.sin(i);
}
function _7(i) {
  i.x -= this.long0;
  var e = Math.sin(i.y), t = Math.cos(i.y), n = Math.cos(i.x), r, s;
  switch (this.mode) {
    case Ei.OBLIQ:
      s = this.sinph0 * e + this.cosph0 * t * n;
      break;
    case Ei.EQUIT:
      s = t * n;
      break;
    case Ei.S_POLE:
      s = -e;
      break;
    case Ei.N_POLE:
      s = e;
      break;
  }
  switch (s = this.pn1 / (this.p - s), r = s * t * Math.sin(i.x), this.mode) {
    case Ei.OBLIQ:
      s *= this.cosph0 * e - this.sinph0 * t * n;
      break;
    case Ei.EQUIT:
      s *= e;
      break;
    case Ei.N_POLE:
      s *= -(t * n);
      break;
    case Ei.S_POLE:
      s *= t * n;
      break;
  }
  var o, a;
  return o = s * this.cg + r * this.sg, a = 1 / (o * this.sw * this.h1 + this.cw), r = (r * this.cg - s * this.sg) * this.cw * a, s = o * a, i.x = r * this.a, i.y = s * this.a, i;
}
function y7(i) {
  i.x /= this.a, i.y /= this.a;
  var e = { x: i.x, y: i.y }, t, n, r;
  r = 1 / (this.pn1 - i.y * this.sw), t = this.pn1 * i.x * r, n = this.pn1 * i.y * this.cw * r, i.x = t * this.cg + n * this.sg, i.y = n * this.cg - t * this.sg;
  var s = zi(i.x, i.y);
  if (Math.abs(s) < J)
    e.x = 0, e.y = i.y;
  else {
    var o, a;
    switch (a = 1 - s * s * this.pfact, a = (this.p - Math.sqrt(a)) / (this.pn1 / s + s / this.pn1), o = Math.sqrt(1 - a * a), this.mode) {
      case Ei.OBLIQ:
        e.y = Math.asin(o * this.sinph0 + i.y * a * this.cosph0 / s), i.y = (o - this.sinph0 * Math.sin(e.y)) * s, i.x *= a * this.cosph0;
        break;
      case Ei.EQUIT:
        e.y = Math.asin(i.y * a / s), i.y = o * s, i.x *= a;
        break;
      case Ei.N_POLE:
        e.y = Math.asin(o), i.y = -i.y;
        break;
      case Ei.S_POLE:
        e.y = -Math.asin(o);
        break;
    }
    e.x = Math.atan2(i.x, i.y);
  }
  return i.x = e.x + this.long0, i.y = e.y, i;
}
var x7 = ["Tilted_Perspective", "tpers"];
const E7 = {
  init: m7,
  forward: _7,
  inverse: y7,
  names: x7
};
function v7() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var i = 1 - this.es, e = 1 / i;
    this.radius_p = Math.sqrt(i), this.radius_p2 = i, this.radius_p_inv2 = e, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function w7(i) {
  var e = i.x, t = i.y, n, r, s, o;
  if (e = e - this.long0, this.shape === "ellipse") {
    t = Math.atan(this.radius_p2 * Math.tan(t));
    var a = this.radius_p / zi(this.radius_p * Math.cos(t), Math.sin(t));
    if (r = a * Math.cos(e) * Math.cos(t), s = a * Math.sin(e) * Math.cos(t), o = a * Math.sin(t), (this.radius_g - r) * r - s * s - o * o * this.radius_p_inv2 < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    n = this.radius_g - r, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(s / zi(o, n)), i.y = this.radius_g_1 * Math.atan(o / n)) : (i.x = this.radius_g_1 * Math.atan(s / n), i.y = this.radius_g_1 * Math.atan(o / zi(s, n)));
  } else this.shape === "sphere" && (n = Math.cos(t), r = Math.cos(e) * n, s = Math.sin(e) * n, o = Math.sin(t), n = this.radius_g - r, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(s / zi(o, n)), i.y = this.radius_g_1 * Math.atan(o / n)) : (i.x = this.radius_g_1 * Math.atan(s / n), i.y = this.radius_g_1 * Math.atan(o / zi(s, n))));
  return i.x = i.x * this.a, i.y = i.y * this.a, i;
}
function b7(i) {
  var e = -1, t = 0, n = 0, r, s, o, a;
  if (i.x = i.x / this.a, i.y = i.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (n = Math.tan(i.y / this.radius_g_1), t = Math.tan(i.x / this.radius_g_1) * zi(1, n)) : (t = Math.tan(i.x / this.radius_g_1), n = Math.tan(i.y / this.radius_g_1) * zi(1, t));
    var l = n / this.radius_p;
    if (r = t * t + l * l + e * e, s = 2 * this.radius_g * e, o = s * s - 4 * r * this.C, o < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    a = (-s - Math.sqrt(o)) / (2 * r), e = this.radius_g + a * e, t *= a, n *= a, i.x = Math.atan2(t, e), i.y = Math.atan(n * Math.cos(i.x) / e), i.y = Math.atan(this.radius_p_inv2 * Math.tan(i.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (n = Math.tan(i.y / this.radius_g_1), t = Math.tan(i.x / this.radius_g_1) * Math.sqrt(1 + n * n)) : (t = Math.tan(i.x / this.radius_g_1), n = Math.tan(i.y / this.radius_g_1) * Math.sqrt(1 + t * t)), r = t * t + n * n + e * e, s = 2 * this.radius_g * e, o = s * s - 4 * r * this.C, o < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    a = (-s - Math.sqrt(o)) / (2 * r), e = this.radius_g + a * e, t *= a, n *= a, i.x = Math.atan2(t, e), i.y = Math.atan(n * Math.cos(i.x) / e);
  }
  return i.x = i.x + this.long0, i;
}
var S7 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const T7 = {
  init: v7,
  forward: w7,
  inverse: b7,
  names: S7
};
var Bl = 1.340264, $l = -0.081106, jl = 893e-6, Xl = 3796e-6, sf = Math.sqrt(3) / 2;
function R7() {
  this.es = 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0;
}
function P7(i) {
  var e = Q(i.x - this.long0, this.over), t = i.y, n = Math.asin(sf * Math.sin(t)), r = n * n, s = r * r * r;
  return i.x = e * Math.cos(n) / (sf * (Bl + 3 * $l * r + s * (7 * jl + 9 * Xl * r))), i.y = n * (Bl + $l * r + s * (jl + Xl * r)), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
}
function M7(i) {
  i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a;
  var e = 1e-9, t = 12, n = i.y, r, s, o, a, l, h;
  for (h = 0; h < t && (r = n * n, s = r * r * r, o = n * (Bl + $l * r + s * (jl + Xl * r)) - i.y, a = Bl + 3 * $l * r + s * (7 * jl + 9 * Xl * r), n -= l = o / a, !(Math.abs(l) < e)); ++h)
    ;
  return r = n * n, s = r * r * r, i.x = sf * i.x * (Bl + 3 * $l * r + s * (7 * jl + 9 * Xl * r)) / Math.cos(n), i.y = Math.asin(Math.sin(n) / sf), i.x = Q(i.x + this.long0, this.over), i;
}
var C7 = ["eqearth", "Equal Earth", "Equal_Earth"];
const A7 = {
  init: R7,
  forward: P7,
  inverse: M7,
  names: C7
};
var yh = 1e-10;
function I7() {
  var i;
  if (this.phi1 = this.lat1, Math.abs(this.phi1) < yh)
    throw new Error();
  this.es ? (this.en = y_(this.es), this.m1 = il(
    this.phi1,
    this.am1 = Math.sin(this.phi1),
    i = Math.cos(this.phi1),
    this.en
  ), this.am1 = i / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1), this.inverse = F7, this.forward = L7) : (Math.abs(this.phi1) + yh >= Y ? this.cphi1 = 0 : this.cphi1 = 1 / Math.tan(this.phi1), this.inverse = N7, this.forward = O7);
}
function L7(i) {
  var e = Q(i.x - (this.long0 || 0), this.over), t = i.y, n, r, s;
  return n = this.am1 + this.m1 - il(t, r = Math.sin(t), s = Math.cos(t), this.en), r = s * e / (n * Math.sqrt(1 - this.es * r * r)), i.x = n * Math.sin(r), i.y = this.am1 - n * Math.cos(r), i.x = this.a * i.x + (this.x0 || 0), i.y = this.a * i.y + (this.y0 || 0), i;
}
function F7(i) {
  i.x = (i.x - (this.x0 || 0)) / this.a, i.y = (i.y - (this.y0 || 0)) / this.a;
  var e, t, n, r;
  if (t = zi(i.x, i.y = this.am1 - i.y), r = x_(this.am1 + this.m1 - t, this.es, this.en), (e = Math.abs(r)) < Y)
    e = Math.sin(r), n = t * Math.atan2(i.x, i.y) * Math.sqrt(1 - this.es * e * e) / Math.cos(r);
  else if (Math.abs(e - Y) <= yh)
    n = 0;
  else
    throw new Error();
  return i.x = Q(n + (this.long0 || 0), this.over), i.y = Fs(r), i;
}
function O7(i) {
  var e = Q(i.x - (this.long0 || 0), this.over), t = i.y, n, r;
  return r = this.cphi1 + this.phi1 - t, Math.abs(r) > yh ? (i.x = r * Math.sin(n = e * Math.cos(t) / r), i.y = this.cphi1 - r * Math.cos(n)) : i.x = i.y = 0, i.x = this.a * i.x + (this.x0 || 0), i.y = this.a * i.y + (this.y0 || 0), i;
}
function N7(i) {
  i.x = (i.x - (this.x0 || 0)) / this.a, i.y = (i.y - (this.y0 || 0)) / this.a;
  var e, t, n = zi(i.x, i.y = this.cphi1 - i.y);
  if (t = this.cphi1 + this.phi1 - n, Math.abs(t) > Y)
    throw new Error();
  return Math.abs(Math.abs(t) - Y) <= yh ? e = 0 : e = n * Math.atan2(i.x, i.y) / Math.cos(t), i.x = Q(e + (this.long0 || 0), this.over), i.y = Fs(t), i;
}
var D7 = ["bonne", "Bonne (Werner lat_1=90)"];
const G7 = {
  init: I7,
  names: D7
}, eE = {
  OBLIQUE: {
    forward: $7,
    inverse: X7
  },
  TRANSVERSE: {
    forward: j7,
    inverse: V7
  }
}, of = {
  ROTATE: {
    o_alpha: "oAlpha",
    o_lon_c: "oLongC",
    o_lat_c: "oLatC"
  },
  NEW_POLE: {
    o_lat_p: "oLatP",
    o_lon_p: "oLongP"
  },
  NEW_EQUATOR: {
    o_lon_1: "oLong1",
    o_lat_1: "oLat1",
    o_lon_2: "oLong2",
    o_lat_2: "oLat2"
  }
};
function k7() {
  if (this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.title = this.title || "General Oblique Transformation", this.isIdentity = qS.includes(this.o_proj), !this.o_proj)
    throw new Error("Missing parameter: o_proj");
  if (this.o_proj === "ob_tran")
    throw new Error("Invalid value for o_proj: " + this.o_proj);
  const i = this.projStr.replace("+proj=ob_tran", "").replace("+o_proj=", "+proj=").trim(), e = Rn(i);
  if (!e)
    throw new Error("Invalid parameter: o_proj. Unknown projection " + this.o_proj);
  e.long0 = 0, this.obliqueProjection = e;
  let t;
  const n = Object.keys(of), r = (a) => {
    if (typeof this[a] > "u")
      return;
    const l = parseFloat(this[a]) * Nt;
    if (isNaN(l))
      throw new Error("Invalid value for " + a + ": " + this[a]);
    return l;
  };
  for (let a = 0; a < n.length; a++) {
    const l = n[a], h = of[l], u = Object.entries(h);
    if (u.some(
      ([f]) => typeof this[f] < "u"
    )) {
      t = h;
      for (let f = 0; f < u.length; f++) {
        const [g, d] = u[f], m = r(g);
        if (typeof m > "u")
          throw new Error("Missing parameter: " + g + ".");
        this[d] = m;
      }
      break;
    }
  }
  if (!t)
    throw new Error("No valid parameters provided for ob_tran projection.");
  const { lamp: s, phip: o } = B7(this, t);
  this.lamp = s, Math.abs(o) > J ? (this.cphip = Math.cos(o), this.sphip = Math.sin(o), this.projectionType = eE.OBLIQUE) : this.projectionType = eE.TRANSVERSE;
}
function U7(i) {
  return this.projectionType.forward(this, i);
}
function z7(i) {
  return this.projectionType.inverse(this, i);
}
function B7(i, e) {
  let t, n;
  if (e === of.ROTATE) {
    let r = i.oLongC, s = i.oLatC, o = i.oAlpha;
    if (Math.abs(Math.abs(s) - Y) <= J)
      throw new Error("Invalid value for o_lat_c: " + i.o_lat_c + " should be < 90°");
    n = r + Math.atan2(-1 * Math.cos(o), -1 * Math.sin(o) * Math.sin(s)), t = Math.asin(Math.cos(s) * Math.sin(o));
  } else if (e === of.NEW_POLE)
    n = i.oLongP, t = i.oLatP;
  else {
    let r = i.oLong1, s = i.oLat1, o = i.oLong2, a = i.oLat2, l = Math.abs(s);
    if (Math.abs(s) > Y - J)
      throw new Error("Invalid value for o_lat_1: " + i.o_lat_1 + " should be < 90°");
    if (Math.abs(a) > Y - J)
      throw new Error("Invalid value for o_lat_2: " + i.o_lat_2 + " should be < 90°");
    if (Math.abs(s - a) < J)
      throw new Error("Invalid value for o_lat_1 and o_lat_2: o_lat_1 should be different from o_lat_2");
    if (l < J)
      throw new Error("Invalid value for o_lat_1: o_lat_1 should be different from zero");
    n = Math.atan2(
      Math.cos(s) * Math.sin(a) * Math.cos(r) - Math.sin(s) * Math.cos(a) * Math.cos(o),
      Math.sin(s) * Math.cos(a) * Math.sin(o) - Math.cos(s) * Math.sin(a) * Math.sin(r)
    ), t = Math.atan(-1 * Math.cos(n - r) / Math.tan(s));
  }
  return { lamp: n, phip: t };
}
function $7(i, e) {
  let { x: t, y: n } = e;
  t += i.long0;
  const r = Math.cos(t), s = Math.sin(n), o = Math.cos(n);
  e.x = Q(
    Math.atan2(
      o * Math.sin(t),
      i.sphip * o * r + i.cphip * s
    ) + i.lamp
  ), e.y = Math.asin(
    i.sphip * s - i.cphip * o * r
  );
  const a = i.obliqueProjection.forward(e);
  return i.isIdentity && (a.x *= $i, a.y *= $i), a;
}
function j7(i, e) {
  let { x: t, y: n } = e;
  t += i.long0;
  const r = Math.cos(n), s = Math.cos(t);
  e.x = Q(
    Math.atan2(
      r * Math.sin(t),
      Math.sin(n)
    ) + i.lamp
  ), e.y = Math.asin(-1 * r * s);
  const o = i.obliqueProjection.forward(e);
  return i.isIdentity && (o.x *= $i, o.y *= $i), o;
}
function X7(i, e) {
  i.isIdentity && (e.x *= Nt, e.y *= Nt);
  const t = i.obliqueProjection.inverse(e);
  let { x: n, y: r } = t;
  if (n < Number.MAX_VALUE) {
    n -= i.lamp;
    const s = Math.cos(n), o = Math.sin(r), a = Math.cos(r);
    e.x = Math.atan2(
      a * Math.sin(n),
      i.sphip * a * s - i.cphip * o
    ), e.y = Math.asin(
      i.sphip * o + i.cphip * a * s
    );
  }
  return e.x = Q(e.x + i.long0), e;
}
function V7(i, e) {
  i.isIdentity && (e.x *= Nt, e.y *= Nt);
  const t = i.obliqueProjection.inverse(e);
  let { x: n, y: r } = t;
  if (n < Number.MAX_VALUE) {
    const s = Math.cos(r);
    n -= i.lamp, e.x = Math.atan2(
      s * Math.sin(n),
      -1 * Math.sin(r)
    ), e.y = Math.asin(
      s * Math.cos(n)
    );
  }
  return e.x = Q(e.x + i.long0), e;
}
var W7 = ["General Oblique Transformation", "General_Oblique_Transformation", "ob_tran"];
const Y7 = {
  init: k7,
  forward: U7,
  inverse: z7,
  names: W7
};
function q7(i) {
  i.Proj.projections.add(ec), i.Proj.projections.add(tc), i.Proj.projections.add(DU), i.Proj.projections.add(VU), i.Proj.projections.add(HU), i.Proj.projections.add(tz), i.Proj.projections.add(az), i.Proj.projections.add(fz), i.Proj.projections.add(_z), i.Proj.projections.add(wz), i.Proj.projections.add(Nz), i.Proj.projections.add(Bz), i.Proj.projections.add(Wz), i.Proj.projections.add(Jz), i.Proj.projections.add(nB), i.Proj.projections.add(lB), i.Proj.projections.add(dB), i.Proj.projections.add(yB), i.Proj.projections.add(SB), i.Proj.projections.add(CB), i.Proj.projections.add(OB), i.Proj.projections.add(UB), i.Proj.projections.add(WB), i.Proj.projections.add(KB), i.Proj.projections.add(i7), i.Proj.projections.add(u7), i.Proj.projections.add(p7), i.Proj.projections.add(E7), i.Proj.projections.add(T7), i.Proj.projections.add(A7), i.Proj.projections.add(G7), i.Proj.projections.add(Y7);
}
const fT = Object.assign(Qk, {
  defaultDatum: "WGS84",
  Proj: Rn,
  WGS84: new Rn("WGS84"),
  Point: Oa,
  toPoint: eT,
  defs: ci,
  nadgrid: Nk,
  transform: tf,
  mgrs: eU,
  version: "__VERSION__"
});
q7(fT);
Vb(fT);
window.eoxMapAdvancedOlLayers = {
  Graticule: FF,
  Heatmap: NO,
  Layer: Yr,
  VectorImage: kO,
  WebGLPoints: zO,
  WebGLTile: Nc,
  WebGLVector: BO,
  STAC: U0,
  MapboxStyle: X6
};
function Z7(i) {
  const e = i[0], t = new Array(e);
  let n = 1 << e - 1, r, s;
  for (r = 0; r < e; ++r)
    s = 48, i[1] & n && (s += 1), i[2] & n && (s += 2), t[r] = String.fromCharCode(s), n >>= 1;
  return t.join("");
}
const H7 = '<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html" target="_blank">Terms of Use</a>';
class K7 extends Ln {
  /**
   * @param {Options} options Bing Maps options.
   */
  constructor(e) {
    const t = e.hidpi !== void 0 ? e.hidpi : !1;
    super({
      cacheSize: e.cacheSize,
      crossOrigin: "anonymous",
      interpolate: e.interpolate,
      projection: ee("EPSG:3857"),
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      state: "loading",
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: t ? 2 : 1,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.hidpi_ = t, this.culture_ = e.culture !== void 0 ? e.culture : "en-us", this.maxZoom_ = e.maxZoom !== void 0 ? e.maxZoom : -1, this.apiKey_ = e.key, this.imagerySet_ = e.imagerySet, this.placeholderTiles_ = e.placeholderTiles;
    const n = (e.url || "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/") + this.imagerySet_ + "?uriScheme=https&include=ImageryProviders&key=" + this.apiKey_ + "&c=" + this.culture_;
    fetch(n).then((r) => r.json()).then((r) => this.handleImageryMetadataResponse(r));
  }
  /**
   * Get the api key used for this source.
   *
   * @return {string} The api key.
   * @api
   */
  getApiKey() {
    return this.apiKey_;
  }
  /**
   * Get the imagery set associated with this source.
   *
   * @return {string} The imagery set.
   * @api
   */
  getImagerySet() {
    return this.imagerySet_;
  }
  /**
   * @param {BingMapsImageryMetadataResponse} response Response.
   */
  handleImageryMetadataResponse(e) {
    if (e.statusCode != 200 || e.statusDescription != "OK" || e.authenticationResultCode != "ValidCredentials" || e.resourceSets.length != 1 || e.resourceSets[0].resources.length != 1) {
      this.setState("error");
      return;
    }
    const t = e.resourceSets[0].resources[0], n = this.maxZoom_ == -1 ? t.zoomMax : this.maxZoom_, r = this.getProjection(), s = Hn(r), o = this.hidpi_ ? 2 : 1, a = t.imageWidth == t.imageHeight ? t.imageWidth / o : [t.imageWidth / o, t.imageHeight / o], l = xr({
      extent: s,
      minZoom: t.zoomMin,
      maxZoom: n,
      tileSize: a
    });
    this.tileGrid = l;
    const h = this.culture_, u = this.hidpi_, c = this.placeholderTiles_;
    if (this.tileUrlFunction = Aa(
      t.imageUrlSubdomains.map(function(f) {
        const g = [0, 0, 0], d = t.imageUrl.replace("{subdomain}", f).replace("{culture}", h);
        return (
          /**
           * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
           * @param {number} pixelRatio Pixel ratio.
           * @param {import("../proj/Projection.js").default} projection Projection.
           * @return {string|undefined} Tile URL.
           */
          (function(m, x, v) {
            if (!m)
              return;
            go(
              m[0],
              m[1],
              m[2],
              g
            );
            const p = new URL(
              d.replace("{quadkey}", Z7(g))
            ), y = p.searchParams;
            return u && (y.set("dpi", "d1"), y.set("device", "mobile")), c === !0 ? y.delete("n") : c === !1 && y.set("n", "z"), p.toString();
          })
        );
      })
    ), t.imageryProviders) {
      const f = xo(
        ee("EPSG:4326"),
        this.getProjection()
      );
      this.setAttributions((g) => {
        const d = [], m = g.viewState, x = this.getTileGrid(), v = x.getZForResolution(
          m.resolution,
          this.zDirection
        ), y = x.getTileCoordForCoordAndZ(
          m.center,
          v
        )[0];
        return t.imageryProviders.map(function(E) {
          let b = !1;
          const T = E.coverageAreas;
          for (let R = 0, M = T.length; R < M; ++R) {
            const C = T[R];
            if (y >= C.zoomMin && y <= C.zoomMax) {
              const I = C.bbox, O = [I[1], I[0], I[3], I[2]], z = so(O, f);
              if (ft(z, g.extent)) {
                b = !0;
                break;
              }
            }
          }
          b && d.push(E.attribution);
        }), d.push(H7), d;
      });
    }
    this.setState("ready");
  }
}
class J7 extends kc {
  /**
   * @param {Options} options CartoDB options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      maxZoom: e.maxZoom !== void 0 ? e.maxZoom : 18,
      minZoom: e.minZoom,
      projection: e.projection,
      transition: e.transition,
      wrapX: e.wrapX,
      zDirection: e.zDirection
    }), this.account_ = e.account, this.mapId_ = e.map || "", this.config_ = e.config || {}, this.templateCache_ = {}, this.initializeMap_();
  }
  /**
   * Returns the current config.
   * @return {!Object} The current configuration.
   * @api
   */
  getConfig() {
    return this.config_;
  }
  /**
   * Updates the carto db config.
   * @param {Object} config a key-value lookup. Values will replace current values
   *     in the config.
   * @api
   */
  updateConfig(e) {
    Object.assign(this.config_, e), this.initializeMap_();
  }
  /**
   * Sets the CartoDB config
   * @param {Object} config In the case of anonymous maps, a CartoDB configuration
   *     object.
   * If using named maps, a key-value lookup with the template parameters.
   * @api
   */
  setConfig(e) {
    this.config_ = e || {}, this.initializeMap_();
  }
  /**
   * Issue a request to initialize the CartoDB map.
   * @private
   */
  initializeMap_() {
    const e = JSON.stringify(this.config_);
    if (this.templateCache_[e]) {
      this.applyTemplate_(this.templateCache_[e]);
      return;
    }
    let t = "https://" + this.account_ + ".carto.com/api/v1/map";
    this.mapId_ && (t += "/named/" + this.mapId_);
    const n = new XMLHttpRequest();
    n.addEventListener(
      "load",
      this.handleInitResponse_.bind(this, e)
    ), n.addEventListener("error", this.handleInitError_.bind(this)), n.open("POST", t), n.setRequestHeader("Content-type", "application/json"), n.send(JSON.stringify(this.config_));
  }
  /**
   * Handle map initialization response.
   * @param {string} paramHash a hash representing the parameter set that was used
   *     for the request
   * @param {Event} event Event.
   * @private
   */
  handleInitResponse_(e, t) {
    const n = (
      /** @type {XMLHttpRequest} */
      t.target
    );
    if (!n.status || n.status >= 200 && n.status < 300) {
      let r;
      try {
        r = /** @type {CartoDBLayerInfo} */
        JSON.parse(n.responseText);
      } catch {
        this.setState("error");
        return;
      }
      this.applyTemplate_(r), this.templateCache_[e] = r, this.setState("ready");
    } else
      this.setState("error");
  }
  /**
   * @private
   * @param {Event} event Event.
   */
  handleInitError_(e) {
    this.setState("error");
  }
  /**
   * Apply the new tile urls returned by carto db
   * @param {CartoDBLayerInfo} data Result of carto db call.
   * @private
   */
  applyTemplate_(e) {
    const t = "https://" + e.cdn_url.https + "/" + this.account_ + "/api/v1/map/" + e.layergroupid + "/{z}/{x}/{y}.png";
    this.setUrl(t);
  }
}
const Q7 = 22;
class e9 extends Ln {
  /**
   * @param {Options} options Google Maps options.
   */
  constructor(e) {
    const t = !!e.highDpi;
    super({
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      crossOrigin: "anonymous",
      interpolate: e.interpolate,
      projection: "EPSG:3857",
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      state: "loading",
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: t ? 2 : 1,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.apiKey_ = e.key, this.error_ = null;
    const n = {
      mapType: e.mapType || "roadmap",
      language: e.language || "en-US",
      region: e.region || "US"
    };
    e.imageFormat && (n.imageFormat = e.imageFormat), e.scale && (n.scale = e.scale), t && (n.highDpi = !0), e.layerTypes && (n.layerTypes = e.layerTypes), e.styles && (n.styles = e.styles), e.overlay === !0 && (n.overlay = !0), e.apiOptions && (n.apiOptions = e.apiOptions), this.sessionTokenRequest_ = n, this.sessionTokenValue_, this.sessionRefreshId_, this.previousViewportAttribution_, this.previousViewportExtent_;
    const r = e.url || "https://tile.googleapis.com/";
    this.createSessionUrl_ = r + "v1/createSession", this.tileUrl_ = r + "v1/2dtiles", this.attributionUrl_ = r + "tile/v1/viewport", this.createSession_();
  }
  /**
   * @return {Error|null} A source loading error. When the source state is `error`, use this function
   * to get more information about the error. To debug a faulty configuration, you may want to use
   * a listener like
   * ```js
   * source.on('change', () => {
   *   if (source.getState() === 'error') {
   *     console.error(source.getError());
   *   }
   * });
   * ```
   */
  getError() {
    return this.error_;
  }
  /**
   * Exposed here so it can be overridden in the tests.
   * @param {string} url The URL.
   * @param {RequestInit} config The config.
   * @return {Promise<Response>} A promise that resolves with the response.
   */
  fetchSessionToken(e, t) {
    return fetch(e, t);
  }
  /**
   * Get or renew a session token for use with tile requests.
   * @private
   */
  async createSession_() {
    const e = this.createSessionUrl_ + "?key=" + this.apiKey_, t = {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(this.sessionTokenRequest_)
    }, n = await this.fetchSessionToken(e, t);
    if (!n.ok) {
      try {
        const f = await n.json();
        this.error_ = new Error(f.error.message);
      } catch {
        this.error_ = new Error("Error fetching session token");
      }
      this.setState("error");
      return;
    }
    const r = await n.json(), s = this.getTilePixelRatio(1), o = [
      r.tileWidth / s,
      r.tileHeight / s
    ];
    this.tileGrid = xr({
      extent: Hn(this.getProjection()),
      maxZoom: Q7,
      tileSize: o
    });
    const a = r.session;
    this.sessionTokenValue_ = a;
    const l = this.apiKey_, h = this.tileUrl_;
    this.tileUrlFunction = function(f, g, d) {
      const m = f[0], x = f[1], v = f[2];
      return `${h}/${m}/${x}/${v}?session=${a}&key=${l}`;
    };
    const u = parseInt(r.expiry, 10) * 1e3, c = Math.max(u - Date.now() - 60 * 1e3, 1);
    this.sessionRefreshId_ = setTimeout(() => this.createSession_(), c), this.setAttributions(this.fetchAttributions_.bind(this)), this.setState("ready");
  }
  /**
   * @param {import('../Map.js').FrameState} frameState The frame state.
   * @return {Promise<string>} The attributions.
   * @private
   */
  async fetchAttributions_(e) {
    if (e.viewHints[Xe.ANIMATING] || e.viewHints[Xe.INTERACTING] || e.animate)
      return this.previousViewportAttribution_;
    const [t, n] = $_(
      vh(e.extent),
      e.viewState.projection
    ), [r, s] = $_(
      wh(e.extent),
      e.viewState.projection
    ), l = `zoom=${this.getTileGrid().getZForResolution(
      e.viewState.resolution,
      this.zDirection
    )}&north=${s}&south=${n}&east=${r}&west=${t}`;
    if (this.previousViewportExtent_ == l)
      return this.previousViewportAttribution_;
    this.previousViewportExtent_ = l;
    const h = this.sessionTokenValue_, u = this.apiKey_, f = `${this.attributionUrl_}?session=${h}&key=${u}&${l}`;
    return this.previousViewportAttribution_ = await fetch(f).then((g) => g.json()).then((g) => g.copyright), this.previousViewportAttribution_;
  }
  /**
   * @override
   */
  disposeInternal() {
    clearTimeout(this.sessionRefreshId_), super.disposeInternal();
  }
}
let dT = class extends Gh {
  /**
   * @param {import("../size.js").Size} tileSize Full tile size.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, n, r, s, o, a) {
    super(t, n, r, s, o, a), this.zoomifyImage_ = null, this.tileSize_ = e;
  }
  /**
   * Get the image element for this tile.
   * @return {HTMLCanvasElement|OffscreenCanvas|HTMLImageElement|HTMLVideoElement} Image.
   * @override
   */
  getImage() {
    if (this.zoomifyImage_)
      return this.zoomifyImage_;
    const e = super.getImage();
    if (this.state == X.LOADED) {
      const t = this.tileSize_;
      if (e.width == t[0] && e.height == t[1])
        return this.zoomifyImage_ = e, e;
      const n = ot(t[0], t[1]);
      return n.drawImage(e, 0, 0), this.zoomifyImage_ = n.canvas, n.canvas;
    }
    return e;
  }
};
class t9 extends Ln {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    const t = e.size, n = e.tierSizeCalculation !== void 0 ? e.tierSizeCalculation : "default", r = e.tilePixelRatio || 1, s = t[0], o = t[1], a = [], l = e.tileSize || Ta;
    let h = l * r;
    switch (n) {
      case "default":
        for (; s > h || o > h; )
          a.push([
            Math.ceil(s / h),
            Math.ceil(o / h)
          ]), h += h;
        break;
      case "truncated":
        let T = s, R = o;
        for (; T > h || R > h; )
          a.push([
            Math.ceil(T / h),
            Math.ceil(R / h)
          ]), T >>= 1, R >>= 1;
        break;
      default:
        throw new Error("Unknown `tierSizeCalculation` configured");
    }
    a.push([1, 1]), a.reverse();
    const u = [r], c = [0];
    for (let T = 1, R = a.length; T < R; T++)
      u.push(r << T), c.push(
        a[T - 1][0] * a[T - 1][1] + c[T - 1]
      );
    u.reverse();
    const f = new qr({
      tileSize: l,
      extent: e.extent || [0, -o, s, 0],
      resolutions: u
    });
    let g = e.url;
    g && !g.includes("{TileGroup}") && !g.includes("{tileIndex}") && (g += "{TileGroup}/{z}-{x}-{y}.jpg");
    const d = Yf(g);
    let m = l * r;
    function x(T) {
      return (
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile Coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        (function(R, M, C) {
          if (!R)
            return;
          const I = R[0], O = R[1], z = R[2], _ = O + z * a[I][0], w = (_ + c[I]) / m | 0, S = {
            z: I,
            x: O,
            y: z,
            tileIndex: _,
            TileGroup: "TileGroup" + w
          };
          return T.replace(/\{(\w+?)\}/g, function(P, A) {
            return S[A];
          });
        })
      );
    }
    const v = Aa(
      d.map(x)
    ), p = dT.bind(
      null,
      dt(l * r)
    );
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: e.projection,
      tilePixelRatio: r,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileClass: p,
      tileGrid: f,
      tileUrlFunction: v,
      transition: e.transition
    }), this.zDirection = e.zDirection;
    const y = f.getTileCoordForCoordAndResolution(
      Vt(f.getExtent()),
      u[u.length - 1]
    ), E = v(y, 1, null), b = new Image();
    b.addEventListener("error", () => {
      m = l, this.changed();
    }), b.src = E;
  }
}
function dl(i) {
  return i.toLocaleString("en", { maximumFractionDigits: 10 });
}
class i9 extends Ln {
  /**
   * @param {Options} [options] Tile source options. Use {@link import("../format/IIIFInfo.js").IIIFInfo}
   * to parse Image API service information responses into constructor options.
   * @api
   */
  constructor(e) {
    const t = e || {};
    let n = t.url || "";
    n = n + (n.lastIndexOf("/") === n.length - 1 || n === "" ? "" : "/");
    const r = t.version || $t.VERSION2, s = t.sizes || [], o = t.size;
    Te(
      o != null && Array.isArray(o) && o.length == 2 && !isNaN(o[0]) && o[0] > 0 && !isNaN(o[1]) && o[1] > 0,
      "Missing or invalid `size`"
    );
    const a = o[0], l = o[1], h = t.tileSize, u = t.tilePixelRatio || 1, c = t.format || "jpg", f = t.quality || (t.version == $t.VERSION1 ? "native" : "default");
    let g = t.resolutions || [];
    const d = t.supports || [], m = t.extent || [0, -l, a, 0], x = s != null && Array.isArray(s) && s.length > 0, v = h !== void 0 && (typeof h == "number" && Number.isInteger(h) && h > 0 || Array.isArray(h) && h.length > 0), p = d != null && Array.isArray(d) && (d.includes("regionByPx") || d.includes("regionByPct")) && (d.includes("sizeByWh") || d.includes("sizeByH") || d.includes("sizeByW") || d.includes("sizeByPct"));
    let y, E, b;
    if (g.sort(function(C, I) {
      return I - C;
    }), v || p)
      if (h != null && (typeof h == "number" && Number.isInteger(h) && h > 0 ? (y = h, E = h) : Array.isArray(h) && h.length > 0 && ((h.length == 1 || h[1] == null && Number.isInteger(h[0])) && (y = h[0], E = h[0]), h.length == 2 && (Number.isInteger(h[0]) && Number.isInteger(h[1]) ? (y = h[0], E = h[1]) : h[0] == null && Number.isInteger(h[1]) && (y = h[1], E = h[1])))), (y === void 0 || E === void 0) && (y = Ta, E = Ta), g.length == 0) {
        b = Math.max(
          Math.ceil(Math.log(a / y) / Math.LN2),
          Math.ceil(Math.log(l / E) / Math.LN2)
        );
        for (let C = b; C >= 0; C--)
          g.push(Math.pow(2, C));
      } else {
        const C = Math.max(...g);
        b = Math.round(Math.log(C) / Math.LN2);
      }
    else if (y = a, E = l, g = [], x) {
      s.sort(function(I, O) {
        return I[0] - O[0];
      }), b = -1;
      const C = [];
      for (let I = 0; I < s.length; I++) {
        const O = a / s[I][0];
        if (g.length > 0 && g[g.length - 1] == O) {
          C.push(I);
          continue;
        }
        g.push(O), b++;
      }
      if (C.length > 0)
        for (let I = 0; I < C.length; I++)
          s.splice(C[I] - I, 1);
    } else
      g.push(1), s.push([a, l]), b = 0;
    const T = new qr({
      tileSize: [y, E],
      extent: m,
      origin: Mn(m),
      resolutions: g
    }), R = function(C, I, O) {
      let z, _;
      const w = C[0];
      if (w > b)
        return;
      const S = C[1], P = C[2], A = g[w];
      if (!(S === void 0 || P === void 0 || A === void 0 || S < 0 || Math.ceil(a / A / y) <= S || P < 0 || Math.ceil(l / A / E) <= P)) {
        if (p || v) {
          const D = S * y * A, k = P * E * A;
          let U = y * A, G = E * A, $ = y, H = E;
          if (D + U > a && (U = a - D), k + G > l && (G = l - k), D + y * A > a && ($ = Math.floor((a - D + A - 1) / A)), k + E * A > l && (H = Math.floor((l - k + A - 1) / A)), D == 0 && U == a && k == 0 && G == l)
            z = "full";
          else if (!p || d.includes("regionByPx"))
            z = D + "," + k + "," + U + "," + G;
          else if (d.includes("regionByPct")) {
            const ne = dl(D / a * 100), te = dl(k / l * 100), re = dl(U / a * 100), ae = dl(G / l * 100);
            z = "pct:" + ne + "," + te + "," + re + "," + ae;
          }
          r == $t.VERSION3 && (!p || d.includes("sizeByWh")) ? _ = $ + "," + H : !p || d.includes("sizeByW") ? _ = $ + "," : d.includes("sizeByH") ? _ = "," + H : d.includes("sizeByWh") ? _ = $ + "," + H : d.includes("sizeByPct") && (_ = "pct:" + dl(100 / A));
        } else if (z = "full", x) {
          const D = s[w][0], k = s[w][1];
          r == $t.VERSION3 ? D == a && k == l ? _ = "max" : _ = D + "," + k : D == a ? _ = "full" : _ = D + ",";
        } else
          _ = r == $t.VERSION3 ? "max" : "full";
        return n + z + "/" + _ + "/0/" + f + "." + c;
      }
    }, M = dT.bind(
      null,
      dt(h || 256).map(function(C) {
        return C * u;
      })
    );
    super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      cacheSize: t.cacheSize,
      crossOrigin: t.crossOrigin,
      interpolate: t.interpolate,
      projection: t.projection,
      reprojectionErrorThreshold: t.reprojectionErrorThreshold,
      state: t.state,
      tileClass: M,
      tileGrid: T,
      tilePixelRatio: t.tilePixelRatio,
      tileUrlFunction: R,
      transition: t.transition
    }), this.zDirection = t.zDirection;
  }
}
function gT(i, e, t, n, r, s) {
  const o = r.getCode().split(/:(?=\d+$)/).pop(), a = t / n, l = [
    rc(_e(e) / a, ps),
    rc(it(e) / a, ps)
  ];
  s.SIZE = l[0] + "," + l[1], s.BBOX = e.join(","), s.BBOXSR = o, s.IMAGESR = o, s.DPI = Math.round(
    s.DPI ? s.DPI * n : 90 * n
  );
  const h = i.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage");
  return Ps(h, s);
}
function n9(i) {
  const e = i.load ? i.load : ja, t = ee(i.projection || "EPSG:3857"), n = i.ratio ?? 1.5, r = i.crossOrigin ?? null;
  return function(s, o, a) {
    a = i.hidpi ? a : 1;
    const l = {
      F: "image",
      FORMAT: "PNG32",
      TRANSPARENT: !0
    };
    Object.assign(l, i.params), s = C0(s, o, a, n);
    const h = gT(
      i.url,
      s,
      o,
      a,
      t,
      l
    ), u = new Image();
    return u.crossOrigin = r, e(u, h).then((c) => {
      const f = _e(s) / c.width * a;
      return { image: c, extent: s, resolution: f, pixelRatio: a };
    });
  };
}
class r9 extends To {
  /**
   * @param {Options} [options] Image ArcGIS Rest Options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: e.projection,
      resolutions: e.resolutions
    }), this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.url_ = e.url, this.imageLoadFunction_ = e.imageLoadFunction !== void 0 ? e.imageLoadFunction : M0, this.params_ = Object.assign({}, e.params), this.imageSize_ = [0, 0], this.renderedRevision_ = 0, this.ratio_ = e.ratio !== void 0 ? e.ratio : 1.5, this.loaderProjection_ = null;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   * @override
   */
  getImageInternal(e, t, n, r) {
    return this.url_ === void 0 ? null : ((!this.loader || this.loaderProjection_ !== r) && (this.loaderProjection_ = r, this.loader = n9({
      crossOrigin: this.crossOrigin_,
      params: this.params_,
      projection: r,
      hidpi: this.hidpi_,
      url: this.url_,
      ratio: this.ratio_,
      load: (s, o) => (this.image.setImage(s), this.imageLoadFunction_(this.image, o), ja(s))
    })), super.getImageInternal(e, t, n, r));
  }
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  /**
   * Return the URL used for this ArcGIS source.
   * @return {string|undefined} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  setImageLoadFunction(e) {
    this.imageLoadFunction_ = e, this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  setUrl(e) {
    e != this.url_ && (this.url_ = e, this.loader = null, this.changed());
  }
  /**
   * Set the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  setParams(e) {
    this.params_ = Object.assign({}, e), this.changed();
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.changed();
  }
  /**
   * @override
   */
  changed() {
    this.image = null, super.changed();
  }
}
class s9 extends To {
  /**
   * @param {Options} [options] ImageCanvas options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: e.projection,
      resolutions: e.resolutions,
      state: e.state
    }), this.canvasFunction_ = e.canvasFunction, this.canvas_ = null, this.renderedRevision_ = 0, this.ratio_ = e.ratio !== void 0 ? e.ratio : 1.5;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageCanvas.js").default} Single image.
   * @override
   */
  getImageInternal(e, t, n, r) {
    t = this.findNearestResolution(t);
    let s = this.canvas_;
    if (s && this.renderedRevision_ == this.getRevision() && s.getResolution() == t && s.getPixelRatio() == n && Bi(s.getExtent(), e))
      return s;
    e = e.slice(), xE(e, this.ratio_);
    const o = _e(e) / t, a = it(e) / t, l = [o * n, a * n], h = this.canvasFunction_.call(
      this,
      e,
      t,
      n,
      l,
      r
    );
    return h && (s = new h0(e, t, n, h)), this.canvas_ = s, this.renderedRevision_ = this.getRevision(), s;
  }
}
function o9(i, e, t, n) {
  const r = _e(i), s = it(i), o = e[0], a = e[1], l = 0.0254 / n;
  return a * r > o * s ? r * t / (o * l) : s * t / (a * l);
}
function a9(i, e, t, n, r, s, o) {
  const a = o9(t, n, s, o), l = Vt(t), h = {
    OPERATION: r ? "GETDYNAMICMAPOVERLAYIMAGE" : "GETMAPIMAGE",
    VERSION: "2.0.0",
    LOCALE: "en",
    CLIENTAGENT: "ol/source/ImageMapGuide source",
    CLIP: "1",
    SETDISPLAYDPI: o,
    SETDISPLAYWIDTH: Math.round(n[0]),
    SETDISPLAYHEIGHT: Math.round(n[1]),
    SETVIEWSCALE: a,
    SETVIEWCENTERX: l[0],
    SETVIEWCENTERY: l[1]
  };
  return Object.assign(h, e), Ps(i, h);
}
function l9(i) {
  const e = i.load || ja, t = i.useOverlay ?? !1, n = i.metersPerUnit || 1, r = i.displayDpi || 96, s = i.ratio ?? 1, o = i.crossOrigin ?? null;
  return function(a, l, h) {
    const u = new Image();
    u.crossOrigin = o, a = C0(a, l, h, s);
    const c = _e(a) / l, f = it(a) / l, g = [c * h, f * h], d = a9(
      i.url,
      i.params,
      a,
      g,
      t,
      n,
      r
    );
    return e(u, d).then((m) => ({ image: m, extent: a, pixelRatio: h }));
  };
}
class h9 extends To {
  /**
   * @param {Options} options ImageMapGuide options.
   */
  constructor(e) {
    super({
      interpolate: e.interpolate,
      projection: e.projection,
      resolutions: e.resolutions
    }), this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.displayDpi_ = e.displayDpi !== void 0 ? e.displayDpi : 96, this.params_ = Object.assign({}, e.params), this.url_ = e.url, this.imageLoadFunction_ = e.imageLoadFunction !== void 0 ? e.imageLoadFunction : M0, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.metersPerUnit_ = e.metersPerUnit !== void 0 ? e.metersPerUnit : 1, this.ratio_ = e.ratio !== void 0 ? e.ratio : 1, this.useOverlay_ = e.useOverlay !== void 0 ? e.useOverlay : !1, this.renderedRevision_ = 0, this.loaderProjection_ = null;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   * @override
   */
  getImageInternal(e, t, n, r) {
    return this.url_ === void 0 ? null : ((!this.loader || this.loaderProjection_ !== r) && (this.loaderProjection_ = r, this.loader = l9({
      crossOrigin: this.crossOrigin_,
      params: this.params_,
      hidpi: this.hidpi_,
      metersPerUnit: this.metersPerUnit_,
      url: this.url_,
      useOverlay: this.useOverlay_,
      ratio: this.ratio_,
      load: (s, o) => (this.image.setImage(s), this.imageLoadFunction_(this.image, o), ja(s))
    })), super.getImageInternal(e, t, n, r));
  }
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  /**
   * Set the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  setParams(e) {
    this.params_ = Object.assign({}, e), this.changed();
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.changed();
  }
  /**
   * Set the image load function of the MapGuide source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  setImageLoadFunction(e) {
    this.imageLoadFunction_ = e, this.changed();
  }
  /**
   * @override
   */
  changed() {
    this.image = null, super.changed();
  }
}
const u9 = new Error("Image failed to load");
function pT(i, e, t, n, r) {
  return new Promise((s, o) => {
    const a = new Image();
    a.crossOrigin = r.crossOrigin ?? null, a.addEventListener("load", () => s(a)), a.addEventListener("error", () => o(u9)), a.src = I0(i, e, t, n, r.maxY);
  });
}
function tE(i) {
  return function(e, t, n, r) {
    const s = qN(i, e, t, n);
    return pT(s, e, t, n, r);
  };
}
function c9(i) {
  return function(e, t, n, r) {
    const s = i(e, t, n, r);
    return pT(s, e, t, n, r);
  };
}
function iE(i) {
  let e;
  if (Array.isArray(i))
    e = tE(i);
  else if (typeof i == "string") {
    const t = Yf(i);
    e = tE(t);
  } else if (typeof i == "function")
    e = c9(i);
  else
    throw new Error(
      "The url option must be a single template, an array of templates, or a function for getting a URL"
    );
  return e;
}
let nE = 0;
function rE(i) {
  return Array.isArray(i) ? i.join(`
`) : typeof i == "string" ? i : (++nE, "url-function-key-" + nE);
}
class mT extends Bh {
  /**
   * @param {Options} [options] DataTile source options.
   */
  constructor(e) {
    e = e || {};
    let t = e.loader, n;
    e.url && (t = iE(e.url), n = rE(e.url));
    const r = t ? e.state : "loading", s = e.wrapX === void 0 ? !0 : e.wrapX;
    super({
      loader: t,
      key: n,
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      maxZoom: e.maxZoom,
      minZoom: e.minZoom,
      tileSize: e.tileSize,
      gutter: e.gutter,
      maxResolution: e.maxResolution,
      projection: e.projection,
      tileGrid: e.tileGrid,
      state: r,
      wrapX: s,
      transition: e.transition,
      interpolate: e.interpolate !== !1,
      crossOrigin: e.crossOrigin,
      zDirection: e.zDirection
    });
  }
  /**
   * @param {UrlLike} url The new URL.
   * @api
   */
  setUrl(e) {
    const t = iE(e);
    this.setLoader(t), this.setKey(rE(e)), this.getState() !== "ready" && this.setState("ready");
  }
}
const f9 = {
  "image/png": !0,
  "image/jpeg": !0,
  "image/gif": !0,
  "image/webp": !0
}, d9 = {
  "application/vnd.mapbox-vector-tile": !0,
  "application/geo+json": !0
};
function _T(i, e) {
  if (!e.length)
    return i;
  const t = new URL(i, "file:/");
  if (t.pathname.split("/").includes("collections"))
    return Hl(
      'The "collections" query parameter cannot be added to collection endpoints'
    ), i;
  const n = e.map((o) => encodeURIComponent(o)).join(",");
  t.searchParams.append("collections", n);
  const r = i.split("?")[0], s = decodeURIComponent(t.searchParams.toString());
  return `${r}?${s}`;
}
function g9(i, e, t) {
  let n, r;
  for (let s = 0; s < i.length; ++s) {
    const o = i[s];
    if (o.rel === "item") {
      if (o.type === e) {
        n = o.href;
        break;
      }
      (f9[o.type] || !r && o.type.startsWith("image/")) && (r = o.href);
    }
  }
  if (!n)
    if (r)
      n = r;
    else
      throw new Error('Could not find "item" link');
  return t && (n = _T(n, t)), n;
}
function p9(i, e, t, n) {
  let r, s;
  const o = {};
  for (let a = 0; a < i.length; ++a) {
    const l = i[a];
    if (o[l.type] = l.href, l.rel === "item") {
      if (l.type === e) {
        r = l.href;
        break;
      }
      d9[l.type] && (s = l.href);
    }
  }
  if (!r && t)
    for (let a = 0; a < t.length; ++a) {
      const l = t[a];
      if (o[l]) {
        r = o[l];
        break;
      }
    }
  if (!r)
    if (s)
      r = s;
    else
      throw new Error('Could not find "item" link');
  return n && (r = _T(r, n)), r;
}
function sE(i, e, t, n) {
  let r = i.projection;
  if (!r && (typeof e.crs == "string" ? r = ee(e.crs) : "uri" in e.crs && (r = ee(e.crs.uri)), !r))
    throw new Error(`Unsupported CRS: ${JSON.stringify(e.crs)}`);
  const s = e.orderedAxes, a = !(s ? s.slice(0, 2).map((T) => T.replace(/E|X|Lon/i, "e").replace(/N|Y|Lat/i, "n")).join("") : r.getAxisOrientation()).startsWith("en"), l = e.tileMatrices, h = {};
  for (let T = 0; T < l.length; ++T) {
    const R = l[T];
    h[R.id] = R;
  }
  const u = {}, c = [];
  if (n)
    for (let T = 0; T < n.length; ++T) {
      const R = n[T], M = R.tileMatrix;
      c.push(M), u[M] = R;
    }
  else
    for (let T = 0; T < l.length; ++T) {
      const R = l[T].id;
      c.push(R);
    }
  const f = c.length, g = new Array(f), d = new Array(f), m = new Array(f), x = new Array(f), v = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
  for (let T = 0; T < f; ++T) {
    const R = c[T], M = h[R], C = M.pointOfOrigin;
    a ? g[T] = [C[1], C[0]] : g[T] = C, d[T] = M.cellSize, m[T] = [M.matrixWidth, M.matrixHeight], x[T] = [M.tileWidth, M.tileHeight];
    const I = u[R];
    if (I) {
      const O = M.cellSize * M.tileWidth, z = g[T][0] + I.minTileCol * O, _ = g[T][0] + (I.maxTileCol + 1) * O, w = M.cellSize * M.tileHeight, S = M.cornerOfOrigin === "bottomLeft";
      let P, A;
      S ? (P = g[T][1] + I.minTileRow * w, A = g[T][1] + (I.maxTileRow + 1) * w) : (P = g[T][1] - (I.maxTileRow + 1) * w, A = g[T][1] - I.minTileRow * w), kt(v, [z, P, _, A], v);
    }
  }
  const p = new qr({
    origins: g,
    resolutions: d,
    sizes: m,
    tileSizes: x,
    extent: n ? v : void 0
  }), y = i.context, E = i.url;
  function b(T, R, M) {
    if (!T)
      return;
    const C = c[T[0]], I = h[C], O = I.cornerOfOrigin === "bottomLeft", z = {
      tileMatrix: C,
      tileCol: T[1],
      tileRow: O ? -T[2] - 1 : T[2]
    };
    if (n) {
      const w = u[I.id];
      if (z.tileCol < w.minTileCol || z.tileCol > w.maxTileCol || z.tileRow < w.minTileRow || z.tileRow > w.maxTileRow)
        return;
    }
    Object.assign(
      z,
      {
        z: z.tileMatrix,
        x: z.tileCol,
        y: z.tileRow
      },
      y
    );
    const _ = t.replace(/\{(\w+?)\}/g, function(w, S) {
      return z[S];
    });
    return Pb(E, _);
  }
  return {
    grid: p,
    projection: r,
    urlTemplate: t,
    urlFunction: b
  };
}
function m9(i, e) {
  const t = e.tileMatrixSetLimits;
  let n;
  if (e.dataType === "map")
    n = g9(
      e.links,
      i.mediaType,
      i.collections
    );
  else if (e.dataType === "vector")
    n = p9(
      e.links,
      i.mediaType,
      i.supportedMediaTypes,
      i.collections
    );
  else
    throw new Error('Expected tileset data type to be "map" or "vector"');
  if (e.tileMatrixSet)
    return sE(
      i,
      e.tileMatrixSet,
      n,
      t
    );
  const r = e.links.find(
    (a) => a.rel === "http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme"
  );
  if (!r)
    throw new Error(
      "Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet"
    );
  const s = r.href, o = Pb(i.url, s);
  return Rb(o).then(function(a) {
    return sE(
      i,
      a,
      n,
      t
    );
  });
}
function yT(i) {
  return Rb(i.url).then(function(e) {
    return m9(i, e);
  });
}
class _9 extends Ln {
  /**
   * @param {Options} options OGC map tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      state: "loading",
      tileLoadFunction: e.tileLoadFunction,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition
    });
    const t = {
      url: e.url,
      projection: this.getProjection(),
      mediaType: e.mediaType,
      context: e.context || null,
      collections: e.collections
    };
    yT(t).then(this.handleTileSetInfo_.bind(this)).catch(this.handleError_.bind(this));
  }
  /**
   * @param {import("./ogcTileUtil.js").TileSetInfo} tileSetInfo Tile set info.
   * @private
   */
  handleTileSetInfo_(e) {
    this.tileGrid = e.grid, this.projection = e.projection, this.setTileUrlFunction(e.urlFunction, e.urlTemplate), this.setState("ready");
  }
  /**
   * @private
   * @param {Error} error The error.
   */
  handleError_(e) {
    Hl(e), this.setState("error");
  }
}
class y9 extends Ja {
  /**
   * @param {Options<FeatureType>} options OGC vector tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      format: e.format,
      overlaps: e.overlaps,
      projection: e.projection,
      tileClass: e.tileClass,
      transition: e.transition,
      wrapX: e.wrapX,
      zDirection: e.zDirection,
      state: "loading"
    });
    const t = {
      url: e.url,
      projection: this.getProjection(),
      mediaType: e.mediaType,
      supportedMediaTypes: e.format.supportedMediaTypes,
      context: e.context || null,
      collections: e.collections
    };
    yT(t).then(this.handleTileSetInfo_.bind(this)).catch(this.handleError_.bind(this));
  }
  /**
   * @param {import("./ogcTileUtil.js").TileSetInfo} tileSetInfo Tile set info.
   * @private
   */
  handleTileSetInfo_(e) {
    this.tileGrid = e.grid, this.projection = e.projection, this.setTileUrlFunction(e.urlFunction, e.urlTemplate), this.setState("ready");
  }
  /**
   * @private
   * @param {Error} error The error.
   */
  handleError_(e) {
    Hl(e), this.setState("error");
  }
}
const x9 = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.', E9 = '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a>', v9 = '&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a>', w9 = '&copy; <a href="https://stamen.com/" target="_blank">Stamen Design</a>', b9 = {
  stamen_terrain: {
    extension: "png"
  },
  stamen_terrain_background: {
    extension: "png"
  },
  stamen_terrain_labels: {
    extension: "png"
  },
  stamen_terrain_lines: {
    extension: "png"
  },
  stamen_toner_background: {
    extension: "png"
  },
  stamen_toner: {
    extension: "png"
  },
  stamen_toner_labels: {
    extension: "png"
  },
  stamen_toner_lines: {
    extension: "png"
  },
  stamen_toner_lite: {
    extension: "png"
  },
  stamen_toner_dark: {
    extension: "png"
  },
  stamen_toner_blacklite: {
    extension: "png"
  },
  stamen_watercolor: {
    extension: "jpg"
  },
  alidade_smooth: {
    extension: "png"
  },
  alidade_smooth_dark: {
    extension: "png"
  },
  alidade_satellite: {
    extension: "png"
  },
  outdoors: {
    extension: "png"
  },
  osm_bright: {
    extension: "png"
  }
}, S9 = {
  stamen_terrain: {
    minZoom: 0,
    maxZoom: 18,
    retina: !0
  },
  stamen_toner: {
    minZoom: 0,
    maxZoom: 20,
    retina: !0
  },
  stamen_toner_dark: {
    minZoom: 0,
    maxZoom: 20,
    retina: !0
  },
  stamen_toner_blacklite: {
    minZoom: 0,
    maxZoom: 20,
    retina: !0
  },
  stamen_watercolor: {
    minZoom: 1,
    maxZoom: 18,
    retina: !1
  }
};
class T9 extends kc {
  /**
   * @param {Options} options StadiaMaps options.
   */
  constructor(e) {
    const t = e.layer.indexOf("-"), n = t == -1 ? e.layer : e.layer.slice(0, t), r = S9[n] || {
      minZoom: 0,
      maxZoom: 20,
      retina: !0
    }, s = b9[e.layer], o = e.apiKey ? "?api_key=" + e.apiKey : "", a = r.retina && e.retina ? "@2x" : "", l = e.url !== void 0 ? e.url : "https://tiles.stadiamaps.com/tiles/" + e.layer + "/{z}/{x}/{y}" + a + "." + s.extension + o, h = [E9, v9, x9];
    e.layer.startsWith("stamen_") && h.splice(1, 0, w9), super({
      attributions: h,
      cacheSize: e.cacheSize,
      crossOrigin: "anonymous",
      interpolate: e.interpolate,
      maxZoom: e.maxZoom !== void 0 ? e.maxZoom : r.maxZoom,
      minZoom: e.minZoom !== void 0 ? e.minZoom : r.minZoom,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileLoadFunction: e.tileLoadFunction,
      transition: e.transition,
      url: l,
      tilePixelRatio: a ? 2 : 1,
      wrapX: e.wrapX,
      zDirection: e.zDirection
    });
  }
}
class R9 extends Ln {
  /**
   * @param {Options} [options] Tile ArcGIS Rest options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.params_ = Object.assign({}, e.params), this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.tmpExtent_ = hi(), this.setKey(this.getKeyForParams_());
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let e = 0;
    const t = [];
    for (const n in this.params_)
      t[e++] = n + "-" + this.params_[n];
    return t.join("/");
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(e, t, n, r, s, o) {
    const a = this.urls;
    if (!a)
      return;
    let l;
    if (a.length == 1)
      l = a[0];
    else {
      const h = $n(e0(e), a.length);
      l = a[h];
    }
    return gT(
      l,
      n,
      (this.tileGrid || this.getTileGridForProjection(s)).getResolution(e[0]),
      r,
      s,
      o
    );
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   * @override
   */
  getTilePixelRatio(e) {
    return this.hidpi_ ? e : 1;
  }
  /**
   * Set the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  setParams(e) {
    this.params_ = Object.assign({}, e), this.setKey(this.getKeyForParams_());
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.setKey(this.getKeyForParams_());
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(e, t, n) {
    let r = this.getTileGrid();
    if (r || (r = this.getTileGridForProjection(n)), r.getResolutions().length <= e[0])
      return;
    t != 1 && !this.hidpi_ && (t = 1);
    const s = r.getTileCoordExtent(e, this.tmpExtent_);
    let o = dt(r.getTileSize(e[0]), this.tmpSize);
    t != 1 && (o = rv(o, t, this.tmpSize));
    const a = {
      F: "image",
      FORMAT: "PNG32",
      TRANSPARENT: !0
    };
    return Object.assign(a, this.params_), this.getRequestUrl_(
      e,
      o,
      s,
      t,
      n,
      a
    );
  }
}
class P9 extends mT {
  /**
   * @param {Options} [options] Debug tile options.
   */
  constructor(e) {
    e = e || {};
    const t = e.template || "z:{z} x:{x} y:{y}", n = e.source, r = e.color || "grey";
    super({
      transition: 0,
      wrapX: e.wrapX !== void 0 ? e.wrapX : n !== void 0 ? n.getWrapX() : void 0
    });
    const s = () => {
      this.projection = e.projection !== void 0 ? ee(e.projection) : n !== void 0 ? n.getProjection() : this.projection, this.tileGrid = e.tileGrid !== void 0 ? e.tileGrid : n !== void 0 ? n.getTileGrid() : this.tileGrid, this.zDirection = e.zDirection !== void 0 ? e.zDirection : n !== void 0 ? n.zDirection : this.zDirection, n instanceof Bh && (this.transformMatrix = n.transformMatrix?.slice() || null);
      const o = this.tileGrid;
      o && this.setTileSizes(
        o.getResolutions().map(
          (a, l) => dt(o.getTileSize(l)).map(
            (h) => Math.max(Math.floor(h), 1)
          )
        )
      ), this.setLoader((a, l, h, u) => {
        const c = I0(t, a, l, h, u.maxY), [f, g] = this.getTileSize(a), d = ot(f, g);
        return d.strokeStyle = r, d.strokeRect(0.5, 0.5, f + 0.5, g + 0.5), d.fillStyle = r, d.strokeStyle = "white", d.textAlign = "center", d.textBaseline = "middle", d.font = "24px sans-serif", d.lineWidth = 4, d.strokeText(c, f / 2, g / 2, f), d.fillText(c, f / 2, g / 2, f), Promise.resolve(d.canvas);
      }), this.setState("ready");
    };
    if (n === void 0 || n.getState() === "ready")
      s();
    else {
      const o = () => {
        n.getState() === "ready" && (n.removeEventListener(le.CHANGE, o), s());
      };
      n.addEventListener(le.CHANGE, o);
    }
  }
}
class M9 extends Za {
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {import("../extent.js").Extent} extent Extent of the tile.
   * @param {boolean} preemptive Load the tile when visible (before it's needed).
   * @param {boolean} jsonp Load the tile as a script.
   */
  constructor(e, t, n, r, s, o) {
    super(e, t), this.src_ = n, this.extent_ = r, this.preemptive_ = s, this.grid_ = null, this.keys_ = null, this.data_ = null, this.jsonp_ = o;
  }
  /**
   * Get the image element for this tile.
   * @return {HTMLImageElement} Image.
   */
  getImage() {
    return null;
  }
  /**
   * Synchronously returns data at given coordinate (if available).
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {*} The data.
   */
  getData(e) {
    if (!this.grid_ || !this.keys_)
      return null;
    const t = (e[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]), n = (e[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]), r = this.grid_[Math.floor((1 - n) * this.grid_.length)];
    if (typeof r != "string")
      return null;
    let s = r.charCodeAt(Math.floor(t * r.length));
    s >= 93 && s--, s >= 35 && s--, s -= 32;
    let o = null;
    if (s in this.keys_) {
      const a = this.keys_[s];
      this.data_ && a in this.data_ ? o = this.data_[a] : o = a;
    }
    return o;
  }
  /**
   * Calls the callback (synchronously by default) with the available data
   * for given coordinate (or `null` if not yet loaded).
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(*): void} callback Callback.
   * @param {boolean} [request] If `true` the callback is always async.
   *                               The tile data is requested if not yet loaded.
   */
  forDataAtCoordinate(e, t, n) {
    this.state == X.EMPTY && n === !0 ? (this.state = X.IDLE, ql(this, le.CHANGE, (r) => {
      t(this.getData(e));
    }), this.loadInternal_()) : n === !0 ? setTimeout(() => {
      t(this.getData(e));
    }, 0) : t(this.getData(e));
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @override
   */
  getKey() {
    return this.src_;
  }
  /**
   * @private
   */
  handleError_() {
    this.state = X.ERROR, this.changed();
  }
  /**
   * @param {!UTFGridJSON} json UTFGrid data.
   * @private
   */
  handleLoad_(e) {
    this.grid_ = e.grid, this.keys_ = e.keys, this.data_ = e.data, this.state = X.LOADED, this.changed();
  }
  /**
   * @private
   */
  loadInternal_() {
    if (this.state == X.IDLE)
      if (this.state = X.LOADING, this.jsonp_)
        A0(
          this.src_,
          this.handleLoad_.bind(this),
          this.handleError_.bind(this)
        );
      else {
        const e = new XMLHttpRequest();
        e.addEventListener("load", this.onXHRLoad_.bind(this)), e.addEventListener("error", this.onXHRError_.bind(this)), e.open("GET", this.src_), e.send();
      }
  }
  /**
   * @private
   * @param {Event} event The load event.
   */
  onXHRLoad_(e) {
    const t = (
      /** @type {XMLHttpRequest} */
      e.target
    );
    if (!t.status || t.status >= 200 && t.status < 300) {
      let n;
      try {
        n = /** @type {!UTFGridJSON} */
        JSON.parse(t.responseText);
      } catch {
        this.handleError_();
        return;
      }
      this.handleLoad_(n);
    } else
      this.handleError_();
  }
  /**
   * @private
   * @param {Event} event The error event.
   */
  onXHRError_(e) {
    this.handleError_();
  }
  /**
   * @override
   */
  load() {
    this.preemptive_ ? this.loadInternal_() : this.setState(X.EMPTY);
  }
}
class C9 extends Wf {
  /**
   * @param {Options} options Source options.
   */
  constructor(e) {
    if (super({
      projection: ee("EPSG:3857"),
      state: "loading",
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      zDirection: e.zDirection
    }), this.preemptive_ = e.preemptive !== void 0 ? e.preemptive : !0, this.tileUrlFunction_ = HN, this.template_ = void 0, this.jsonp_ = e.jsonp || !1, this.tileCache_ = new Ic(512), e.url)
      if (this.jsonp_)
        A0(
          e.url,
          this.handleTileJSONResponse.bind(this),
          this.handleTileJSONError.bind(this)
        );
      else {
        const t = new XMLHttpRequest();
        t.addEventListener("load", this.onXHRLoad_.bind(this)), t.addEventListener("error", this.onXHRError_.bind(this)), t.open("GET", e.url), t.send();
      }
    else if (e.tileJSON)
      this.handleTileJSONResponse(e.tileJSON);
    else
      throw new Error("Either `url` or `tileJSON` options must be provided");
  }
  /**
   * @private
   * @param {Event} event The load event.
   */
  onXHRLoad_(e) {
    const t = (
      /** @type {XMLHttpRequest} */
      e.target
    );
    if (!t.status || t.status >= 200 && t.status < 300) {
      let n;
      try {
        n = /** @type {import("./TileJSON.js").Config} */
        JSON.parse(t.responseText);
      } catch {
        this.handleTileJSONError();
        return;
      }
      this.handleTileJSONResponse(n);
    } else
      this.handleTileJSONError();
  }
  /**
   * @private
   * @param {Event} event The error event.
   */
  onXHRError_(e) {
    this.handleTileJSONError();
  }
  /**
   * Return the template from TileJSON.
   * @return {string|undefined} The template from TileJSON.
   * @api
   */
  getTemplate() {
    return this.template_;
  }
  /**
   * Calls the callback (synchronously by default) with the available data
   * for given coordinate and resolution (or `null` if not yet loaded or
   * in case of an error).
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {function(*): void} callback Callback.
   * @param {boolean} [request] If `true` the callback is always async.
   *                               The tile data is requested if not yet loaded.
   * @api
   */
  forDataAtCoordinateAndResolution(e, t, n, r) {
    if (this.tileGrid) {
      const s = this.tileGrid.getZForResolution(t, this.zDirection), o = this.tileGrid.getTileCoordForCoordAndZ(e, s), a = (
        /** @type {!CustomTile} */
        this.getTile(
          o[0],
          o[1],
          o[2],
          1,
          this.getProjection()
        )
      );
      a.getState() == X.IDLE && a.load(), a.forDataAtCoordinate(e, n, r);
    } else
      r === !0 ? setTimeout(function() {
        n(null);
      }, 0) : n(null);
  }
  /**
   * @protected
   */
  handleTileJSONError() {
    this.setState("error");
  }
  /**
   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse
   * @protected
   * @param {import("./TileJSON.js").Config} tileJSON Tile JSON.
   */
  handleTileJSONResponse(e) {
    const t = ee("EPSG:4326"), n = this.getProjection();
    let r;
    if (e.bounds !== void 0) {
      const u = xo(
        t,
        n
      );
      r = so(e.bounds, u);
    }
    const s = Hn(n), o = e.minzoom || 0, a = e.maxzoom || 22, l = xr({
      extent: s,
      maxZoom: a,
      minZoom: o
    });
    this.tileGrid = l, this.template_ = e.template;
    const h = e.grids;
    if (!h) {
      this.setState("error");
      return;
    }
    if (this.tileUrlFunction_ = L0(h, l), e.attribution) {
      const u = r !== void 0 ? r : s;
      this.setAttributions(function(c) {
        return ft(u, c.extent) ? [e.attribution] : null;
      });
    }
    this.setState("ready");
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!CustomTile} Tile.
   * @override
   */
  getTile(e, t, n, r, s) {
    const o = [e, t, n], a = this.getTileCoordForTileUrlFunction(
      o,
      s
    ), l = this.tileUrlFunction_(a, r, s), h = `${this.getKey()},${Qm(e, t, n)}`;
    if (this.tileCache_.containsKey(h))
      return this.tileCache_.get(h);
    this.tileCache_.expireCache();
    const u = new M9(
      o,
      l !== void 0 ? X.IDLE : X.EMPTY,
      l !== void 0 ? l : "",
      this.tileGrid.getTileCoordExtent(o),
      this.preemptive_,
      this.jsonp_
    );
    return this.tileCache_.set(h, u), u;
  }
}
class A9 extends ys {
  /**
   * @param {Options<FeatureType>} [options] Cluster options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      wrapX: e.wrapX
    }), this.resolution = void 0, this.distance = e.distance !== void 0 ? e.distance : 20, this.minDistance = e.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = e.geometryFunction || function(t) {
      const n = (
        /** @type {Point} */
        t.getGeometry()
      );
      return Te(
        !n || n.getType() === "Point",
        "The default `geometryFunction` can only handle `Point` or null geometries"
      ), n;
    }, this.createCustomCluster_ = e.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(e.source || null);
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
   * @api
   * @override
   */
  clear(e) {
    this.features.length = 0, super.clear(e);
  }
  /**
   * Get the distance in pixels between clusters.
   * @return {number} Distance.
   * @api
   */
  getDistance() {
    return this.distance;
  }
  /**
   * Get a reference to the wrapped source.
   * @return {VectorSource<FeatureType>|null} Source.
   * @api
   */
  getSource() {
    return this.source;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @override
   */
  loadFeatures(e, t, n) {
    this.source?.loadFeatures(e, t, n), t !== this.resolution && (this.resolution = t, this.refresh());
  }
  /**
   * Set the distance within which features will be clusterd together.
   * @param {number} distance The distance in pixels.
   * @api
   */
  setDistance(e) {
    this.updateDistance(e, this.minDistance);
  }
  /**
   * Set the minimum distance between clusters. Will be capped at the
   * configured distance.
   * @param {number} minDistance The minimum distance in pixels.
   * @api
   */
  setMinDistance(e) {
    this.updateDistance(this.distance, e);
  }
  /**
   * The configured minimum distance between clusters.
   * @return {number} The minimum distance in pixels.
   * @api
   */
  getMinDistance() {
    return this.minDistance;
  }
  /**
   * Replace the wrapped source.
   * @param {VectorSource<FeatureType>|null} source The new source for this instance.
   * @api
   */
  setSource(e) {
    this.source && this.source.removeEventListener(le.CHANGE, this.boundRefresh_), this.source = e, e && e.addEventListener(le.CHANGE, this.boundRefresh_), this.refresh();
  }
  /**
   * Handle the source changing.
   * @override
   */
  refresh() {
    this.clear(), this.cluster(), this.addFeatures(this.features);
  }
  /**
   * Update the distances and refresh the source if necessary.
   * @param {number} distance The new distance.
   * @param {number} minDistance The new minimum distance.
   */
  updateDistance(e, t) {
    const n = e === 0 ? 0 : Math.min(t, e) / e, r = e !== this.distance || this.interpolationRatio !== n;
    this.distance = e, this.minDistance = t, this.interpolationRatio = n, r && this.refresh();
  }
  /**
   * @protected
   */
  cluster() {
    if (this.resolution === void 0 || !this.source)
      return;
    const e = hi(), t = this.distance * this.resolution, n = this.source.getFeatures(), r = {};
    for (let s = 0, o = n.length; s < o; s++) {
      const a = n[s];
      if (!(ie(a) in r)) {
        const l = this.geometryFunction(a);
        if (l) {
          const h = l.getCoordinates();
          Bp(h, e), ln(e, t, e);
          const u = this.source.getFeaturesInExtent(e).filter(function(c) {
            const f = ie(c);
            return f in r ? !1 : (r[f] = !0, !0);
          });
          this.features.push(this.createCluster(u, e));
        }
      }
    }
  }
  /**
   * @param {Array<FeatureType>} features Features
   * @param {import("../extent.js").Extent} extent The searched extent for these features.
   * @return {Feature} The cluster feature.
   * @protected
   */
  createCluster(e, t) {
    const n = [0, 0];
    for (let a = e.length - 1; a >= 0; --a) {
      const l = this.geometryFunction(e[a]);
      l ? wE(n, l.getCoordinates()) : e.splice(a, 1);
    }
    bE(n, 1 / e.length);
    const r = Vt(t), s = this.interpolationRatio, o = new Jt([
      n[0] * (1 - s) + r[0] * s,
      n[1] * (1 - s) + r[1] * s
    ]);
    return this.createCustomCluster_ ? this.createCustomCluster_(o, e) : new li({
      geometry: o,
      features: e
    });
  }
}
class af extends A9 {
  /**
   * @param {ClusterOptions} options
   */
  constructor(e = {}) {
    super({
      ...e,
      createCluster: af.defaultCreateCluster,
      geometryFunction: af.defaultGeometryFunction
    });
  }
  static defaultCreateCluster(e, t) {
    const n = t.length === 1 && t[0].getGeometry() instanceof ei ? t[0].getGeometry() : e, r = new li({
      geometry: n,
      features: t
    });
    if (t.length === 1) {
      const s = t[0];
      for (const o in s.getProperties())
        o !== "geometry" && r.set(o, s.get(o));
    }
    return r;
  }
  /**
   * @param {import("ol/Feature").FeatureLike} feature
   * @returns {import("ol/geom/Point").default}
   */
  static defaultGeometryFunction(e) {
    const t = e && e.getGeometry();
    return t instanceof Jt ? t : t instanceof ei ? t.getInteriorPoint() : null;
  }
}
class I9 extends Ln {
  /**
   * Constructs a WMTS capabilities instance and fetches the WMTS capabilities XML from the provided URL.
   *
   * @param {WMTSCapabilitiesOptions} options - Image tile options including URL, layer, and other properties.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      tilePixelRatio: e.tilePixelRatio,
      transition: e.transition,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection,
      wrapX: e.wrapX
    }), this.version_ = e.version !== void 0 ? e.version : "1.0.0", this.dimensions_ = e.dimensions !== void 0 ? e.dimensions : {}, this.layer_ = e.layer, fetch(e.url).then((t) => t.text()).then(
      (t) => new window.DOMParser().parseFromString(t, "application/xml")
    ).then((t) => {
      this.handleCapabilitiesResponse(t, e);
    });
  }
  /**
   * Handles the WMTS capabilities XML response by parsing it and setting up the necessary properties.
   *
   * @param {Document} xml - The XML document containing WMTS capabilities.
   * @param {WMTSCapabilitiesOptions} options - Options for WMTS capabilities.
   */
  handleCapabilitiesResponse(e, t) {
    const r = new Gm().read(e), s = Ib(r, t);
    this.crossOrigin = s.crossOrigin, this.projection = /** @type {import("ol/proj").Projection} */
    s.projection, this.tileGrid = s.tileGrid, this.requestEncoding_ = s.requestEncoding, this.matrixSet_ = s.matrixSet, this.style_ = s.style, this.format_ = s.format, this.dimensions_ = s.dimensions, this.setUrls(s.urls), this.urls && this.urls.length > 0 && (this.tileUrlFunction = Aa(
      this.urls.map(this.createFromWMTSTemplate.bind(this))
    )), this.setState("ready");
  }
  /**
   * Creates a URL function for WMTS tiles based on a template.
   *
   * @param {String} template - The WMTS URL template.
   */
  createFromWMTSTemplate(e) {
    const t = this.requestEncoding_, n = {
      layer: this.layer_,
      style: this.style_,
      tilematrixset: this.matrixSet_
    };
    t === "KVP" && Object.assign(n, {
      Service: "WMTS",
      Request: "GetTile",
      Version: this.version_,
      Format: this.format_
    }), e = t === "KVP" ? Ps(e, n) : e.replace(
      /\{(\w+?)\}/g,
      (o, a) => a.toLowerCase() in n ? n[a.toLowerCase()] : o
    );
    const r = (
      /** @type {import("ol/tilegrid/WMTS").default} **/
      this.tileGrid
    ), s = this.dimensions_;
    return (
      /**
       * Returns the tile URL based on the tile coordinates.
       *
       * @param {Array<number>} tileCoord - The tile coordinate.
       * @return {string|undefined} - The tile URL, or `undefined` if tileCoord is invalid.
       */
      (function(o) {
        if (!o)
          return;
        const a = {
          // @ts-expect-error - Property 'getMatrixId' does not exist on type 'TileGrid'
          TileMatrix: r.getMatrixId(o[0]),
          TileCol: o[1],
          TileRow: o[2]
        };
        Object.assign(a, s);
        let l = e;
        return t === "KVP" ? l = Ps(l, a) : l = l.replace(/\{(\w+?)\}/g, (h, u) => a[u]), l;
      })
    );
  }
}
const Lr = new Uint8Array([102, 103, 98, 3, 102, 103, 98, 0]), an = 4, gl = 4, pl = 4, eu = 4, hs = new Int32Array(2), oE = new Float32Array(hs.buffer), aE = new Float64Array(hs.buffer), Uu = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var Np;
(function(i) {
  i[i.UTF8_BYTES = 1] = "UTF8_BYTES", i[i.UTF16_STRING = 2] = "UTF16_STRING";
})(Np || (Np = {}));
class Yn {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(e) {
    this.bytes_ = e, this.position_ = 0, this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(e) {
    return new Yn(new Uint8Array(e));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(e) {
    this.position_ = e;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(e) {
    return this.readUint8(e) << 24 >> 24;
  }
  readUint8(e) {
    return this.bytes_[e];
  }
  readInt16(e) {
    return this.readUint16(e) << 16 >> 16;
  }
  readUint16(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8;
  }
  readInt32(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8 | this.bytes_[e + 2] << 16 | this.bytes_[e + 3] << 24;
  }
  readUint32(e) {
    return this.readInt32(e) >>> 0;
  }
  readInt64(e) {
    return BigInt.asIntN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readUint64(e) {
    return BigInt.asUintN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readFloat32(e) {
    return hs[0] = this.readInt32(e), oE[0];
  }
  readFloat64(e) {
    return hs[Uu ? 0 : 1] = this.readInt32(e), hs[Uu ? 1 : 0] = this.readInt32(e + 4), aE[0];
  }
  writeInt8(e, t) {
    this.bytes_[e] = t;
  }
  writeUint8(e, t) {
    this.bytes_[e] = t;
  }
  writeInt16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeUint16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeInt32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeUint32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeInt64(e, t) {
    this.writeInt32(e, Number(BigInt.asIntN(32, t))), this.writeInt32(e + 4, Number(BigInt.asIntN(32, t >> BigInt(32))));
  }
  writeUint64(e, t) {
    this.writeUint32(e, Number(BigInt.asUintN(32, t))), this.writeUint32(e + 4, Number(BigInt.asUintN(32, t >> BigInt(32))));
  }
  writeFloat32(e, t) {
    oE[0] = t, this.writeInt32(e, hs[0]);
  }
  writeFloat64(e, t) {
    aE[0] = t, this.writeInt32(e, hs[Uu ? 0 : 1]), this.writeInt32(e + 4, hs[Uu ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + gl + pl)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let e = "";
    for (let t = 0; t < pl; t++)
      e += String.fromCharCode(this.readInt8(this.position_ + gl + t));
    return e;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(e, t) {
    const n = e - this.readInt32(e);
    return t < this.readInt16(n) ? this.readInt16(n + t) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(e, t) {
    return e.bb_pos = t + this.readInt32(t), e.bb = this, e;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(e, t) {
    e += this.readInt32(e);
    const n = this.readInt32(e);
    e += gl;
    const r = this.bytes_.subarray(e, e + n);
    return t === Np.UTF8_BYTES ? r : this.text_decoder_.decode(r);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(e, t) {
    return typeof e == "string" ? this.__string(t) : this.__union(e, t);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(e) {
    return e + this.readInt32(e);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(e) {
    return e + this.readInt32(e) + gl;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(e) {
    return this.readInt32(e + this.readInt32(e));
  }
  __has_identifier(e) {
    if (e.length != pl)
      throw new Error("FlatBuffers: file identifier must be length " + pl);
    for (let t = 0; t < pl; t++)
      if (e.charCodeAt(t) != this.readInt8(this.position() + gl + t))
        return !1;
    return !0;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(e, t) {
    const n = [];
    for (let r = 0; r < t; ++r) {
      const s = e(r);
      s !== null && n.push(s);
    }
    return n;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(e, t) {
    const n = [];
    for (let r = 0; r < t; ++r) {
      const s = e(r);
      s !== null && n.push(s.unpack());
    }
    return n;
  }
}
var Ye, ui = ((Ye = {})[Ye.Byte = 0] = "Byte", Ye[Ye.UByte = 1] = "UByte", Ye[Ye.Bool = 2] = "Bool", Ye[Ye.Short = 3] = "Short", Ye[Ye.UShort = 4] = "UShort", Ye[Ye.Int = 5] = "Int", Ye[Ye.UInt = 6] = "UInt", Ye[Ye.Long = 7] = "Long", Ye[Ye.ULong = 8] = "ULong", Ye[Ye.Float = 9] = "Float", Ye[Ye.Double = 10] = "Double", Ye[Ye.String = 11] = "String", Ye[Ye.Json = 12] = "Json", Ye[Ye.DateTime = 13] = "DateTime", Ye[Ye.Binary = 14] = "Binary", Ye);
class ni {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsColumn(e, t) {
    return (t || new ni()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsColumn(e, t) {
    return e.setPosition(e.position() + eu), (t || new ni()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  type() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readUint8(this.bb_pos + e) : ui.Byte;
  }
  title(e) {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  width() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  precision() {
    let e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  scale() {
    let e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  nullable() {
    let e = this.bb.__offset(this.bb_pos, 18);
    return !e || !!this.bb.readInt8(this.bb_pos + e);
  }
  unique() {
    let e = this.bb.__offset(this.bb_pos, 20);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  primaryKey() {
    let e = this.bb.__offset(this.bb_pos, 22);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  metadata(e) {
    let t = this.bb.__offset(this.bb_pos, 24);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startColumn(e) {
    e.startObject(11);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addType(e, t) {
    e.addFieldInt8(1, t, ui.Byte);
  }
  static addTitle(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWidth(e, t) {
    e.addFieldInt32(4, t, -1);
  }
  static addPrecision(e, t) {
    e.addFieldInt32(5, t, -1);
  }
  static addScale(e, t) {
    e.addFieldInt32(6, t, -1);
  }
  static addNullable(e, t) {
    e.addFieldInt8(7, +t, 1);
  }
  static addUnique(e, t) {
    e.addFieldInt8(8, +t, 0);
  }
  static addPrimaryKey(e, t) {
    e.addFieldInt8(9, +t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static endColumn(e) {
    let t = e.endObject();
    return e.requiredField(t, 4), t;
  }
  static createColumn(e, t, n, r, s, o, a, l, h, u, c, f) {
    return ni.startColumn(e), ni.addName(e, t), ni.addType(e, n), ni.addTitle(e, r), ni.addDescription(e, s), ni.addWidth(e, o), ni.addPrecision(e, a), ni.addScale(e, l), ni.addNullable(e, h), ni.addUnique(e, u), ni.addPrimaryKey(e, c), ni.addMetadata(e, f), ni.endColumn(e);
  }
}
var ke, xi = ((ke = {})[ke.Unknown = 0] = "Unknown", ke[ke.Point = 1] = "Point", ke[ke.LineString = 2] = "LineString", ke[ke.Polygon = 3] = "Polygon", ke[ke.MultiPoint = 4] = "MultiPoint", ke[ke.MultiLineString = 5] = "MultiLineString", ke[ke.MultiPolygon = 6] = "MultiPolygon", ke[ke.GeometryCollection = 7] = "GeometryCollection", ke[ke.CircularString = 8] = "CircularString", ke[ke.CompoundCurve = 9] = "CompoundCurve", ke[ke.CurvePolygon = 10] = "CurvePolygon", ke[ke.MultiCurve = 11] = "MultiCurve", ke[ke.MultiSurface = 12] = "MultiSurface", ke[ke.Curve = 13] = "Curve", ke[ke.Surface = 14] = "Surface", ke[ke.PolyhedralSurface = 15] = "PolyhedralSurface", ke[ke.TIN = 16] = "TIN", ke[ke.Triangle = 17] = "Triangle", ke);
class Si {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsGeometry(e, t) {
    return (t || new Si()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsGeometry(e, t) {
    return e.setPosition(e.position() + eu), (t || new Si()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  ends(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t) + 4 * e) : 0;
  }
  endsLength() {
    let e = this.bb.__offset(this.bb_pos, 4);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  endsArray() {
    let e = this.bb.__offset(this.bb_pos, 4);
    return e ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  xy(e) {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  xyLength() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  xyArray() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  z(e) {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  zLength() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  zArray() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  m(e) {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  mLength() {
    let e = this.bb.__offset(this.bb_pos, 10);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  mArray() {
    let e = this.bb.__offset(this.bb_pos, 10);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  t(e) {
    let t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  tLength() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  tArray() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  tm(e) {
    let t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t) + 8 * e) : BigInt(0);
  }
  tmLength() {
    let e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  type() {
    let e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readUint8(this.bb_pos + e) : xi.Unknown;
  }
  parts(e, t) {
    let n = this.bb.__offset(this.bb_pos, 18);
    return n ? (t || new Si()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * e), this.bb) : null;
  }
  partsLength() {
    let e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startGeometry(e) {
    e.startObject(8);
  }
  static addEnds(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static createEndsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let n = t.length - 1; n >= 0; n--) e.addInt32(t[n]);
    return e.endVector();
  }
  static startEndsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addXy(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createXyVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startXyVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addZ(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createZVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startZVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addM(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static createMVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startMVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addT(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static createTVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startTVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addTm(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static createTmVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addInt64(t[n]);
    return e.endVector();
  }
  static startTmVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addType(e, t) {
    e.addFieldInt8(6, t, xi.Unknown);
  }
  static addParts(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createPartsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);
    return e.endVector();
  }
  static startPartsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endGeometry(e) {
    return e.endObject();
  }
  static createGeometry(e, t, n, r, s, o, a, l, h) {
    return Si.startGeometry(e), Si.addEnds(e, t), Si.addXy(e, n), Si.addZ(e, r), Si.addM(e, s), Si.addT(e, o), Si.addTm(e, a), Si.addType(e, l), Si.addParts(e, h), Si.endGeometry(e);
  }
}
class yn {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsFeature(e, t) {
    return (t || new yn()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsFeature(e, t) {
    return e.setPosition(e.position() + eu), (t || new yn()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  geometry(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? (e || new Si()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  properties(e) {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t) + e) : 0;
  }
  propertiesLength() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  propertiesArray() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  columns(e, t) {
    let n = this.bb.__offset(this.bb_pos, 8);
    return n ? (t || new ni()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * e), this.bb) : null;
  }
  columnsLength() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startFeature(e) {
    e.startObject(3);
  }
  static addGeometry(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addProperties(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createPropertiesVector(e, t) {
    e.startVector(1, t.length, 1);
    for (let n = t.length - 1; n >= 0; n--) e.addInt8(t[n]);
    return e.endVector();
  }
  static startPropertiesVector(e, t) {
    e.startVector(1, t, 1);
  }
  static addColumns(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endFeature(e) {
    return e.endObject();
  }
  static finishFeatureBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedFeatureBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
  static createFeature(e, t, n, r) {
    return yn.startFeature(e), yn.addGeometry(e, t), yn.addProperties(e, n), yn.addColumns(e, r), yn.endFeature(e);
  }
}
function bg(i, e) {
  let t = [];
  for (let n = 0; n < i.length; n += 2) {
    let r = [i[n], i[n + 1]];
    e && r.push(e[n >> 1]), t.push(r);
  }
  return t;
}
new TextEncoder();
let lE = new TextDecoder();
function L9(i, e) {
  let t = {};
  if (!e || e.length === 0) return t;
  let n = i.propertiesArray();
  if (!n) return t;
  let r = new DataView(n.buffer, n.byteOffset), s = i.propertiesLength(), o = 0;
  for (; o < s; ) {
    let a = r.getUint16(o, !0);
    o += 2;
    let l = e[a], h = l.name;
    switch (l.type) {
      case ui.Bool:
        t[h] = !!r.getUint8(o), o += 1;
        break;
      case ui.Byte:
        t[h] = r.getInt8(o), o += 1;
        break;
      case ui.UByte:
        t[h] = r.getUint8(o), o += 1;
        break;
      case ui.Short:
        t[h] = r.getInt16(o, !0), o += 2;
        break;
      case ui.UShort:
        t[h] = r.getUint16(o, !0), o += 2;
        break;
      case ui.Int:
        t[h] = r.getInt32(o, !0), o += 4;
        break;
      case ui.UInt:
        t[h] = r.getUint32(o, !0), o += 4;
        break;
      case ui.Long:
        t[h] = Number(r.getBigInt64(o, !0)), o += 8;
        break;
      case ui.ULong:
        t[h] = Number(r.getBigUint64(o, !0)), o += 8;
        break;
      case ui.Float:
        t[h] = r.getFloat32(o, !0), o += 4;
        break;
      case ui.Double:
        t[h] = r.getFloat64(o, !0), o += 8;
        break;
      case ui.DateTime:
      case ui.String: {
        let u = r.getUint32(o, !0);
        o += 4, t[h] = lE.decode(n.subarray(o, o + u)), o += u;
        break;
      }
      case ui.Json: {
        let u = r.getUint32(o, !0);
        o += 4;
        let c = lE.decode(n.subarray(o, o + u));
        t[h] = JSON.parse(c), o += u;
        break;
      }
      case ui.Binary: {
        let u = r.getUint32(o, !0);
        o += 4, t[h] = n.subarray(o, o + u), o += u;
        break;
      }
      default:
        throw Error(`Unknown type ${l.type}`);
    }
  }
  return t;
}
const T_ = new Uint8Array(0);
function F9() {
  return this._source.cancel();
}
function O9(i, e) {
  if (!i.length) return e;
  if (!e.length) return i;
  var t = new Uint8Array(i.length + e.length);
  return t.set(i), t.set(e, i.length), t;
}
function N9() {
  var i = this, e = i._array.subarray(i._index);
  return i._source.read().then(function(t) {
    return i._array = T_, i._index = 0, t.done ? e.length > 0 ? { done: !1, value: e } : { done: !0, value: void 0 } : { done: !1, value: O9(e, t.value) };
  });
}
function D9(i) {
  if ((i |= 0) < 0) throw new Error("invalid length");
  var e = this, t = this._array.length - this._index;
  if (this._index + i <= this._array.length)
    return Promise.resolve(this._array.subarray(this._index, this._index += i));
  var n = new Uint8Array(i);
  return n.set(this._array.subarray(this._index)), (function r() {
    return e._source.read().then(function(s) {
      return s.done ? (e._array = T_, e._index = 0, t > 0 ? n.subarray(0, t) : null) : t + s.value.length >= i ? (e._array = s.value, e._index = i - t, n.set(s.value.subarray(0, i - t), t), n) : (n.set(s.value, t), t += s.value.length, r());
    });
  })();
}
function G9(i) {
  return typeof i.slice == "function" ? i : new dd(typeof i.read == "function" ? i : i.getReader());
}
function dd(i) {
  this._source = i, this._array = T_, this._index = 0;
}
dd.prototype.read = N9;
dd.prototype.slice = D9;
dd.prototype.cancel = F9;
class _n {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsCrs(e, t) {
    return (t || new _n()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsCrs(e, t) {
    return e.setPosition(e.position() + eu), (t || new _n()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  org(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  code() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readInt32(this.bb_pos + e) : 0;
  }
  name(e) {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  wkt(e) {
    let t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  codeString(e) {
    let t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startCrs(e) {
    e.startObject(6);
  }
  static addOrg(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addCode(e, t) {
    e.addFieldInt32(1, t, 0);
  }
  static addName(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWkt(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static addCodeString(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static endCrs(e) {
    return e.endObject();
  }
  static createCrs(e, t, n, r, s, o, a) {
    return _n.startCrs(e), _n.addOrg(e, t), _n.addCode(e, n), _n.addName(e, r), _n.addDescription(e, s), _n.addWkt(e, o), _n.addCodeString(e, a), _n.endCrs(e);
  }
}
class lf {
  bb = null;
  bb_pos = 0;
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsHeader(e, t) {
    return (t || new lf()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsHeader(e, t) {
    return e.setPosition(e.position() + eu), (t || new lf()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  envelope(e) {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  envelopeLength() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  envelopeArray() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  geometryType() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.readUint8(this.bb_pos + e) : xi.Unknown;
  }
  hasZ() {
    let e = this.bb.__offset(this.bb_pos, 10);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  hasM() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  hasT() {
    let e = this.bb.__offset(this.bb_pos, 14);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  hasTm() {
    let e = this.bb.__offset(this.bb_pos, 16);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  columns(e, t) {
    let n = this.bb.__offset(this.bb_pos, 18);
    return n ? (t || new ni()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * e), this.bb) : null;
  }
  columnsLength() {
    let e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  featuresCount() {
    let e = this.bb.__offset(this.bb_pos, 20);
    return e ? this.bb.readUint64(this.bb_pos + e) : BigInt("0");
  }
  indexNodeSize() {
    let e = this.bb.__offset(this.bb_pos, 22);
    return e ? this.bb.readUint16(this.bb_pos + e) : 16;
  }
  crs(e) {
    let t = this.bb.__offset(this.bb_pos, 24);
    return t ? (e || new _n()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  title(e) {
    let t = this.bb.__offset(this.bb_pos, 26);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    let t = this.bb.__offset(this.bb_pos, 28);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  metadata(e) {
    let t = this.bb.__offset(this.bb_pos, 30);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startHeader(e) {
    e.startObject(14);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addEnvelope(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createEnvelopeVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startEnvelopeVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addGeometryType(e, t) {
    e.addFieldInt8(2, t, xi.Unknown);
  }
  static addHasZ(e, t) {
    e.addFieldInt8(3, +t, 0);
  }
  static addHasM(e, t) {
    e.addFieldInt8(4, +t, 0);
  }
  static addHasT(e, t) {
    e.addFieldInt8(5, +t, 0);
  }
  static addHasTm(e, t) {
    e.addFieldInt8(6, +t, 0);
  }
  static addColumns(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addFeaturesCount(e, t) {
    e.addFieldInt64(8, t, BigInt("0"));
  }
  static addIndexNodeSize(e, t) {
    e.addFieldInt16(9, t, 16);
  }
  static addCrs(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static addTitle(e, t) {
    e.addFieldOffset(11, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(12, t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(13, t, 0);
  }
  static endHeader(e) {
    return e.endObject();
  }
  static finishHeaderBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedHeaderBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
}
function gd(i) {
  let e = lf.getRootAsHeader(i), t = e.featuresCount(), n = e.indexNodeSize(), r = [];
  for (let a = 0; a < e.columnsLength(); a++) {
    let l = e.columns(a);
    if (!l) throw Error("Column unexpectedly missing");
    if (!l.name()) throw Error("Column name unexpectedly missing");
    r.push({ name: l.name(), type: l.type(), title: l.title(), description: l.description(), width: l.width(), precision: l.precision(), scale: l.scale(), nullable: l.nullable(), unique: l.unique(), primary_key: l.primaryKey() });
  }
  let s = e.crs(), o = s ? { org: s.org(), code: s.code(), name: s.name(), description: s.description(), wkt: s.wkt(), code_string: s.codeString() } : null;
  return { geometryType: e.geometryType(), columns: r, envelope: null, featuresCount: Number(t), indexNodeSize: n, crs: o, title: e.title(), description: e.description(), metadata: e.metadata() };
}
class pd {
  static global = new pd();
  _extraRequestThreshold = 262144;
  extraRequestThreshold() {
    return this._extraRequestThreshold;
  }
  setExtraRequestThreshold(e) {
    if (e < 0) throw Error("extraRequestThreshold cannot be negative");
    this._extraRequestThreshold = e;
  }
}
const k9 = 40, U9 = 16;
function md(i, e) {
  e = Math.min(Math.max(+e, 2), 65535);
  let t = i, n = t;
  do
    n += t = Math.ceil(t / e);
  while (t !== 1);
  return 40 * n;
}
function z9(i, e) {
  if (e < 2) throw Error("Node size must be at least 2");
  if (i === 0) throw Error("Number of items must be greater than 0");
  let t = i, n = t, r = [t];
  do
    n += t = Math.ceil(t / e), r.push(t);
  while (t !== 1);
  let s = [];
  for (let a of (t = n, r)) s.push(t - a), t -= a;
  let o = [];
  for (let a = 0; a < r.length; a++) o.push([s[a], s[a] + r[a]]);
  return o;
}
async function* xT(i, e, t, n) {
  class r {
    _level;
    nodes;
    constructor(g, d) {
      this._level = d, this.nodes = g;
    }
    level() {
      return this._level;
    }
    startNodeIdx() {
      return this.nodes[0];
    }
    endNodeIdx() {
      return this.nodes[1];
    }
    extendEndNodeIdx(g) {
      this.nodes[1] = g;
    }
    toString() {
      return `[NodeRange level: ${this._level}, nodes: ${this.nodes[0]}-${this.nodes[1]}]`;
    }
  }
  let { minX: s, minY: o, maxX: a, maxY: l } = t, h = z9(i, e), u = h[0][0], c = [new r([0, 1], h.length - 1)];
  for (; c.length !== 0; ) {
    let f = c.shift(), g = f.startNodeIdx(), d = g >= u, m = (() => {
      let [, p] = h[f.level()], y = Math.min(f.endNodeIdx() + e, p);
      return d && y < p ? y + 1 : y;
    })(), x = m - g, v = new DataView(await n(40 * g, 40 * x));
    for (let p = g; p < m; p++) {
      let y = p - g, E = 40 * y;
      if (a < v.getFloat64(E + 0, !0) || l < v.getFloat64(E + 8, !0) || s > v.getFloat64(E + 16, !0) || o > v.getFloat64(E + 24, !0)) continue;
      let b = v.getBigUint64(E + 32, !0);
      if (d) {
        let C = (() => {
          if (p < i - 1) {
            let O = (y + 1) * 40;
            return v.getBigUint64(O + 32, !0) - b;
          }
          return null;
        })(), I = p - u;
        yield [Number(b), I, Number(C)];
        continue;
      }
      let T = pd.global.extraRequestThreshold() / 40, R = c[c.length - 1];
      if (R !== void 0 && R.level() === f.level() - 1 && b < R.endNodeIdx() + T) {
        R.extendEndNodeIdx(Number(b));
        continue;
      }
      let M = (() => {
        let C = f.level() - 1;
        return new r([Number(b), Number(b) + 1], C);
      })();
      R !== void 0 && (R.level(), M.level()), c.push(M);
    }
  }
}
class R_ {
  bytes;
  header;
  headerLength;
  indexLength;
  constructor(e, t, n, r) {
    this.bytes = e, this.header = t, this.headerLength = n, this.indexLength = r;
  }
  static open(e) {
    if (!e.subarray(0, 3).every((o, a) => Lr[a] === o)) throw Error("Not a FlatGeobuf file");
    let t = new DataView(e.buffer).getUint32(8, !0);
    if (t > 10485760 || t < 8) throw Error("Invalid header size");
    let n = e.subarray(12, 12 + t), r = gd(new Yn(n)), s = md(r.featuresCount, r.indexNodeSize);
    return new R_(e, r, t, s);
  }
  async *selectBbox(e) {
    let t = this.lengthBeforeTree(), n = async (r, s) => {
      let o = t + r;
      return this.bytes.slice(o, o + s).buffer;
    };
    for await (let r of xT(this.header.featuresCount, this.header.indexNodeSize, e, n)) {
      let [s, o] = r, a = this.readFeature(s);
      yield { id: o, feature: a };
    }
  }
  lengthBeforeTree() {
    return Lr.length + an + this.headerLength;
  }
  lengthBeforeFeatures() {
    return this.lengthBeforeTree() + this.indexLength;
  }
  readFeature(e) {
    let t = e + this.lengthBeforeFeatures(), n = new DataView(this.bytes.buffer).getUint32(t, !0), r = this.bytes.subarray(t + 4, t + 4 + n), s = new Uint8Array(n + an);
    s.set(r, an);
    let o = new Yn(s);
    return o.setPosition(an), yn.getRootAsFeature(o);
  }
}
var Dp = function(i, e) {
  return Dp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var r in n) n.hasOwnProperty(r) && (t[r] = n[r]);
  }, Dp(i, e);
};
function B9(i, e) {
  Dp(i, e);
  function t() {
    this.constructor = i;
  }
  i.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Na(i, e, t, n) {
  function r(s) {
    return s instanceof t ? s : new t(function(o) {
      o(s);
    });
  }
  return new (t || (t = Promise))(function(s, o) {
    function a(u) {
      try {
        h(n.next(u));
      } catch (c) {
        o(c);
      }
    }
    function l(u) {
      try {
        h(n.throw(u));
      } catch (c) {
        o(c);
      }
    }
    function h(u) {
      u.done ? s(u.value) : r(u.value).then(a, l);
    }
    h((n = n.apply(i, [])).next());
  });
}
function As(i, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, r, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(h) {
    return function(u) {
      return l([h, u]);
    };
  }
  function l(h) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (n = 1, r && (s = h[0] & 2 ? r.return : h[0] ? r.throw || ((s = r.return) && s.call(r), 0) : r.next) && !(s = s.call(r, h[1])).done) return s;
      switch (r = 0, s && (h = [h[0] & 2, s.value]), h[0]) {
        case 0:
        case 1:
          s = h;
          break;
        case 4:
          return t.label++, { value: h[1], done: !1 };
        case 5:
          t.label++, r = h[1], h = [0];
          continue;
        case 7:
          h = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (h[0] === 6 || h[0] === 2)) {
            t = 0;
            continue;
          }
          if (h[0] === 3 && (!s || h[1] > s[0] && h[1] < s[3])) {
            t.label = h[1];
            break;
          }
          if (h[0] === 6 && t.label < s[1]) {
            t.label = s[1], s = h;
            break;
          }
          if (s && t.label < s[2]) {
            t.label = s[2], t.ops.push(h);
            break;
          }
          s[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      h = e.call(i, t);
    } catch (u) {
      h = [6, u], r = 0;
    } finally {
      n = s = 0;
    }
    if (h[0] & 5) throw h[1];
    return { value: h[0] ? h[1] : void 0, done: !0 };
  }
}
function nl(i) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && i[e], n = 0;
  if (t) return t.call(i);
  if (i && typeof i.length == "number") return {
    next: function() {
      return i && n >= i.length && (i = void 0), { value: i && i[n++], done: !i };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function xh(i) {
  return this instanceof xh ? (this.v = i, this) : new xh(i);
}
function $9(i, e, t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = t.apply(i, e || []), r, s = [];
  return r = {}, o("next"), o("throw"), o("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r;
  function o(f) {
    n[f] && (r[f] = function(g) {
      return new Promise(function(d, m) {
        s.push([f, g, d, m]) > 1 || a(f, g);
      });
    });
  }
  function a(f, g) {
    try {
      l(n[f](g));
    } catch (d) {
      c(s[0][3], d);
    }
  }
  function l(f) {
    f.value instanceof xh ? Promise.resolve(f.value.v).then(h, u) : c(s[0][2], f);
  }
  function h(f) {
    a("next", f);
  }
  function u(f) {
    a("throw", f);
  }
  function c(f, g) {
    f(g), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
var ET = (
  /** @class */
  (function(i) {
    B9(e, i);
    function e(t) {
      var n = i.call(this, t) || this;
      return Object.defineProperty(n, "name", {
        value: "RepeaterOverflowError",
        enumerable: !1
      }), typeof Object.setPrototypeOf == "function" ? Object.setPrototypeOf(n, n.constructor.prototype) : n.__proto__ = n.constructor.prototype, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(n, n.constructor), n;
    }
    return e;
  })(Error)
);
(function() {
  function i(e) {
    if (e < 0)
      throw new RangeError("Capacity may not be less than 0");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(i.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "full", {
    get: function() {
      return this._q.length >= this._c;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.add = function(e) {
    if (this.full)
      throw new Error("Buffer full");
    this._q.push(e);
  }, i.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, i;
})();
(function() {
  function i(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(i.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.add = function(e) {
    for (; this._q.length >= this._c; )
      this._q.shift();
    this._q.push(e);
  }, i.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, i;
})();
(function() {
  function i(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(i.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.add = function(e) {
    this._q.length < this._c && this._q.push(e);
  }, i.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, i;
})();
function Gp(i) {
  i != null && typeof i.then == "function" && i.then(cf, cf);
}
var Sg = 0, hE = 1, _o = 2, hf = 3, kp = 4, uf = 1024, cf = function() {
};
function ya(i) {
  var e = i.err, t = Promise.resolve(i.execution).then(function(n) {
    if (e != null)
      throw e;
    return n;
  });
  return i.err = void 0, i.execution = t.then(function() {
  }, function() {
  }), i.pending === void 0 ? t : i.pending.then(function() {
    return t;
  });
}
function Vs(i, e) {
  var t = i.state >= hf;
  return Promise.resolve(e).then(function(n) {
    return !t && i.state >= kp ? ya(i).then(function(r) {
      return {
        value: r,
        done: !0
      };
    }) : { value: n, done: t };
  });
}
function P_(i, e) {
  var t, n;
  if (!(i.state >= _o))
    if (i.state = _o, i.onnext(), i.onstop(), i.err == null && (i.err = e), i.pushes.length === 0 && (typeof i.buffer > "u" || i.buffer.empty))
      Vl(i);
    else
      try {
        for (var r = nl(i.pushes), s = r.next(); !s.done; s = r.next()) {
          var o = s.value;
          o.resolve();
        }
      } catch (a) {
        t = { error: a };
      } finally {
        try {
          s && !s.done && (n = r.return) && n.call(r);
        } finally {
          if (t) throw t.error;
        }
      }
}
function Vl(i) {
  var e, t;
  if (!(i.state >= hf)) {
    i.state < _o && P_(i), i.state = hf, i.buffer = void 0;
    try {
      for (var n = nl(i.nexts), r = n.next(); !r.done; r = n.next()) {
        var s = r.value, o = i.pending === void 0 ? ya(i) : i.pending.then(function() {
          return ya(i);
        });
        s.resolve(Vs(i, o));
      }
    } catch (a) {
      e = { error: a };
    } finally {
      try {
        r && !r.done && (t = n.return) && t.call(n);
      } finally {
        if (e) throw e.error;
      }
    }
    i.pushes = [], i.nexts = [];
  }
}
function uE(i) {
  i.state >= kp || (i.state < hf && Vl(i), i.state = kp);
}
function j9(i, e) {
  if (Gp(e), i.pushes.length >= uf)
    throw new ET("No more than " + uf + " pending calls to push are allowed on a single repeater.");
  if (i.state >= _o)
    return Promise.resolve(void 0);
  var t = i.pending === void 0 ? Promise.resolve(e) : i.pending.then(function() {
    return e;
  });
  t = t.catch(function(l) {
    i.state < _o && (i.err = l), uE(i);
  });
  var n;
  if (i.nexts.length) {
    var r = i.nexts.shift();
    r.resolve(Vs(i, t)), i.nexts.length ? n = Promise.resolve(i.nexts[0].value) : typeof i.buffer < "u" && !i.buffer.full ? n = Promise.resolve(void 0) : n = new Promise(function(l) {
      return i.onnext = l;
    });
  } else typeof i.buffer < "u" && !i.buffer.full ? (i.buffer.add(t), n = Promise.resolve(void 0)) : n = new Promise(function(l) {
    return i.pushes.push({ resolve: l, value: t });
  });
  var s = !0, o = {}, a = n.catch(function(l) {
    if (s)
      throw l;
  });
  return o.then = function(l, h) {
    return s = !1, Promise.prototype.then.call(n, l, h);
  }, o.catch = function(l) {
    return s = !1, Promise.prototype.catch.call(n, l);
  }, o.finally = n.finally.bind(n), i.pending = t.then(function() {
    return a;
  }).catch(function(l) {
    i.err = l, uE(i);
  }), o;
}
function X9(i) {
  var e = P_.bind(null, i), t = new Promise(function(n) {
    return i.onstop = n;
  });
  return e.then = t.then.bind(t), e.catch = t.catch.bind(t), e.finally = t.finally.bind(t), e;
}
function V9(i) {
  if (!(i.state >= hE)) {
    i.state = hE;
    var e = j9.bind(null, i), t = X9(i);
    i.execution = new Promise(function(n) {
      return n(i.executor(e, t));
    }), i.execution.catch(function() {
      return P_(i);
    });
  }
}
var zu = /* @__PURE__ */ new WeakMap(), tu = (
  /** @class */
  (function() {
    function i(e, t) {
      zu.set(this, {
        executor: e,
        buffer: t,
        err: void 0,
        state: Sg,
        pushes: [],
        nexts: [],
        pending: void 0,
        execution: void 0,
        onnext: cf,
        onstop: cf
      });
    }
    return i.prototype.next = function(e) {
      Gp(e);
      var t = zu.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      if (t.nexts.length >= uf)
        throw new ET("No more than " + uf + " pending calls to next are allowed on a single repeater.");
      if (t.state <= Sg && V9(t), t.onnext(e), typeof t.buffer < "u" && !t.buffer.empty) {
        var n = Vs(t, t.buffer.remove());
        if (t.pushes.length) {
          var r = t.pushes.shift();
          t.buffer.add(r.value), t.onnext = r.resolve;
        }
        return n;
      } else if (t.pushes.length) {
        var s = t.pushes.shift();
        return t.onnext = s.resolve, Vs(t, s.value);
      } else if (t.state >= _o)
        return Vl(t), Vs(t, ya(t));
      return new Promise(function(o) {
        return t.nexts.push({ resolve: o, value: e });
      });
    }, i.prototype.return = function(e) {
      Gp(e);
      var t = zu.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return Vl(t), t.execution = Promise.resolve(t.execution).then(function() {
        return e;
      }), Vs(t, ya(t));
    }, i.prototype.throw = function(e) {
      var t = zu.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return t.state <= Sg || t.state >= _o || typeof t.buffer < "u" && !t.buffer.empty ? (Vl(t), t.err == null && (t.err = e), Vs(t, ya(t))) : this.next(Promise.reject(e));
    }, i.prototype[Symbol.asyncIterator] = function() {
      return this;
    }, i.race = W9, i.merge = Y9, i.zip = q9, i.latest = Z9, i;
  })()
);
function _d(i, e) {
  var t, n, r = [], s = function(h) {
    h != null && typeof h[Symbol.asyncIterator] == "function" ? r.push(h[Symbol.asyncIterator]()) : h != null && typeof h[Symbol.iterator] == "function" ? r.push(h[Symbol.iterator]()) : r.push((function() {
      return $9(this, arguments, function() {
        return As(this, function(f) {
          switch (f.label) {
            case 0:
              return e.yieldValues ? [4, xh(h)] : [3, 3];
            case 1:
              return [4, f.sent()];
            case 2:
              f.sent(), f.label = 3;
            case 3:
              return e.returnValues ? [4, xh(h)] : [3, 5];
            case 4:
              return [2, f.sent()];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    })());
  };
  try {
    for (var o = nl(i), a = o.next(); !a.done; a = o.next()) {
      var l = a.value;
      s(l);
    }
  } catch (h) {
    t = { error: h };
  } finally {
    try {
      a && !a.done && (n = o.return) && n.call(o);
    } finally {
      if (t) throw t.error;
    }
  }
  return r;
}
function W9(i) {
  var e = this, t = _d(i, { returnValues: !0 });
  return new tu(function(n, r) {
    return Na(e, void 0, void 0, function() {
      var s, o, a, l, h, u;
      return As(this, function(c) {
        switch (c.label) {
          case 0:
            if (!t.length)
              return r(), [
                2
                /*return*/
              ];
            o = !1, r.then(function() {
              s(), o = !0;
            }), c.label = 1;
          case 1:
            c.trys.push([1, , 5, 7]), l = void 0, h = 0, u = function() {
              var f, g, d, m, x, v;
              return As(this, function(p) {
                switch (p.label) {
                  case 0:
                    f = h;
                    try {
                      for (g = (x = void 0, nl(t)), d = g.next(); !d.done; d = g.next())
                        m = d.value, Promise.resolve(m.next()).then(function(y) {
                          y.done ? (r(), a === void 0 && (a = y)) : h === f && (h++, s(y));
                        }, function(y) {
                          return r(y);
                        });
                    } catch (y) {
                      x = { error: y };
                    } finally {
                      try {
                        d && !d.done && (v = g.return) && v.call(g);
                      } finally {
                        if (x) throw x.error;
                      }
                    }
                    return [4, new Promise(function(y) {
                      return s = y;
                    })];
                  case 1:
                    return l = p.sent(), l === void 0 ? [3, 3] : [4, n(l.value)];
                  case 2:
                    p.sent(), p.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            }, c.label = 2;
          case 2:
            return o ? [3, 4] : [5, u()];
          case 3:
            return c.sent(), [3, 2];
          case 4:
            return [2, a && a.value];
          case 5:
            return r(), [4, Promise.race(t.map(function(f) {
              return f.return && f.return();
            }))];
          case 6:
            return c.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function Y9(i) {
  var e = this, t = _d(i, { yieldValues: !0 });
  return new tu(function(n, r) {
    return Na(e, void 0, void 0, function() {
      var s, o, a, l = this;
      return As(this, function(h) {
        switch (h.label) {
          case 0:
            if (!t.length)
              return r(), [
                2
                /*return*/
              ];
            s = [], o = !1, r.then(function() {
              var u, c;
              o = !0;
              try {
                for (var f = nl(s), g = f.next(); !g.done; g = f.next()) {
                  var d = g.value;
                  d();
                }
              } catch (m) {
                u = { error: m };
              } finally {
                try {
                  g && !g.done && (c = f.return) && c.call(f);
                } finally {
                  if (u) throw u.error;
                }
              }
            }), h.label = 1;
          case 1:
            return h.trys.push([1, , 3, 4]), [4, Promise.all(t.map(function(u, c) {
              return Na(l, void 0, void 0, function() {
                var f, g;
                return As(this, function(d) {
                  switch (d.label) {
                    case 0:
                      d.trys.push([0, , 6, 9]), d.label = 1;
                    case 1:
                      return o ? [3, 5] : (Promise.resolve(u.next()).then(function(m) {
                        return s[c](m);
                      }, function(m) {
                        return r(m);
                      }), [4, new Promise(function(m) {
                        s[c] = m;
                      })]);
                    case 2:
                      return f = d.sent(), f === void 0 ? [3, 4] : f.done ? (a = f, [
                        2
                        /*return*/
                      ]) : [4, n(f.value)];
                    case 3:
                      d.sent(), d.label = 4;
                    case 4:
                      return [3, 1];
                    case 5:
                      return [3, 9];
                    case 6:
                      return g = u.return, g ? [4, u.return()] : [3, 8];
                    case 7:
                      g = d.sent(), d.label = 8;
                    case 8:
                      return [
                        7
                        /*endfinally*/
                      ];
                    case 9:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 2:
            return h.sent(), [2, a && a.value];
          case 3:
            return r(), [
              7
              /*endfinally*/
            ];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function q9(i) {
  var e = this, t = _d(i, { returnValues: !0 });
  return new tu(function(n, r) {
    return Na(e, void 0, void 0, function() {
      var s, o, a, l;
      return As(this, function(h) {
        switch (h.label) {
          case 0:
            if (!t.length)
              return r(), [2, []];
            o = !1, r.then(function() {
              s(), o = !0;
            }), h.label = 1;
          case 1:
            h.trys.push([1, , 6, 8]), h.label = 2;
          case 2:
            return o ? [3, 5] : (Promise.all(t.map(function(u) {
              return u.next();
            })).then(function(u) {
              return s(u);
            }, function(u) {
              return r(u);
            }), [4, new Promise(function(u) {
              return s = u;
            })]);
          case 3:
            return a = h.sent(), a === void 0 ? [
              2
              /*return*/
            ] : (l = a.map(function(u) {
              return u.value;
            }), a.some(function(u) {
              return u.done;
            }) ? [2, l] : [4, n(l)]);
          case 4:
            return h.sent(), [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return r(), [4, Promise.all(t.map(function(u) {
              return u.return && u.return();
            }))];
          case 7:
            return h.sent(), [
              7
              /*endfinally*/
            ];
          case 8:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function Z9(i) {
  var e = this, t = _d(i, {
    yieldValues: !0,
    returnValues: !0
  });
  return new tu(function(n, r) {
    return Na(e, void 0, void 0, function() {
      var s, o, a, l, h, u = this;
      return As(this, function(c) {
        switch (c.label) {
          case 0:
            if (!t.length)
              return r(), [2, []];
            o = [], a = !1, r.then(function() {
              var f, g;
              s();
              try {
                for (var d = nl(o), m = d.next(); !m.done; m = d.next()) {
                  var x = m.value;
                  x();
                }
              } catch (v) {
                f = { error: v };
              } finally {
                try {
                  m && !m.done && (g = d.return) && g.call(d);
                } finally {
                  if (f) throw f.error;
                }
              }
              a = !0;
            }), c.label = 1;
          case 1:
            return c.trys.push([1, , 5, 7]), Promise.all(t.map(function(f) {
              return f.next();
            })).then(function(f) {
              return s(f);
            }, function(f) {
              return r(f);
            }), [4, new Promise(function(f) {
              return s = f;
            })];
          case 2:
            return l = c.sent(), l === void 0 ? [
              2
              /*return*/
            ] : (h = l.map(function(f) {
              return f.value;
            }), l.every(function(f) {
              return f.done;
            }) ? [2, h] : [4, n(h.slice())]);
          case 3:
            return c.sent(), [4, Promise.all(t.map(function(f, g) {
              return Na(u, void 0, void 0, function() {
                var d;
                return As(this, function(m) {
                  switch (m.label) {
                    case 0:
                      if (l[g].done)
                        return [2, l[g].value];
                      m.label = 1;
                    case 1:
                      return a ? [3, 4] : (Promise.resolve(f.next()).then(function(x) {
                        return o[g](x);
                      }, function(x) {
                        return r(x);
                      }), [4, new Promise(function(x) {
                        return o[g] = x;
                      })]);
                    case 2:
                      return d = m.sent(), d === void 0 ? [2, l[g].value] : d.done ? [2, d.value] : (h[g] = d.value, [4, n(h.slice())]);
                    case 3:
                      return m.sent(), [3, 1];
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 4:
            return [2, c.sent()];
          case 5:
            return r(), [4, Promise.all(t.map(function(f) {
              return f.return && f.return();
            }))];
          case 6:
            return c.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
class M_ {
  headerClient;
  header;
  headerLength;
  indexLength;
  nocache;
  headers;
  constructor(e, t, n, r, s, o = {}) {
    this.headerClient = e, this.header = t, this.headerLength = n, this.indexLength = r, this.nocache = s, this.headers = o;
  }
  static async open(e, t, n = {}) {
    let r, s = new cE(e, t, n), o = 2024 + (() => {
      let u, c = 0;
      for (u = 0; u < 3; u++) c += U9 ** u * k9;
      return c;
    })();
    if (!new Uint8Array(await s.getRange(0, 8, o, "header")).subarray(0, 3).every((u, c) => Lr[c] === u)) throw Error("Not a FlatGeobuf file");
    if ((r = new DataView(await s.getRange(8, 4, o, "header")).getUint32(0, !0)) > 10485760 || r < 8) throw Error("Invalid header size");
    let a = await s.getRange(12, r, o, "header"), l = gd(new Yn(new Uint8Array(a)));
    if (l.indexNodeSize === 0) throw Error("No index found, cannot read features filtered by bbox");
    let h = md(l.featuresCount, l.indexNodeSize);
    return new M_(s, l, r, h, t, n);
  }
  async *selectBbox(e) {
    let t = this.lengthBeforeTree(), n = this.headerClient, r = async (l, h) => n.getRange(t + l, h, 0, "index"), s = [], o = [];
    for await (let l of xT(this.header.featuresCount, this.header.indexNodeSize, e, r)) {
      let [h, u] = l, [, , c] = l;
      if (c || (c = 4), o.length === 0) {
        o.push([h, c, u]);
        continue;
      }
      let f = o[o.length - 1];
      h - (f[0] + f[1]) > pd.global.extraRequestThreshold() && (s.push(o), o = []), o.push([h, c, u]);
    }
    this.headerClient.logUsage("header+index"), o.length > 0 && s.push(o);
    let a = s.flatMap((l) => this.readFeatureBatch(l, this.nocache));
    yield* tu.merge(a);
  }
  lengthBeforeTree() {
    return Lr.length + an + this.headerLength;
  }
  lengthBeforeFeatures() {
    return this.lengthBeforeTree() + this.indexLength;
  }
  buildFeatureClient(e) {
    return new cE(this.headerClient.httpClient, e, this.headers);
  }
  async *readFeatureBatch(e, t) {
    let [n] = e[0], [r, s] = e[e.length - 1], o = this.buildFeatureClient(t), a = r + s - n;
    for (let [l, , h] of e) {
      let u = await this.readFeature(o, l, a);
      yield { id: h, feature: u }, a = 0;
    }
    o.logUsage("feature");
  }
  async readFeature(e, t, n) {
    let r, s = t + this.lengthBeforeFeatures();
    r = new DataView(await e.getRange(s, 4, n, "feature length")).getUint32(0, !0);
    let o = new Uint8Array(await e.getRange(s + 4, r, n, "feature data")), a = new Uint8Array(r + an);
    a.set(o, an);
    let l = new Yn(a);
    return l.setPosition(an), yn.getRootAsFeature(l);
  }
}
class cE {
  httpClient;
  bytesEverUsed = 0;
  bytesEverFetched = 0;
  buffer = new ArrayBuffer(0);
  head = 0;
  constructor(e, t, n = {}) {
    if (typeof e == "string") this.httpClient = new fE(e, t, n);
    else if (e instanceof fE) this.httpClient = e;
    else throw Error("Unknown source");
  }
  async getRange(e, t, n, r) {
    this.bytesEverUsed += t;
    let s = e - this.head, o = s + t;
    if (s >= 0 && o <= this.buffer.byteLength) return this.buffer.slice(s, o);
    let a = Math.max(t, n);
    return this.bytesEverFetched += a, this.buffer = await this.httpClient.getRange(e, a, r), this.head = e, this.buffer.slice(0, t);
  }
  logUsage(e) {
    e.split(" ")[0], (100 * this.bytesEverUsed / this.bytesEverFetched).toFixed(2);
  }
}
class fE {
  url;
  nocache;
  headers;
  requestsEverMade = 0;
  bytesEverRequested = 0;
  constructor(e, t, n = {}) {
    this.url = e, this.nocache = t, this.headers = n;
  }
  async getRange(e, t, n) {
    this.requestsEverMade += 1, this.bytesEverRequested += t;
    let r = `bytes=${e}-${e + t - 1}`, s = new Headers(this.headers);
    return s.set("Range", r), this.nocache && s.set("Cache-Control", "no-cache, no-store"), await (await fetch(this.url, { headers: s })).arrayBuffer();
  }
}
async function* H9(i, e, t, n) {
  if (!i.subarray(0, 3).every((c, f) => Lr[f] === c)) throw Error("Not a FlatGeobuf file");
  if (t) {
    let c = R_.open(i);
    for await (let f of c.selectBbox(t)) yield e(f.id, f.feature, c.header);
    return;
  }
  let r = new Yn(i), s = r.readUint32(Lr.length);
  r.setPosition(Lr.length + an);
  let o = gd(r), a = Lr.length + an + s, { indexNodeSize: l, featuresCount: h } = o;
  l > 0 && (a += md(h, l));
  let u = 0;
  for (; a < r.capacity(); ) {
    let c = r.readUint32(a);
    r.setPosition(a + an);
    let f = yn.getRootAsFeature(r);
    yield e(u++, f, o), a += an + c;
  }
}
async function* K9(i, e, t) {
  let n, r = G9(i), s = async (g) => await r.slice(g), o = new Uint8Array(await s(8));
  if (!o.subarray(0, 3).every((g, d) => Lr[d] === g)) throw Error("Not a FlatGeobuf file");
  o = new Uint8Array(await s(4));
  let a = new Yn(o), l = a.readUint32(0);
  o = new Uint8Array(await s(l));
  let h = gd(a = new Yn(o)), { indexNodeSize: u, featuresCount: c } = h;
  if (u > 0) {
    let g = md(c, u);
    await s(g);
  }
  let f = 0;
  for (; n = await Q9(s, h, e, f++); ) yield n;
}
async function* J9(i, e, t, n, r = !1, s = {}) {
  let o = await M_.open(i, r, s);
  for await (let a of o.selectBbox(e)) yield t(a.id, a.feature, o.header);
}
async function Q9(i, e, t, n) {
  let r = new Uint8Array(await i(4, "feature length"));
  if (r.byteLength === 0) return;
  let s = new Yn(r), o = s.readUint32(0);
  r = new Uint8Array(await i(o, "feature data"));
  let a = new Uint8Array(o + 4);
  return a.set(r, 4), (s = new Yn(a)).setPosition(an), t(n, yn.getRootAsFeature(s), e);
}
function Up(i, e) {
  let t = e;
  if (t === xi.Unknown && (t = i.type()), t === xi.GeometryCollection) {
    let r = [];
    for (let s = 0; s < i.partsLength(); s++) {
      let o = i.parts(s), a = o.type();
      r.push(Up(o, a));
    }
    return { type: xi[t], geometries: r };
  }
  if (t === xi.MultiPolygon) {
    let r = [];
    for (let s = 0; s < i.partsLength(); s++) r.push(Up(i.parts(s), xi.Polygon));
    return { type: xi[t], coordinates: r.map((s) => s.coordinates) };
  }
  let n = (function(r, s) {
    let o = r.xyArray(), a = r.zArray();
    switch (s) {
      case xi.Point: {
        let l = Array.from(o);
        return a && l.push(a[0]), l;
      }
      case xi.MultiPoint:
      case xi.LineString:
        return bg(o, a);
      case xi.MultiLineString:
      case xi.Polygon:
        return (function(l, h, u) {
          let c;
          if (!u || u.length === 0) return [bg(l, h)];
          let f = 0, g = Array.from(u).map((d) => l.slice(f, f = d << 1));
          return h && (f = 0, c = Array.from(u).map((d) => h.slice(f, f = d))), g.map((d, m) => bg(d, c ? c[m] : void 0));
        })(o, a, r.endsArray());
    }
  })(i, t);
  return { type: xi[t], coordinates: n };
}
function C_(i, e, t) {
  let n = t.columns;
  return { type: "Feature", id: i, geometry: Up(e.geometry(), t.geometryType), properties: L9(e, n) };
}
async function* e$(i, e, t) {
  yield* H9(i, C_, e);
}
function t$(i, e) {
  return K9(i, C_);
}
function i$(i, e, t, n = !1, r = {}) {
  return J9(i, e, C_, t, n, r);
}
function n$(i, e, t, n = !1, r = {}) {
  return i instanceof Uint8Array ? e$(i, e) : i instanceof ReadableStream ? t$(i) : i$(i, e, t, n, r);
}
const r$ = {
  dataProjection: "EPSG:4326"
};
class s$ extends ys {
  /**
   * @param {FlatGeoBufOptions} options
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      wrapX: e.wrapX,
      strategy: rw
    }), this.dataProjection = e.projection || r$.dataProjection, this.resourceURL = e.url, super.setLoader(this.loader);
  }
  /**
   * transform an ol extent into FlatGeoBuf-format
   * @param {import("ol/extent").Extent} extent
   * @param {import("ol/proj").Projection} projection
   * @returns
   */
  fgbBoundingBox(e, t) {
    const n = Or(
      e,
      t.getCode(),
      this.dataProjection
    );
    return {
      minX: n[0],
      minY: n[1],
      maxX: n[2],
      maxY: n[3]
    };
  }
  /**
   * @type {import("ol/featureloader").FeatureLoader}
   * @this {FlatGeoBuf}
   */
  async loader(e, t, n, r, s) {
    const o = this.fgbBoundingBox(e, n);
    try {
      if (o.minX !== -1 / 0) {
        const a = [], l = n$(this.resourceURL, o), h = new Dc({
          featureProjection: n,
          dataProjection: this.dataProjection
        });
        for await (const u of l) {
          const c = h.readFeature(u);
          a.push(c);
        }
        super.clear(), super.addFeatures(a), r(a);
      }
    } catch {
      s();
    }
  }
}
window.eoxMapAdvancedOlSources = {
  BingMaps: K7,
  CartoDB: J7,
  Cluster: af,
  DataTile: Bh,
  GeoTIFF: R0,
  Google: e9,
  IIIF: i9,
  Image: To,
  ImageArcGISRest: r9,
  ImageCanvas: s9,
  ImageMapGuide: h9,
  ImageStatic: Tb,
  ImageTile: mT,
  OGCMapTile: _9,
  OGCVectorTile: y9,
  Raster: g_,
  Source: vo,
  StadiaMaps: T9,
  TileArcGISRest: R9,
  TileDebug: P9,
  TileImage: Ln,
  TileJSON: qf,
  UrlTile: $h,
  UTFGrid: C9,
  Zoomify: t9,
  WMTSCapabilities: I9,
  FlatGeoBuf: s$
};
export {
  x$ as L,
  E$ as a,
  jf as g
};
