{"version":3,"file":"itemfilter.stories-00c2bfa2.js","sources":["../../node_modules/lit/node_modules/lit-html/directives/repeat.js","../../elements/itemfilter/src/style.ts","../../elements/itemfilter/src/style.eox.ts","../../elements/itemfilter/src/filters/_expandcontainer.ts","../../elements/itemfilter/src/filters/multiselect.ts","../../node_modules/lodash.debounce/index.js","../../elements/itemfilter/src/filters/range.ts","../../elements/itemfilter/src/filters/select.ts","../../node_modules/@turf/helpers/dist/es/index.js","../../node_modules/@turf/invariant/dist/es/index.js","../../node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","../../node_modules/@turf/meta/dist/es/index.js","../../node_modules/@turf/line-segment/dist/es/index.js","../../node_modules/@turf/bbox/dist/es/index.js","../../node_modules/geojson-rbush/index.js","../../node_modules/@turf/line-intersect/dist/es/index.js","../../node_modules/@turf/polygon-to-line/dist/es/index.js","../../node_modules/@turf/boolean-disjoint/dist/es/index.js","../../node_modules/@turf/boolean-intersects/dist/es/index.js","../../node_modules/@turf/boolean-point-on-line/dist/es/index.js","../../node_modules/@turf/boolean-within/dist/es/index.js","../../elements/itemfilter/src/filters/spatial.ts","../../elements/itemfilter/src/filters/text.ts","../../node_modules/fuse.js/dist/fuse.mjs","../../elements/itemfilter/src/itemHighlighting.ts","../../elements/itemfilter/src/filterClient.ts","../../elements/itemfilter/src/filterExternal.ts","../../elements/itemfilter/src/main.ts"],"sourcesContent":["import{noChange as e}from\"../lit-html.js\";import{directive as s,Directive as t,PartType as r}from\"../directive.js\";import{getCommittedValue as l,setChildPartValue as o,insertPart as i,removePart as n,setCommittedValue as f}from\"../directive-helpers.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst u=(e,s,t)=>{const r=new Map;for(let l=s;l<=t;l++)r.set(e[l],l);return r},c=s(class extends t{constructor(e){if(super(e),e.type!==r.CHILD)throw Error(\"repeat() can only be used in text expressions\")}ht(e,s,t){let r;void 0===t?t=s:void 0!==s&&(r=s);const l=[],o=[];let i=0;for(const s of e)l[i]=r?r(s,i):i,o[i]=t(s,i),i++;return{values:o,keys:l}}render(e,s,t){return this.ht(e,s,t).values}update(s,[t,r,c]){const d=l(s),{values:p,keys:a}=this.ht(t,r,c);if(!Array.isArray(d))return this.dt=a,p;const h=this.dt??=[],v=[];let m,y,x=0,j=d.length-1,k=0,w=p.length-1;for(;x<=j&&k<=w;)if(null===d[x])x++;else if(null===d[j])j--;else if(h[x]===a[k])v[k]=o(d[x],p[k]),x++,k++;else if(h[j]===a[w])v[w]=o(d[j],p[w]),j--,w--;else if(h[x]===a[w])v[w]=o(d[x],p[w]),i(s,v[w+1],d[x]),x++,w--;else if(h[j]===a[k])v[k]=o(d[j],p[k]),i(s,d[x],d[j]),j--,k++;else if(void 0===m&&(m=u(a,k,w),y=u(h,x,j)),m.has(h[x]))if(m.has(h[j])){const e=y.get(a[k]),t=void 0!==e?d[e]:null;if(null===t){const e=i(s,d[x]);o(e,p[k]),v[k]=e}else v[k]=o(t,p[k]),i(s,d[x],t),d[e]=null;k++}else n(d[j]),j--;else n(d[x]),x++;for(;k<=w;){const e=i(s,v[w+1]);o(e,p[k]),v[k++]=e}for(;x<=j;){const e=d[x++];null!==e&&n(e)}return this.dt=a,f(s,v),e}});export{c as repeat};\n//# sourceMappingURL=repeat.js.map\n","export const style = `\n:host {\n  display: flex;\n  box-sizing: border-box;\n  height: 100%;\n}\n*,\n*:before,\n*:after {\n  box-sizing: inherit;\n}\nform#itemfilter {\n  height: 100%;\n  width: 100%;\n  max-width: 100%;\n  display: flex;\n  flex-direction: column;\n}\ndetails {\n  width: 100%;\n}\n`;\n","import { button } from \"../../../utils/styles/button\";\nimport { checkbox } from \"../../../utils/styles/checkbox\";\nimport { radio } from \"../../../utils/styles/radio\";\nimport { slider } from \"../../../utils/styles/slider\";\n\nexport const styleEOX = `\n* {\n  font-family: Roboto, sans-serif;\n}\n\n${button}\n${checkbox}\n${radio}\n${slider}\n\nul {\n  padding-left: 0;\n  margin-top: 0;\n}\nli {\n  list-style: none;\n}\nli span {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\nli label {\n  display: flex;\n  align-items: center;\n}\ndetails summary > * {\n  display: inline;\n}\ndetails summary {\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid #0002;\n  padding: .5rem 0;\n}\n\ndetails > summary::-webkit-details-marker {\n  display: none;\n}\n\n.title {\n  font-size: small;\n  align-items: center;\n}\ndetails summary .title {\n  display: flex;\n  font-weight: 500;\n}\ndetails.details-filter summary::after,\ndetails.details-results summary::before {\n  content: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%230009' viewBox='0 0 24 24'%3E%3Ctitle%3Echevron-right%3C/title%3E%3Cpath d='M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z' /%3E%3C/svg%3E\");\n  height: 24px;\n  width: 24px;\n}\ndetails.details-filter summary::after {\n  position: absolute;\n  right: 8px;\n  transform: rotate(90deg);\n}\ndetails[open] summary::before {\n  transform: rotate(90deg);\n}\ndetails[open] summary::after {\n  transform: rotate(270deg);\n}\neox-itemfilter-expandcontainer {\n  max-height: 200px;\n}\neox-itemfilter-expandcontainer > [data-type=filter] {\n  display: block;\n  height: calc(100% - 32px);\n  overflow-y: auto;\n}\n[data-type=filter] .title,\ndetails summary {\n  text-transform: capitalize;\n}\nli,\nlabel,\ndetails,\ninput[type=\"checkbox\"],\ninput[type=\"radio\"] {\n  cursor: pointer;\n}\ninput[type=\"checkbox\"],\ninput[type=\"radio\"] {\n  margin: 0;\n}\ninput[type=\"text\"] {\n  box-sizing: border-box;\n  width: 100%;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n  padding: 5px 7px;\n  border-radius: 4px;\n  border: 1px solid #0004;\n}\nsection:not(section:last-of-type) {\n  margin-bottom: 1rem;\n}\n#section-results {\n  overflow: hidden;\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\nul li {\n  padding-left: 0;\n}\neox-itemfilter-expandcontainer ul li,\ndetails ul li {\n  padding: 0.2rem;\n}\nli.highlighted {\n  background: #00417011;\n}\nsection {\n  position: relative;\n}\nbutton#filter-reset {\n  position: absolute;\n  top: 4px;\n  right: 0;\n  text-indent: -9999px;\n  line-height: 0;\n}\nbutton#filter-reset:after {\n  content: \"Reset\";\n  text-indent: 0px;\n  line-height: initial;\n}\n.scroll {\n  height: 100%;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.count {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background: #00417044;\n  padding: 0 12px;\n  height: 20px;\n  border-radius: 10px;\n  color: #004170;\n  font-weight: 500;\n  margin-left: 9px;\n}\neox-itemfilter-range {\n  display: flex;\n  align-items: center;\n  padding: .5rem 0;\n}\n.range-before,\n.range-after {\n  font-size: small;\n}\n.range-before {\n  margin-right: .5rem;\n}\n.range-after {\n  margin-left: .5rem;\n}\n`;\n","import { LitElement, html, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators.js\";\nimport { style } from \"../style\";\nimport { styleEOX } from \"../style.eox\";\n\n@customElement(\"eox-itemfilter-expandcontainer\")\nexport class EOxItemFilterExpandContainer extends LitElement {\n  @property({ attribute: false })\n  filterObject: FilterObject;\n\n  @property()\n  unstyled: boolean;\n\n  handleDetailsToggle(event: Event) {\n    this.dispatchEvent(\n      new CustomEvent(\"details-toggled\", {\n        detail: event,\n        bubbles: true,\n        composed: true,\n      })\n    );\n  }\n\n  render() {\n    return html`\n      <style>\n        ${style}\n        ${!this.unstyled && styleEOX}\n      </style>\n      <details\n        @toggle=\"${this.handleDetailsToggle}\"\n        class=\"details-filter\"\n        part=\"details-filter\"\n        open=${this.filterObject.expanded || nothing}\n      >\n        <summary>\n          <span\n            class=\"title\"\n            style=\"${!this.filterObject.title && \"text-transform: capitalize\"}\"\n          >\n            ${this.filterObject.title || this.filterObject.key || \"Filter\"}\n          </span>\n        </summary>\n        <div class=\"scroll\">\n          <slot name=\"filter\"></slot>\n        </div>\n      </details>\n    `;\n  }\n}\n","import { LitElement, html, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators.js\";\nimport { map } from \"lit/directives/map.js\";\n\n@customElement(\"eox-itemfilter-multiselect\")\nexport class EOxItemFilterMultiselect extends LitElement {\n  @property()\n  filterObject: FilterObject;\n\n  public reset() {\n    this.renderRoot\n      .querySelectorAll(\"input[type='checkbox']\")\n      .forEach((f: Element) => {\n        if (f instanceof HTMLInputElement) {\n          f.checked = false;\n        }\n      });\n    for (const filter in this.filterObject.state) {\n      // @ts-ignore\n      this.filterObject.state[filter] = false;\n    }\n    delete this.filterObject.dirty;\n    this.requestUpdate();\n  }\n\n  // skip shadow root creation\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    return html`\n      <ul>\n        ${map(\n          Object.keys(this.filterObject.state).sort((a, b) =>\n            a.localeCompare(b)\n          ),\n          (key) => html`\n            <li class=${this.filterObject.state[key] ? \"highlighted\" : nothing}>\n              <label>\n                <input\n                  data-cy=\"multiselect-checkbox\"\n                  name=\"selection\"\n                  type=\"checkbox\"\n                  class=\"multiselect-checkbox\"\n                  id=${key}\n                  checked=\"${this.filterObject.state[key] || nothing}\"\n                  @click=${() => {\n                    // @ts-ignore\n                    this.filterObject.state[key] =\n                      !this.filterObject.state[key];\n                    this.filterObject.dirty = true;\n                    this.dispatchEvent(new CustomEvent(\"filter\"));\n                    this.requestUpdate();\n                  }}\n                />\n                <span class=\"title\">${key}</span>\n              </label>\n            </li>\n          `\n        )}\n      </ul>\n    `;\n  }\n}\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n","import { LitElement, html } from \"lit\";\nimport { customElement, property } from \"lit/decorators.js\";\nimport dayjs from \"dayjs\";\nimport _debounce from \"lodash.debounce\";\n\n@customElement(\"eox-itemfilter-range\")\nexport class EOxItemFilterRange extends LitElement {\n  @property()\n  filterObject: RangeFilterObject;\n\n  inputHandler = (evt: CustomEvent) => {\n    const [min, max] = evt.detail.values;\n    if (\n      min !== this.filterObject.state.min ||\n      max != this.filterObject.state.max\n    ) {\n      [this.filterObject.state.min, this.filterObject.state.max] = [min, max];\n      this.filterObject.dirty = true;\n    }\n    this.dispatchEvent(new CustomEvent(\"filter\"));\n    this.requestUpdate();\n  };\n\n  debouncedInputHandler = _debounce(this.inputHandler, 0, {\n    leading: true,\n  });\n\n  public reset() {\n    // @ts-ignore\n    this.filterObject.state.min = this.filterObject.min;\n    // @ts-ignore\n    this.filterObject.state.max = this.filterObject.max;\n    delete this.filterObject.dirty;\n    this.requestUpdate();\n  }\n\n  // skip shadow root creation\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    return html`\n      <div class=\"range-before\">\n        ${this.filterObject.format === \"date\"\n          ? // @ts-ignore\n            dayjs.unix(this.filterObject.state.min)\n          : this.filterObject.state.min}\n      </div>\n      <tc-range-slider\n        min=\"${this.filterObject.min}\"\n        max=\"${this.filterObject.max}\"\n        value1=\"${this.filterObject.state.min}\"\n        value2=\"${this.filterObject.state.max}\"\n        step=\"1\"\n        @change=\"${this.debouncedInputHandler}\"\n      ></tc-range-slider>\n      <div class=\"range-after\">\n        ${this.filterObject.format === \"date\"\n          ? // @ts-ignore\n            dayjs.unix(this.filterObject.state.max)\n          : this.filterObject.state.max}\n      </div>\n    `;\n  }\n}\n","import { LitElement, html, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators.js\";\nimport { map } from \"lit/directives/map.js\";\n\n@customElement(\"eox-itemfilter-select\")\nexport class EOxItemFilterSelect extends LitElement {\n  @property()\n  filterObject: FilterObject;\n\n  public reset() {\n    this.renderRoot\n      .querySelectorAll(\"input[type='radio']\")\n      .forEach((f: Element) => {\n        if (f instanceof HTMLInputElement) {\n          f.checked = false;\n        }\n      });\n    for (const filter in this.filterObject.state) {\n      // @ts-ignore\n      this.filterObject.state[filter] = false;\n    }\n    delete this.filterObject.dirty;\n    this.requestUpdate();\n  }\n\n  // skip shadow root creation\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    return html`\n      <ul>\n        ${map(\n          Object.keys(this.filterObject.state).sort((a, b) =>\n            a.localeCompare(b)\n          ),\n          (key) => html`\n            <li class=${this.filterObject.state[key] ? \"highlighted\" : nothing}>\n              <label>\n                <input\n                  name=\"selection\"\n                  type=\"radio\"\n                  class=\"select-radio\"\n                  id=${key}\n                  checked=\"${this.filterObject.state[key] || nothing}\"\n                  @click=${() => {\n                    for (const el in this.filterObject.state) {\n                      // @ts-ignore\n                      this.filterObject.state[el] = el === key;\n                    }\n                    this.filterObject.dirty = true;\n                    this.dispatchEvent(new CustomEvent(\"filter\"));\n                    this.requestUpdate();\n                  }}\n                />\n                <span class=\"title\">${key}</span>\n              </label>\n            </li>\n          `\n        )}\n      </ul>\n    `;\n  }\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import { featureCollection, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = x1 < x2 ? x1 : x2;\n    var south = y1 < y2 ? y1 : y2;\n    var east = x1 > x2 ? x1 : x2;\n    var north = y1 > y2 ? y1 : y2;\n    return [west, south, east, north];\n}\nexport default lineSegment;\n","import { coordEach } from \"@turf/meta\";\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexport default bbox;\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = new rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","import { feature, featureCollection, point, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport lineSegment from \"@turf/line-segment\";\nimport { featureEach } from \"@turf/meta\";\nimport rbush from \"geojson-rbush\";\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + uA * (x2 - x1);\n        var y = y1 + uA * (y2 - y1);\n        return point([x, y]);\n    }\n    return null;\n}\nexport default lineIntersect;\n","import { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a\n * {@link FeatureCollection} of {@link LineString|(Multi)LineString}.\n *\n * @name polygonToLine\n * @param {Feature<Polygon|MultiPolygon>} poly Feature to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString\n * @example\n * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);\n *\n * var line = turf.polygonToLine(poly);\n *\n * //addToMap\n * var addToMap = [line];\n */\nexport default function (poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    if (!options.properties && poly.type === \"Feature\") {\n        options.properties = poly.properties;\n    }\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonToLine(geom, options);\n        case \"MultiPolygon\":\n            return multiPolygonToLine(geom, options);\n        default:\n            throw new Error(\"invalid poly\");\n    }\n}\n/**\n * @private\n */\nexport function polygonToLine(poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : poly.type === \"Feature\"\n            ? poly.properties\n            : {};\n    return coordsToLine(coords, properties);\n}\n/**\n * @private\n */\nexport function multiPolygonToLine(multiPoly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(multiPoly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : multiPoly.type === \"Feature\"\n            ? multiPoly.properties\n            : {};\n    var lines = [];\n    coords.forEach(function (coord) {\n        lines.push(coordsToLine(coord, properties));\n    });\n    return featureCollection(lines);\n}\n/**\n * @private\n */\nexport function coordsToLine(coords, properties) {\n    if (coords.length > 1) {\n        return multiLineString(coords, properties);\n    }\n    return lineString(coords[0], properties);\n}\n","import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport polygonToLine from \"@turf/polygon-to-line\";\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(feature1, feature2) {\n    var bool = true;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === false) {\n                return false;\n            }\n            bool = disjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1, geom2) {\n    switch (geom1.type) {\n        case \"Point\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !compareCoords(geom1.coordinates, geom2.coordinates);\n                case \"LineString\":\n                    return !isPointOnLine(geom2, geom1);\n                case \"Polygon\":\n                    return !booleanPointInPolygon(geom1, geom2);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"LineString\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !isPointOnLine(geom1, geom2);\n                case \"LineString\":\n                    return !isLineOnLine(geom1, geom2);\n                case \"Polygon\":\n                    return !isLineInPoly(geom2, geom1);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"Polygon\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !booleanPointInPolygon(geom2, geom1);\n                case \"LineString\":\n                    return !isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return !isPolyInPoly(geom2, geom1);\n            }\n    }\n    return false;\n}\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString, pt) {\n    for (var i = 0; i < lineString.coordinates.length - 1; i++) {\n        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n    var doLinesIntersect = lineIntersect(lineString1, lineString2);\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isLineInPoly(polygon, lineString) {\n    for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (booleanPointInPolygon(coord, polygon)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {\n        var coord1 = _a[_i];\n        if (booleanPointInPolygon(coord1, feature2)) {\n            return true;\n        }\n    }\n    for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {\n        var coord2 = _c[_b];\n        if (booleanPointInPolygon(coord2, feature1)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n    var dxc = pt[0] - lineSegmentStart[0];\n    var dyc = pt[1] - lineSegmentStart[1];\n    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n        if (dxl > 0) {\n            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n        }\n        else {\n            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n        }\n    }\n    else if (dyl > 0) {\n        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n    }\n    else {\n        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n    }\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport default booleanDisjoint;\n","import booleanDisjoint from \"@turf/boolean-disjoint\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Boolean-intersects returns (TRUE) two geometries intersect.\n *\n * @name booleanIntersects\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanIntersects(line, point);\n * //=true\n */\nexport default function booleanIntersects(feature1, feature2) {\n    var bool = false;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === true) {\n                return true;\n            }\n            bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n","import { getCoord, getCoords } from \"@turf/invariant\";\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Normalize inputs\n    var ptCoords = getCoord(pt);\n    var lineCoords = getCoords(line);\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (options.ignoreEndVertices) {\n            if (i === 0) {\n                ignoreBoundary = \"start\";\n            }\n            if (i === lineCoords.length - 2) {\n                ignoreBoundary = \"end\";\n            }\n            if (i === 0 && i + 1 === lineCoords.length - 1) {\n                ignoreBoundary = \"both\";\n            }\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === \"undefined\" ? null : options.epsilon)) {\n            return true;\n        }\n    }\n    return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n// See https://stackoverflow.com/a/328122/1048847\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (epsilon !== null) {\n        if (Math.abs(cross) > epsilon) {\n            return false;\n        }\n    }\n    else if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    }\n    else if (excludeBoundary === \"start\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    }\n    else if (excludeBoundary === \"end\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    }\n    else if (excludeBoundary === \"both\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n    return false;\n}\nexport default booleanPointOnLine;\n","import calcBbox from \"@turf/bbox\";\nimport booleanPointOnLine from \"@turf/boolean-point-on-line\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Boolean-within returns true if the first geometry is completely within the second geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the primary (geometry a)\n * must not intersect the exterior of the secondary (geometry b).\n * Boolean-within returns the exact opposite result of the `@turf/boolean-contains`.\n *\n * @name booleanWithin\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanWithin(point, line);\n * //=true\n */\nfunction booleanWithin(feature1, feature2) {\n    var geom1 = getGeom(feature1);\n    var geom2 = getGeom(feature2);\n    var type1 = geom1.type;\n    var type2 = geom2.type;\n    switch (type1) {\n        case \"Point\":\n            switch (type2) {\n                case \"MultiPoint\":\n                    return isPointInMultiPoint(geom1, geom2);\n                case \"LineString\":\n                    return booleanPointOnLine(geom1, geom2, { ignoreEndVertices: true });\n                case \"Polygon\":\n                case \"MultiPolygon\":\n                    return booleanPointInPolygon(geom1, geom2, { ignoreBoundary: true });\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"MultiPoint\":\n            switch (type2) {\n                case \"MultiPoint\":\n                    return isMultiPointInMultiPoint(geom1, geom2);\n                case \"LineString\":\n                    return isMultiPointOnLine(geom1, geom2);\n                case \"Polygon\":\n                case \"MultiPolygon\":\n                    return isMultiPointInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"LineString\":\n            switch (type2) {\n                case \"LineString\":\n                    return isLineOnLine(geom1, geom2);\n                case \"Polygon\":\n                case \"MultiPolygon\":\n                    return isLineInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"Polygon\":\n            switch (type2) {\n                case \"Polygon\":\n                case \"MultiPolygon\":\n                    return isPolyInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        default:\n            throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n    }\n}\nfunction isPointInMultiPoint(point, multiPoint) {\n    var i;\n    var output = false;\n    for (i = 0; i < multiPoint.coordinates.length; i++) {\n        if (compareCoords(multiPoint.coordinates[i], point.coordinates)) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nfunction isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n    for (var i = 0; i < multiPoint1.coordinates.length; i++) {\n        var anyMatch = false;\n        for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {\n            if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {\n                anyMatch = true;\n            }\n        }\n        if (!anyMatch) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isMultiPointOnLine(multiPoint, lineString) {\n    var foundInsidePoint = false;\n    for (var i = 0; i < multiPoint.coordinates.length; i++) {\n        if (!booleanPointOnLine(multiPoint.coordinates[i], lineString)) {\n            return false;\n        }\n        if (!foundInsidePoint) {\n            foundInsidePoint = booleanPointOnLine(multiPoint.coordinates[i], lineString, { ignoreEndVertices: true });\n        }\n    }\n    return foundInsidePoint;\n}\nfunction isMultiPointInPoly(multiPoint, polygon) {\n    var output = true;\n    var oneInside = false;\n    var isInside = false;\n    for (var i = 0; i < multiPoint.coordinates.length; i++) {\n        isInside = booleanPointInPolygon(multiPoint.coordinates[1], polygon);\n        if (!isInside) {\n            output = false;\n            break;\n        }\n        if (!oneInside) {\n            isInside = booleanPointInPolygon(multiPoint.coordinates[1], polygon, {\n                ignoreBoundary: true,\n            });\n        }\n    }\n    return output && isInside;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n    for (var i = 0; i < lineString1.coordinates.length; i++) {\n        if (!booleanPointOnLine(lineString1.coordinates[i], lineString2)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isLineInPoly(linestring, polygon) {\n    var polyBbox = calcBbox(polygon);\n    var lineBbox = calcBbox(linestring);\n    if (!doBBoxOverlap(polyBbox, lineBbox)) {\n        return false;\n    }\n    var foundInsidePoint = false;\n    for (var i = 0; i < linestring.coordinates.length - 1; i++) {\n        if (!booleanPointInPolygon(linestring.coordinates[i], polygon)) {\n            return false;\n        }\n        if (!foundInsidePoint) {\n            foundInsidePoint = booleanPointInPolygon(linestring.coordinates[i], polygon, { ignoreBoundary: true });\n        }\n        if (!foundInsidePoint) {\n            var midpoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n            foundInsidePoint = booleanPointInPolygon(midpoint, polygon, {\n                ignoreBoundary: true,\n            });\n        }\n    }\n    return foundInsidePoint;\n}\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Polygon} geometry1\n * @param {Polygon|MultiPolygon} geometry2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(geometry1, geometry2) {\n    var poly1Bbox = calcBbox(geometry1);\n    var poly2Bbox = calcBbox(geometry2);\n    if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {\n        return false;\n    }\n    for (var i = 0; i < geometry1.coordinates[0].length; i++) {\n        if (!booleanPointInPolygon(geometry1.coordinates[0][i], geometry2)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction doBBoxOverlap(bbox1, bbox2) {\n    if (bbox1[0] > bbox2[0])\n        return false;\n    if (bbox1[2] < bbox2[2])\n        return false;\n    if (bbox1[1] > bbox2[1])\n        return false;\n    if (bbox1[3] < bbox2[3])\n        return false;\n    return true;\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\n/**\n * getMidpoint\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {Position} midpoint of pair1 and pair2\n */\nfunction getMidpoint(pair1, pair2) {\n    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\nexport default booleanWithin;\n","import { LitElement, html, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators.js\";\nimport { map } from \"lit/directives/map.js\";\nimport booleanIntersects from \"@turf/boolean-intersects\";\nimport booleanWithin from \"@turf/boolean-within\";\nimport { Geometry } from \"@turf/helpers\";\nimport { EOxMap } from \"../../../map/main\";\nimport { EoxLayer } from \"../../../map/src/generate\";\nimport { Vector as VectorSource } from \"ol/source\";\n\nexport const intersects = (\n  itemGeometry: Geometry,\n  filterGeometry: Geometry\n) => {\n  if (!filterGeometry) {\n    return true;\n  }\n  return booleanIntersects(itemGeometry, filterGeometry);\n};\n\nexport const within = (itemGeometry: Geometry, filterGeometry: Geometry) => {\n  if (!filterGeometry) {\n    return true;\n  }\n  return booleanWithin(itemGeometry, filterGeometry);\n};\n@customElement(\"eox-itemfilter-spatial\")\nexport class EOxItemFilterSpatial extends LitElement {\n  @property()\n  filterObject: SpatialFilterObject;\n\n  public reset() {\n    this.filterObject.state.geometry = undefined;\n    const spatialFilter: SpatialFilter = this.renderRoot.querySelector(\n      \"eox-itemfilter-spatial-filter\"\n    );\n    delete this.filterObject.dirty;\n    spatialFilter.reset();\n    this.requestUpdate();\n  }\n\n  // skip shadow root creation\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    return html`\n      <form style=\"display: inline\">\n      ${map(\n        [\"intersects\", \"within\"],\n        (mode: string) => html`\n          <label>\n            <input\n              type=\"radio\"\n              name=\"mode\"\n              .checked=\"${(this.filterObject.state\n                .mode as unknown as string) === mode || nothing}\n              \"\n              value=\"${mode}\"\n              @click=\"${() => {\n                /* @ts-ignore */\n                this.filterObject.state.mode = mode;\n                const event = new CustomEvent(\"filter\", {\n                  detail: {\n                    [this.filterObject.key]: {},\n                  },\n                });\n                this.dispatchEvent(event);\n              }}\"\n            />\n            <small>${mode} filter geometry</small>\n          </label>\n        `\n      )}\n      </form>\n      <eox-itemfilter-spatial-filter\n        exportparts=\"map: spatial-filter-map\"\n        .geometry=${this.filterObject.state?.geometry}\n        @filter=\"${(e: Event) => {\n          this.filterObject.state.geometry = (<CustomEvent>e).detail.geometry;\n          this.filterObject.dirty = true;\n          this.dispatchEvent(new CustomEvent(\"filter\"));\n        }}\"\n      ></eox-itemfilter-spatial>\n    `;\n  }\n}\n\n@customElement(\"eox-itemfilter-spatial-filter\")\nexport class SpatialFilter extends LitElement {\n  @property()\n  geometry: Geometry;\n\n  @state()\n  eoxMap: EOxMap;\n\n  render() {\n    return html`<eox-map part=\"map\" style=\"height: 400px\"></eox-map>`;\n  }\n\n  firstUpdated() {\n    this.setup();\n  }\n\n  setup() {\n    const mapLayers = [\n      {\n        type: \"Vector\",\n        properties: {\n          id: \"draw\",\n        },\n        source: {\n          type: \"Vector\",\n          ...(this.geometry && { format: \"GeoJSON\" }),\n          ...(this.geometry && { url: this.createFeatureUrl(this.geometry) }),\n        },\n        zIndex: 1,\n      },\n      {\n        type: \"Tile\",\n        source: {\n          type: \"XYZ\",\n          url: \"https://s2maps-tiles.eu/wmts/1.0.0/osm_3857/default/g/{z}/{y}/{x}.jpg\",\n          attribution:\n            \"{ OSM: Data &copy; OpenStreetMap contributors and others, Rendering &copy; EOX }\",\n        },\n      },\n    ];\n\n    this.eoxMap = this.renderRoot.querySelector(\"eox-map\");\n    setTimeout(() => {\n      this.eoxMap.setLayers(mapLayers as EoxLayer[]);\n      this.eoxMap.addDraw(\"draw\", {\n        id: \"drawInteraction\",\n        type: \"Polygon\",\n      });\n      const updateGeometryFilter = (feature: unknown) => {\n        const event = new CustomEvent(\"filter\", {\n          detail: {\n            geometry: {\n              type: \"Polygon\",\n              coordinates: feature\n                // @ts-ignore\n                .getGeometry()\n                .clone()\n                .transform(\"EPSG:3857\", \"EPSG:4326\")\n                .getCoordinates(),\n            },\n          },\n        });\n        this.dispatchEvent(event);\n      };\n      this.eoxMap.interactions[\"drawInteraction\"].on(\n        // @ts-ignore\n        \"drawend\",\n        (e: { feature: unknown }) => {\n          updateGeometryFilter(e.feature);\n          this.eoxMap.removeInteraction(\"drawInteraction\");\n        }\n      );\n      this.eoxMap.interactions[\"drawInteraction_modify\"].on(\n        // @ts-ignore\n        \"modifyend\",\n        (e: { features: unknown }) => {\n          // @ts-ignore\n          updateGeometryFilter(e.features.getArray()[0]);\n        }\n      );\n    });\n  }\n\n  // TODO move to epx-map helper function?\n  createFeatureUrl(geometry: Geometry) {\n    const featureString = encodeURIComponent(\n      JSON.stringify({\n        type: \"FeatureCollection\",\n        features: [\n          {\n            type: \"Feature\",\n            properties: null,\n            geometry,\n          },\n        ],\n      })\n    );\n    return `data:text/json,${featureString}`;\n  }\n\n  reset() {\n    const source = this.eoxMap.getLayerById(\"draw\").getSource();\n    if ((source as unknown as VectorSource).getFeatures()?.length > 0) {\n      (source as unknown as VectorSource).clear();\n      this.eoxMap.removeInteraction(\"drawInteraction_modify\");\n      this.setup();\n    }\n  }\n}\n","import { LitElement, html } from \"lit\";\nimport { customElement, property } from \"lit/decorators.js\";\nimport _debounce from \"lodash.debounce\";\n\n@customElement(\"eox-itemfilter-text\")\nexport class EOxItemFilterText extends LitElement {\n  @property()\n  filterObject: TextFilterObject;\n\n  inputHandler = () => {\n    // Can't use evt.target.value here since it might\n    // be undefined when debounced\n    const searchInput = <HTMLInputElement>(\n      this.renderRoot.querySelector(\"input[type='text']\")\n    );\n    this.filterObject.keys.forEach((key) => {\n      // @ts-ignore\n      this.filterObject.state[key] = searchInput.value;\n    });\n    this.filterObject.dirty = true;\n    // this.filterObject.state = searchInput.value;\n    this.dispatchEvent(new CustomEvent(\"filter\"));\n  };\n\n  debouncedInputHandler = _debounce(this.inputHandler, 500, {\n    leading: true,\n  });\n\n  public reset() {\n    const searchInput = <HTMLInputElement>(\n      this.renderRoot.querySelector(\"input[type='text']\")\n    );\n    searchInput.value = \"\";\n    this.filterObject.keys.forEach((key) => {\n      this.filterObject.state[key] = undefined;\n    });\n    delete this.filterObject.dirty;\n    this.requestUpdate();\n  }\n\n  // skip shadow root creation\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    return html`\n      <input\n        type=\"text\"\n        placeholder=\"Type something...\"\n        data-cy=\"search\"\n        part=\"input-search\"\n        value=\"${Object.values(this.filterObject.state)[0]}\"\n        @input=\"${this.debouncedInputHandler}\"\n      />\n    `;\n  }\n}\n","/**\n * Fuse.js v7.0.0 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2023 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\nfunction isArray(value) {\n  return !Array.isArray\n    ? getTag(value) === '[object Array]'\n    : Array.isArray(value)\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nconst INFINITY = 1 / 0;\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value\n  }\n  let result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result\n}\n\nfunction toString(value) {\n  return value == null ? '' : baseToString(value)\n}\n\nfunction isString(value) {\n  return typeof value === 'string'\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number'\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n  return (\n    value === true ||\n    value === false ||\n    (isObjectLike(value) && getTag(value) == '[object Boolean]')\n  )\n}\n\nfunction isObject(value) {\n  return typeof value === 'object'\n}\n\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n  return isObject(value) && value !== null\n}\n\nfunction isDefined(value) {\n  return value !== undefined && value !== null\n}\n\nfunction isBlank(value) {\n  return !value.trim().length\n}\n\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n  return value == null\n    ? value === undefined\n      ? '[object Undefined]'\n      : '[object Null]'\n    : Object.prototype.toString.call(value)\n}\n\nconst EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\n\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\n\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>\n  `Invalid value for key ${key}`;\n\nconst PATTERN_LENGTH_TOO_LARGE = (max) =>\n  `Pattern length exceeds max of ${max}.`;\n\nconst MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;\n\nconst INVALID_KEY_WEIGHT_VALUE = (key) =>\n  `Property 'weight' in key '${key}' must be a positive integer`;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nclass KeyStore {\n  constructor(keys) {\n    this._keys = [];\n    this._keyMap = {};\n\n    let totalWeight = 0;\n\n    keys.forEach((key) => {\n      let obj = createKey(key);\n\n      this._keys.push(obj);\n      this._keyMap[obj.id] = obj;\n\n      totalWeight += obj.weight;\n    });\n\n    // Normalize weights so that their sum is equal to 1\n    this._keys.forEach((key) => {\n      key.weight /= totalWeight;\n    });\n  }\n  get(keyId) {\n    return this._keyMap[keyId]\n  }\n  keys() {\n    return this._keys\n  }\n  toJSON() {\n    return JSON.stringify(this._keys)\n  }\n}\n\nfunction createKey(key) {\n  let path = null;\n  let id = null;\n  let src = null;\n  let weight = 1;\n  let getFn = null;\n\n  if (isString(key) || isArray(key)) {\n    src = key;\n    path = createKeyPath(key);\n    id = createKeyId(key);\n  } else {\n    if (!hasOwn.call(key, 'name')) {\n      throw new Error(MISSING_KEY_PROPERTY('name'))\n    }\n\n    const name = key.name;\n    src = name;\n\n    if (hasOwn.call(key, 'weight')) {\n      weight = key.weight;\n\n      if (weight <= 0) {\n        throw new Error(INVALID_KEY_WEIGHT_VALUE(name))\n      }\n    }\n\n    path = createKeyPath(name);\n    id = createKeyId(name);\n    getFn = key.getFn;\n  }\n\n  return { path, id, weight, src, getFn }\n}\n\nfunction createKeyPath(key) {\n  return isArray(key) ? key : key.split('.')\n}\n\nfunction createKeyId(key) {\n  return isArray(key) ? key.join('.') : key\n}\n\nfunction get(obj, path) {\n  let list = [];\n  let arr = false;\n\n  const deepGet = (obj, path, index) => {\n    if (!isDefined(obj)) {\n      return\n    }\n    if (!path[index]) {\n      // If there's no path left, we've arrived at the object we care about.\n      list.push(obj);\n    } else {\n      let key = path[index];\n\n      const value = obj[key];\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      // If we're at the last value in the path, and if it's a string/number/bool,\n      // add it to the list\n      if (\n        index === path.length - 1 &&\n        (isString(value) || isNumber(value) || isBoolean(value))\n      ) {\n        list.push(toString(value));\n      } else if (isArray(value)) {\n        arr = true;\n        // Search each item in the array.\n        for (let i = 0, len = value.length; i < len; i += 1) {\n          deepGet(value[i], path, index + 1);\n        }\n      } else if (path.length) {\n        // An object. Recurse further.\n        deepGet(value, path, index + 1);\n      }\n    }\n  };\n\n  // Backwards compatibility (since path used to be a string)\n  deepGet(obj, isString(path) ? path.split('.') : path, 0);\n\n  return arr ? list : list[0]\n}\n\nconst MatchOptions = {\n  // Whether the matches should be included in the result set. When `true`, each record in the result\n  // set will include the indices of the matched characters.\n  // These can consequently be used for highlighting purposes.\n  includeMatches: false,\n  // When `true`, the matching function will continue to the end of a search pattern even if\n  // a perfect match has already been located in the string.\n  findAllMatches: false,\n  // Minimum number of characters that must be matched before a result is considered a match\n  minMatchCharLength: 1\n};\n\nconst BasicOptions = {\n  // When `true`, the algorithm continues searching to the end of the input even if a perfect\n  // match is found before the end of the same input.\n  isCaseSensitive: false,\n  // When true, the matching function will continue to the end of a search pattern even if\n  includeScore: false,\n  // List of properties that will be searched. This also supports nested properties.\n  keys: [],\n  // Whether to sort the result list, by score\n  shouldSort: true,\n  // Default sort function: sort by ascending score, ascending index\n  sortFn: (a, b) =>\n    a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1\n};\n\nconst FuzzyOptions = {\n  // Approximately where in the text is the pattern expected to be found?\n  location: 0,\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n  // (of both letters and location), a threshold of '1.0' would match anything.\n  threshold: 0.6,\n  // Determines how close the match must be to the fuzzy location (specified above).\n  // An exact letter match which is 'distance' characters away from the fuzzy location\n  // would score as a complete mismatch. A distance of '0' requires the match be at\n  // the exact location specified, a threshold of '1000' would require a perfect match\n  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n  distance: 100\n};\n\nconst AdvancedOptions = {\n  // When `true`, it enables the use of unix-like search commands\n  useExtendedSearch: false,\n  // The get function to use when fetching an object's properties.\n  // The default will search nested paths *ie foo.bar.baz*\n  getFn: get,\n  // When `true`, search will ignore `location` and `distance`, so it won't matter\n  // where in the string the pattern appears.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n  ignoreLocation: false,\n  // When `true`, the calculation for the relevance score (used for sorting) will\n  // ignore the field-length norm.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n  ignoreFieldNorm: false,\n  // The weight to determine how much field length norm effects scoring.\n  fieldNormWeight: 1\n};\n\nvar Config = {\n  ...BasicOptions,\n  ...MatchOptions,\n  ...FuzzyOptions,\n  ...AdvancedOptions\n};\n\nconst SPACE = /[^ ]+/g;\n\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm(weight = 1, mantissa = 3) {\n  const cache = new Map();\n  const m = Math.pow(10, mantissa);\n\n  return {\n    get(value) {\n      const numTokens = value.match(SPACE).length;\n\n      if (cache.has(numTokens)) {\n        return cache.get(numTokens)\n      }\n\n      // Default function is 1/sqrt(x), weight makes that variable\n      const norm = 1 / Math.pow(numTokens, 0.5 * weight);\n\n      // In place of `toFixed(mantissa)`, for faster computation\n      const n = parseFloat(Math.round(norm * m) / m);\n\n      cache.set(numTokens, n);\n\n      return n\n    },\n    clear() {\n      cache.clear();\n    }\n  }\n}\n\nclass FuseIndex {\n  constructor({\n    getFn = Config.getFn,\n    fieldNormWeight = Config.fieldNormWeight\n  } = {}) {\n    this.norm = norm(fieldNormWeight, 3);\n    this.getFn = getFn;\n    this.isCreated = false;\n\n    this.setIndexRecords();\n  }\n  setSources(docs = []) {\n    this.docs = docs;\n  }\n  setIndexRecords(records = []) {\n    this.records = records;\n  }\n  setKeys(keys = []) {\n    this.keys = keys;\n    this._keysMap = {};\n    keys.forEach((key, idx) => {\n      this._keysMap[key.id] = idx;\n    });\n  }\n  create() {\n    if (this.isCreated || !this.docs.length) {\n      return\n    }\n\n    this.isCreated = true;\n\n    // List is Array<String>\n    if (isString(this.docs[0])) {\n      this.docs.forEach((doc, docIndex) => {\n        this._addString(doc, docIndex);\n      });\n    } else {\n      // List is Array<Object>\n      this.docs.forEach((doc, docIndex) => {\n        this._addObject(doc, docIndex);\n      });\n    }\n\n    this.norm.clear();\n  }\n  // Adds a doc to the end of the index\n  add(doc) {\n    const idx = this.size();\n\n    if (isString(doc)) {\n      this._addString(doc, idx);\n    } else {\n      this._addObject(doc, idx);\n    }\n  }\n  // Removes the doc at the specified index of the index\n  removeAt(idx) {\n    this.records.splice(idx, 1);\n\n    // Change ref index of every subsquent doc\n    for (let i = idx, len = this.size(); i < len; i += 1) {\n      this.records[i].i -= 1;\n    }\n  }\n  getValueForItemAtKeyId(item, keyId) {\n    return item[this._keysMap[keyId]]\n  }\n  size() {\n    return this.records.length\n  }\n  _addString(doc, docIndex) {\n    if (!isDefined(doc) || isBlank(doc)) {\n      return\n    }\n\n    let record = {\n      v: doc,\n      i: docIndex,\n      n: this.norm.get(doc)\n    };\n\n    this.records.push(record);\n  }\n  _addObject(doc, docIndex) {\n    let record = { i: docIndex, $: {} };\n\n    // Iterate over every key (i.e, path), and fetch the value at that key\n    this.keys.forEach((key, keyIndex) => {\n      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      if (isArray(value)) {\n        let subRecords = [];\n        const stack = [{ nestedArrIndex: -1, value }];\n\n        while (stack.length) {\n          const { nestedArrIndex, value } = stack.pop();\n\n          if (!isDefined(value)) {\n            continue\n          }\n\n          if (isString(value) && !isBlank(value)) {\n            let subRecord = {\n              v: value,\n              i: nestedArrIndex,\n              n: this.norm.get(value)\n            };\n\n            subRecords.push(subRecord);\n          } else if (isArray(value)) {\n            value.forEach((item, k) => {\n              stack.push({\n                nestedArrIndex: k,\n                value: item\n              });\n            });\n          } else ;\n        }\n        record.$[keyIndex] = subRecords;\n      } else if (isString(value) && !isBlank(value)) {\n        let subRecord = {\n          v: value,\n          n: this.norm.get(value)\n        };\n\n        record.$[keyIndex] = subRecord;\n      }\n    });\n\n    this.records.push(record);\n  }\n  toJSON() {\n    return {\n      keys: this.keys,\n      records: this.records\n    }\n  }\n}\n\nfunction createIndex(\n  keys,\n  docs,\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\n) {\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\n  myIndex.setKeys(keys.map(createKey));\n  myIndex.setSources(docs);\n  myIndex.create();\n  return myIndex\n}\n\nfunction parseIndex(\n  data,\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\n) {\n  const { keys, records } = data;\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\n  myIndex.setKeys(keys);\n  myIndex.setIndexRecords(records);\n  return myIndex\n}\n\nfunction computeScore$1(\n  pattern,\n  {\n    errors = 0,\n    currentLocation = 0,\n    expectedLocation = 0,\n    distance = Config.distance,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  const accuracy = errors / pattern.length;\n\n  if (ignoreLocation) {\n    return accuracy\n  }\n\n  const proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy\n  }\n\n  return accuracy + proximity / distance\n}\n\nfunction convertMaskToIndices(\n  matchmask = [],\n  minMatchCharLength = Config.minMatchCharLength\n) {\n  let indices = [];\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (let len = matchmask.length; i < len; i += 1) {\n    let match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        indices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    indices.push([start, i - 1]);\n  }\n\n  return indices\n}\n\n// Machine word size\nconst MAX_BITS = 32;\n\nfunction search(\n  text,\n  pattern,\n  patternAlphabet,\n  {\n    location = Config.location,\n    distance = Config.distance,\n    threshold = Config.threshold,\n    findAllMatches = Config.findAllMatches,\n    minMatchCharLength = Config.minMatchCharLength,\n    includeMatches = Config.includeMatches,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  if (pattern.length > MAX_BITS) {\n    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))\n  }\n\n  const patternLen = pattern.length;\n  // Set starting location at beginning text and initialize the alphabet.\n  const textLen = text.length;\n  // Handle the case when location > text.length\n  const expectedLocation = Math.max(0, Math.min(location, textLen));\n  // Highest score beyond which we give up.\n  let currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  let bestLocation = expectedLocation;\n\n  // Performance: only computer matches when the minMatchCharLength > 1\n  // OR if `includeMatches` is true.\n  const computeMatches = minMatchCharLength > 1 || includeMatches;\n  // A mask of the matches, used for building the indices\n  const matchMask = computeMatches ? Array(textLen) : [];\n\n  let index;\n\n  // Get all exact matches, here for speed up\n  while ((index = text.indexOf(pattern, bestLocation)) > -1) {\n    let score = computeScore$1(pattern, {\n      currentLocation: index,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    currentThreshold = Math.min(score, currentThreshold);\n    bestLocation = index + patternLen;\n\n    if (computeMatches) {\n      let i = 0;\n      while (i < patternLen) {\n        matchMask[index + i] = 1;\n        i += 1;\n      }\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  let lastBitArr = [];\n  let finalScore = 1;\n  let binMax = patternLen + textLen;\n\n  const mask = 1 << (patternLen - 1);\n\n  for (let i = 0; i < patternLen; i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    let binMin = 0;\n    let binMid = binMax;\n\n    while (binMin < binMid) {\n      const score = computeScore$1(pattern, {\n        errors: i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation,\n        distance,\n        ignoreLocation\n      });\n\n      if (score <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    let start = Math.max(1, expectedLocation - binMid + 1);\n    let finish = findAllMatches\n      ? textLen\n      : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    let bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << i) - 1;\n\n    for (let j = finish; j >= start; j -= 1) {\n      let currentLocation = j - 1;\n      let charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (computeMatches) {\n        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n        matchMask[currentLocation] = +!!charMatch;\n      }\n\n      // First pass: exact match\n      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (i) {\n        bitArr[j] |=\n          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = computeScore$1(pattern, {\n          errors: i,\n          currentLocation,\n          expectedLocation,\n          distance,\n          ignoreLocation\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    const score = computeScore$1(pattern, {\n      errors: i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    if (score > currentThreshold) {\n      break\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  const result = {\n    isMatch: bestLocation >= 0,\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    score: Math.max(0.001, finalScore)\n  };\n\n  if (computeMatches) {\n    const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n    if (!indices.length) {\n      result.isMatch = false;\n    } else if (includeMatches) {\n      result.indices = indices;\n    }\n  }\n\n  return result\n}\n\nfunction createPatternAlphabet(pattern) {\n  let mask = {};\n\n  for (let i = 0, len = pattern.length; i < len; i += 1) {\n    const char = pattern.charAt(i);\n    mask[char] = (mask[char] || 0) | (1 << (len - i - 1));\n  }\n\n  return mask\n}\n\nclass BitapSearch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    this.options = {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    this.chunks = [];\n\n    if (!this.pattern.length) {\n      return\n    }\n\n    const addChunk = (pattern, startIndex) => {\n      this.chunks.push({\n        pattern,\n        alphabet: createPatternAlphabet(pattern),\n        startIndex\n      });\n    };\n\n    const len = this.pattern.length;\n\n    if (len > MAX_BITS) {\n      let i = 0;\n      const remainder = len % MAX_BITS;\n      const end = len - remainder;\n\n      while (i < end) {\n        addChunk(this.pattern.substr(i, MAX_BITS), i);\n        i += MAX_BITS;\n      }\n\n      if (remainder) {\n        const startIndex = len - MAX_BITS;\n        addChunk(this.pattern.substr(startIndex), startIndex);\n      }\n    } else {\n      addChunk(this.pattern, 0);\n    }\n  }\n\n  searchIn(text) {\n    const { isCaseSensitive, includeMatches } = this.options;\n\n    if (!isCaseSensitive) {\n      text = text.toLowerCase();\n    }\n\n    // Exact match\n    if (this.pattern === text) {\n      let result = {\n        isMatch: true,\n        score: 0\n      };\n\n      if (includeMatches) {\n        result.indices = [[0, text.length - 1]];\n      }\n\n      return result\n    }\n\n    // Otherwise, use Bitap algorithm\n    const {\n      location,\n      distance,\n      threshold,\n      findAllMatches,\n      minMatchCharLength,\n      ignoreLocation\n    } = this.options;\n\n    let allIndices = [];\n    let totalScore = 0;\n    let hasMatches = false;\n\n    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {\n      const { isMatch, score, indices } = search(text, pattern, alphabet, {\n        location: location + startIndex,\n        distance,\n        threshold,\n        findAllMatches,\n        minMatchCharLength,\n        includeMatches,\n        ignoreLocation\n      });\n\n      if (isMatch) {\n        hasMatches = true;\n      }\n\n      totalScore += score;\n\n      if (isMatch && indices) {\n        allIndices = [...allIndices, ...indices];\n      }\n    });\n\n    let result = {\n      isMatch: hasMatches,\n      score: hasMatches ? totalScore / this.chunks.length : 1\n    };\n\n    if (hasMatches && includeMatches) {\n      result.indices = allIndices;\n    }\n\n    return result\n  }\n}\n\nclass BaseMatch {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n  static isMultiMatch(pattern) {\n    return getMatch(pattern, this.multiRegex)\n  }\n  static isSingleMatch(pattern) {\n    return getMatch(pattern, this.singleRegex)\n  }\n  search(/*text*/) {}\n}\n\nfunction getMatch(pattern, exp) {\n  const matches = pattern.match(exp);\n  return matches ? matches[1] : null\n}\n\n// Token: 'file\n\nclass ExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'exact'\n  }\n  static get multiRegex() {\n    return /^=\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^=(.*)$/\n  }\n  search(text) {\n    const isMatch = text === this.pattern;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !fire\n\nclass InverseExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!(.*)$/\n  }\n  search(text) {\n    const index = text.indexOf(this.pattern);\n    const isMatch = index === -1;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: ^file\n\nclass PrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'prefix-exact'\n  }\n  static get multiRegex() {\n    return /^\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !^fire\n\nclass InversePrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-prefix-exact'\n  }\n  static get multiRegex() {\n    return /^!\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = !text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: .file$\n\nclass SuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'suffix-exact'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = text.endsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [text.length - this.pattern.length, text.length - 1]\n    }\n  }\n}\n\n// Token: !.file$\n\nclass InverseSuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-suffix-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^!(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = !text.endsWith(this.pattern);\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\nclass FuzzyMatch extends BaseMatch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    super(pattern);\n    this._bitapSearch = new BitapSearch(pattern, {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    });\n  }\n  static get type() {\n    return 'fuzzy'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^(.*)$/\n  }\n  search(text) {\n    return this._bitapSearch.searchIn(text)\n  }\n}\n\n// Token: 'file\n\nclass IncludeMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'include'\n  }\n  static get multiRegex() {\n    return /^'\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^'(.*)$/\n  }\n  search(text) {\n    let location = 0;\n    let index;\n\n    const indices = [];\n    const patternLen = this.pattern.length;\n\n    // Get all exact matches\n    while ((index = text.indexOf(this.pattern, location)) > -1) {\n      location = index + patternLen;\n      indices.push([index, location - 1]);\n    }\n\n    const isMatch = !!indices.length;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices\n    }\n  }\n}\n\n// ❗Order is important. DO NOT CHANGE.\nconst searchers = [\n  ExactMatch,\n  IncludeMatch,\n  PrefixExactMatch,\n  InversePrefixExactMatch,\n  InverseSuffixExactMatch,\n  SuffixExactMatch,\n  InverseExactMatch,\n  FuzzyMatch\n];\n\nconst searchersLen = searchers.length;\n\n// Regex to split by spaces, but keep anything in quotes together\nconst SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = '|';\n\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern, options = {}) {\n  return pattern.split(OR_TOKEN).map((item) => {\n    let query = item\n      .trim()\n      .split(SPACE_RE)\n      .filter((item) => item && !!item.trim());\n\n    let results = [];\n    for (let i = 0, len = query.length; i < len; i += 1) {\n      const queryItem = query[i];\n\n      // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n      let found = false;\n      let idx = -1;\n      while (!found && ++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isMultiMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          found = true;\n        }\n      }\n\n      if (found) {\n        continue\n      }\n\n      // 2. Handle single query matches (i.e, once that are *not* quoted)\n      idx = -1;\n      while (++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isSingleMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          break\n        }\n      }\n    }\n\n    return results\n  })\n}\n\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nconst MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);\n\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */\nclass ExtendedSearch {\n  constructor(\n    pattern,\n    {\n      isCaseSensitive = Config.isCaseSensitive,\n      includeMatches = Config.includeMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      ignoreLocation = Config.ignoreLocation,\n      findAllMatches = Config.findAllMatches,\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance\n    } = {}\n  ) {\n    this.query = null;\n    this.options = {\n      isCaseSensitive,\n      includeMatches,\n      minMatchCharLength,\n      findAllMatches,\n      ignoreLocation,\n      location,\n      threshold,\n      distance\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.query = parseQuery(this.pattern, this.options);\n  }\n\n  static condition(_, options) {\n    return options.useExtendedSearch\n  }\n\n  searchIn(text) {\n    const query = this.query;\n\n    if (!query) {\n      return {\n        isMatch: false,\n        score: 1\n      }\n    }\n\n    const { includeMatches, isCaseSensitive } = this.options;\n\n    text = isCaseSensitive ? text : text.toLowerCase();\n\n    let numMatches = 0;\n    let allIndices = [];\n    let totalScore = 0;\n\n    // ORs\n    for (let i = 0, qLen = query.length; i < qLen; i += 1) {\n      const searchers = query[i];\n\n      // Reset indices\n      allIndices.length = 0;\n      numMatches = 0;\n\n      // ANDs\n      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {\n        const searcher = searchers[j];\n        const { isMatch, indices, score } = searcher.search(text);\n\n        if (isMatch) {\n          numMatches += 1;\n          totalScore += score;\n          if (includeMatches) {\n            const type = searcher.constructor.type;\n            if (MultiMatchSet.has(type)) {\n              allIndices = [...allIndices, ...indices];\n            } else {\n              allIndices.push(indices);\n            }\n          }\n        } else {\n          totalScore = 0;\n          numMatches = 0;\n          allIndices.length = 0;\n          break\n        }\n      }\n\n      // OR condition, so if TRUE, return\n      if (numMatches) {\n        let result = {\n          isMatch: true,\n          score: totalScore / numMatches\n        };\n\n        if (includeMatches) {\n          result.indices = allIndices;\n        }\n\n        return result\n      }\n    }\n\n    // Nothing was matched\n    return {\n      isMatch: false,\n      score: 1\n    }\n  }\n}\n\nconst registeredSearchers = [];\n\nfunction register(...args) {\n  registeredSearchers.push(...args);\n}\n\nfunction createSearcher(pattern, options) {\n  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {\n    let searcherClass = registeredSearchers[i];\n    if (searcherClass.condition(pattern, options)) {\n      return new searcherClass(pattern, options)\n    }\n  }\n\n  return new BitapSearch(pattern, options)\n}\n\nconst LogicalOperator = {\n  AND: '$and',\n  OR: '$or'\n};\n\nconst KeyType = {\n  PATH: '$path',\n  PATTERN: '$val'\n};\n\nconst isExpression = (query) =>\n  !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\n\nconst isPath = (query) => !!query[KeyType.PATH];\n\nconst isLeaf = (query) =>\n  !isArray(query) && isObject(query) && !isExpression(query);\n\nconst convertToExplicit = (query) => ({\n  [LogicalOperator.AND]: Object.keys(query).map((key) => ({\n    [key]: query[key]\n  }))\n});\n\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options, { auto = true } = {}) {\n  const next = (query) => {\n    let keys = Object.keys(query);\n\n    const isQueryPath = isPath(query);\n\n    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n      return next(convertToExplicit(query))\n    }\n\n    if (isLeaf(query)) {\n      const key = isQueryPath ? query[KeyType.PATH] : keys[0];\n\n      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n\n      if (!isString(pattern)) {\n        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))\n      }\n\n      const obj = {\n        keyId: createKeyId(key),\n        pattern\n      };\n\n      if (auto) {\n        obj.searcher = createSearcher(pattern, options);\n      }\n\n      return obj\n    }\n\n    let node = {\n      children: [],\n      operator: keys[0]\n    };\n\n    keys.forEach((key) => {\n      const value = query[key];\n\n      if (isArray(value)) {\n        value.forEach((item) => {\n          node.children.push(next(item));\n        });\n      }\n    });\n\n    return node\n  };\n\n  if (!isExpression(query)) {\n    query = convertToExplicit(query);\n  }\n\n  return next(query)\n}\n\n// Practical scoring function\nfunction computeScore(\n  results,\n  { ignoreFieldNorm = Config.ignoreFieldNorm }\n) {\n  results.forEach((result) => {\n    let totalScore = 1;\n\n    result.matches.forEach(({ key, norm, score }) => {\n      const weight = key ? key.weight : null;\n\n      totalScore *= Math.pow(\n        score === 0 && weight ? Number.EPSILON : score,\n        (weight || 1) * (ignoreFieldNorm ? 1 : norm)\n      );\n    });\n\n    result.score = totalScore;\n  });\n}\n\nfunction transformMatches(result, data) {\n  const matches = result.matches;\n  data.matches = [];\n\n  if (!isDefined(matches)) {\n    return\n  }\n\n  matches.forEach((match) => {\n    if (!isDefined(match.indices) || !match.indices.length) {\n      return\n    }\n\n    const { indices, value } = match;\n\n    let obj = {\n      indices,\n      value\n    };\n\n    if (match.key) {\n      obj.key = match.key.src;\n    }\n\n    if (match.idx > -1) {\n      obj.refIndex = match.idx;\n    }\n\n    data.matches.push(obj);\n  });\n}\n\nfunction transformScore(result, data) {\n  data.score = result.score;\n}\n\nfunction format(\n  results,\n  docs,\n  {\n    includeMatches = Config.includeMatches,\n    includeScore = Config.includeScore\n  } = {}\n) {\n  const transformers = [];\n\n  if (includeMatches) transformers.push(transformMatches);\n  if (includeScore) transformers.push(transformScore);\n\n  return results.map((result) => {\n    const { idx } = result;\n\n    const data = {\n      item: docs[idx],\n      refIndex: idx\n    };\n\n    if (transformers.length) {\n      transformers.forEach((transformer) => {\n        transformer(result, data);\n      });\n    }\n\n    return data\n  })\n}\n\nclass Fuse {\n  constructor(docs, options = {}, index) {\n    this.options = { ...Config, ...options };\n\n    if (\n      this.options.useExtendedSearch &&\n      !true\n    ) {\n      throw new Error(EXTENDED_SEARCH_UNAVAILABLE)\n    }\n\n    this._keyStore = new KeyStore(this.options.keys);\n\n    this.setCollection(docs, index);\n  }\n\n  setCollection(docs, index) {\n    this._docs = docs;\n\n    if (index && !(index instanceof FuseIndex)) {\n      throw new Error(INCORRECT_INDEX_TYPE)\n    }\n\n    this._myIndex =\n      index ||\n      createIndex(this.options.keys, this._docs, {\n        getFn: this.options.getFn,\n        fieldNormWeight: this.options.fieldNormWeight\n      });\n  }\n\n  add(doc) {\n    if (!isDefined(doc)) {\n      return\n    }\n\n    this._docs.push(doc);\n    this._myIndex.add(doc);\n  }\n\n  remove(predicate = (/* doc, idx */) => false) {\n    const results = [];\n\n    for (let i = 0, len = this._docs.length; i < len; i += 1) {\n      const doc = this._docs[i];\n      if (predicate(doc, i)) {\n        this.removeAt(i);\n        i -= 1;\n        len -= 1;\n\n        results.push(doc);\n      }\n    }\n\n    return results\n  }\n\n  removeAt(idx) {\n    this._docs.splice(idx, 1);\n    this._myIndex.removeAt(idx);\n  }\n\n  getIndex() {\n    return this._myIndex\n  }\n\n  search(query, { limit = -1 } = {}) {\n    const {\n      includeMatches,\n      includeScore,\n      shouldSort,\n      sortFn,\n      ignoreFieldNorm\n    } = this.options;\n\n    let results = isString(query)\n      ? isString(this._docs[0])\n        ? this._searchStringList(query)\n        : this._searchObjectList(query)\n      : this._searchLogical(query);\n\n    computeScore(results, { ignoreFieldNorm });\n\n    if (shouldSort) {\n      results.sort(sortFn);\n    }\n\n    if (isNumber(limit) && limit > -1) {\n      results = results.slice(0, limit);\n    }\n\n    return format(results, this._docs, {\n      includeMatches,\n      includeScore\n    })\n  }\n\n  _searchStringList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { records } = this._myIndex;\n    const results = [];\n\n    // Iterate over every string in the index\n    records.forEach(({ v: text, i: idx, n: norm }) => {\n      if (!isDefined(text)) {\n        return\n      }\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        results.push({\n          item: text,\n          idx,\n          matches: [{ score, value: text, norm, indices }]\n        });\n      }\n    });\n\n    return results\n  }\n\n  _searchLogical(query) {\n\n    const expression = parse(query, this.options);\n\n    const evaluate = (node, item, idx) => {\n      if (!node.children) {\n        const { keyId, searcher } = node;\n\n        const matches = this._findMatches({\n          key: this._keyStore.get(keyId),\n          value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n          searcher\n        });\n\n        if (matches && matches.length) {\n          return [\n            {\n              idx,\n              item,\n              matches\n            }\n          ]\n        }\n\n        return []\n      }\n\n      const res = [];\n      for (let i = 0, len = node.children.length; i < len; i += 1) {\n        const child = node.children[i];\n        const result = evaluate(child, item, idx);\n        if (result.length) {\n          res.push(...result);\n        } else if (node.operator === LogicalOperator.AND) {\n          return []\n        }\n      }\n      return res\n    };\n\n    const records = this._myIndex.records;\n    const resultMap = {};\n    const results = [];\n\n    records.forEach(({ $: item, i: idx }) => {\n      if (isDefined(item)) {\n        let expResults = evaluate(expression, item, idx);\n\n        if (expResults.length) {\n          // Dedupe when adding\n          if (!resultMap[idx]) {\n            resultMap[idx] = { idx, item, matches: [] };\n            results.push(resultMap[idx]);\n          }\n          expResults.forEach(({ matches }) => {\n            resultMap[idx].matches.push(...matches);\n          });\n        }\n      }\n    });\n\n    return results\n  }\n\n  _searchObjectList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { keys, records } = this._myIndex;\n    const results = [];\n\n    // List is Array<Object>\n    records.forEach(({ $: item, i: idx }) => {\n      if (!isDefined(item)) {\n        return\n      }\n\n      let matches = [];\n\n      // Iterate over every key (i.e, path), and fetch the value at that key\n      keys.forEach((key, keyIndex) => {\n        matches.push(\n          ...this._findMatches({\n            key,\n            value: item[keyIndex],\n            searcher\n          })\n        );\n      });\n\n      if (matches.length) {\n        results.push({\n          idx,\n          item,\n          matches\n        });\n      }\n    });\n\n    return results\n  }\n  _findMatches({ key, value, searcher }) {\n    if (!isDefined(value)) {\n      return []\n    }\n\n    let matches = [];\n\n    if (isArray(value)) {\n      value.forEach(({ v: text, i: idx, n: norm }) => {\n        if (!isDefined(text)) {\n          return\n        }\n\n        const { isMatch, score, indices } = searcher.searchIn(text);\n\n        if (isMatch) {\n          matches.push({\n            score,\n            key,\n            value: text,\n            idx,\n            norm,\n            indices\n          });\n        }\n      });\n    } else {\n      const { v: text, n: norm } = value;\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        matches.push({ score, key, value: text, norm, indices });\n      }\n    }\n\n    return matches\n  }\n}\n\nFuse.version = '7.0.0';\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n\n{\n  Fuse.parseQuery = parse;\n}\n\n{\n  register(ExtendedSearch);\n}\n\nexport { Fuse as default };\n","// @ts-nocheck\n// adapted from https://gist.github.com/evenfrost/1ba123656ded32fb7a0cd4651efd4db0\nexport const highlight = (\n  fuseSearchResult: unknown,\n  highlightClassName = \"highlight\",\n  matchKey = \"title\"\n) => {\n  const set = (\n    obj: { [key: string]: unknown },\n    path: string,\n    value: unknown\n  ) => {\n    const pathValue = path.split(\".\");\n    let i;\n\n    for (i = 0; i < pathValue.length - 1; i++) {\n      obj = obj[pathValue[i]];\n    }\n\n    obj[pathValue[i]] = value;\n  };\n\n  const generateHighlightedText = (\n    inputText: string,\n    regions: number[] = []\n  ) => {\n    let content = \"\";\n    let nextUnhighlightedRegionStartingIndex = 0;\n\n    regions.forEach((region: number) => {\n      const lastRegionNextIndex = region[1] + 1;\n\n      content += [\n        inputText.substring(nextUnhighlightedRegionStartingIndex, region[0]),\n        `<mark class=\"${highlightClassName}\">`,\n        inputText.substring(region[0], lastRegionNextIndex),\n        \"</mark>\",\n      ].join(\"\");\n\n      nextUnhighlightedRegionStartingIndex = lastRegionNextIndex;\n    });\n\n    content += inputText.substring(nextUnhighlightedRegionStartingIndex);\n\n    return content;\n  };\n\n  return (fuseSearchResult as Array<{ matches?: unknown[]; item: unknown }>)\n    .filter(({ matches }) => matches && matches.length)\n    .map(({ item, matches }) => {\n      const highlightedItem: { [key: string]: unknown } = {};\n      for (const [key, value] of Object.entries(item)) {\n        highlightedItem[key] = value;\n      }\n\n      (matches as Array<{ [key: string]: unknown }>).forEach((match) => {\n        if (match.key !== matchKey) return;\n        set(\n          highlightedItem,\n          match.key as string,\n          generateHighlightedText(\n            match.value as string,\n            match.indices as number[]\n          )\n        );\n      });\n\n      return highlightedItem;\n    });\n};\n","import Fuse from \"fuse.js\";\nimport dayjs from \"dayjs\";\nimport { intersects, within } from \"./filters/spatial\";\nimport { highlight } from \"./itemHighlighting\";\nimport { ElementConfig } from \"./main\";\n\nlet _fuse: Fuse<unknown>;\n\nexport const indexItems = (items: Array<object>, fuseConfig: object) => {\n  _fuse = new Fuse(items, {\n    // minMatchCharLength: 3,\n    // location: 0,\n    threshold: 0.4,\n    distance: 50,\n    includeMatches: true,\n    useExtendedSearch: true,\n    ...fuseConfig,\n  });\n};\n\nexport const filter = async (\n  items: Array<object>,\n  filters: object,\n  config: ElementConfig\n) => {\n  const parsedFilters = Object.entries(filters)\n    .filter(\n      ([, filter]) =>\n        filter.type === \"text\" ||\n        filter.type === \"select\" ||\n        filter.type === \"multiselect\"\n    )\n    .reduce((store, [key, filter]) => {\n      const operator = \"$or\";\n      const holding: Array<unknown> = [];\n      const createProperty = (pKey: string, pVal: unknown) => {\n        const property: { [key: string]: unknown } = {};\n        if (filter.type === \"text\") {\n          // convert strings to (fuzzy) inputs\n          property[pKey] = `${pVal}`;\n        } else {\n          // convert boolean values to exact inputs\n          // using \"=\"\n          property[key] = `=\"${pKey}\"`;\n        }\n        holding.push(property);\n      };\n      Object.entries(filter.state)\n        .filter(([, v]) => v)\n        .forEach(([k, v]) => createProperty(k, v));\n      if (holding.length > 0) {\n        store.push({\n          [operator]: holding,\n        });\n      }\n      return store;\n    }, []);\n  let results;\n  if (!(parsedFilters.length > 0) && config.matchAllWhenEmpty !== false) {\n    results = items;\n  } else {\n    const parameters: object = {\n      $and: [...parsedFilters],\n    };\n    const response = _fuse.search(parameters);\n    results = config.enableHighlighting\n      ? highlight(response, \"highlight\", config.titleProperty)\n      : response.map((i) => i.item);\n  }\n  interface RangeFilter {\n    min: number;\n    max: number;\n    format: string;\n  }\n\n  const rangeFilters = Object.entries(filters)\n    .filter(([, value]) => value.type === \"range\")\n    .reduce((acc: { [key: string]: RangeFilter }, [key, value]) => {\n      acc[key] = {\n        min: value.state.min,\n        max: value.state.max,\n        format: value.format,\n      };\n      return acc;\n    }, {});\n  if (Object.keys(rangeFilters).length > 0) {\n    const filteredResults = [];\n    for (let i = 0; i < results.length; i++) {\n      const pass: { [key: string]: boolean } = {};\n      for (const [key, value] of Object.entries(rangeFilters)) {\n        const parseValue = (input: string) => {\n          return value.format === \"date\" ? dayjs(input).unix() : input;\n        };\n        if (Object.prototype.hasOwnProperty.call(results[i], key)) {\n          // @ts-ignore\n          if (Array.isArray(results[i][key])) {\n            // TODO - make configurable?\n            const mode = \"overlap\";\n            if (mode === \"overlap\") {\n              // must have an overlap with the range to pass\n              pass[key] =\n                // @ts-ignore\n                rangeFilters[key].min <= parseValue(results[i][key][1]) &&\n                // @ts-ignore\n                parseValue(results[i][key][0]) <= rangeFilters[key].max;\n            } else if (mode === \"contain\") {\n              // must contain complete range to pass\n              pass[key] =\n                // @ts-ignore\n                parseValue(results[i][key][0]) >= rangeFilters[key].min &&\n                // @ts-ignore\n                parseValue(results[i][key][1]) <= rangeFilters[key].max;\n            }\n          } else if (\n            // @ts-ignore\n            parseValue(results[i][key]) >= rangeFilters[key].min &&\n            // @ts-ignore\n            parseValue(results[i][key]) <= rangeFilters[key].max\n          ) {\n            pass[key] = true;\n          } else {\n            pass[key] = false;\n          }\n        } else {\n          pass[key] = true;\n        }\n      }\n      if (Object.values(pass).every((v) => !!v)) {\n        filteredResults.push(results[i]);\n      }\n    }\n    results = [...filteredResults];\n  }\n  const spatialFilters: {\n    [key: string]: { geometry?: unknown; mode?: string };\n  } = Object.entries(filters)\n    .filter(([, value]) => value.type === \"spatial\")\n    .reduce((acc: { [key: string]: unknown }, [key, value]) => {\n      acc[key] = {\n        geometry: value.state.geometry,\n        mode: value.state.mode,\n      };\n      return acc;\n    }, {});\n  if (\n    Object.values(spatialFilters)\n      .map((f) => f.geometry)\n      .filter((f) => !!f).length > 0\n  ) {\n    const filteredResults = [];\n    for (let i = 0; i < results.length; i++) {\n      const pass: { [key: string]: boolean } = {};\n      for (const key of Object.keys(spatialFilters)) {\n        const mode = spatialFilters[key].mode || \"within\";\n        if (Object.prototype.hasOwnProperty.call(results[i], key)) {\n          const test =\n            mode === \"within\"\n              ? // @ts-ignore\n                within(results[i][key], spatialFilters[key].geometry)\n              : // @ts-ignore\n                intersects(results[i][key], spatialFilters[key].geometry);\n          if (test) {\n            pass[key] = true;\n          } else {\n            pass[key] = false;\n          }\n        } else {\n          pass[key] = false;\n        }\n      }\n      if (Object.values(pass).every((v) => !!v)) {\n        filteredResults.push(results[i]);\n      }\n    }\n    results = [...filteredResults];\n  }\n  return results;\n};\n","import { ElementConfig } from \"./main\";\n\nexport const filter = async (\n  items: Array<object>,\n  filters: object,\n  config: ElementConfig\n) => {\n  // @ts-ignore\n  const response = await fetch(`${config.externalFilter(items, filters)}`);\n  const jsonData = await response.json();\n  return jsonData.features;\n};\n","import { html, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators.js\";\nimport { when } from \"lit/directives/when.js\";\nimport { map } from \"lit/directives/map.js\";\nimport { repeat } from \"lit/directives/repeat.js\";\nimport { unsafeHTML } from \"lit/directives/unsafe-html.js\";\nimport { html as staticHTML, unsafeStatic } from \"lit/static-html.js\";\nimport \"toolcool-range-slider\";\nimport dayjs from \"dayjs\";\nimport { TemplateElement } from \"../../../utils/templateElement\";\nimport \"./filters/_expandcontainer\";\nimport \"./filters/multiselect\";\nimport \"./filters/range\";\nimport \"./filters/select\";\nimport \"./filters/spatial\";\nimport \"./filters/text\";\nimport { indexItems, filter as filterClient } from \"./filterClient\";\nimport { filter as filterExternal } from \"./filterExternal\";\nimport { style } from \"./style\";\nimport { styleEOX } from \"./style.eox\";\n\nexport class ElementConfig {\n  /**\n   * Aggregate results by a property key\n   */\n  public aggregateResults?: string = undefined;\n\n  /**\n   * Highlighting of search result character matches\n   */\n  public enableHighlighting?: boolean = false;\n\n  /**\n   * Use an external search endpoint instead of fuse search.\n   * Passed properties: input string, filters object\n   */\n  public externalFilter?: (input: string, filters: object[]) => string;\n\n  /**\n   * The filter properties.\n   * @param filterProperties\n   */\n  public filterProperties?: Array<FilterObject> = [];\n\n  /**\n   * Native fuse.js config override\n   */\n  public fuseConfig?: object;\n\n  /**\n   * Inline mode, for rendering the itemfilter in avery condensed space.\n   * Expexts showResults to be false\n   */\n  public inlineMode?: boolean = false;\n\n  /**\n   * Show all result items if nothing is input by the user\n   * @default true\n   */\n  public matchAllWhenEmpty?: boolean = true;\n\n  /**\n   * Callback that is triggered on item search\n   * @returns result items\n   */\n  // eslint-disable-next-line\n  public onFilter?: Function = () => {};\n\n  /**\n   * Callback that is triggered on item selection\n   * @returns selected item\n   */\n  // eslint-disable-next-line\n  public onSelect?: Function = () => {};\n\n  /**\n   * Display results list\n   */\n  public showResults?: boolean = true;\n\n  /**\n   * The property of the result items used for display\n   */\n  public titleProperty = \"title\";\n\n  /**\n   * Allow opening multiple filter accordeons in parallel\n   * @default true\n   */\n  public expandMultipleFilters?: boolean = true;\n\n  /**\n   * Initialize result accordeons expanded\n   * @default true\n   */\n  public expandResults?: boolean = true;\n\n  /**\n   * Allow opening multiple result accordeons in parallel\n   * @default true\n   */\n  public expandMultipleResults?: boolean = true;\n}\n\n@customElement(\"eox-itemfilter\")\nexport class EOxItemFilter extends TemplateElement {\n  _resultAggregation: Array<string> = [];\n\n  @state()\n  public filters: { [key: string]: FilterObject } = {};\n\n  @state()\n  public items: Array<object> = [];\n\n  @state()\n  public results: Array<object>;\n\n  @state()\n  public selectedResult: Item;\n\n  @property({ attribute: false }) set config(config) {\n    const oldValue = this._config;\n    this._config = {\n      ...new ElementConfig(),\n      ...config,\n    };\n    this.requestUpdate(\"config\", oldValue);\n  }\n  get config() {\n    return this._config;\n  }\n  private _config = new ElementConfig();\n\n  @property()\n  apply = (items: Array<object>) => {\n    this.items = items.map((i, index) => ({\n      id: `item-${index}`,\n      ...i,\n    }));\n\n    // build filters\n    if (this._config.filterProperties.length) {\n      this._config.filterProperties.forEach((filterProperty: FilterObject) => {\n        const filterKeys: FilterState = {};\n        const parseValue = (value: string) => {\n          return (<RangeFilterObject>filterProperty).format === \"date\"\n            ? dayjs(value).unix()\n            : parseInt(value);\n        };\n        // @ts-ignore\n        this.items.forEach((item: Item) => {\n          if (filterProperty.type === \"range\") {\n            if (Array.isArray(item[filterProperty.key] as Array<number>)) {\n              const currentValues = [\n                // @ts-ignore\n                parseValue(item[filterProperty.key][0]),\n                // @ts-ignore\n                parseValue(item[filterProperty.key][1]),\n              ];\n              // @ts-ignore\n              filterKeys.min =\n                filterKeys.min !== undefined\n                  ? // @ts-ignore\n                    Math.min(filterKeys.min, currentValues[0])\n                  : currentValues[0];\n              // @ts-ignore\n              filterKeys.max =\n                filterKeys.max !== undefined\n                  ? // @ts-ignore\n                    Math.max(filterKeys.max, currentValues[1])\n                  : currentValues[1];\n            } else {\n              // @ts-ignore\n              const currentValue = parseValue(item[filterProperty.key]);\n              // @ts-ignore\n              filterKeys.min =\n                filterKeys.min !== undefined\n                  ? // @ts-ignore\n                    Math.min(filterKeys.min, currentValue)\n                  : currentValue;\n              // @ts-ignore\n              filterKeys.max =\n                filterKeys.max !== undefined\n                  ? // @ts-ignore\n                    Math.max(filterKeys.max, currentValue)\n                  : currentValue;\n            }\n            return;\n          }\n          if (Array.isArray(item[filterProperty.key])) {\n            // @ts-ignore\n            item[filterProperty.key].forEach((prop: string) => {\n              filterKeys[prop] = undefined;\n            });\n          } else {\n            if (filterProperty.type === \"spatial\") {\n              // @ts-ignore\n              (<SpatialFilterObject>filterKeys).geometry = undefined;\n              // @ts-ignore\n              (<SpatialFilterObject>filterKeys).mode =\n                (<SpatialFilterObject>filterProperty).mode || \"intersects\";\n            } else {\n              // @ts-ignore\n              filterKeys[item[filterProperty.key]] = undefined;\n            }\n          }\n        });\n        this.filters[\n          filterProperty.key ||\n            (<TextFilterObject>filterProperty).keys.join(\"|\")\n        ] = {\n          ...filterProperty,\n          type: filterProperty.type || \"multiselect\",\n          state: {\n            ...filterKeys,\n            ...filterProperty.state,\n          },\n          ...(filterProperty.state && {\n            dirty: true,\n          }),\n          ...(filterProperty.type === \"range\" && {\n            // @ts-ignore\n            min: (<RangeFilterObject>filterKeys).min,\n            // @ts-ignore\n            max: (<RangeFilterObject>filterKeys).max,\n            format: (<RangeFilterObject>filterProperty).format,\n          }),\n        };\n      });\n    }\n\n    if (this._config.matchAllWhenEmpty !== false) {\n      // initially render all items\n      this.results = this.sortResults(this.items);\n      this.requestUpdate();\n    }\n\n    if (this._config.aggregateResults) {\n      // @ts-ignore\n      this._resultAggregation = [\n        ...new Set(\n          // @ts-ignore\n          this.items.reduce((store: Array<string>, item: Item) => {\n            // @ts-ignore\n            return store.concat(item[this._config.aggregateResults]);\n          }, [])\n        ),\n        // @ts-ignore\n      ].sort((a, b) => a.localeCompare(b));\n    }\n\n    const fuseKeys: Array<string> = [];\n    Object.values(this.filters).forEach((f) => {\n      if (f.type === \"text\") {\n        (<TextFilterObject>f).keys.forEach((k) => {\n          if (!fuseKeys.includes(k)) {\n            fuseKeys.push(k);\n          }\n        });\n      } else if (f.type === \"select\" || f.type === \"multiselect\") {\n        if (!fuseKeys.includes(f.key)) {\n          fuseKeys.push(f.key);\n        }\n      }\n    });\n    indexItems(this.items, {\n      keys: fuseKeys,\n      ...this._config.fuseConfig,\n    });\n    this.search();\n  };\n\n  @property({ attribute: false })\n  styleOverride: string;\n\n  @property({ type: Boolean })\n  unstyled: boolean;\n\n  private async search() {\n    let results;\n    if (this.config.externalFilter) {\n      results = await filterExternal(this.items, this.filters, this._config);\n    } else {\n      results = await filterClient(this.items, this.filters, this._config);\n    }\n    this.results = this.sortResults(results);\n    this._config.onFilter(this.results, this.filters);\n  }\n\n  aggregateResults(items: Array<object>, property: string) {\n    // @ts-ignore\n    return items.filter((item: Item) => {\n      const aggregation = item[this._config.aggregateResults];\n      // special check if a currently selected fiter property is part of a filter key\n      // also used for aggregation. if aggregation of results uses the same property\n      // as the filter, it doesn't make sense to show all aggregations, but only\n      // the one matching the current filter\n      let currentFilter;\n      if (this.filters[this._config.aggregateResults]) {\n        currentFilter = Object.keys(\n          this.filters[this._config.aggregateResults]\n        ).filter((f) => this.filters[this._config.aggregateResults].state[f]);\n      }\n\n      const includedInCurrentFilter = currentFilter?.length\n        ? currentFilter.includes(property)\n        : true;\n\n      return includedInCurrentFilter && Array.isArray(aggregation)\n        ? aggregation.includes(property)\n        : aggregation === property;\n    });\n  }\n\n  sortResults(items: Array<object>) {\n    // @ts-ignore\n    return [...items].sort((a: Item, b: Item) =>\n      // @ts-ignore\n      a[this._config.titleProperty].localeCompare(b[this._config.titleProperty])\n    );\n  }\n\n  resetFilters() {\n    this.renderRoot.querySelectorAll(\"[data-type='filter']\").forEach((f) => {\n      (<Filter>f).reset();\n    });\n    this.search();\n  }\n\n  toggleAccordion(event: CustomEvent) {\n    let detailsElement: HTMLDetailsElement;\n\n    if (event.detail) {\n      detailsElement = event.detail.target as HTMLDetailsElement;\n    } else {\n      detailsElement = event.target as HTMLDetailsElement;\n    }\n\n    if (detailsElement.classList.contains(\"details-filter\")) {\n      if (!detailsElement.open || this.config.expandMultipleFilters) return;\n\n      this.shadowRoot\n        .querySelectorAll(\"eox-itemfilter-expandcontainer\")\n        .forEach((container) => {\n          const details = container.shadowRoot.querySelector(\".details-filter\");\n          if (details && details !== detailsElement) {\n            details.removeAttribute(\"open\");\n          }\n        });\n    } else {\n      if (!detailsElement.open || this.config.expandMultipleResults) return;\n\n      this.shadowRoot.querySelectorAll(\"details\").forEach((details) => {\n        if (details !== detailsElement) {\n          details.removeAttribute(\"open\");\n        }\n      });\n    }\n  }\n\n  render() {\n    return html`\n      <style>\n        ${style}\n        ${!this.unstyled && styleEOX}\n        ${this.styleOverride}\n      </style>\n      <form\n        id=\"itemfilter\"\n        @submit=\"${(evt: FormDataEvent) => evt.preventDefault()}\"\n      >\n        ${when(\n          this._config.filterProperties.length,\n          () => html`\n            <section class=\"${this.config.inlineMode ? \"inline\" : nothing}\">\n              ${when(\n                !this.config.inlineMode,\n                () =>\n                  html`\n                    <slot name=\"filterstitle\"\n                      ><h4 style=\"margin-top: 8px\">Filters</h4></slot\n                    >\n                  `\n              )}\n              <ul id=\"filters\">\n                ${map(\n                  Object.values(this.filters),\n                  (filterObject) => staticHTML`\n                  <li>\n                    ${\n                      filterObject.featured\n                        ? staticHTML`\n                          <eox-itemfilter-${unsafeStatic(filterObject.type)}\n                            slot=\"filter\"\n                            data-type=\"filter\"\n                            .filterObject=${filterObject}\n                            @filter=\"${() => this.search()}\"\n                          ></eox-itemfilter-${unsafeStatic(filterObject.type)}>\n                        `\n                        : staticHTML`\n                          <eox-itemfilter-expandcontainer\n                            .filterObject=${filterObject}\n                            .unstyled=${this.unstyled}\n                            @details-toggled=${this.toggleAccordion}\n                          >\n                            <eox-itemfilter-${unsafeStatic(filterObject.type)}\n                              slot=\"filter\"\n                              data-type=\"filter\"\n                              data-filter=\"${filterObject.key}\"\n                              .filterObject=${filterObject}\n                              @filter=\"${() => this.search()}\"\n                            ></eox-itemfilter-${unsafeStatic(\n                              filterObject.type\n                            )}>\n                          </eox-itemfilter-expandcontainer>\n                      `\n                    }\n                  </li>\n                `\n                )}\n              </ul>\n              ${when(\n                this._config.filterProperties &&\n                  Object.values(this.filters)\n                    .map((f) => f.dirty)\n                    .filter((f) => f).length > 0,\n                () => html`\n                  <button\n                    id=\"filter-reset\"\n                    class=\"outline small\"\n                    data-cy=\"filter-reset\"\n                    @click=${() => this.resetFilters()}\n                  >\n                    Reset filters\n                  </a>\n                `\n              )}\n            </section>\n          `\n        )}\n        ${when(\n          this.config.showResults && this.results,\n          () => html`\n            <section id=\"section-results\">\n              <div>\n                <slot name=\"resultstitle\"\n                  ><h4 style=\"margin-top: 8px\">Results</h4></slot\n                >\n              </div>\n              <div id=\"container-results\" class=\"scroll\">\n                ${this.results.length < 1\n                  ? html` <small class=\"no-results\">No matching items</small> `\n                  : nothing}\n                <ul id=\"results\" part=\"results\">\n                  ${this._config.aggregateResults\n                    ? map(\n                        this._resultAggregation.filter(\n                          (aggregationProperty) =>\n                            this.aggregateResults(\n                              this.results,\n                              aggregationProperty\n                            ).length\n                        ),\n                        (aggregationProperty) => html`<details\n                          class=\"details-results\"\n                          @toggle=${this.toggleAccordion}\n                          open=${this._config.expandResults || nothing}\n                        >\n                          <summary>\n                            <span class=\"title\">\n                              ${aggregationProperty}\n                              <span class=\"count\"\n                                >${this.aggregateResults(\n                                  this.results,\n                                  aggregationProperty\n                                ).length}</span\n                              >\n                            </span>\n                          </summary>\n                          <ul>\n                            ${repeat(\n                              // @ts-ignore\n                              this.aggregateResults(\n                                this.results,\n                                aggregationProperty\n                              ),\n                              (item: Item) => item.id,\n                              (item: Item) => html`\n                                <li\n                                  class=${this.selectedResult?.[\n                                    this._config.titleProperty\n                                  ] === item[this._config.titleProperty]\n                                    ? \"highlighted\"\n                                    : nothing}\n                                >\n                                  <label>\n                                    <input\n                                      data-cy=\"result-radio\"\n                                      type=\"radio\"\n                                      class=\"result-radio\"\n                                      name=\"result\"\n                                      id=\"${item.id}\"\n                                      checked=${this.selectedResult?.[\n                                        this._config.titleProperty\n                                      ] === item[this._config.titleProperty] ||\n                                      nothing}\n                                      @click=${() => {\n                                        this.selectedResult = item;\n                                        this._config.onSelect(item);\n                                      }}\n                                    />\n                                    ${when(\n                                      this.hasTemplate(\"result\"),\n                                      () =>\n                                        this.renderTemplate(\n                                          \"result\",\n                                          item,\n                                          `result-${item.id}`\n                                        ),\n                                      () => html`\n                                        <span class=\"title\"\n                                          >${unsafeHTML(\n                                            // @ts-ignore\n                                            item[this._config.titleProperty]\n                                          )}</span\n                                        >\n                                      `\n                                    )}\n                                  </label>\n                                </li>\n                              `\n                            )}\n                          </ul>\n                        </details>`\n                      )\n                    : map(\n                        // @ts-ignore\n                        this.results,\n                        (item: Item) =>\n                          html`<li part=\"result\">\n                            <label>\n                              <input\n                                type=\"radio\"\n                                name=\"result\"\n                                id=\"${item.id}\"\n                                @click=${() => {\n                                  this.selectedResult = item;\n                                  this._config.onSelect(item);\n                                }}\n                              />\n                              ${when(\n                                this.hasTemplate(\"result\"),\n                                () =>\n                                  this.renderTemplate(\n                                    \"result\",\n                                    item,\n                                    `result-${item.id}`\n                                  ),\n                                () => html`\n                                  <span class=\"title\"\n                                    >${unsafeHTML(\n                                      // @ts-ignore\n                                      item[this._config.titleProperty]\n                                    )}</span\n                                  >\n                                `\n                              )}\n                            </label>\n                          </li>`\n                      )}\n                </ul>\n              </div>\n            </section>\n          `\n        )}\n      </form>\n    `;\n  }\n}\n"],"names":["u","e","s","t","r","l","c","o","i","d","p","h","v","m","y","x","j","k","w","n","f","style","styleEOX","button","checkbox","radio","slider","EOxItemFilterExpandContainer","LitElement","event","html","nothing","__decorateClass","property","customElement","EOxItemFilterMultiselect","filter","map","a","b","key","FUNC_ERROR_TEXT","NAN","symbolTag","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","freeGlobal","global","freeSelf","root","objectProto","objectToString","nativeMax","nativeMin","now","debounce","func","wait","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","toNumber","isObject","invokeFunc","time","args","thisArg","leadingEdge","timerExpired","remainingWait","timeSinceLastCall","timeSinceLastInvoke","shouldInvoke","trailingEdge","cancel","flush","debounced","isInvoking","value","type","isObjectLike","isSymbol","other","isBinary","lodash_debounce","EOxItemFilterRange","evt","min","max","_debounce","dayjs","EOxItemFilterSelect","el","earthRadius","factors","unitsFactors","areaFactors","feature","geom","properties","feat","geometry","coordinates","_options","point","lineString","polygon","multiPoint","multiLineString","multiPolygon","isNumber","points","featureCollection","coords","_i","coordinates_1","ring","polygons","lineStrings","features","fc","geometryCollection","geometries","round","num","precision","multiplier","radiansToLength","radians","units","factor","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","degrees","degreesToRadians","convertLength","length","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","input","validateBBox","bbox","validateId","id","getCoord","coord","getCoords","getGeom","geojson","booleanPointInPolygon","pt","polys","inBBox","insidePoly","inRing","inHole","ignoreBoundary","isInside","xi","yi","xj","yj","onBoundary","intersect","coordEach","callback","excludeWrapCoord","stopG","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","coordReduce","initialValue","previousValue","currentCoord","propEach","propReduce","currentProperties","featureEach","featureReduce","currentFeature","coordAll","geomEach","g","featureProperties","featureBBox","featureId","geomReduce","currentGeometry","flattenEach","coordinate","flattenReduce","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","featureIndexCoord","multiPartIndexCoord","currentSegment","segmentReduce","started","lineEach","lineReduce","currentLine","findSegment","findPoint","lineSegment","results","lineSegmentFeature","segments","createSegments","segment","currentCoords","coords1","coords2","x1","y1","x2","y2","west","south","east","north","rbush","require$$0","helpers","require$$1","meta","require$$2","turfBBox","require$$3","geojsonRbush","maxEntries","tree","load","equals","json","geojsonRbushModule","lineIntersect","line1","line2","unique","intersects","match","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","polygonToLine","poly","multiPolygonToLine","coordsToLine","multiPoly","lines","booleanDisjoint","feature1","feature2","bool","flatten1","flatten2","disjoint","geom1","geom2","compareCoords","isPointOnLine","isLineOnLine","isLineInPoly","isPolyInPoly","isPointOnLineSegment","lineString1","lineString2","doLinesIntersect","_a","coord1","_b","_c","coord2","lineSegmentStart","lineSegmentEnd","dxc","dyc","dxl","dyl","cross","pair1","pair2","booleanIntersects","booleanPointOnLine","line","ptCoords","lineCoords","excludeBoundary","epsilon","booleanWithin","type1","type2","isPointInMultiPoint","isMultiPointInMultiPoint","isMultiPointOnLine","isMultiPointInPoly","output","multiPoint1","multiPoint2","anyMatch","i2","foundInsidePoint","linestring","polyBbox","calcBbox","lineBbox","doBBoxOverlap","midpoint","getMidpoint","geometry1","geometry2","poly1Bbox","poly2Bbox","bbox1","bbox2","itemGeometry","filterGeometry","within","EOxItemFilterSpatial","spatialFilter","mode","SpatialFilter","mapLayers","updateGeometryFilter","source","state","EOxItemFilterText","searchInput","isArray","getTag","INFINITY","baseToString","toString","isString","isBoolean","isDefined","isBlank","INCORRECT_INDEX_TYPE","LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY","PATTERN_LENGTH_TOO_LARGE","MISSING_KEY_PROPERTY","name","INVALID_KEY_WEIGHT_VALUE","hasOwn","KeyStore","keys","totalWeight","obj","createKey","keyId","path","src","weight","getFn","createKeyPath","createKeyId","get","list","arr","deepGet","index","len","MatchOptions","BasicOptions","FuzzyOptions","AdvancedOptions","Config","SPACE","norm","mantissa","cache","numTokens","FuseIndex","fieldNormWeight","docs","records","idx","doc","docIndex","item","record","keyIndex","subRecords","stack","nestedArrIndex","subRecord","createIndex","myIndex","parseIndex","data","computeScore$1","pattern","errors","currentLocation","expectedLocation","ignoreLocation","accuracy","proximity","convertMaskToIndices","matchmask","minMatchCharLength","indices","start","end","MAX_BITS","search","text","patternAlphabet","location","threshold","findAllMatches","includeMatches","patternLen","textLen","currentThreshold","bestLocation","computeMatches","matchMask","score","lastBitArr","finalScore","binMax","mask","binMin","binMid","finish","bitArr","charMatch","createPatternAlphabet","char","BitapSearch","isCaseSensitive","addChunk","startIndex","remainder","allIndices","totalScore","hasMatches","alphabet","isMatch","BaseMatch","getMatch","exp","matches","ExactMatch","InverseExactMatch","PrefixExactMatch","InversePrefixExactMatch","SuffixExactMatch","InverseSuffixExactMatch","FuzzyMatch","IncludeMatch","searchers","searchersLen","SPACE_RE","OR_TOKEN","parseQuery","query","queryItem","found","searcher","token","MultiMatchSet","ExtendedSearch","_","numMatches","qLen","pLen","registeredSearchers","register","createSearcher","searcherClass","LogicalOperator","KeyType","isExpression","isPath","isLeaf","convertToExplicit","parse","auto","next","isQueryPath","node","computeScore","ignoreFieldNorm","transformMatches","transformScore","format","includeScore","transformers","transformer","Fuse","predicate","limit","shouldSort","sortFn","expression","evaluate","res","child","resultMap","expResults","highlight","fuseSearchResult","highlightClassName","matchKey","set","pathValue","generateHighlightedText","inputText","regions","content","nextUnhighlightedRegionStartingIndex","region","lastRegionNextIndex","highlightedItem","_fuse","indexItems","items","fuseConfig","filters","config","parsedFilters","store","operator","holding","createProperty","pKey","pVal","parameters","response","rangeFilters","acc","filteredResults","pass","parseValue","spatialFilters","ElementConfig","EOxItemFilter","TemplateElement","filterProperty","filterKeys","currentValues","currentValue","prop","fuseKeys","oldValue","filterExternal","filterClient","aggregation","currentFilter","detailsElement","container","details","when","filterObject","staticHTML","unsafeStatic","aggregationProperty","repeat","unsafeHTML"],"mappings":"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","x_google_ignoreList":[0,5,8,9,10,11,12,13,14,15,16,17,18,19,20,23]}