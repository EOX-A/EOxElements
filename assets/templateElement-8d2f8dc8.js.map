{"version":3,"file":"templateElement-8d2f8dc8.js","sources":["../../node_modules/quickselect/index.js","../../node_modules/rbush/index.js","../../utils/templateElement.ts"],"sourcesContent":["\nexport default function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","import { LitElement, html } from \"lit\";\n\n/**\n * Inspired by microsoft-graph-toolkit\n * https://github.com/microsoftgraph/microsoft-graph-toolkit/blob/main/packages/mgt-element/src/components/templatedComponent.ts\n *\n * Allows to render parts of the web component via templateas, e.g.\n * @example ```\n * <template data-type=\"result\">\n *   <div>\n *     The title: <strong>{{result.title}}</strong> -\n *     <small>{{result.id}}</small>\n *   </div>\n * </template>\n * ```\n *\n * To implement it in a web component, just extend this TemplateElement\n * while creating and include e.g.\n * ```\n * this.renderTemplate(\"result\", item, `result-${item.id}`),\n * ```\n */\nexport abstract class TemplateElement extends LitElement {\n  /**\n   * Set an alternative binding syntax. Default is {{ <value> }}\n   *\n   * @param {string} startStr start of binding syntax\n   * @param {string} endStr end of binding syntax\n   */\n  public setBindingSyntax(startStr: string, endStr: string) {\n    this._startExpression = startStr;\n    this._endExpression = endStr;\n\n    const start = this.escapeRegex(this._startExpression);\n    const end = this.escapeRegex(this._endExpression);\n\n    this._expression = new RegExp(\n      `${start}\\\\s*([$\\\\w\\\\.,'\"\\\\s()\\\\[\\\\]]+)\\\\s*${end}`,\n      \"g\"\n    );\n  }\n\n  /**\n   * Check if a specific template has been provided.\n   *\n   * @param {string} templateName\n   * @returns {boolean}\n   */\n  public hasTemplate(templateName: string): boolean {\n    // @ts-ignore\n    return this.templates && !!this.templates[templateName];\n  }\n\n  /**\n   * Render a <template> by type and return content to render\n   *\n   * @param templateType type of template (indicated by the data-type attribute)\n   * @param context the data context that should be expanded in template\n   * @param slotName the slot name that will be used to host the new rendered template. set to a unique value if multiple templates of this type will be rendered. default is templateType\n   */\n  public renderTemplate(\n    templateType: string,\n    context: object,\n    slotName?: string\n  ) {\n    if (!this.hasTemplate(templateType)) {\n      return null;\n    }\n\n    slotName = slotName || templateType;\n\n    const template = html` <slot name=${slotName}></slot> `;\n\n    const dataContext = { [templateType]: { ...context } };\n    if (this._renderedTemplates.hasOwnProperty(slotName)) {\n      const { slot } =\n        // @ts-ignore\n        this._renderedTemplates[slotName];\n      if (this.contains(slot)) {\n        this.removeChild(slot);\n      }\n    }\n\n    const div = document.createElement(\"div\");\n    div.slot = slotName;\n    div.dataset.generated = \"template\";\n\n    // @ts-ignore\n    this._renderTemplate(div, this.templates[templateType], dataContext);\n\n    this.appendChild(div);\n\n    // @ts-ignore\n    this._renderedTemplates[slotName] = { context: dataContext, slot: div };\n\n    return template;\n  }\n\n  private templates = {};\n  private _renderedTemplates = {};\n\n  private _startExpression: string;\n  private _endExpression: string;\n  private _expression: RegExp;\n\n  private getTemplates() {\n    const templates: any = {};\n\n    // tslint:disable-next-line: prefer-for-of\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      if (child.nodeName === \"RENDER-TEMPLATE\") {\n        const template = child as HTMLElement;\n        if (template.dataset.type) {\n          templates[template.dataset.type] = template;\n        } else {\n          templates.default = template;\n        }\n\n        (template as any).templateOrder = i;\n      }\n    }\n    return templates;\n  }\n\n  private _renderTemplate(\n    root: HTMLElement,\n    template: HTMLTemplateElement,\n    context: object\n  ) {\n    let rendered: Node;\n    if (template && template.childNodes.length) {\n      const templateContent = template.cloneNode(true);\n      rendered = this.renderNode(templateContent, root, context);\n    }\n\n    if (rendered) {\n      root.appendChild(rendered);\n    }\n  }\n\n  private expandExpressionsAsString(str: string, context: object) {\n    return str.replace(this.expression, (match, p1) => {\n      const value = this.evalInContext(\n        p1 || this.trimExpression(match),\n        context\n      );\n      if (value) {\n        if (typeof value === \"object\") {\n          return JSON.stringify(value);\n        } else {\n          return (value as any).toString();\n        }\n      }\n      return \"\";\n    });\n  }\n\n  private get expression() {\n    if (!this._expression) {\n      this.setBindingSyntax(\"{{\", \"}}\");\n    }\n\n    return this._expression;\n  }\n\n  private escapeRegex(str: string) {\n    return str.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n  }\n\n  private evalInContext(expression: string, context: Object) {\n    context = { ...context };\n    const func = new Function(\"with(this) { return \" + expression + \";}\");\n    let result;\n    try {\n      result = func.call(context);\n    } catch (e) {}\n    return result;\n  }\n\n  private trimExpression(expression: string) {\n    expression = expression.trim();\n\n    if (\n      expression.startsWith(this._startExpression) &&\n      expression.endsWith(this._endExpression)\n    ) {\n      expression = expression.substr(\n        this._startExpression.length,\n        expression.length -\n          this._startExpression.length -\n          this._endExpression.length\n      );\n      expression = expression.trim();\n    }\n\n    return expression;\n  }\n\n  private renderNode(node: Node, root: HTMLElement, context: object) {\n    if (node.nodeName === \"#text\") {\n      node.textContent = this.expandExpressionsAsString(\n        node.textContent,\n        context\n      );\n      return node;\n    } else if (node.nodeName === \"TEMPLATE\") {\n      (node as any).$parentTemplateContext = context;\n      return node;\n    }\n    for (let i = 0; i < node.childNodes.length; i++) {\n      const childNode = node.childNodes[i];\n      this.renderNode(childNode, root, context);\n    }\n    return node;\n  }\n\n  firstUpdated() {\n    this.templates = this.getTemplates();\n  }\n}\n"],"names":["quickselect","arr","k","left","right","compare","quickselectStep","defaultCompare","n","m","z","s","sd","newLeft","newRight","t","i","j","swap","tmp","a","b","RBush$1","maxEntries","bbox","node","result","intersects","toBBox","nodesToSearch","child","childBBox","contains","data","tmpNode","item","createNode","equalsFn","path","indexes","parent","goingUp","index","findItem","items","height","N","M","calcBBox","N2","N1","multiSelect","right2","right3","level","minArea","minEnlargement","targetNode","area","bboxArea","enlargement","enlargedArea","isNode","insertPath","extend","splitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","compareMinX","compareNodeMinX","compareMinY","compareNodeMinY","xMargin","yMargin","leftBBox","rightBBox","margin","bboxMargin","siblings","p","destNode","minX","minY","maxX","maxY","children","stack","mid","TemplateElement","LitElement","startStr","endStr","start","end","templateName","templateType","context","slotName","template","html","dataContext","slot","div","templates","root","rendered","templateContent","str","match","p1","value","expression","func","childNode"],"mappings":"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","x_google_ignoreList":[0,1]}