{"version":3,"file":"itemfilter.stories-owYCrQWl.js","sources":["../../node_modules/lit-html/directives/repeat.js","../../elements/itemfilter/src/style.ts","../../elements/itemfilter/src/style.eox.ts","../../elements/itemfilter/src/filters/_expandcontainer.ts","../../elements/itemfilter/src/reset.ts","../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs","../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../elements/itemfilter/src/dropdown.ts","../../elements/itemfilter/src/chips.ts","../../elements/itemfilter/src/autocomplete.ts","../../elements/itemfilter/src/selectionlist.ts","../../elements/itemfilter/src/filters/multiselect.ts","../../node_modules/lodash.debounce/index.js","../../elements/itemfilter/src/filters/range.ts","../../elements/itemfilter/src/filters/select.ts","../../node_modules/@turf/helpers/dist/es/index.js","../../node_modules/@turf/invariant/dist/es/index.js","../../node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","../../node_modules/@turf/meta/dist/es/index.js","../../node_modules/@turf/line-segment/dist/es/index.js","../../node_modules/@turf/bbox/dist/es/index.js","../../node_modules/geojson-rbush/index.js","../../node_modules/@turf/line-intersect/dist/es/index.js","../../node_modules/@turf/polygon-to-line/dist/es/index.js","../../node_modules/@turf/boolean-disjoint/dist/es/index.js","../../node_modules/@turf/boolean-intersects/dist/es/index.js","../../node_modules/@turf/boolean-point-on-line/dist/es/index.js","../../node_modules/@turf/boolean-within/dist/es/index.js","../../elements/itemfilter/src/filters/spatial.ts","../../elements/itemfilter/src/filters/text.ts","../../elements/itemfilter/src/inline.ts","../../node_modules/fuse.js/dist/fuse.mjs","../../elements/itemfilter/src/itemHighlighting.ts","../../elements/itemfilter/src/filterClient.ts","../../elements/itemfilter/src/filterExternal.ts","../../elements/itemfilter/src/main.ts"],"sourcesContent":["import{noChange as e}from\"../lit-html.js\";import{directive as s,Directive as t,PartType as r}from\"../directive.js\";import{getCommittedValue as l,setChildPartValue as o,insertPart as i,removePart as n,setCommittedValue as f}from\"../directive-helpers.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst u=(e,s,t)=>{const r=new Map;for(let l=s;l<=t;l++)r.set(e[l],l);return r},c=s(class extends t{constructor(e){if(super(e),e.type!==r.CHILD)throw Error(\"repeat() can only be used in text expressions\")}ht(e,s,t){let r;void 0===t?t=s:void 0!==s&&(r=s);const l=[],o=[];let i=0;for(const s of e)l[i]=r?r(s,i):i,o[i]=t(s,i),i++;return{values:o,keys:l}}render(e,s,t){return this.ht(e,s,t).values}update(s,[t,r,c]){const d=l(s),{values:p,keys:a}=this.ht(t,r,c);if(!Array.isArray(d))return this.dt=a,p;const h=this.dt??=[],v=[];let m,y,x=0,j=d.length-1,k=0,w=p.length-1;for(;x<=j&&k<=w;)if(null===d[x])x++;else if(null===d[j])j--;else if(h[x]===a[k])v[k]=o(d[x],p[k]),x++,k++;else if(h[j]===a[w])v[w]=o(d[j],p[w]),j--,w--;else if(h[x]===a[w])v[w]=o(d[x],p[w]),i(s,v[w+1],d[x]),x++,w--;else if(h[j]===a[k])v[k]=o(d[j],p[k]),i(s,d[x],d[j]),j--,k++;else if(void 0===m&&(m=u(a,k,w),y=u(h,x,j)),m.has(h[x]))if(m.has(h[j])){const e=y.get(a[k]),t=void 0!==e?d[e]:null;if(null===t){const e=i(s,d[x]);o(e,p[k]),v[k]=e}else v[k]=o(t,p[k]),i(s,d[x],t),d[e]=null;k++}else n(d[j]),j--;else n(d[x]),x++;for(;k<=w;){const e=i(s,v[w+1]);o(e,p[k]),v[k++]=e}for(;x<=j;){const e=d[x++];null!==e&&n(e)}return this.dt=a,f(s,v),e}});export{c as repeat};\n//# sourceMappingURL=repeat.js.map\n","export const style = `\n:host {\n  display: flex;\n  box-sizing: border-box;\n  height: 100%;\n  line-height: 1;\n}\n*,\n*:before,\n*:after {\n  box-sizing: inherit;\n}\nform#itemfilter {\n  height: 100%;\n  width: 100%;\n  max-width: 100%;\n  display: flex;\n  flex-direction: column;\n}\ndetails {\n  width: 100%;\n}\n`;\n","import { button } from \"../../../utils/styles/button\";\nimport { checkbox } from \"../../../utils/styles/checkbox\";\nimport { radio } from \"../../../utils/styles/radio\";\nimport { slider } from \"../../../utils/styles/slider\";\n\nexport const styleEOX = `\n* {\n  font-family: Roboto, sans-serif;\n}\n\n${button}\n${checkbox}\n${radio}\n${slider}\n\nul {\n  padding-left: 0;\n  margin-top: 0;\n}\nli {\n  list-style: none;\n}\nli span {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\nli label {\n  display: flex;\n  align-items: center;\n}\ndetails summary > * {\n  display: inline;\n}\ndetails summary {\n  display: flex;\n  align-items: center;\n  border-bottom: 1px solid #0002;\n  padding: .5rem 0;\n}\n\ndetails > summary::-webkit-details-marker {\n  display: none;\n}\n\n.title {\n  font-size: small;\n  align-items: center;\n}\ndetails summary .title {\n  display: flex;\n  font-weight: 500;\n}\ndetails.details-filter summary::after,\ndetails.details-results summary::before {\n  content: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%230009' viewBox='0 0 24 24'%3E%3Ctitle%3Echevron-right%3C/title%3E%3Cpath d='M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z' /%3E%3C/svg%3E\");\n  height: 24px;\n  width: 24px;\n}\ndetails.details-filter summary::after {\n  position: absolute;\n  right: 8px;\n  transform: rotate(90deg);\n}\ndetails[open] summary::before {\n  transform: rotate(90deg);\n}\ndetails[open] summary::after {\n  transform: rotate(270deg);\n}\neox-itemfilter-expandcontainer {\n  max-height: 200px;\n}\neox-itemfilter-expandcontainer > [data-type=filter] {\n  display: block;\n  height: calc(100% - 32px);\n  overflow-y: auto;\n}\n[data-type=filter] .title,\ndetails summary {\n  text-transform: capitalize;\n}\nli,\nlabel,\ndetails,\ninput[type=\"checkbox\"],\ninput[type=\"radio\"] {\n  cursor: pointer;\n}\ninput[type=\"checkbox\"],\ninput[type=\"radio\"] {\n  margin: 0;\n}\ninput[type=\"text\"] {\n  box-sizing: border-box;\n  width: 100%;\n  margin-top: 0.5rem;\n  margin-bottom: 0.5rem;\n  padding: 5px 7px;\n  border-radius: 4px;\n  border: 1px solid #0004;\n}\nsection:not(section:last-of-type) {\n  margin-bottom: 1rem;\n}\n#section-results {\n  overflow: hidden;\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\nul li {\n  padding: 5px 10px;\n}\nli.highlighted {\n  background: #00417011;\n}\nsection {\n  position: relative;\n}\nbutton#filter-reset {\n  position: absolute;\n  top: 4px;\n  right: 0;\n}\n.scroll {\n  max-height: calc(100% - 30px);\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.count {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background: #00417044;\n  padding: 0 12px;\n  height: 20px;\n  border-radius: 10px;\n  color: #004170;\n  font-weight: 500;\n  margin-left: 9px;\n}\neox-itemfilter-range {\n  display: flex;\n  align-items: center;\n  padding: .5rem 0;\n}\n.range-before,\n.range-after {\n  font-size: small;\n}\n.range-before {\n  margin-right: .5rem;\n}\n.range-after {\n  margin-left: .5rem;\n}\n\nbutton.reset-icon:before {\n  content: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23004170' viewBox='0 0 24 24'%3E%3Ctitle%3Eclose%3C/title%3E%3Cpath d='M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z' /%3E%3C/svg%3E\");\n}\neox-itemfilter-expandcontainer button.reset-icon {\n  margin-left: 4px;\n  margin-top: 1px;\n}\neox-itemfilter-expandcontainer button.reset-icon:before {\n  height: 16px;\n  width: 16px;\n}\n  `;\n","import { LitElement, html, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators.js\";\nimport { style } from \"../style\";\nimport { styleEOX } from \"../style.eox\";\n\n@customElement(\"eox-itemfilter-expandcontainer\")\nexport class EOxItemFilterExpandContainer extends LitElement {\n  @property({ attribute: false })\n  filterObject: FilterObject;\n\n  @property()\n  unstyled: boolean;\n\n  handleDetailsToggle(event: Event) {\n    this.dispatchEvent(\n      new CustomEvent(\"details-toggled\", {\n        detail: event,\n        bubbles: true,\n        composed: true,\n      })\n    );\n  }\n\n  _resetFilter() {\n    const filterEl = this.querySelector(`[slot='filter']`) as Element & {\n      reset: () => void;\n    };\n    filterEl.reset();\n  }\n\n  render() {\n    return html`\n      <style>\n        ${style}\n        ${!this.unstyled && styleEOX}\n      </style>\n      <details\n        @toggle=\"${this.handleDetailsToggle}\"\n        class=\"details-filter\"\n        part=\"details-filter\"\n        ?open=${this.filterObject.expanded || (nothing as null)}\n      >\n        <summary>\n          <span\n            class=\"title\"\n            style=\"${!this.filterObject.title && \"text-transform: capitalize\"}\"\n          >\n            ${this.filterObject.title || this.filterObject.key || \"Filter\"}\n            <slot name=\"reset-button\"></slot>\n          </span>\n        </summary>\n        <div class=\"scroll\">\n          <slot name=\"filter\"></slot>\n        </div>\n      </details>\n    `;\n  }\n}\n","export const resetFilter = (filterObject: FilterObject) => {\n  if (!filterObject.dirty) {\n    return null;\n  }\n  const filterType = filterObject.type;\n  switch (filterType) {\n    case \"multiselect\":\n      for (const filter in filterObject.state) {\n        filterObject.state[filter] = false;\n      }\n      break;\n    case \"range\":\n      filterObject.state.min = (<RangeFilterObject>filterObject).min;\n      filterObject.state.max = (<RangeFilterObject>filterObject).max;\n      break;\n    case \"select\":\n      for (const filter in filterObject.state) {\n        filterObject.state[filter] = false;\n      }\n      break;\n    case \"spatial\":\n      filterObject.state.geometry = undefined;\n      break;\n    case \"text\":\n      filterObject.keys.forEach((key) => {\n        filterObject.state[key] = undefined;\n      });\n      break;\n  }\n  delete filterObject.stringifiedState;\n  delete filterObject.dirty;\n  return filterObject;\n};\n","const sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, platform };\n","import { LitElement, html, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators.js\";\nimport { computePosition, autoUpdate } from \"@floating-ui/dom\";\n\n@customElement(\"eox-dropdown\")\nexport class EOxDropdown extends LitElement {\n  @property({ type: Boolean })\n  open = false;\n\n  @property()\n  parent: Element = null;\n\n  @property({ type: Boolean })\n  unstyled = false;\n\n  _handleKeyboard(key: string) {\n    if (this.clientHeight === 0) {\n      return;\n    }\n    if (key === \"Escape\") {\n      //\n    }\n  }\n\n  /**\n   * Stores the autoUpdate cleanup function to be called\n   * when disconnected\n   */\n  _overlayCleanup(): void {}\n\n  _clickEventListener: EventListener = () => {\n    this.open = false;\n  };\n  _keyboardEventListener = ((event: KeyboardEvent) => {\n    const { code } = <KeyboardEvent>event;\n    if ([\"Escape\"].includes(code)) {\n      this._handleKeyboard(code);\n    }\n  }) as EventListener;\n\n  connectedCallback(): void {\n    super.connectedCallback();\n    if (!this.unstyled) {\n      setTimeout(() => {\n        const trigger = (this.parent ||\n          (<HTMLSlotElement>(\n            this.renderRoot.querySelector(\"[name=trigger]\")\n          )).assignedNodes()[0]) as Element;\n        const dropdown = <HTMLElement>(\n          this.renderRoot.querySelector(\"#dropdown\")\n        );\n        const updatePosition = () => {\n          if (dropdown.classList.contains(\"open\")) {\n            computePosition(trigger, dropdown, { strategy: \"fixed\" }).then(\n              ({ x, y }) => {\n                Object.assign(dropdown.style, {\n                  left: `${x}px`,\n                  top: `${y}px`,\n                  width: `${trigger.getBoundingClientRect().width}px`,\n                });\n              }\n            );\n          }\n        };\n        this._overlayCleanup = autoUpdate(trigger, dropdown, updatePosition);\n      });\n    }\n  }\n\n  disconnectedCallback(): void {\n    super.disconnectedCallback();\n    this._overlayCleanup();\n    this.getRootNode().removeEventListener(\n      \"keydown\",\n      this._keyboardEventListener\n    );\n    window.removeEventListener(\"click\", this._clickEventListener);\n  }\n\n  render() {\n    return html`\n      <style>\n        #dropdown {\n          display: none;\n        }\n        #dropdown.open {\n          display: block;\n        }\n        ${!this.unstyled\n          ? html`\n              eox-dropdown { height: 100%;} #dropdown { position: fixed; top:\n              0px; left: 0; width: 100%; margin: 0; padding: 0; background:\n              white; border-bottom-left-radius: 4px; border-bottom-right-radius:\n              4px; box-shadow: 0 4px 4px #0007; cursor: default; max-height:\n              200px; overflow-y: auto; z-index: 99;}\n            `\n          : nothing}\n      </style>\n      <slot name=\"trigger\"></slot>\n      <div id=\"dropdown\">\n        <slot name=\"content\"></slot>\n      </div>\n    `;\n  }\n\n  updated(changedProperties: Map<PropertyKey, unknown>) {\n    if (changedProperties.has(\"open\")) {\n      const dropdown = this.renderRoot.querySelector(\"#dropdown\");\n      if (this.open) {\n        dropdown.classList.add(\"open\");\n      } else {\n        dropdown.classList.remove(\"open\");\n      }\n      this.requestUpdate();\n    }\n  }\n\n  firstUpdated() {\n    window.addEventListener(\"click\", this._clickEventListener);\n    this.getRootNode().addEventListener(\"keydown\", this._keyboardEventListener);\n    const trigger = (<HTMLSlotElement>(\n      this.renderRoot.querySelector(\"[name=trigger]\")\n    )).assignedNodes()[0];\n    trigger.addEventListener(\"focus\", () => {\n      this.open = true;\n    });\n  }\n}\n","import { LitElement, html, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators.js\";\nimport { map } from \"lit/directives/map.js\";\nimport { when } from \"lit/directives/when.js\";\n\n@customElement(\"eox-itemfilter-chips\")\nexport class EOxItemFilterChips extends LitElement {\n  @property({ type: Array })\n  items: FilterObject[] = [];\n\n  @property()\n  titleProperty: string = \"title\";\n\n  @property({ type: Boolean })\n  unstyled = false;\n\n  _dispatchEvent() {\n    this.dispatchEvent(\n      new CustomEvent(\"items-selected\", {\n        detail: this.items,\n      })\n    );\n  }\n\n  _handleKeyboard(key: string, textValue: string) {\n    const highlightedChip = this.renderRoot.querySelector(\".chip.highlighted\");\n    if (key === \"Escape\" || textValue) {\n      if (highlightedChip) {\n        highlightedChip.classList.remove(\"highlighted\");\n      }\n    }\n    if (key === \"Backspace\" && !textValue) {\n      if (this.items.length) {\n        if (highlightedChip) {\n          this.items.splice(\n            Array.from(this.renderRoot.querySelectorAll(\".chip\")).indexOf(\n              highlightedChip\n            ),\n            1\n          );\n        }\n        const lastChip =\n          this.renderRoot.querySelectorAll(\".chip\")[\n            this.renderRoot.querySelectorAll(\".chip\").length - 1\n          ];\n        if (!lastChip.classList.contains(\"highlighted\")) {\n          lastChip.classList.add(\"highlighted\");\n        }\n        this.requestUpdate();\n      }\n      this._dispatchEvent();\n    }\n    if ((key === \"ArrowLeft\" || key === \"ArrowRight\") && !textValue) {\n      if (this.renderRoot.querySelectorAll(\".chip\").length < 1) {\n        return;\n      }\n      let highlightedChipIndex = 0;\n      const highlightedChip =\n        this.renderRoot.querySelector(\".chip.highlighted\");\n      if (highlightedChip) {\n        highlightedChipIndex = Array.from(\n          this.renderRoot.querySelectorAll(\".chip\")\n        ).indexOf(highlightedChip);\n        highlightedChip.classList.remove(\"highlighted\");\n      }\n      highlightedChipIndex =\n        highlightedChipIndex + (key === \"ArrowLeft\" ? -1 : +1);\n      if (key === \"ArrowLeft\" && highlightedChipIndex < 0) {\n        highlightedChipIndex =\n          this.renderRoot.querySelectorAll(\".chip\").length - 1;\n      }\n      if (\n        key === \"ArrowRight\" &&\n        highlightedChipIndex >\n          this.renderRoot.querySelectorAll(\".chip\").length - 1\n      ) {\n        highlightedChipIndex = 0;\n      }\n      Array.from(this.renderRoot.querySelectorAll(\".chip\"))[\n        highlightedChipIndex\n      ].classList.add(\"highlighted\");\n    }\n  }\n\n  _keyboardEventListener: EventListener = (event: Event) => {\n    const { code } = <KeyboardEvent>event;\n    if (\n      this.parentElement.classList.contains(\"hidden\") &&\n      [\"ArrowLeft\", \"ArrowRight\", \"Backspace\"].includes(code)\n    ) {\n      return;\n    }\n    if (code === \"Space\") {\n      event.preventDefault();\n    }\n    if (![\"Escape\", \"Space\", \"Enter\"].includes(code)) {\n      event.stopPropagation();\n    }\n    if ([\"ArrowLeft\", \"ArrowRight\", \"Escape\", \"Backspace\"].includes(code)) {\n      this._handleKeyboard(code, (<HTMLInputElement>event.target).value ?? \"\");\n    }\n  };\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.getRootNode().addEventListener(\"keydown\", this._keyboardEventListener);\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.getRootNode().removeEventListener(\n      \"keydown\",\n      this._keyboardEventListener\n    );\n  }\n\n  render() {\n    return html`\n      <style>\n        .chip.highlighted {\n          background: lightgrey;\n        }\n        .chip-title {\n          pointer-events: none;\n        }\n        ${!this.unstyled\n          ? html`\n              .chip-container { display: flex; flex: 0; } .chip { display: flex;\n              align-items: center; background: #00417022; border-radius: 4px;\n              margin-right: 4px; padding: 5px 10px; font-size: small; cursor:\n              default; white-space: nowrap; } .chip.highlighted { background:\n              #004170; color: white; } .chip-close { cursor: pointer;\n              margin-left: 4px; }\n            `\n          : nothing}\n      </style>\n      <span class=\"chip-container\">\n        ${map(\n          this.items,\n          (item) => html`\n            <span\n              class=\"chip\"\n              @click=${(evt: Event) => {\n                this.renderRoot.querySelectorAll(\".chip\").forEach((chip) => {\n                  chip.classList.remove(\"highlighted\");\n                });\n                (<HTMLLIElement>evt.target).classList.add(\"highlighted\");\n                this.requestUpdate();\n              }}\n            >\n              <span class=\"chip-title\"\n                >${item[this.titleProperty as keyof FilterObject]}</span\n              >\n              ${when(item._inProgress, () =>\n                !item.stringifiedState ? html` ... ` : \"\"\n              )}\n              ${when(\n                item.stringifiedState,\n                () => html`: ${item.stringifiedState}`\n              )}\n              <span\n                class=\"chip-close\"\n                @click=${(evt: Event) => {\n                  evt.stopPropagation();\n                  this.items.splice(this.items.indexOf(item), 1);\n                  this._dispatchEvent();\n                  this.requestUpdate();\n                }}\n                >✕</span\n              >\n            </span>\n          `\n        )}\n      </span>\n    `;\n  }\n}\n","import { LitElement, html, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators.js\";\nimport { when } from \"lit/directives/when.js\";\nimport \"./dropdown\";\nimport \"./chips\";\nimport { button } from \"../../../utils/styles/button\";\nimport { EOxDropdown } from \"./dropdown\";\nimport { EOxItemFilterMultiselect } from \"./filters/multiselect\";\nimport { EOxSelectionlist } from \"./selectionlist\";\nimport { EOxItemFilterChips } from \"./chips\";\n\n@customElement(\"eox-autocomplete\")\nexport class EOxAutocomplete extends LitElement {\n  @property()\n  idProperty = \"id\";\n\n  @property()\n  items: FilterObject[] = [];\n\n  @property()\n  titleProperty = \"title\";\n\n  @property()\n  itemTitleProperty = this.titleProperty;\n\n  @property({ type: Boolean })\n  multiple = false;\n\n  @property({ type: Boolean })\n  unstyled = false;\n\n  @property({ type: Boolean })\n  multiStep = false;\n\n  @state()\n  public inputText = \"\";\n\n  @state()\n  selectedItems: FilterObject[] = [];\n\n  _handleKeyboard(key: string) {\n    if (this.clientHeight === 0) {\n      return;\n    }\n    if (key === \"Escape\") {\n      // If nothing is selected yet, first clear the input,\n      // then on second escape blur the input\n      if (this.selectedItems.length < 1 || this.multiple) {\n        if (this.renderRoot.querySelector(\"input\").value !== \"\") {\n          this.renderRoot.querySelector(\"input\").value = \"\";\n        } else {\n          (<EOxDropdown>this.renderRoot.querySelector(\"eox-dropdown\")).open =\n            false;\n        }\n        return;\n      }\n      if (!this.multiple) {\n        // In single-select mode, check if the currently displayed text matches\n        // the selected item or not. Useful if the user \"browses\" the list but\n        // wants to abort; resets input to the currently selected item\n        if (\n          this.renderRoot.querySelector(\"input\").value !==\n          this.selectedItems[0][<keyof FilterObject>this.titleProperty]\n        ) {\n          this.renderRoot.querySelector(\"input\").value = this.selectedItems[0][\n            <keyof FilterObject>this.titleProperty\n          ] as string;\n        } else {\n          (<EOxDropdown>this.renderRoot.querySelector(\"eox-dropdown\")).open =\n            false;\n        }\n      }\n      return;\n    }\n\n    if (key === \"ArrowDown\" || key === \"ArrowUp\") {\n      (<EOxDropdown>this.renderRoot.querySelector(\"eox-dropdown\")).open = true;\n      if ((<EOxItemFilterMultiselect | undefined>this.parentElement)?.inline) {\n        (<EOxSelectionlist>(\n          this.renderRoot.querySelector(\"eox-selectionlist\")\n        ))._handleKeyboard(key);\n      }\n    }\n\n    this.renderRoot.querySelector(\"input\").select();\n    if ((<EOxItemFilterMultiselect | undefined>this.parentElement)?.inline) {\n      if (![\"ArrowUp\", \"ArrowDown\"].includes(key)) {\n        (<HTMLInputElement>(\n          this.parentElement.parentElement?.parentElement?.querySelector(\n            \"#inline-input\"\n          )\n        )).focus();\n      }\n    }\n  }\n\n  _handleHighlight(items: FilterObject[]) {\n    if (!items[0]._inProgress) {\n      this.renderRoot.querySelector(\"input\").value =\n        <string>items[0][<keyof FilterObject>this.titleProperty] || \"\";\n      this.renderRoot.querySelector(\"input\").select();\n    }\n  }\n\n  _handleSelect(items: FilterObject[]) {\n    // TODO\n    if (items.length > 0 && this.multiStep) {\n      items.forEach((i) => {\n        if (!this.selectedItems.includes(i)) {\n          i._inProgress = true;\n        }\n      });\n    }\n    this.selectedItems = items;\n    if (items.length > 0) {\n      if (this.multiple) {\n        this.renderRoot.querySelector(\"input\").value = \"\";\n        this.renderRoot.querySelector(\"input\").focus();\n      } else {\n        this.renderRoot.querySelector(\"input\").value = items[0][\n          <keyof FilterObject>this.titleProperty\n        ] as string;\n\n        // in multi-step items, when the item is still in progress,\n        // keep the dropdown open\n        if (!items[0]._inProgress) {\n          (<EOxDropdown>this.renderRoot.querySelector(\"eox-dropdown\")).open =\n            false;\n        }\n      }\n    } else {\n      this.renderRoot.querySelector(\"input\").select();\n      this.renderRoot.querySelector(\"input\").focus();\n    }\n    this._dispatchEvent();\n    this.requestUpdate();\n    (<EOxItemFilterChips>(\n      this.renderRoot.querySelector(\"eox-itemfilter-chips\")\n    ))?.requestUpdate();\n  }\n\n  _dispatchEvent() {\n    this.dispatchEvent(\n      new CustomEvent(\"items-selected\", {\n        detail: this.selectedItems,\n      })\n    );\n  }\n\n  _keyboardEventListener = ((event: KeyboardEvent) => {\n    const { code } = <KeyboardEvent>event;\n    if (\n      [\n        \"ArrowUp\",\n        \"ArrowDown\",\n        // \"ArrowLeft\",\n        // \"ArrowRight\",\n        \"Escape\",\n        \"Backspace\",\n      ].includes(code)\n    ) {\n      this._handleKeyboard(code);\n    }\n  }) as EventListener;\n\n  disconnectedCallback(): void {\n    super.disconnectedCallback();\n    this.getRootNode().removeEventListener(\n      \"keydown\",\n      this._keyboardEventListener\n    );\n  }\n\n  firstUpdated() {\n    this.getRootNode().addEventListener(\"keydown\", this._keyboardEventListener);\n    // }\n  }\n\n  updated(updatedProperties: Map<PropertyKey, unknown>) {\n    if (updatedProperties.has(\"selectedItems\")) {\n      this._handleSelect(this.selectedItems);\n    }\n  }\n\n  render() {\n    return html`\n      <style>\n        :host,\n        .container {\n          display: flex;\n        }\n        #dropdown {\n          display: none;\n        }\n        ${!this.unstyled\n          ? html`\n              ${button} :host { position: relative; } .container { width: 100%;\n              position: relative; border: 1px solid #00417066; border-radius:\n              4px; height: 24px; padding: 5px; flex: 1; justify-content:\n              space-between; cursor: text; overflow-x: auto; } .container:hover\n              { border: 1px solid #004170; } .input-container { display: flex;\n              flex: 1; align-items: center; } input, input:focus { height: 100%;\n              border: none; outline: none; } .button-container { display: flex;\n              align-items: center; justify-content: center; position: absolute;\n              right: 1px; top: 5px; height: calc(100% - 10px); width: 34px;\n              background: white; } button.icon { color: #004170; height: 24px;\n              font-size: large; width: unset; } .container::-webkit-scrollbar {\n              height: 2px; } .container::-webkit-scrollbar-thumb { background:\n              lightgrey; border-radius: 2px;} .hidden {height: 1px; padding: 0;\n              border: none;} .hidden:hover {border: none} .hidden input {\n              opacity: 0% }\n            `\n          : nothing}\n      </style>\n      <div\n        class=\"container\"\n        part=\"container\"\n        @click=${(evt: Event) => {\n          evt.stopPropagation();\n          (<HTMLInputElement>(\n            this.renderRoot.querySelector(\"input[type=text]\")\n          )).focus();\n        }}\n      >\n        ${when(\n          this.multiple,\n          () => html`\n            <eox-itemfilter-chips\n              .items=${this.selectedItems}\n              .titleProperty=${this.titleProperty}\n              .unstyled=${this.unstyled}\n            ></eox-itemfilter-chips>\n          `\n        )}\n        <div class=\"input-container\">\n          <eox-dropdown\n            .parent=${this.parentNode.parentNode as Element}\n            .unstyled=${this.unstyled}\n          >\n            <input\n              slot=\"trigger\"\n              type=\"text\"\n              @focus=${() => {\n                this.inputText = \"\";\n                this.requestUpdate();\n              }}\n              @input=${(event: Event) => {\n                this.inputText = (event!\n                  .target as HTMLInputElement)!.value.toLowerCase();\n              }}\n            />\n            ${when(\n              this.items.length > 0,\n              () => html`\n                <eox-selectionlist\n                  slot=\"content\"\n                  .filter=${this.inputText}\n                  .idProperty=${this.idProperty}\n                  .titleProperty=${this.titleProperty}\n                  .items=${this.items\n                    .filter((f) =>\n                      this.multiStep ? !f.stringifiedState : true\n                    )\n                    .filter((f) =>\n                      this.inputText\n                        ? (<string>f[<keyof FilterObject>this.titleProperty])\n                            .toLowerCase()\n                            .includes(this.inputText.toLowerCase())\n                        : true\n                    )}\n                  .multiple=${this.multiStep ? true : this.multiple}\n                  .disableKeyboardEvents=${this.multiStep}\n                  .selectedItems=${this.multiStep\n                    ? this.selectedItems.filter((i) => i.stringifiedState)\n                    : this.selectedItems}\n                  .unstyled=${this.unstyled}\n                  @items-highlighted=${(event: CustomEvent) => {\n                    this._handleHighlight(event.detail);\n                  }}\n                  @items-selected=${(event: CustomEvent) => {\n                    this._handleSelect(event.detail);\n                  }}\n                >\n                </eox-selectionlist>\n              `\n            )}\n          </eox-dropdown>\n        </div>\n      </div>\n      ${when(\n        this.selectedItems.length > 0,\n        () => html`\n          <div class=\"button-container\">\n            <button\n              class=\"icon\"\n              @click=${() => {\n                this._handleSelect([]);\n              }}\n            >\n              ✕\n            </button>\n          </div>\n        `\n      )}\n    `;\n  }\n}\n","import { LitElement, html, nothing, PropertyValues } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators.js\";\nimport { repeat } from \"lit/directives/repeat.js\";\nimport { style } from \"./style\";\nimport { styleEOX } from \"./style.eox\";\n\n@customElement(\"eox-selectionlist\")\nexport class EOxSelectionlist extends LitElement {\n  @property()\n  filter = \"\";\n\n  @property()\n  idProperty: string = \"id\";\n\n  @property()\n  items: FilterObject[] = [];\n\n  @property()\n  titleProperty = \"title\";\n\n  @property({ type: Boolean })\n  multiple = false;\n\n  @property()\n  selectedItems: FilterObject[] = [];\n\n  @property({ type: Boolean })\n  unstyled = false;\n\n  @state()\n  _currentHighlight: FilterObject = null;\n\n  _handleKeyboard(key: string) {\n    if (this.clientHeight === 0) {\n      return;\n    }\n    const currentlyHighlighted = this.renderRoot.querySelector(\n      \"li.highlighted\"\n    ) as HTMLLIElement;\n    if (key === \"Escape\") {\n      if (this._currentHighlight) {\n        this._currentHighlight = null;\n      }\n      return;\n    }\n    if (key === \"Enter\") {\n      if (currentlyHighlighted) {\n        const currentItem = this.items.find(\n          (f) =>\n            f[<keyof FilterObject>this.idProperty] ===\n            currentlyHighlighted.dataset.identifier\n        ) as FilterObject;\n        this._handleSelect(currentItem);\n        this.requestUpdate();\n      }\n      return;\n    }\n    const listItems = this.renderRoot.querySelectorAll(\"li\");\n    let currentIndex = -1;\n    if (currentlyHighlighted) {\n      delete (<HTMLElement>currentlyHighlighted).dataset.highlighted;\n      currentIndex = Array.from(listItems).indexOf(currentlyHighlighted);\n    }\n    if (key === \"ArrowDown\") {\n      currentIndex++;\n      if (currentIndex > listItems.length - 1) {\n        currentIndex = 0;\n      }\n    }\n    if (key === \"ArrowUp\") {\n      currentIndex--;\n      if (currentIndex < 0) {\n        currentIndex = listItems.length - 1;\n      }\n    }\n    const currentListItem = Array.from(listItems)[currentIndex];\n    if (currentListItem) {\n      this._currentHighlight = this.items.find(\n        (f) =>\n          f[<keyof FilterObject>this.idProperty] ===\n          currentListItem.dataset.identifier\n      );\n    }\n    this.dispatchEvent(\n      new CustomEvent(\"items-highlighted\", { detail: [this._currentHighlight] })\n    );\n  }\n\n  _handleSelect(item: FilterObject) {\n    if (item) {\n      if (this.multiple) {\n        // In multiple mode, selecting the same item again removes it from the selectedItem list\n        const selected = this.selectedItems.find(\n          (i) =>\n            i[<keyof FilterObject>this.idProperty] ===\n            item[<keyof FilterObject>this.idProperty]\n        );\n        if (selected) {\n          this.selectedItems.splice(this.selectedItems.indexOf(selected), 1);\n        } else {\n          this.selectedItems.push(item);\n        }\n      } else {\n        this.selectedItems = [item];\n      }\n    } else {\n      this.selectedItems = [];\n      this._currentHighlight = null;\n    }\n    this._dispatchEvent();\n  }\n\n  _dispatchEvent() {\n    this.dispatchEvent(\n      new CustomEvent(\"items-selected\", { detail: this.selectedItems })\n    );\n  }\n\n  _keyboardEventListener = ((event: KeyboardEvent) => {\n    if ([\"ArrowDown\", \"ArrowUp\", \"Enter\", \"Escape\"].includes(event.code)) {\n      this._handleKeyboard(event.code);\n    }\n  }) as EventListener;\n\n  disconnectedCallback(): void {\n    super.disconnectedCallback();\n    this.getRootNode().removeEventListener(\n      \"keydown\",\n      this._keyboardEventListener\n    );\n  }\n\n  firstUpdated() {\n    this.getRootNode().addEventListener(\"keydown\", this._keyboardEventListener);\n  }\n\n  updated(changedProperties: PropertyValues<this>) {\n    if (changedProperties.has(\"filter\")) {\n      if (this.filter.length > 0) {\n        setTimeout(() => {\n          const firstItem = this.renderRoot.querySelectorAll(\"li\")[0];\n          if (firstItem) {\n            this._currentHighlight = this.items.find(\n              (f) =>\n                f[<keyof FilterObject>this.idProperty] ===\n                firstItem.dataset.identifier\n            );\n          }\n        });\n      } else {\n        this._currentHighlight = null;\n      }\n    }\n  }\n\n  render() {\n    return html`\n      <style>\n        ${style}\n        :host {\n          height: auto;\n        }\n        ul {\n          width: 100%;\n        }\n        li.highlighted {\n          background: lightgrey;\n        }\n        ${!this.unstyled && styleEOX}\n      </style>\n      <ul>\n        ${repeat(\n          this.items.filter((item) =>\n            this.filter\n              ? (<string>item[<keyof FilterObject>this.titleProperty])\n                  .toLowerCase()\n                  .includes(this.filter.toLowerCase())\n              : true\n          ),\n          (item) => item[<keyof FilterObject>this.idProperty],\n          (item) => html`\n            <li\n              class=${this._currentHighlight === item\n                ? \"highlighted\"\n                : (nothing as undefined)}\n              data-identifier=${item[\n                <keyof FilterObject>this.idProperty\n              ] as string}\n              data-title=${item[\n                <keyof FilterObject>this.titleProperty\n              ] as string}\n              @mouseenter=${() => {\n                this._currentHighlight = item;\n              }}\n              @mouseleave=${() => {\n                this._currentHighlight = null;\n              }}\n            >\n              <label>\n                <input\n                  type=\"${this.multiple ? \"checkbox\" : \"radio\"}\"\n                  .checked=${!!this.selectedItems.find(\n                    (i) =>\n                      i[<keyof FilterObject>this.idProperty] ===\n                      item[<keyof FilterObject>this.idProperty]\n                  ) || (nothing as null)}\n                  @change=${() => this._handleSelect(item)}\n                />\n                <span class=\"title\"\n                  >${item[<keyof FilterObject>this.titleProperty]}</span\n                >\n              </label>\n            </li>\n          `\n        )}\n      </ul>\n    `;\n  }\n}\n","import { LitElement, html } from \"lit\";\nimport { customElement, property } from \"lit/decorators.js\";\nimport { when } from \"lit/directives/when.js\";\nimport { resetFilter } from \"../reset\";\nimport \"../autocomplete\";\nimport \"../selectionlist\";\n\n@customElement(\"eox-itemfilter-multiselect\")\nexport class EOxItemFilterMultiselect extends LitElement {\n  @property()\n  filterObject: FilterObject;\n\n  @property({ type: Boolean })\n  inline = false;\n\n  @property({ type: Boolean })\n  unstyled = false;\n\n  public reset() {\n    this.renderRoot\n      .querySelectorAll(\"input[type='checkbox']\")\n      .forEach((f: Element) => {\n        if (f instanceof HTMLInputElement) {\n          f.checked = false;\n        }\n      });\n    resetFilter(this.filterObject);\n    this.requestUpdate();\n  }\n\n  // skip shadow root creation\n  createRenderRoot() {\n    return this;\n  }\n\n  _getItems(): FilterObject[] {\n    return Object.keys(this.filterObject.state)\n      .sort((a, b) => a.localeCompare(b))\n      .map((i) => ({\n        id: i,\n        title: i.replace(/^./, i[0].toUpperCase()),\n      }));\n  }\n\n  _getSelectedItems(): FilterObject[] {\n    return Object.keys(this.filterObject.state)\n      .filter((i) => this.filterObject.state[i])\n      .map((i) => ({\n        id: i,\n        title: i.replace(/^./, i[0].toUpperCase()),\n      }));\n  }\n\n  _handleSelected(selectedItems: FilterObject[]) {\n    Object.keys(this.filterObject.state).forEach((k) => {\n      this.filterObject.state[k] = selectedItems.map((i) => i.id).includes(k);\n    });\n    this.filterObject.stringifiedState = Object.keys(this.filterObject.state)\n      .filter((k) => this.filterObject.state[k])\n      .join(\", \");\n    this.filterObject.dirty = true;\n    this.dispatchEvent(new CustomEvent(\"filter\"));\n  }\n\n  render() {\n    return when(\n      this.filterObject,\n      () => html`\n        ${when(\n          this.inline || Object.keys(this.filterObject.state).length > 10,\n          () => html`\n            <eox-autocomplete\n              multiple\n              .items=${this._getItems()}\n              .selectedItems=${this._getSelectedItems()}\n              .unstyled=${this.unstyled}\n              @items-selected=${(evt: CustomEvent) =>\n                this._handleSelected(<FilterObject[]>evt.detail)}\n            >\n            </eox-autocomplete>\n          `,\n          () => html`\n            <eox-selectionlist\n              multiple\n              .items=${this._getItems()}\n              .selectedItems=${this._getSelectedItems()}\n              .unstyled=${this.unstyled}\n              @items-selected=${(evt: CustomEvent) =>\n                this._handleSelected(evt.detail)}\n            ></eox-selectionlist>\n          `\n        )}\n      `\n    );\n  }\n}\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n","import { LitElement, html } from \"lit\";\nimport { when } from \"lit/directives/when.js\";\nimport { customElement, property } from \"lit/decorators.js\";\nimport dayjs from \"dayjs\";\nimport _debounce from \"lodash.debounce\";\nimport { resetFilter } from \"../reset\";\n\n@customElement(\"eox-itemfilter-range\")\nexport class EOxItemFilterRange extends LitElement {\n  @property()\n  filterObject: RangeFilterObject;\n\n  inputHandler = (evt: CustomEvent) => {\n    const [min, max] = evt.detail.values;\n    if (\n      min !== this.filterObject.state.min ||\n      max != this.filterObject.state.max\n    ) {\n      [this.filterObject.state.min, this.filterObject.state.max] = [min, max];\n      this.filterObject.dirty = true;\n    }\n    if (this.filterObject.dirty) {\n      this.filterObject.stringifiedState = `${dayjs(min)} - ${dayjs(max)}`;\n    }\n    this.dispatchEvent(new CustomEvent(\"filter\"));\n    this.requestUpdate();\n  };\n\n  debouncedInputHandler = _debounce(this.inputHandler, 0, {\n    leading: true,\n  });\n\n  public reset() {\n    resetFilter(this.filterObject);\n    this.requestUpdate();\n  }\n\n  // skip shadow root creation\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    return when(\n      this.filterObject,\n      () => html`\n        <div class=\"range-before\">\n          ${this.filterObject.format === \"date\"\n            ? dayjs.unix(<number>this.filterObject.state.min)\n            : this.filterObject.state.min}\n        </div>\n        <tc-range-slider\n          min=\"${this.filterObject.min}\"\n          max=\"${this.filterObject.max}\"\n          value1=\"${this.filterObject.state.min}\"\n          value2=\"${this.filterObject.state.max}\"\n          step=\"1\"\n          @change=${this.debouncedInputHandler}\n        ></tc-range-slider>\n        <div class=\"range-after\">\n          ${this.filterObject.format === \"date\"\n            ? dayjs.unix(<number>this.filterObject.state.max)\n            : this.filterObject.state.max}\n        </div>\n      `\n    );\n  }\n}\n","import { LitElement, html } from \"lit\";\nimport { customElement, property } from \"lit/decorators.js\";\nimport { when } from \"lit/directives/when.js\";\nimport { resetFilter } from \"../reset\";\nimport \"../autocomplete\";\nimport \"../selectionlist\";\n\n@customElement(\"eox-itemfilter-select\")\nexport class EOxItemFilterSelect extends LitElement {\n  @property()\n  filterObject: FilterObject;\n\n  @property({ type: Boolean })\n  inline = false;\n\n  @property({ type: Boolean })\n  unstyled = false;\n\n  public reset() {\n    this.renderRoot\n      .querySelectorAll(\"input[type='radio']\")\n      .forEach((f: Element) => {\n        if (f instanceof HTMLInputElement) {\n          f.checked = false;\n        }\n      });\n    resetFilter(this.filterObject);\n    this.requestUpdate();\n  }\n\n  // skip shadow root creation\n  createRenderRoot() {\n    return this;\n  }\n\n  _getItems(): FilterObject[] {\n    return Object.keys(this.filterObject.state)\n      .sort((a, b) => a.localeCompare(b))\n      .map((i) => ({\n        id: i,\n        title: i.replace(/^./, i[0].toUpperCase()),\n      }));\n  }\n\n  _getSelectedItems(): FilterObject[] {\n    return Object.keys(this.filterObject.state)\n      .filter((i) => this.filterObject.state[i])\n      .map((i) => ({\n        id: i,\n        title: i.replace(/^./, i[0].toUpperCase()),\n      }));\n  }\n\n  _handleSelected(evt: CustomEvent) {\n    Object.keys(this.filterObject.state).forEach((k) => {\n      this.filterObject.state[k] = (<FilterObject[]>evt.detail)\n        .map((i) => i.id)\n        .includes(k);\n    });\n    this.filterObject.stringifiedState = Object.keys(\n      this.filterObject.state\n    ).filter((k) => this.filterObject.state[k])[0];\n    this.filterObject.dirty = true;\n    this.dispatchEvent(new CustomEvent(\"filter\"));\n  }\n\n  render() {\n    return when(\n      this.filterObject,\n      () => html`\n        ${when(\n          this.inline || Object.keys(this.filterObject.state).length > 1,\n          () => html`\n            <eox-autocomplete\n              .items=${this._getItems()}\n              .selectedItems=${this._getSelectedItems()}\n              .unstyled=${this.unstyled}\n              @items-selected=${(evt: CustomEvent) => this._handleSelected(evt)}\n            >\n            </eox-autocomplete>\n          `,\n          () => html`\n            <eox-selectionlist\n              .items=${this._getItems()}\n              .selectedItems=${this._getSelectedItems()}\n              .unstyled=${this.unstyled}\n              @items-selected=${(evt: CustomEvent) => this._handleSelected(evt)}\n            ></eox-selectionlist>\n          `\n        )}\n      `\n    );\n  }\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import { featureCollection, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = x1 < x2 ? x1 : x2;\n    var south = y1 < y2 ? y1 : y2;\n    var east = x1 > x2 ? x1 : x2;\n    var north = y1 > y2 ? y1 : y2;\n    return [west, south, east, north];\n}\nexport default lineSegment;\n","import { coordEach } from \"@turf/meta\";\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexport default bbox;\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = new rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","import { feature, featureCollection, point, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport lineSegment from \"@turf/line-segment\";\nimport { featureEach } from \"@turf/meta\";\nimport rbush from \"geojson-rbush\";\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + uA * (x2 - x1);\n        var y = y1 + uA * (y2 - y1);\n        return point([x, y]);\n    }\n    return null;\n}\nexport default lineIntersect;\n","import { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a\n * {@link FeatureCollection} of {@link LineString|(Multi)LineString}.\n *\n * @name polygonToLine\n * @param {Feature<Polygon|MultiPolygon>} poly Feature to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString\n * @example\n * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);\n *\n * var line = turf.polygonToLine(poly);\n *\n * //addToMap\n * var addToMap = [line];\n */\nexport default function (poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    if (!options.properties && poly.type === \"Feature\") {\n        options.properties = poly.properties;\n    }\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonToLine(geom, options);\n        case \"MultiPolygon\":\n            return multiPolygonToLine(geom, options);\n        default:\n            throw new Error(\"invalid poly\");\n    }\n}\n/**\n * @private\n */\nexport function polygonToLine(poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : poly.type === \"Feature\"\n            ? poly.properties\n            : {};\n    return coordsToLine(coords, properties);\n}\n/**\n * @private\n */\nexport function multiPolygonToLine(multiPoly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(multiPoly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : multiPoly.type === \"Feature\"\n            ? multiPoly.properties\n            : {};\n    var lines = [];\n    coords.forEach(function (coord) {\n        lines.push(coordsToLine(coord, properties));\n    });\n    return featureCollection(lines);\n}\n/**\n * @private\n */\nexport function coordsToLine(coords, properties) {\n    if (coords.length > 1) {\n        return multiLineString(coords, properties);\n    }\n    return lineString(coords[0], properties);\n}\n","import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport polygonToLine from \"@turf/polygon-to-line\";\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(feature1, feature2) {\n    var bool = true;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === false) {\n                return false;\n            }\n            bool = disjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1, geom2) {\n    switch (geom1.type) {\n        case \"Point\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !compareCoords(geom1.coordinates, geom2.coordinates);\n                case \"LineString\":\n                    return !isPointOnLine(geom2, geom1);\n                case \"Polygon\":\n                    return !booleanPointInPolygon(geom1, geom2);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"LineString\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !isPointOnLine(geom1, geom2);\n                case \"LineString\":\n                    return !isLineOnLine(geom1, geom2);\n                case \"Polygon\":\n                    return !isLineInPoly(geom2, geom1);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"Polygon\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !booleanPointInPolygon(geom2, geom1);\n                case \"LineString\":\n                    return !isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return !isPolyInPoly(geom2, geom1);\n            }\n    }\n    return false;\n}\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString, pt) {\n    for (var i = 0; i < lineString.coordinates.length - 1; i++) {\n        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n    var doLinesIntersect = lineIntersect(lineString1, lineString2);\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isLineInPoly(polygon, lineString) {\n    for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (booleanPointInPolygon(coord, polygon)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {\n        var coord1 = _a[_i];\n        if (booleanPointInPolygon(coord1, feature2)) {\n            return true;\n        }\n    }\n    for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {\n        var coord2 = _c[_b];\n        if (booleanPointInPolygon(coord2, feature1)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n    var dxc = pt[0] - lineSegmentStart[0];\n    var dyc = pt[1] - lineSegmentStart[1];\n    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n        if (dxl > 0) {\n            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n        }\n        else {\n            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n        }\n    }\n    else if (dyl > 0) {\n        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n    }\n    else {\n        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n    }\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport default booleanDisjoint;\n","import booleanDisjoint from \"@turf/boolean-disjoint\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Boolean-intersects returns (TRUE) two geometries intersect.\n *\n * @name booleanIntersects\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanIntersects(line, point);\n * //=true\n */\nexport default function booleanIntersects(feature1, feature2) {\n    var bool = false;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === true) {\n                return true;\n            }\n            bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n","import { getCoord, getCoords } from \"@turf/invariant\";\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Normalize inputs\n    var ptCoords = getCoord(pt);\n    var lineCoords = getCoords(line);\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (options.ignoreEndVertices) {\n            if (i === 0) {\n                ignoreBoundary = \"start\";\n            }\n            if (i === lineCoords.length - 2) {\n                ignoreBoundary = \"end\";\n            }\n            if (i === 0 && i + 1 === lineCoords.length - 1) {\n                ignoreBoundary = \"both\";\n            }\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === \"undefined\" ? null : options.epsilon)) {\n            return true;\n        }\n    }\n    return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n// See https://stackoverflow.com/a/328122/1048847\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (epsilon !== null) {\n        if (Math.abs(cross) > epsilon) {\n            return false;\n        }\n    }\n    else if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    }\n    else if (excludeBoundary === \"start\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    }\n    else if (excludeBoundary === \"end\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    }\n    else if (excludeBoundary === \"both\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n    return false;\n}\nexport default booleanPointOnLine;\n","import calcBbox from \"@turf/bbox\";\nimport booleanPointOnLine from \"@turf/boolean-point-on-line\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Boolean-within returns true if the first geometry is completely within the second geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the primary (geometry a)\n * must not intersect the exterior of the secondary (geometry b).\n * Boolean-within returns the exact opposite result of the `@turf/boolean-contains`.\n *\n * @name booleanWithin\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanWithin(point, line);\n * //=true\n */\nfunction booleanWithin(feature1, feature2) {\n    var geom1 = getGeom(feature1);\n    var geom2 = getGeom(feature2);\n    var type1 = geom1.type;\n    var type2 = geom2.type;\n    switch (type1) {\n        case \"Point\":\n            switch (type2) {\n                case \"MultiPoint\":\n                    return isPointInMultiPoint(geom1, geom2);\n                case \"LineString\":\n                    return booleanPointOnLine(geom1, geom2, { ignoreEndVertices: true });\n                case \"Polygon\":\n                case \"MultiPolygon\":\n                    return booleanPointInPolygon(geom1, geom2, { ignoreBoundary: true });\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"MultiPoint\":\n            switch (type2) {\n                case \"MultiPoint\":\n                    return isMultiPointInMultiPoint(geom1, geom2);\n                case \"LineString\":\n                    return isMultiPointOnLine(geom1, geom2);\n                case \"Polygon\":\n                case \"MultiPolygon\":\n                    return isMultiPointInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"LineString\":\n            switch (type2) {\n                case \"LineString\":\n                    return isLineOnLine(geom1, geom2);\n                case \"Polygon\":\n                case \"MultiPolygon\":\n                    return isLineInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"Polygon\":\n            switch (type2) {\n                case \"Polygon\":\n                case \"MultiPolygon\":\n                    return isPolyInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        default:\n            throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n    }\n}\nfunction isPointInMultiPoint(point, multiPoint) {\n    var i;\n    var output = false;\n    for (i = 0; i < multiPoint.coordinates.length; i++) {\n        if (compareCoords(multiPoint.coordinates[i], point.coordinates)) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nfunction isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n    for (var i = 0; i < multiPoint1.coordinates.length; i++) {\n        var anyMatch = false;\n        for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {\n            if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {\n                anyMatch = true;\n            }\n        }\n        if (!anyMatch) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isMultiPointOnLine(multiPoint, lineString) {\n    var foundInsidePoint = false;\n    for (var i = 0; i < multiPoint.coordinates.length; i++) {\n        if (!booleanPointOnLine(multiPoint.coordinates[i], lineString)) {\n            return false;\n        }\n        if (!foundInsidePoint) {\n            foundInsidePoint = booleanPointOnLine(multiPoint.coordinates[i], lineString, { ignoreEndVertices: true });\n        }\n    }\n    return foundInsidePoint;\n}\nfunction isMultiPointInPoly(multiPoint, polygon) {\n    var output = true;\n    var oneInside = false;\n    var isInside = false;\n    for (var i = 0; i < multiPoint.coordinates.length; i++) {\n        isInside = booleanPointInPolygon(multiPoint.coordinates[1], polygon);\n        if (!isInside) {\n            output = false;\n            break;\n        }\n        if (!oneInside) {\n            isInside = booleanPointInPolygon(multiPoint.coordinates[1], polygon, {\n                ignoreBoundary: true,\n            });\n        }\n    }\n    return output && isInside;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n    for (var i = 0; i < lineString1.coordinates.length; i++) {\n        if (!booleanPointOnLine(lineString1.coordinates[i], lineString2)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isLineInPoly(linestring, polygon) {\n    var polyBbox = calcBbox(polygon);\n    var lineBbox = calcBbox(linestring);\n    if (!doBBoxOverlap(polyBbox, lineBbox)) {\n        return false;\n    }\n    var foundInsidePoint = false;\n    for (var i = 0; i < linestring.coordinates.length - 1; i++) {\n        if (!booleanPointInPolygon(linestring.coordinates[i], polygon)) {\n            return false;\n        }\n        if (!foundInsidePoint) {\n            foundInsidePoint = booleanPointInPolygon(linestring.coordinates[i], polygon, { ignoreBoundary: true });\n        }\n        if (!foundInsidePoint) {\n            var midpoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n            foundInsidePoint = booleanPointInPolygon(midpoint, polygon, {\n                ignoreBoundary: true,\n            });\n        }\n    }\n    return foundInsidePoint;\n}\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Polygon} geometry1\n * @param {Polygon|MultiPolygon} geometry2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(geometry1, geometry2) {\n    var poly1Bbox = calcBbox(geometry1);\n    var poly2Bbox = calcBbox(geometry2);\n    if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {\n        return false;\n    }\n    for (var i = 0; i < geometry1.coordinates[0].length; i++) {\n        if (!booleanPointInPolygon(geometry1.coordinates[0][i], geometry2)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction doBBoxOverlap(bbox1, bbox2) {\n    if (bbox1[0] > bbox2[0])\n        return false;\n    if (bbox1[2] < bbox2[2])\n        return false;\n    if (bbox1[1] > bbox2[1])\n        return false;\n    if (bbox1[3] < bbox2[3])\n        return false;\n    return true;\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\n/**\n * getMidpoint\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {Position} midpoint of pair1 and pair2\n */\nfunction getMidpoint(pair1, pair2) {\n    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\nexport default booleanWithin;\n","import { LitElement, html, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators.js\";\nimport { map } from \"lit/directives/map.js\";\nimport { when } from \"lit/directives/when.js\";\nimport booleanIntersects from \"@turf/boolean-intersects\";\nimport booleanWithin from \"@turf/boolean-within\";\nimport { Geometry } from \"@turf/helpers\";\nimport { EOxMap } from \"../../../map/main\";\nimport { resetFilter } from \"../reset\";\nimport { EoxLayer } from \"../../../map/src/generate\";\nimport { Vector as VectorSource } from \"ol/source\";\n\nexport const intersects = (\n  itemGeometry: Geometry,\n  filterGeometry: Geometry\n) => {\n  if (!filterGeometry) {\n    return true;\n  }\n  return booleanIntersects(itemGeometry, filterGeometry);\n};\n\nexport const within = (itemGeometry: Geometry, filterGeometry: Geometry) => {\n  if (!filterGeometry) {\n    return true;\n  }\n  return booleanWithin(itemGeometry, filterGeometry);\n};\n@customElement(\"eox-itemfilter-spatial\")\nexport class EOxItemFilterSpatial extends LitElement {\n  @property()\n  filterObject: SpatialFilterObject;\n\n  public reset() {\n    resetFilter(this.filterObject);\n\n    const spatialFilter: SpatialFilter = this.renderRoot.querySelector(\n      \"eox-itemfilter-spatial-filter\"\n    );\n    spatialFilter.reset();\n    this.requestUpdate();\n  }\n\n  // skip shadow root creation\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    return when(\n      this.filterObject,\n      () => html`\n      <form style=\"display: inline\">\n      ${map(\n        [\"intersects\", \"within\"],\n        (mode: string) => html`\n          <label>\n            <input\n              type=\"radio\"\n              name=\"mode\"\n              .checked=\"${(this.filterObject.state\n                .mode as unknown as string) === mode || nothing}\n              \"\n              value=\"${mode}\"\n              @click=\"${() => {\n                /* @ts-ignore */\n                this.filterObject.state.mode = mode;\n                const event = new CustomEvent(\"filter\", {\n                  detail: {\n                    [this.filterObject.key]: {},\n                  },\n                });\n                this.dispatchEvent(event);\n              }}\"\n            />\n            <small>${mode} filter geometry</small>\n          </label>\n        `\n      )}\n      </form>\n      <eox-itemfilter-spatial-filter\n        exportparts=\"map: spatial-filter-map\"\n        .geometry=${this.filterObject.state?.geometry}\n        @filter=\"${(e: Event) => {\n          this.filterObject.state.geometry = (<CustomEvent>e).detail.geometry;\n          this.filterObject.dirty = true;\n          this.filterObject.stringifiedState = \"Polygon\";\n          this.dispatchEvent(new CustomEvent(\"filter\"));\n        }}\"\n      ></eox-itemfilter-spatial>\n    `\n    );\n  }\n}\n\n@customElement(\"eox-itemfilter-spatial-filter\")\nexport class SpatialFilter extends LitElement {\n  @property()\n  geometry: Geometry;\n\n  @state()\n  eoxMap: EOxMap;\n\n  render() {\n    return html`<eox-map part=\"map\" style=\"height: 400px\"></eox-map>`;\n  }\n\n  firstUpdated() {\n    this.setup();\n  }\n\n  setup() {\n    const mapLayers = [\n      {\n        type: \"Vector\",\n        properties: {\n          id: \"draw\",\n        },\n        source: {\n          type: \"Vector\",\n          ...(this.geometry && { format: \"GeoJSON\" }),\n          ...(this.geometry && { url: this.createFeatureUrl(this.geometry) }),\n        },\n        zIndex: 1,\n        interactions: [\n          {\n            type: \"draw\",\n            options: {\n              id: \"drawInteraction\",\n              type: \"Box\",\n              modify: true,\n            },\n          },\n        ],\n      },\n      {\n        type: \"Tile\",\n        source: {\n          type: \"XYZ\",\n          url: \"https://s2maps-tiles.eu/wmts/1.0.0/osm_3857/default/g/{z}/{y}/{x}.jpg\",\n          attribution:\n            \"{ OSM: Data &copy; OpenStreetMap contributors and others, Rendering &copy; EOX }\",\n        },\n      },\n    ];\n\n    this.eoxMap = this.renderRoot.querySelector(\"eox-map\");\n    setTimeout(() => {\n      this.eoxMap.setLayers(mapLayers as EoxLayer[]);\n      const updateGeometryFilter = (feature: unknown) => {\n        const event = new CustomEvent(\"filter\", {\n          detail: {\n            geometry: {\n              type: \"Polygon\",\n              coordinates: feature\n                // @ts-ignore\n                .getGeometry()\n                .clone()\n                .transform(\"EPSG:3857\", \"EPSG:4326\")\n                .getCoordinates(),\n            },\n          },\n        });\n        this.dispatchEvent(event);\n      };\n      this.eoxMap.interactions[\"drawInteraction\"].on(\n        // @ts-ignore\n        \"drawend\",\n        (e: { feature: unknown }) => {\n          updateGeometryFilter(e.feature);\n          this.eoxMap.removeInteraction(\"drawInteraction\");\n        }\n      );\n      this.eoxMap.interactions[\"drawInteraction_modify\"].on(\n        // @ts-ignore\n        \"modifyend\",\n        (e: { features: unknown }) => {\n          // @ts-ignore\n          updateGeometryFilter(e.features.getArray()[0]);\n        }\n      );\n      // TODO remove\n    }, 1000);\n  }\n\n  // TODO move to epx-map helper function?\n  createFeatureUrl(geometry: Geometry) {\n    const featureString = encodeURIComponent(\n      JSON.stringify({\n        type: \"FeatureCollection\",\n        features: [\n          {\n            type: \"Feature\",\n            properties: null,\n            geometry,\n          },\n        ],\n      })\n    );\n    return `data:text/json,${featureString}`;\n  }\n\n  reset() {\n    const source = this.eoxMap.getLayerById(\"draw\").getSource();\n    if ((source as unknown as VectorSource).getFeatures()?.length > 0) {\n      (source as unknown as VectorSource).clear();\n      this.eoxMap.removeInteraction(\"drawInteraction_modify\");\n      this.setup();\n    }\n  }\n}\n","import { LitElement, html } from \"lit\";\nimport { when } from \"lit/directives/when.js\";\nimport { customElement, property } from \"lit/decorators.js\";\nimport _debounce from \"lodash.debounce\";\nimport { resetFilter } from \"../reset\";\n\n@customElement(\"eox-itemfilter-text\")\nexport class EOxItemFilterText extends LitElement {\n  @property()\n  filterObject: TextFilterObject;\n\n  inputHandler = () => {\n    // Can't use evt.target.value here since it might\n    // be undefined when debounced\n    const searchInput = <HTMLInputElement>(\n      this.renderRoot.querySelector(\"input[type='text']\")\n    );\n    this.filterObject.keys.forEach((key) => {\n      // @ts-ignore\n      this.filterObject.state[key] = searchInput.value;\n    });\n    this.filterObject.dirty = true;\n    this.filterObject.stringifiedState = searchInput.value;\n    this.dispatchEvent(new CustomEvent(\"filter\"));\n  };\n\n  debouncedInputHandler = _debounce(this.inputHandler, 500, {\n    leading: true,\n  });\n\n  public reset() {\n    const searchInput = <HTMLInputElement>(\n      this.renderRoot.querySelector(\"input[type='text']\")\n    );\n    searchInput.value = \"\";\n    resetFilter(this.filterObject);\n    this.filterObject.dirty = false;\n    this.requestUpdate();\n  }\n\n  // skip shadow root creation\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    return when(\n      this.filterObject,\n      () => html`\n        <style>\n          input {\n            max-height: 100%;\n          }\n        </style>\n        <input\n          type=\"text\"\n          placeholder=\"Type something...\"\n          data-cy=\"search\"\n          part=\"input-search\"\n          value=\"${Object.values(this.filterObject.state)[0]}\"\n          @input=\"${this.debouncedInputHandler}\"\n          @click=${(evt: Event) => {\n            evt.stopPropagation();\n          }}\n        />\n      `\n    );\n  }\n}\n","import { LitElement, html, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators.js\";\nimport { html as staticHTML, unsafeStatic } from \"lit/static-html.js\";\nimport { when } from \"lit/directives/when.js\";\nimport { resetFilter } from \"./reset\";\nimport \"./filters/multiselect\";\nimport \"./filters/range\";\nimport \"./filters/select\";\nimport \"./filters/spatial\";\nimport \"./filters/text\";\nimport \"./chips\";\nimport \"./selectionlist\";\nimport { button } from \"../../../utils/styles/button\";\nimport { EOxDropdown } from \"./dropdown\";\n\n@customElement(\"eox-itemfilter-inline\")\nexport class EOxItemFilterInline extends LitElement {\n  @property()\n  idProperty: string = \"id\";\n\n  @property()\n  items: FilterObject[] = [];\n\n  @property()\n  titleProperty: string = \"title\";\n\n  @property()\n  unstyled: boolean = false;\n\n  @state()\n  inputText: string = \"\";\n\n  @state()\n  replaceInput: boolean = null;\n\n  _handleKeyboard(key: string) {\n    if (this.clientHeight === 0) {\n      return;\n    }\n    const inProgressItem = this.items.find((i) => i._inProgress);\n    const textInProgress =\n      inProgressItem?.type === \"text\" && inProgressItem?.dirty;\n    const inputEl = this.renderRoot.querySelector(\n      \"#inline-input\"\n    ) as HTMLInputElement;\n    const highlightedLiItem = (<LitElement>(\n      (<LitElement>(\n        this.renderRoot\n          ?.querySelector(\"[data-filter]\")\n          ?.querySelector(\"eox-autocomplete\")\n      ))?.renderRoot?.querySelector(\"eox-selectionlist\")\n    ))?.renderRoot?.querySelector(\"li.highlighted\");\n\n    if (key == \"Enter\" && highlightedLiItem && inputEl.selectionStart) {\n      highlightedLiItem\n        .querySelector(\"input[type=checkbox]\")\n        .dispatchEvent(new Event(\"change\"));\n      inputEl.selectionStart = 0;\n      inputEl.value = \"\";\n      inputEl.focus();\n    }\n    if (\n      [\"Escape\", \"Space\"].includes(key) ||\n      (key == \"Enter\" && textInProgress)\n    ) {\n      if (inProgressItem) {\n        delete inProgressItem._inProgress;\n        this.requestUpdate();\n        this.inputText = \"\";\n        this.renderRoot.querySelector(\"input\").value = \"\";\n        this.renderRoot.querySelector(\"input\").focus();\n      }\n      this.renderRoot\n        .querySelector(\"[slot=content]\")\n        .classList.remove(\"hidden\");\n      return;\n    }\n  }\n\n  _handleReset(items: FilterObject[]) {\n    items.forEach((item) => {\n      resetFilter(item);\n      delete item._inProgress;\n      delete item.stringifiedState;\n    });\n    this.renderRoot.querySelector(\"[slot=content]\").classList.remove(\"hidden\");\n    this.requestUpdate();\n    this.dispatchEvent(new CustomEvent(\"filter\"));\n  }\n\n  _clickOutsideListener = (() => {\n    this.items.forEach((item) => {\n      delete item._inProgress;\n    });\n    this.requestUpdate();\n  }) as EventListener;\n  _keyboardEventListener = ((event: KeyboardEvent) => {\n    if ([\"Enter\", \"Escape\", \"Space\"].includes(event.code)) {\n      this._handleKeyboard(event.code);\n    }\n  }) as EventListener;\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.getRootNode().addEventListener(\"keydown\", this._keyboardEventListener);\n    window.addEventListener(\"click\", this._clickOutsideListener);\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.getRootNode().removeEventListener(\n      \"keydown\",\n      this._keyboardEventListener\n    );\n    window.removeEventListener(\"click\", this._clickOutsideListener);\n  }\n\n  render() {\n    return html`\n      <style>\n        :host,\n        .container {\n          display: flex;\n        }\n        ${!this.unstyled\n          ? html`\n              ${button} :host { position: relative; } .container { width: 100%;\n              position: relative; border: 1px solid #00417066; border-radius:\n              4px; height: 24px; padding: 5px; flex: 1; justify-content:\n              space-between; cursor: text; transition: all 0.2s ease-in-out;\n              overflow-x: auto; } .container:hover { border: 1px solid #004170;\n              } .input-container { display: flex; flex: 1; align-items: center;\n              } input, input:focus { height: 100%; border: none; outline: none;\n              } .button-container { display: flex; align-items: center;\n              justify-content: center; position: absolute; right: 1px; top: 5px;\n              height: calc(100% - 10px); width: 34px; background: white; }\n              button.icon { color: #004170; height: 24px; font-size: large;\n              width: unset; } .container::-webkit-scrollbar { height: 2px; }\n              .container::-webkit-scrollbar-thumb { background: lightgrey;\n              border-radius: 2px; } .hidden {height: 0; padding: 0; border:\n              none;} .hidden:hover {border: none}\n            `\n          : nothing}\n      </style>\n      <div\n        class=\"container\"\n        part=\"container\"\n        @click=${(evt: Event) => {\n          evt.stopPropagation();\n          (<HTMLInputElement>(\n            this.renderRoot.querySelector(\"input[type=text]\")\n          ))?.focus();\n        }}\n      >\n        <eox-itemfilter-chips\n          .items=${this.items.filter(\n            (i) => i._inProgress || i.stringifiedState\n          )}\n          .titleProperty=${this.titleProperty}\n          .unstyled=${this.unstyled}\n          @items-selected=${(evt: CustomEvent) => {\n            this.items.forEach((item) => {\n              if (!(<FilterObject[]>evt.detail).find((i) => i.id === item.id)) {\n                this._handleReset([item]);\n              }\n            });\n          }}\n          @click=${(evt: Event) => {\n            evt.stopPropagation();\n          }}\n        ></eox-itemfilter-chips>\n        <div class=\"input-container\">\n          <eox-dropdown .parent=${this} .unstyled=${this.unstyled}>\n            <input\n              id=\"inline-input\"\n              slot=\"trigger\"\n              type=\"text\"\n              placeholder=\"Type something...\"\n              @focus=${() => {\n                this.inputText = \"\";\n                this.requestUpdate();\n              }}\n              @input=${(event: Event) => {\n                this.inputText = (event!\n                  .target as HTMLInputElement)!.value.toLowerCase();\n                if (this.replaceInput) {\n                  const foundInput =\n                    (<LitElement>(\n                      this.renderRoot.querySelector(\"[data-filter]\")\n                    )).renderRoot.querySelector(\"input\") ||\n                    (<LitElement>(\n                      (<LitElement>(\n                        this.renderRoot.querySelector(\"[data-filter]\")\n                      )).renderRoot.querySelector(\"eox-autocomplete\")\n                    )).renderRoot.querySelector(\"input\");\n                  if (foundInput) {\n                    foundInput.value = this.inputText;\n                    foundInput.dispatchEvent(new Event(\"input\"));\n                  }\n                }\n              }}\n            />\n            <div slot=\"content\">\n              ${when(\n                !this.items.find((i) => i._inProgress),\n                () => html`\n                  <eox-selectionlist\n                    .filter=${this.inputText}\n                    .idProperty=${this.idProperty}\n                    .titleProperty=${this.titleProperty}\n                    .items=${this.items.filter((f) => !f.stringifiedState)}\n                    .multiple=${false}\n                    .selectedItems=${this.items.filter(\n                      (i) => i.stringifiedState\n                    )}\n                    .unstyled=${this.unstyled}\n                    @click=${(evt: Event) => {\n                      evt.stopPropagation();\n                    }}\n                    @items-highlighted=${() => {\n                      // this._handleHighlight(event.detail);\n                    }}\n                    @items-selected=${(evt: CustomEvent) => {\n                      // this._handleSelect(event.detail);\n                      const items = evt.detail;\n                      if (items.length > 0) {\n                        items[items.length - 1]._inProgress = true;\n                        (<HTMLInputElement>(\n                          this.renderRoot.querySelector(\"input[slot=trigger]\")\n                        )).value = \"\";\n                        this.inputText = \"\";\n                        this.requestUpdate();\n                      }\n\n                      const inProgressItem = this.items.find(\n                        (i) => i._inProgress\n                      );\n                      if (\n                        (inProgressItem && inProgressItem.type === \"text\") ||\n                        inProgressItem.type === \"multiselect\" ||\n                        inProgressItem.type === \"select\"\n                      ) {\n                        this.replaceInput = true;\n                      }\n\n                      if (this.replaceInput) {\n                        setTimeout(() => {\n                          if (inProgressItem.type === \"text\") {\n                            this.renderRoot\n                              .querySelector(\"[slot=content]\")\n                              .classList.add(\"hidden\");\n                          } else if (\n                            inProgressItem.type === \"multiselect\" ||\n                            inProgressItem.type === \"select\"\n                          ) {\n                            const found: LitElement = (<LitElement>(\n                              this.renderRoot.querySelector(\"[data-filter]\")\n                            )).renderRoot.querySelector(\"eox-autocomplete\");\n                            (<EOxDropdown>(\n                              found.renderRoot.querySelector(\"eox-dropdown\")\n                            )).open = true;\n                            found.renderRoot\n                              .querySelector(\".container\")\n                              .classList.add(\"hidden\");\n                          }\n                        });\n                        this.renderRoot.querySelector(\"input\").select();\n                        this.renderRoot.querySelector(\"input\").focus();\n                      }\n                    }}\n                  >\n                  </eox-selectionlist>\n                `\n              )}\n              ${when(\n                this.items.find((i) => i._inProgress),\n                () => staticHTML`\n            <eox-itemfilter-${unsafeStatic(\n              this.items.find((i) => i._inProgress).type\n            )}\n              data-filter=${this.items.find((i) => i._inProgress).id}\n              slot=\"dropdown\"\n              .filterObject=${this.items.find((i) => i._inProgress)}\n              .unstyled=${this.unstyled}\n              .inline=${true}\n              @filter=${() => {\n                this.dispatchEvent(new CustomEvent(\"filter\"));\n              }}\n              @click=${(evt: Event) => {\n                evt.stopPropagation();\n              }}\n            ></eox-itemfilter-${unsafeStatic(\n              this.items.find((i) => i._inProgress).type\n            )}>\n  `\n              )}\n            </div>\n          </eox-dropdown>\n        </div>\n      </div>\n      ${when(\n        this.items.filter((i) => i.stringifiedState || i._inProgress).length >\n          0,\n        () => html`\n          <div class=\"button-container\">\n            <button\n              class=\"icon\"\n              @click=${() => {\n                this._handleReset(\n                  this.items.filter((i) => i.stringifiedState || i._inProgress)\n                );\n              }}\n            >\n              ✕\n            </button>\n          </div>\n        `\n      )}\n    `;\n  }\n}\n","/**\n * Fuse.js v7.0.0 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2023 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\nfunction isArray(value) {\n  return !Array.isArray\n    ? getTag(value) === '[object Array]'\n    : Array.isArray(value)\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nconst INFINITY = 1 / 0;\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value\n  }\n  let result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result\n}\n\nfunction toString(value) {\n  return value == null ? '' : baseToString(value)\n}\n\nfunction isString(value) {\n  return typeof value === 'string'\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number'\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n  return (\n    value === true ||\n    value === false ||\n    (isObjectLike(value) && getTag(value) == '[object Boolean]')\n  )\n}\n\nfunction isObject(value) {\n  return typeof value === 'object'\n}\n\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n  return isObject(value) && value !== null\n}\n\nfunction isDefined(value) {\n  return value !== undefined && value !== null\n}\n\nfunction isBlank(value) {\n  return !value.trim().length\n}\n\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n  return value == null\n    ? value === undefined\n      ? '[object Undefined]'\n      : '[object Null]'\n    : Object.prototype.toString.call(value)\n}\n\nconst EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\n\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\n\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>\n  `Invalid value for key ${key}`;\n\nconst PATTERN_LENGTH_TOO_LARGE = (max) =>\n  `Pattern length exceeds max of ${max}.`;\n\nconst MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;\n\nconst INVALID_KEY_WEIGHT_VALUE = (key) =>\n  `Property 'weight' in key '${key}' must be a positive integer`;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nclass KeyStore {\n  constructor(keys) {\n    this._keys = [];\n    this._keyMap = {};\n\n    let totalWeight = 0;\n\n    keys.forEach((key) => {\n      let obj = createKey(key);\n\n      this._keys.push(obj);\n      this._keyMap[obj.id] = obj;\n\n      totalWeight += obj.weight;\n    });\n\n    // Normalize weights so that their sum is equal to 1\n    this._keys.forEach((key) => {\n      key.weight /= totalWeight;\n    });\n  }\n  get(keyId) {\n    return this._keyMap[keyId]\n  }\n  keys() {\n    return this._keys\n  }\n  toJSON() {\n    return JSON.stringify(this._keys)\n  }\n}\n\nfunction createKey(key) {\n  let path = null;\n  let id = null;\n  let src = null;\n  let weight = 1;\n  let getFn = null;\n\n  if (isString(key) || isArray(key)) {\n    src = key;\n    path = createKeyPath(key);\n    id = createKeyId(key);\n  } else {\n    if (!hasOwn.call(key, 'name')) {\n      throw new Error(MISSING_KEY_PROPERTY('name'))\n    }\n\n    const name = key.name;\n    src = name;\n\n    if (hasOwn.call(key, 'weight')) {\n      weight = key.weight;\n\n      if (weight <= 0) {\n        throw new Error(INVALID_KEY_WEIGHT_VALUE(name))\n      }\n    }\n\n    path = createKeyPath(name);\n    id = createKeyId(name);\n    getFn = key.getFn;\n  }\n\n  return { path, id, weight, src, getFn }\n}\n\nfunction createKeyPath(key) {\n  return isArray(key) ? key : key.split('.')\n}\n\nfunction createKeyId(key) {\n  return isArray(key) ? key.join('.') : key\n}\n\nfunction get(obj, path) {\n  let list = [];\n  let arr = false;\n\n  const deepGet = (obj, path, index) => {\n    if (!isDefined(obj)) {\n      return\n    }\n    if (!path[index]) {\n      // If there's no path left, we've arrived at the object we care about.\n      list.push(obj);\n    } else {\n      let key = path[index];\n\n      const value = obj[key];\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      // If we're at the last value in the path, and if it's a string/number/bool,\n      // add it to the list\n      if (\n        index === path.length - 1 &&\n        (isString(value) || isNumber(value) || isBoolean(value))\n      ) {\n        list.push(toString(value));\n      } else if (isArray(value)) {\n        arr = true;\n        // Search each item in the array.\n        for (let i = 0, len = value.length; i < len; i += 1) {\n          deepGet(value[i], path, index + 1);\n        }\n      } else if (path.length) {\n        // An object. Recurse further.\n        deepGet(value, path, index + 1);\n      }\n    }\n  };\n\n  // Backwards compatibility (since path used to be a string)\n  deepGet(obj, isString(path) ? path.split('.') : path, 0);\n\n  return arr ? list : list[0]\n}\n\nconst MatchOptions = {\n  // Whether the matches should be included in the result set. When `true`, each record in the result\n  // set will include the indices of the matched characters.\n  // These can consequently be used for highlighting purposes.\n  includeMatches: false,\n  // When `true`, the matching function will continue to the end of a search pattern even if\n  // a perfect match has already been located in the string.\n  findAllMatches: false,\n  // Minimum number of characters that must be matched before a result is considered a match\n  minMatchCharLength: 1\n};\n\nconst BasicOptions = {\n  // When `true`, the algorithm continues searching to the end of the input even if a perfect\n  // match is found before the end of the same input.\n  isCaseSensitive: false,\n  // When true, the matching function will continue to the end of a search pattern even if\n  includeScore: false,\n  // List of properties that will be searched. This also supports nested properties.\n  keys: [],\n  // Whether to sort the result list, by score\n  shouldSort: true,\n  // Default sort function: sort by ascending score, ascending index\n  sortFn: (a, b) =>\n    a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1\n};\n\nconst FuzzyOptions = {\n  // Approximately where in the text is the pattern expected to be found?\n  location: 0,\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n  // (of both letters and location), a threshold of '1.0' would match anything.\n  threshold: 0.6,\n  // Determines how close the match must be to the fuzzy location (specified above).\n  // An exact letter match which is 'distance' characters away from the fuzzy location\n  // would score as a complete mismatch. A distance of '0' requires the match be at\n  // the exact location specified, a threshold of '1000' would require a perfect match\n  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n  distance: 100\n};\n\nconst AdvancedOptions = {\n  // When `true`, it enables the use of unix-like search commands\n  useExtendedSearch: false,\n  // The get function to use when fetching an object's properties.\n  // The default will search nested paths *ie foo.bar.baz*\n  getFn: get,\n  // When `true`, search will ignore `location` and `distance`, so it won't matter\n  // where in the string the pattern appears.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n  ignoreLocation: false,\n  // When `true`, the calculation for the relevance score (used for sorting) will\n  // ignore the field-length norm.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n  ignoreFieldNorm: false,\n  // The weight to determine how much field length norm effects scoring.\n  fieldNormWeight: 1\n};\n\nvar Config = {\n  ...BasicOptions,\n  ...MatchOptions,\n  ...FuzzyOptions,\n  ...AdvancedOptions\n};\n\nconst SPACE = /[^ ]+/g;\n\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm(weight = 1, mantissa = 3) {\n  const cache = new Map();\n  const m = Math.pow(10, mantissa);\n\n  return {\n    get(value) {\n      const numTokens = value.match(SPACE).length;\n\n      if (cache.has(numTokens)) {\n        return cache.get(numTokens)\n      }\n\n      // Default function is 1/sqrt(x), weight makes that variable\n      const norm = 1 / Math.pow(numTokens, 0.5 * weight);\n\n      // In place of `toFixed(mantissa)`, for faster computation\n      const n = parseFloat(Math.round(norm * m) / m);\n\n      cache.set(numTokens, n);\n\n      return n\n    },\n    clear() {\n      cache.clear();\n    }\n  }\n}\n\nclass FuseIndex {\n  constructor({\n    getFn = Config.getFn,\n    fieldNormWeight = Config.fieldNormWeight\n  } = {}) {\n    this.norm = norm(fieldNormWeight, 3);\n    this.getFn = getFn;\n    this.isCreated = false;\n\n    this.setIndexRecords();\n  }\n  setSources(docs = []) {\n    this.docs = docs;\n  }\n  setIndexRecords(records = []) {\n    this.records = records;\n  }\n  setKeys(keys = []) {\n    this.keys = keys;\n    this._keysMap = {};\n    keys.forEach((key, idx) => {\n      this._keysMap[key.id] = idx;\n    });\n  }\n  create() {\n    if (this.isCreated || !this.docs.length) {\n      return\n    }\n\n    this.isCreated = true;\n\n    // List is Array<String>\n    if (isString(this.docs[0])) {\n      this.docs.forEach((doc, docIndex) => {\n        this._addString(doc, docIndex);\n      });\n    } else {\n      // List is Array<Object>\n      this.docs.forEach((doc, docIndex) => {\n        this._addObject(doc, docIndex);\n      });\n    }\n\n    this.norm.clear();\n  }\n  // Adds a doc to the end of the index\n  add(doc) {\n    const idx = this.size();\n\n    if (isString(doc)) {\n      this._addString(doc, idx);\n    } else {\n      this._addObject(doc, idx);\n    }\n  }\n  // Removes the doc at the specified index of the index\n  removeAt(idx) {\n    this.records.splice(idx, 1);\n\n    // Change ref index of every subsquent doc\n    for (let i = idx, len = this.size(); i < len; i += 1) {\n      this.records[i].i -= 1;\n    }\n  }\n  getValueForItemAtKeyId(item, keyId) {\n    return item[this._keysMap[keyId]]\n  }\n  size() {\n    return this.records.length\n  }\n  _addString(doc, docIndex) {\n    if (!isDefined(doc) || isBlank(doc)) {\n      return\n    }\n\n    let record = {\n      v: doc,\n      i: docIndex,\n      n: this.norm.get(doc)\n    };\n\n    this.records.push(record);\n  }\n  _addObject(doc, docIndex) {\n    let record = { i: docIndex, $: {} };\n\n    // Iterate over every key (i.e, path), and fetch the value at that key\n    this.keys.forEach((key, keyIndex) => {\n      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      if (isArray(value)) {\n        let subRecords = [];\n        const stack = [{ nestedArrIndex: -1, value }];\n\n        while (stack.length) {\n          const { nestedArrIndex, value } = stack.pop();\n\n          if (!isDefined(value)) {\n            continue\n          }\n\n          if (isString(value) && !isBlank(value)) {\n            let subRecord = {\n              v: value,\n              i: nestedArrIndex,\n              n: this.norm.get(value)\n            };\n\n            subRecords.push(subRecord);\n          } else if (isArray(value)) {\n            value.forEach((item, k) => {\n              stack.push({\n                nestedArrIndex: k,\n                value: item\n              });\n            });\n          } else ;\n        }\n        record.$[keyIndex] = subRecords;\n      } else if (isString(value) && !isBlank(value)) {\n        let subRecord = {\n          v: value,\n          n: this.norm.get(value)\n        };\n\n        record.$[keyIndex] = subRecord;\n      }\n    });\n\n    this.records.push(record);\n  }\n  toJSON() {\n    return {\n      keys: this.keys,\n      records: this.records\n    }\n  }\n}\n\nfunction createIndex(\n  keys,\n  docs,\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\n) {\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\n  myIndex.setKeys(keys.map(createKey));\n  myIndex.setSources(docs);\n  myIndex.create();\n  return myIndex\n}\n\nfunction parseIndex(\n  data,\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\n) {\n  const { keys, records } = data;\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\n  myIndex.setKeys(keys);\n  myIndex.setIndexRecords(records);\n  return myIndex\n}\n\nfunction computeScore$1(\n  pattern,\n  {\n    errors = 0,\n    currentLocation = 0,\n    expectedLocation = 0,\n    distance = Config.distance,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  const accuracy = errors / pattern.length;\n\n  if (ignoreLocation) {\n    return accuracy\n  }\n\n  const proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy\n  }\n\n  return accuracy + proximity / distance\n}\n\nfunction convertMaskToIndices(\n  matchmask = [],\n  minMatchCharLength = Config.minMatchCharLength\n) {\n  let indices = [];\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (let len = matchmask.length; i < len; i += 1) {\n    let match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        indices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    indices.push([start, i - 1]);\n  }\n\n  return indices\n}\n\n// Machine word size\nconst MAX_BITS = 32;\n\nfunction search(\n  text,\n  pattern,\n  patternAlphabet,\n  {\n    location = Config.location,\n    distance = Config.distance,\n    threshold = Config.threshold,\n    findAllMatches = Config.findAllMatches,\n    minMatchCharLength = Config.minMatchCharLength,\n    includeMatches = Config.includeMatches,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  if (pattern.length > MAX_BITS) {\n    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))\n  }\n\n  const patternLen = pattern.length;\n  // Set starting location at beginning text and initialize the alphabet.\n  const textLen = text.length;\n  // Handle the case when location > text.length\n  const expectedLocation = Math.max(0, Math.min(location, textLen));\n  // Highest score beyond which we give up.\n  let currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  let bestLocation = expectedLocation;\n\n  // Performance: only computer matches when the minMatchCharLength > 1\n  // OR if `includeMatches` is true.\n  const computeMatches = minMatchCharLength > 1 || includeMatches;\n  // A mask of the matches, used for building the indices\n  const matchMask = computeMatches ? Array(textLen) : [];\n\n  let index;\n\n  // Get all exact matches, here for speed up\n  while ((index = text.indexOf(pattern, bestLocation)) > -1) {\n    let score = computeScore$1(pattern, {\n      currentLocation: index,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    currentThreshold = Math.min(score, currentThreshold);\n    bestLocation = index + patternLen;\n\n    if (computeMatches) {\n      let i = 0;\n      while (i < patternLen) {\n        matchMask[index + i] = 1;\n        i += 1;\n      }\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  let lastBitArr = [];\n  let finalScore = 1;\n  let binMax = patternLen + textLen;\n\n  const mask = 1 << (patternLen - 1);\n\n  for (let i = 0; i < patternLen; i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    let binMin = 0;\n    let binMid = binMax;\n\n    while (binMin < binMid) {\n      const score = computeScore$1(pattern, {\n        errors: i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation,\n        distance,\n        ignoreLocation\n      });\n\n      if (score <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    let start = Math.max(1, expectedLocation - binMid + 1);\n    let finish = findAllMatches\n      ? textLen\n      : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    let bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << i) - 1;\n\n    for (let j = finish; j >= start; j -= 1) {\n      let currentLocation = j - 1;\n      let charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (computeMatches) {\n        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n        matchMask[currentLocation] = +!!charMatch;\n      }\n\n      // First pass: exact match\n      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (i) {\n        bitArr[j] |=\n          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = computeScore$1(pattern, {\n          errors: i,\n          currentLocation,\n          expectedLocation,\n          distance,\n          ignoreLocation\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    const score = computeScore$1(pattern, {\n      errors: i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    if (score > currentThreshold) {\n      break\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  const result = {\n    isMatch: bestLocation >= 0,\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    score: Math.max(0.001, finalScore)\n  };\n\n  if (computeMatches) {\n    const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n    if (!indices.length) {\n      result.isMatch = false;\n    } else if (includeMatches) {\n      result.indices = indices;\n    }\n  }\n\n  return result\n}\n\nfunction createPatternAlphabet(pattern) {\n  let mask = {};\n\n  for (let i = 0, len = pattern.length; i < len; i += 1) {\n    const char = pattern.charAt(i);\n    mask[char] = (mask[char] || 0) | (1 << (len - i - 1));\n  }\n\n  return mask\n}\n\nclass BitapSearch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    this.options = {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    this.chunks = [];\n\n    if (!this.pattern.length) {\n      return\n    }\n\n    const addChunk = (pattern, startIndex) => {\n      this.chunks.push({\n        pattern,\n        alphabet: createPatternAlphabet(pattern),\n        startIndex\n      });\n    };\n\n    const len = this.pattern.length;\n\n    if (len > MAX_BITS) {\n      let i = 0;\n      const remainder = len % MAX_BITS;\n      const end = len - remainder;\n\n      while (i < end) {\n        addChunk(this.pattern.substr(i, MAX_BITS), i);\n        i += MAX_BITS;\n      }\n\n      if (remainder) {\n        const startIndex = len - MAX_BITS;\n        addChunk(this.pattern.substr(startIndex), startIndex);\n      }\n    } else {\n      addChunk(this.pattern, 0);\n    }\n  }\n\n  searchIn(text) {\n    const { isCaseSensitive, includeMatches } = this.options;\n\n    if (!isCaseSensitive) {\n      text = text.toLowerCase();\n    }\n\n    // Exact match\n    if (this.pattern === text) {\n      let result = {\n        isMatch: true,\n        score: 0\n      };\n\n      if (includeMatches) {\n        result.indices = [[0, text.length - 1]];\n      }\n\n      return result\n    }\n\n    // Otherwise, use Bitap algorithm\n    const {\n      location,\n      distance,\n      threshold,\n      findAllMatches,\n      minMatchCharLength,\n      ignoreLocation\n    } = this.options;\n\n    let allIndices = [];\n    let totalScore = 0;\n    let hasMatches = false;\n\n    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {\n      const { isMatch, score, indices } = search(text, pattern, alphabet, {\n        location: location + startIndex,\n        distance,\n        threshold,\n        findAllMatches,\n        minMatchCharLength,\n        includeMatches,\n        ignoreLocation\n      });\n\n      if (isMatch) {\n        hasMatches = true;\n      }\n\n      totalScore += score;\n\n      if (isMatch && indices) {\n        allIndices = [...allIndices, ...indices];\n      }\n    });\n\n    let result = {\n      isMatch: hasMatches,\n      score: hasMatches ? totalScore / this.chunks.length : 1\n    };\n\n    if (hasMatches && includeMatches) {\n      result.indices = allIndices;\n    }\n\n    return result\n  }\n}\n\nclass BaseMatch {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n  static isMultiMatch(pattern) {\n    return getMatch(pattern, this.multiRegex)\n  }\n  static isSingleMatch(pattern) {\n    return getMatch(pattern, this.singleRegex)\n  }\n  search(/*text*/) {}\n}\n\nfunction getMatch(pattern, exp) {\n  const matches = pattern.match(exp);\n  return matches ? matches[1] : null\n}\n\n// Token: 'file\n\nclass ExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'exact'\n  }\n  static get multiRegex() {\n    return /^=\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^=(.*)$/\n  }\n  search(text) {\n    const isMatch = text === this.pattern;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !fire\n\nclass InverseExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!(.*)$/\n  }\n  search(text) {\n    const index = text.indexOf(this.pattern);\n    const isMatch = index === -1;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: ^file\n\nclass PrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'prefix-exact'\n  }\n  static get multiRegex() {\n    return /^\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !^fire\n\nclass InversePrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-prefix-exact'\n  }\n  static get multiRegex() {\n    return /^!\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = !text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: .file$\n\nclass SuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'suffix-exact'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = text.endsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [text.length - this.pattern.length, text.length - 1]\n    }\n  }\n}\n\n// Token: !.file$\n\nclass InverseSuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-suffix-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^!(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = !text.endsWith(this.pattern);\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\nclass FuzzyMatch extends BaseMatch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    super(pattern);\n    this._bitapSearch = new BitapSearch(pattern, {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    });\n  }\n  static get type() {\n    return 'fuzzy'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^(.*)$/\n  }\n  search(text) {\n    return this._bitapSearch.searchIn(text)\n  }\n}\n\n// Token: 'file\n\nclass IncludeMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'include'\n  }\n  static get multiRegex() {\n    return /^'\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^'(.*)$/\n  }\n  search(text) {\n    let location = 0;\n    let index;\n\n    const indices = [];\n    const patternLen = this.pattern.length;\n\n    // Get all exact matches\n    while ((index = text.indexOf(this.pattern, location)) > -1) {\n      location = index + patternLen;\n      indices.push([index, location - 1]);\n    }\n\n    const isMatch = !!indices.length;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices\n    }\n  }\n}\n\n// ❗Order is important. DO NOT CHANGE.\nconst searchers = [\n  ExactMatch,\n  IncludeMatch,\n  PrefixExactMatch,\n  InversePrefixExactMatch,\n  InverseSuffixExactMatch,\n  SuffixExactMatch,\n  InverseExactMatch,\n  FuzzyMatch\n];\n\nconst searchersLen = searchers.length;\n\n// Regex to split by spaces, but keep anything in quotes together\nconst SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = '|';\n\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern, options = {}) {\n  return pattern.split(OR_TOKEN).map((item) => {\n    let query = item\n      .trim()\n      .split(SPACE_RE)\n      .filter((item) => item && !!item.trim());\n\n    let results = [];\n    for (let i = 0, len = query.length; i < len; i += 1) {\n      const queryItem = query[i];\n\n      // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n      let found = false;\n      let idx = -1;\n      while (!found && ++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isMultiMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          found = true;\n        }\n      }\n\n      if (found) {\n        continue\n      }\n\n      // 2. Handle single query matches (i.e, once that are *not* quoted)\n      idx = -1;\n      while (++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isSingleMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          break\n        }\n      }\n    }\n\n    return results\n  })\n}\n\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nconst MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);\n\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */\nclass ExtendedSearch {\n  constructor(\n    pattern,\n    {\n      isCaseSensitive = Config.isCaseSensitive,\n      includeMatches = Config.includeMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      ignoreLocation = Config.ignoreLocation,\n      findAllMatches = Config.findAllMatches,\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance\n    } = {}\n  ) {\n    this.query = null;\n    this.options = {\n      isCaseSensitive,\n      includeMatches,\n      minMatchCharLength,\n      findAllMatches,\n      ignoreLocation,\n      location,\n      threshold,\n      distance\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.query = parseQuery(this.pattern, this.options);\n  }\n\n  static condition(_, options) {\n    return options.useExtendedSearch\n  }\n\n  searchIn(text) {\n    const query = this.query;\n\n    if (!query) {\n      return {\n        isMatch: false,\n        score: 1\n      }\n    }\n\n    const { includeMatches, isCaseSensitive } = this.options;\n\n    text = isCaseSensitive ? text : text.toLowerCase();\n\n    let numMatches = 0;\n    let allIndices = [];\n    let totalScore = 0;\n\n    // ORs\n    for (let i = 0, qLen = query.length; i < qLen; i += 1) {\n      const searchers = query[i];\n\n      // Reset indices\n      allIndices.length = 0;\n      numMatches = 0;\n\n      // ANDs\n      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {\n        const searcher = searchers[j];\n        const { isMatch, indices, score } = searcher.search(text);\n\n        if (isMatch) {\n          numMatches += 1;\n          totalScore += score;\n          if (includeMatches) {\n            const type = searcher.constructor.type;\n            if (MultiMatchSet.has(type)) {\n              allIndices = [...allIndices, ...indices];\n            } else {\n              allIndices.push(indices);\n            }\n          }\n        } else {\n          totalScore = 0;\n          numMatches = 0;\n          allIndices.length = 0;\n          break\n        }\n      }\n\n      // OR condition, so if TRUE, return\n      if (numMatches) {\n        let result = {\n          isMatch: true,\n          score: totalScore / numMatches\n        };\n\n        if (includeMatches) {\n          result.indices = allIndices;\n        }\n\n        return result\n      }\n    }\n\n    // Nothing was matched\n    return {\n      isMatch: false,\n      score: 1\n    }\n  }\n}\n\nconst registeredSearchers = [];\n\nfunction register(...args) {\n  registeredSearchers.push(...args);\n}\n\nfunction createSearcher(pattern, options) {\n  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {\n    let searcherClass = registeredSearchers[i];\n    if (searcherClass.condition(pattern, options)) {\n      return new searcherClass(pattern, options)\n    }\n  }\n\n  return new BitapSearch(pattern, options)\n}\n\nconst LogicalOperator = {\n  AND: '$and',\n  OR: '$or'\n};\n\nconst KeyType = {\n  PATH: '$path',\n  PATTERN: '$val'\n};\n\nconst isExpression = (query) =>\n  !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\n\nconst isPath = (query) => !!query[KeyType.PATH];\n\nconst isLeaf = (query) =>\n  !isArray(query) && isObject(query) && !isExpression(query);\n\nconst convertToExplicit = (query) => ({\n  [LogicalOperator.AND]: Object.keys(query).map((key) => ({\n    [key]: query[key]\n  }))\n});\n\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options, { auto = true } = {}) {\n  const next = (query) => {\n    let keys = Object.keys(query);\n\n    const isQueryPath = isPath(query);\n\n    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n      return next(convertToExplicit(query))\n    }\n\n    if (isLeaf(query)) {\n      const key = isQueryPath ? query[KeyType.PATH] : keys[0];\n\n      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n\n      if (!isString(pattern)) {\n        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))\n      }\n\n      const obj = {\n        keyId: createKeyId(key),\n        pattern\n      };\n\n      if (auto) {\n        obj.searcher = createSearcher(pattern, options);\n      }\n\n      return obj\n    }\n\n    let node = {\n      children: [],\n      operator: keys[0]\n    };\n\n    keys.forEach((key) => {\n      const value = query[key];\n\n      if (isArray(value)) {\n        value.forEach((item) => {\n          node.children.push(next(item));\n        });\n      }\n    });\n\n    return node\n  };\n\n  if (!isExpression(query)) {\n    query = convertToExplicit(query);\n  }\n\n  return next(query)\n}\n\n// Practical scoring function\nfunction computeScore(\n  results,\n  { ignoreFieldNorm = Config.ignoreFieldNorm }\n) {\n  results.forEach((result) => {\n    let totalScore = 1;\n\n    result.matches.forEach(({ key, norm, score }) => {\n      const weight = key ? key.weight : null;\n\n      totalScore *= Math.pow(\n        score === 0 && weight ? Number.EPSILON : score,\n        (weight || 1) * (ignoreFieldNorm ? 1 : norm)\n      );\n    });\n\n    result.score = totalScore;\n  });\n}\n\nfunction transformMatches(result, data) {\n  const matches = result.matches;\n  data.matches = [];\n\n  if (!isDefined(matches)) {\n    return\n  }\n\n  matches.forEach((match) => {\n    if (!isDefined(match.indices) || !match.indices.length) {\n      return\n    }\n\n    const { indices, value } = match;\n\n    let obj = {\n      indices,\n      value\n    };\n\n    if (match.key) {\n      obj.key = match.key.src;\n    }\n\n    if (match.idx > -1) {\n      obj.refIndex = match.idx;\n    }\n\n    data.matches.push(obj);\n  });\n}\n\nfunction transformScore(result, data) {\n  data.score = result.score;\n}\n\nfunction format(\n  results,\n  docs,\n  {\n    includeMatches = Config.includeMatches,\n    includeScore = Config.includeScore\n  } = {}\n) {\n  const transformers = [];\n\n  if (includeMatches) transformers.push(transformMatches);\n  if (includeScore) transformers.push(transformScore);\n\n  return results.map((result) => {\n    const { idx } = result;\n\n    const data = {\n      item: docs[idx],\n      refIndex: idx\n    };\n\n    if (transformers.length) {\n      transformers.forEach((transformer) => {\n        transformer(result, data);\n      });\n    }\n\n    return data\n  })\n}\n\nclass Fuse {\n  constructor(docs, options = {}, index) {\n    this.options = { ...Config, ...options };\n\n    if (\n      this.options.useExtendedSearch &&\n      !true\n    ) {\n      throw new Error(EXTENDED_SEARCH_UNAVAILABLE)\n    }\n\n    this._keyStore = new KeyStore(this.options.keys);\n\n    this.setCollection(docs, index);\n  }\n\n  setCollection(docs, index) {\n    this._docs = docs;\n\n    if (index && !(index instanceof FuseIndex)) {\n      throw new Error(INCORRECT_INDEX_TYPE)\n    }\n\n    this._myIndex =\n      index ||\n      createIndex(this.options.keys, this._docs, {\n        getFn: this.options.getFn,\n        fieldNormWeight: this.options.fieldNormWeight\n      });\n  }\n\n  add(doc) {\n    if (!isDefined(doc)) {\n      return\n    }\n\n    this._docs.push(doc);\n    this._myIndex.add(doc);\n  }\n\n  remove(predicate = (/* doc, idx */) => false) {\n    const results = [];\n\n    for (let i = 0, len = this._docs.length; i < len; i += 1) {\n      const doc = this._docs[i];\n      if (predicate(doc, i)) {\n        this.removeAt(i);\n        i -= 1;\n        len -= 1;\n\n        results.push(doc);\n      }\n    }\n\n    return results\n  }\n\n  removeAt(idx) {\n    this._docs.splice(idx, 1);\n    this._myIndex.removeAt(idx);\n  }\n\n  getIndex() {\n    return this._myIndex\n  }\n\n  search(query, { limit = -1 } = {}) {\n    const {\n      includeMatches,\n      includeScore,\n      shouldSort,\n      sortFn,\n      ignoreFieldNorm\n    } = this.options;\n\n    let results = isString(query)\n      ? isString(this._docs[0])\n        ? this._searchStringList(query)\n        : this._searchObjectList(query)\n      : this._searchLogical(query);\n\n    computeScore(results, { ignoreFieldNorm });\n\n    if (shouldSort) {\n      results.sort(sortFn);\n    }\n\n    if (isNumber(limit) && limit > -1) {\n      results = results.slice(0, limit);\n    }\n\n    return format(results, this._docs, {\n      includeMatches,\n      includeScore\n    })\n  }\n\n  _searchStringList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { records } = this._myIndex;\n    const results = [];\n\n    // Iterate over every string in the index\n    records.forEach(({ v: text, i: idx, n: norm }) => {\n      if (!isDefined(text)) {\n        return\n      }\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        results.push({\n          item: text,\n          idx,\n          matches: [{ score, value: text, norm, indices }]\n        });\n      }\n    });\n\n    return results\n  }\n\n  _searchLogical(query) {\n\n    const expression = parse(query, this.options);\n\n    const evaluate = (node, item, idx) => {\n      if (!node.children) {\n        const { keyId, searcher } = node;\n\n        const matches = this._findMatches({\n          key: this._keyStore.get(keyId),\n          value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n          searcher\n        });\n\n        if (matches && matches.length) {\n          return [\n            {\n              idx,\n              item,\n              matches\n            }\n          ]\n        }\n\n        return []\n      }\n\n      const res = [];\n      for (let i = 0, len = node.children.length; i < len; i += 1) {\n        const child = node.children[i];\n        const result = evaluate(child, item, idx);\n        if (result.length) {\n          res.push(...result);\n        } else if (node.operator === LogicalOperator.AND) {\n          return []\n        }\n      }\n      return res\n    };\n\n    const records = this._myIndex.records;\n    const resultMap = {};\n    const results = [];\n\n    records.forEach(({ $: item, i: idx }) => {\n      if (isDefined(item)) {\n        let expResults = evaluate(expression, item, idx);\n\n        if (expResults.length) {\n          // Dedupe when adding\n          if (!resultMap[idx]) {\n            resultMap[idx] = { idx, item, matches: [] };\n            results.push(resultMap[idx]);\n          }\n          expResults.forEach(({ matches }) => {\n            resultMap[idx].matches.push(...matches);\n          });\n        }\n      }\n    });\n\n    return results\n  }\n\n  _searchObjectList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { keys, records } = this._myIndex;\n    const results = [];\n\n    // List is Array<Object>\n    records.forEach(({ $: item, i: idx }) => {\n      if (!isDefined(item)) {\n        return\n      }\n\n      let matches = [];\n\n      // Iterate over every key (i.e, path), and fetch the value at that key\n      keys.forEach((key, keyIndex) => {\n        matches.push(\n          ...this._findMatches({\n            key,\n            value: item[keyIndex],\n            searcher\n          })\n        );\n      });\n\n      if (matches.length) {\n        results.push({\n          idx,\n          item,\n          matches\n        });\n      }\n    });\n\n    return results\n  }\n  _findMatches({ key, value, searcher }) {\n    if (!isDefined(value)) {\n      return []\n    }\n\n    let matches = [];\n\n    if (isArray(value)) {\n      value.forEach(({ v: text, i: idx, n: norm }) => {\n        if (!isDefined(text)) {\n          return\n        }\n\n        const { isMatch, score, indices } = searcher.searchIn(text);\n\n        if (isMatch) {\n          matches.push({\n            score,\n            key,\n            value: text,\n            idx,\n            norm,\n            indices\n          });\n        }\n      });\n    } else {\n      const { v: text, n: norm } = value;\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        matches.push({ score, key, value: text, norm, indices });\n      }\n    }\n\n    return matches\n  }\n}\n\nFuse.version = '7.0.0';\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n\n{\n  Fuse.parseQuery = parse;\n}\n\n{\n  register(ExtendedSearch);\n}\n\nexport { Fuse as default };\n","// @ts-nocheck\n// adapted from https://gist.github.com/evenfrost/1ba123656ded32fb7a0cd4651efd4db0\nexport const highlight = (\n  fuseSearchResult: unknown,\n  highlightClassName = \"highlight\",\n  matchKey = \"title\"\n) => {\n  const set = (\n    obj: { [key: string]: unknown },\n    path: string,\n    value: unknown\n  ) => {\n    const pathValue = path.split(\".\");\n    let i;\n\n    for (i = 0; i < pathValue.length - 1; i++) {\n      obj = obj[pathValue[i]];\n    }\n\n    obj[pathValue[i]] = value;\n  };\n\n  const generateHighlightedText = (\n    inputText: string,\n    regions: number[] = []\n  ) => {\n    let content = \"\";\n    let nextUnhighlightedRegionStartingIndex = 0;\n\n    regions.forEach((region: number) => {\n      const lastRegionNextIndex = region[1] + 1;\n\n      content += [\n        inputText.substring(nextUnhighlightedRegionStartingIndex, region[0]),\n        `<mark class=\"${highlightClassName}\">`,\n        inputText.substring(region[0], lastRegionNextIndex),\n        \"</mark>\",\n      ].join(\"\");\n\n      nextUnhighlightedRegionStartingIndex = lastRegionNextIndex;\n    });\n\n    content += inputText.substring(nextUnhighlightedRegionStartingIndex);\n\n    return content;\n  };\n\n  return (fuseSearchResult as Array<{ matches?: unknown[]; item: unknown }>)\n    .filter(({ matches }) => matches && matches.length)\n    .map(({ item, matches }) => {\n      const highlightedItem: { [key: string]: unknown } = {};\n      for (const [key, value] of Object.entries(item)) {\n        highlightedItem[key] = value;\n      }\n\n      (matches as Array<{ [key: string]: unknown }>).forEach((match) => {\n        if (match.key !== matchKey) return;\n        set(\n          highlightedItem,\n          match.key as string,\n          generateHighlightedText(\n            match.value as string,\n            match.indices as number[]\n          )\n        );\n      });\n\n      return highlightedItem;\n    });\n};\n","import Fuse from \"fuse.js\";\nimport dayjs from \"dayjs\";\nimport { intersects, within } from \"./filters/spatial\";\nimport { highlight } from \"./itemHighlighting\";\nimport { ElementConfig } from \"./main\";\n\nlet _fuse: Fuse<unknown>;\n\nexport const indexItems = (items: Array<object>, fuseConfig: object) => {\n  _fuse = new Fuse(items, {\n    // minMatchCharLength: 3,\n    // location: 0,\n    threshold: 0.4,\n    distance: 50,\n    includeMatches: true,\n    useExtendedSearch: true,\n    ...fuseConfig,\n  });\n};\n\nexport const filter = async (\n  items: Array<object>,\n  filters: object,\n  config: ElementConfig\n) => {\n  const parsedFilters = Object.entries(filters)\n    .filter(\n      ([, filter]) =>\n        filter.type === \"text\" ||\n        filter.type === \"select\" ||\n        filter.type === \"multiselect\"\n    )\n    .reduce((store, [key, filter]) => {\n      const operator = \"$or\";\n      const holding: Array<unknown> = [];\n      const createProperty = (pKey: string, pVal: unknown) => {\n        const property: { [key: string]: unknown } = {};\n        if (filter.type === \"text\") {\n          // convert strings to (fuzzy) inputs\n          property[pKey] = `${pVal}`;\n        } else {\n          // convert boolean values to exact inputs\n          // using \"=\"\n          property[key] = `=\"${pKey}\"`;\n        }\n        holding.push(property);\n      };\n      Object.entries(filter.state)\n        .filter(([, v]) => v)\n        .forEach(([k, v]) => createProperty(k, v));\n      if (holding.length > 0) {\n        store.push({\n          [operator]: holding,\n        });\n      }\n      return store;\n    }, []);\n  let results;\n  if (!(parsedFilters.length > 0) && config.matchAllWhenEmpty !== false) {\n    results = items;\n  } else {\n    const parameters: object = {\n      $and: [...parsedFilters],\n    };\n    const response = _fuse.search(parameters);\n    results = config.enableHighlighting\n      ? highlight(response, \"highlight\", config.titleProperty)\n      : response.map((i) => i.item);\n  }\n  interface RangeFilter {\n    min: number;\n    max: number;\n    format: string;\n  }\n\n  const rangeFilters = Object.entries(filters)\n    .filter(([, value]) => value.type === \"range\")\n    .reduce((acc: { [key: string]: RangeFilter }, [key, value]) => {\n      acc[key] = {\n        min: value.state.min,\n        max: value.state.max,\n        format: value.format,\n      };\n      return acc;\n    }, {});\n  if (Object.keys(rangeFilters).length > 0) {\n    const filteredResults = [];\n    for (let i = 0; i < results.length; i++) {\n      const pass: { [key: string]: boolean } = {};\n      for (const [key, value] of Object.entries(rangeFilters)) {\n        const parseValue = (input: string) => {\n          return value.format === \"date\" ? dayjs(input).unix() : input;\n        };\n        if (Object.prototype.hasOwnProperty.call(results[i], key)) {\n          // @ts-ignore\n          if (Array.isArray(results[i][key])) {\n            // TODO - make configurable?\n            const mode = \"overlap\";\n            if (mode === \"overlap\") {\n              // must have an overlap with the range to pass\n              pass[key] =\n                // @ts-ignore\n                rangeFilters[key].min <= parseValue(results[i][key][1]) &&\n                // @ts-ignore\n                parseValue(results[i][key][0]) <= rangeFilters[key].max;\n            } else if (mode === \"contain\") {\n              // must contain complete range to pass\n              pass[key] =\n                // @ts-ignore\n                parseValue(results[i][key][0]) >= rangeFilters[key].min &&\n                // @ts-ignore\n                parseValue(results[i][key][1]) <= rangeFilters[key].max;\n            }\n          } else if (\n            // @ts-ignore\n            parseValue(results[i][key]) >= rangeFilters[key].min &&\n            // @ts-ignore\n            parseValue(results[i][key]) <= rangeFilters[key].max\n          ) {\n            pass[key] = true;\n          } else {\n            pass[key] = false;\n          }\n        } else {\n          pass[key] = true;\n        }\n      }\n      if (Object.values(pass).every((v) => !!v)) {\n        filteredResults.push(results[i]);\n      }\n    }\n    results = [...filteredResults];\n  }\n  const spatialFilters: {\n    [key: string]: { geometry?: unknown; mode?: string };\n  } = Object.entries(filters)\n    .filter(([, value]) => value.type === \"spatial\")\n    .reduce((acc: { [key: string]: unknown }, [key, value]) => {\n      acc[key] = {\n        geometry: value.state.geometry,\n        mode: value.state.mode,\n      };\n      return acc;\n    }, {});\n  if (\n    Object.values(spatialFilters)\n      .map((f) => f.geometry)\n      .filter((f) => !!f).length > 0\n  ) {\n    const filteredResults = [];\n    for (let i = 0; i < results.length; i++) {\n      const pass: { [key: string]: boolean } = {};\n      for (const key of Object.keys(spatialFilters)) {\n        const mode = spatialFilters[key].mode || \"within\";\n        if (Object.prototype.hasOwnProperty.call(results[i], key)) {\n          const test =\n            mode === \"within\"\n              ? // @ts-ignore\n                within(results[i][key], spatialFilters[key].geometry)\n              : // @ts-ignore\n                intersects(results[i][key], spatialFilters[key].geometry);\n          if (test) {\n            pass[key] = true;\n          } else {\n            pass[key] = false;\n          }\n        } else {\n          pass[key] = false;\n        }\n      }\n      if (Object.values(pass).every((v) => !!v)) {\n        filteredResults.push(results[i]);\n      }\n    }\n    results = [...filteredResults];\n  }\n  return results;\n};\n","import { ElementConfig } from \"./main\";\n\nexport const filter = async (\n  items: Array<object>,\n  filters: object,\n  config: ElementConfig\n) => {\n  // @ts-ignore\n  const response = await fetch(`${config.externalFilter(items, filters)}`);\n  const jsonData = await response.json();\n  return jsonData.features;\n};\n","import { html, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators.js\";\nimport { when } from \"lit/directives/when.js\";\nimport { map } from \"lit/directives/map.js\";\nimport { repeat } from \"lit/directives/repeat.js\";\nimport { unsafeHTML } from \"lit/directives/unsafe-html.js\";\nimport { html as staticHTML, unsafeStatic } from \"lit/static-html.js\";\nimport \"toolcool-range-slider\";\nimport dayjs from \"dayjs\";\nimport { TemplateElement } from \"../../../utils/templateElement\";\nimport \"./filters/_expandcontainer\";\nimport \"./filters/multiselect\";\nimport \"./filters/range\";\nimport \"./filters/select\";\nimport \"./filters/spatial\";\nimport \"./filters/text\";\nimport \"./inline\";\nimport { indexItems, filter as filterClient } from \"./filterClient\";\nimport { filter as filterExternal } from \"./filterExternal\";\nimport { style } from \"./style\";\nimport { styleEOX } from \"./style.eox\";\n\nexport class ElementConfig {\n  /**\n   * Aggregate results by a property key\n   */\n  public aggregateResults?: string = undefined;\n\n  /**\n   * Highlighting of search result character matches\n   */\n  public enableHighlighting?: boolean = false;\n\n  /**\n   * Use an external search endpoint instead of fuse search.\n   * Passed properties: input string, filters object\n   */\n  public externalFilter?: (input: string, filters: object[]) => string;\n\n  /**\n   * The filter properties.\n   * @param filterProperties\n   */\n  public filterProperties?: Array<FilterObject> = [];\n\n  /**\n   * Native fuse.js config override\n   */\n  public fuseConfig?: object;\n\n  /**\n   * Inline mode, for rendering the itemfilter in avery condensed space.\n   * Expexts showResults to be false\n   */\n  public inlineMode?: boolean = false;\n\n  /**\n   * Show all result items if nothing is input by the user\n   * @default true\n   */\n  public matchAllWhenEmpty?: boolean = true;\n\n  /**\n   * Callback that is triggered on item search\n   * @returns result items\n   */\n  // eslint-disable-next-line\n  public onFilter?: Function = () => {};\n\n  /**\n   * Callback that is triggered on item selection\n   * @returns selected item\n   */\n  // eslint-disable-next-line\n  public onSelect?: Function = () => {};\n\n  /**\n   * Display results list\n   */\n  public showResults?: boolean = true;\n\n  /**\n   * The property of the result items used for display\n   */\n  public titleProperty = \"title\";\n\n  /**\n   * Allow opening multiple filter accordeons in parallel\n   * @default true\n   */\n  public expandMultipleFilters?: boolean = true;\n\n  /**\n   * Initialize result accordeons expanded\n   * @default true\n   */\n  public expandResults?: boolean = true;\n\n  /**\n   * Allow opening multiple result accordeons in parallel\n   * @default true\n   */\n  public expandMultipleResults?: boolean = true;\n}\n\n@customElement(\"eox-itemfilter\")\nexport class EOxItemFilter extends TemplateElement {\n  _resultAggregation: Array<string> = [];\n\n  @state()\n  public filters: { [key: string]: FilterObject } = {};\n\n  @state()\n  public items: Record<string, unknown>[] = [];\n\n  @state()\n  public results: Record<string, unknown>[];\n\n  @state()\n  public selectedResult: Item;\n\n  @property({ attribute: false }) set config(config) {\n    const oldValue = this._config;\n    this._config = {\n      ...new ElementConfig(),\n      ...config,\n    };\n    this.requestUpdate(\"config\", oldValue);\n  }\n  get config() {\n    return this._config;\n  }\n  private _config = new ElementConfig();\n\n  @property()\n  apply = (items: Array<object>) => {\n    this.items = items.map((i, index) => ({\n      id: `item-${index}`,\n      ...i,\n    }));\n\n    // build filters\n    if (this._config.filterProperties.length) {\n      this._config.filterProperties.forEach((filterProperty: FilterObject) => {\n        const filterKeys: FilterState = {};\n        const parseValue = (value: string) => {\n          return (<RangeFilterObject>filterProperty).format === \"date\"\n            ? dayjs(value).unix()\n            : parseInt(value);\n        };\n        // @ts-ignore\n        this.items.forEach((item: Item) => {\n          if (filterProperty.type === \"range\") {\n            if (Array.isArray(item[filterProperty.key] as Array<number>)) {\n              const currentValues = [\n                // @ts-ignore\n                parseValue(item[filterProperty.key][0]),\n                // @ts-ignore\n                parseValue(item[filterProperty.key][1]),\n              ];\n              // @ts-ignore\n              filterKeys.min =\n                filterKeys.min !== undefined\n                  ? // @ts-ignore\n                    Math.min(filterKeys.min, currentValues[0])\n                  : currentValues[0];\n              // @ts-ignore\n              filterKeys.max =\n                filterKeys.max !== undefined\n                  ? // @ts-ignore\n                    Math.max(filterKeys.max, currentValues[1])\n                  : currentValues[1];\n            } else {\n              // @ts-ignore\n              const currentValue = parseValue(item[filterProperty.key]);\n              // @ts-ignore\n              filterKeys.min =\n                filterKeys.min !== undefined\n                  ? // @ts-ignore\n                    Math.min(filterKeys.min, currentValue)\n                  : currentValue;\n              // @ts-ignore\n              filterKeys.max =\n                filterKeys.max !== undefined\n                  ? // @ts-ignore\n                    Math.max(filterKeys.max, currentValue)\n                  : currentValue;\n            }\n            return;\n          }\n          if (Array.isArray(item[filterProperty.key])) {\n            // @ts-ignore\n            item[filterProperty.key].forEach((prop: string) => {\n              filterKeys[prop] = undefined;\n            });\n          } else {\n            if (filterProperty.type === \"spatial\") {\n              // @ts-ignore\n              (<SpatialFilterObject>filterKeys).geometry = undefined;\n              // @ts-ignore\n              (<SpatialFilterObject>filterKeys).mode =\n                (<SpatialFilterObject>filterProperty).mode || \"intersects\";\n            } else {\n              // @ts-ignore\n              filterKeys[item[filterProperty.key]] = undefined;\n            }\n          }\n        });\n        this.filters[\n          filterProperty.key ||\n            (<TextFilterObject>filterProperty).keys.join(\"|\")\n        ] = {\n          ...filterProperty,\n          type: filterProperty.type || \"multiselect\",\n          state: {\n            ...filterKeys,\n            ...filterProperty.state,\n          },\n          ...(filterProperty.state && {\n            dirty: false,\n          }),\n          ...(filterProperty.type === \"range\" && {\n            // @ts-ignore\n            min: (<RangeFilterObject>filterKeys).min,\n            // @ts-ignore\n            max: (<RangeFilterObject>filterKeys).max,\n            format: (<RangeFilterObject>filterProperty).format,\n          }),\n        };\n      });\n    }\n\n    if (this._config.matchAllWhenEmpty !== false) {\n      // initially render all items\n      this.results = this.sortResults(this.items);\n      this.requestUpdate();\n    }\n\n    if (this._config.aggregateResults) {\n      // @ts-ignore\n      this._resultAggregation = [\n        ...new Set(\n          // @ts-ignore\n          this.items.reduce((store: Array<string>, item: Item) => {\n            // @ts-ignore\n            return store.concat(item[this._config.aggregateResults]);\n          }, [])\n        ),\n        // @ts-ignore\n      ].sort((a, b) => a.localeCompare(b));\n    }\n\n    const fuseKeys: Array<string> = [];\n    Object.values(this.filters).forEach((f) => {\n      if (f.type === \"text\") {\n        (<TextFilterObject>f).keys.forEach((k) => {\n          if (!fuseKeys.includes(k)) {\n            fuseKeys.push(k);\n          }\n        });\n      } else if (f.type === \"select\" || f.type === \"multiselect\") {\n        if (!fuseKeys.includes(f.key)) {\n          fuseKeys.push(f.key);\n        }\n      }\n    });\n    indexItems(this.items, {\n      keys: fuseKeys,\n      ...this._config.fuseConfig,\n    });\n    this.search();\n  };\n\n  @property({ attribute: false })\n  styleOverride: string;\n\n  @property({ type: Boolean })\n  unstyled: boolean;\n\n  private async search() {\n    let results;\n    if (this.config.externalFilter) {\n      results = await filterExternal(this.items, this.filters, this._config);\n    } else {\n      results = await filterClient(this.items, this.filters, this._config);\n    }\n    this.results = this.sortResults(results);\n    this._config.onFilter(this.results, this.filters);\n  }\n\n  aggregateResults(items: FilterObject[], property: string) {\n    // @ts-ignore\n    return items.filter((item: Item) => {\n      const aggregation = item[this._config.aggregateResults];\n      // special check if a currently selected fiter property is part of a filter key\n      // also used for aggregation. if aggregation of results uses the same property\n      // as the filter, it doesn't make sense to show all aggregations, but only\n      // the one matching the current filter\n      let currentFilter;\n      if (this.filters[this._config.aggregateResults]) {\n        currentFilter = Object.keys(\n          this.filters[this._config.aggregateResults]\n        ).filter((f) => this.filters[this._config.aggregateResults].state[f]);\n      }\n\n      const includedInCurrentFilter = currentFilter?.length\n        ? currentFilter.includes(property)\n        : true;\n\n      return includedInCurrentFilter && Array.isArray(aggregation)\n        ? aggregation.includes(property)\n        : aggregation === property;\n    });\n  }\n\n  sortResults(items: Record<string, unknown>[]) {\n    return [...items].sort((a: Item, b: Item) =>\n      (<string>a[this._config.titleProperty]).localeCompare(\n        <string>b[this._config.titleProperty]\n      )\n    );\n  }\n\n  resetFilters() {\n    this.renderRoot.querySelectorAll(\"[data-type='filter']\").forEach((f) => {\n      (<Filter>f).reset();\n    });\n    this.search();\n  }\n\n  toggleAccordion(event: CustomEvent) {\n    let detailsElement: HTMLDetailsElement;\n\n    if (event.detail) {\n      detailsElement = event.detail.target as HTMLDetailsElement;\n    } else {\n      detailsElement = event.target as HTMLDetailsElement;\n    }\n\n    if (detailsElement.classList.contains(\"details-filter\")) {\n      if (!detailsElement.open || this.config.expandMultipleFilters) return;\n\n      this.shadowRoot\n        .querySelectorAll(\"eox-itemfilter-expandcontainer\")\n        .forEach((container) => {\n          const details = container.shadowRoot.querySelector(\".details-filter\");\n          if (details && details !== detailsElement) {\n            details.removeAttribute(\"open\");\n          }\n        });\n    } else {\n      if (!detailsElement.open || this.config.expandMultipleResults) return;\n\n      this.shadowRoot.querySelectorAll(\"details\").forEach((details) => {\n        if (details !== detailsElement) {\n          details.removeAttribute(\"open\");\n        }\n      });\n    }\n  }\n\n  render() {\n    return html`\n      <style>\n        ${style}\n        ${!this.unstyled && styleEOX}\n        ${this.styleOverride}\n      </style>\n      <form\n        id=\"itemfilter\"\n        @submit=\"${(evt: FormDataEvent) => evt.preventDefault()}\"\n      >\n        ${when(\n          this._config.inlineMode,\n          () => html`\n            <eox-itemfilter-inline\n              .items=${Object.values(this.filters)}\n              .unstyled=${this.unstyled}\n              @filter=${() => this.search()}\n            >\n            </eox-itemfilter-inline>\n          `,\n          () => html`\n            ${when(\n              this._config.filterProperties.length,\n              () => html`\n                <section\n                  class=\"${this.config.inlineMode\n                    ? \"inline\"\n                    : (nothing as null)}\"\n                >\n                  ${when(\n                    !this.config.inlineMode,\n                    () =>\n                      html`\n                        <slot name=\"filterstitle\"\n                          ><h4 style=\"margin-top: 8px\">Filters</h4></slot\n                        >\n                      `\n                  )}\n                  <ul id=\"filters\">\n                    ${map(\n                      Object.values(this.filters),\n                      (filterObject) => staticHTML`\n                    <li>\n                      ${\n                        filterObject.featured\n                          ? staticHTML`\n                            <eox-itemfilter-${unsafeStatic(filterObject.type)}\n                              slot=\"filter\"\n                              data-type=\"filter\"\n                              .filterObject=${filterObject}\n                              .unstyled=${this.unstyled}\n                              @filter=\"${() => this.search()}\"\n                            ></eox-itemfilter-${unsafeStatic(\n                              filterObject.type\n                            )}>\n                          `\n                          : staticHTML`\n                            <eox-itemfilter-expandcontainer\n                              .filterObject=${filterObject}\n                              .unstyled=${this.unstyled}\n                              @details-toggled=${this.toggleAccordion}\n                            >\n                            ${when(\n                              filterObject.dirty,\n                              () => html`\n                                <button\n                                  slot=\"reset-button\"\n                                  class=\"reset-icon icon\"\n                                  @click=${(e: MouseEvent) => {\n                                    (<Element & { reset: () => void }>(\n                                      (<HTMLButtonElement>(\n                                        e.target\n                                      )).parentElement.querySelector(\n                                        \"[slot=filter]\"\n                                      )\n                                    )).reset();\n                                    this.search();\n                                    this.requestUpdate();\n                                  }}\n                                >\n                                  ${this.unstyled ? \"Reset\" : nothing}\n                                </button>\n                              `\n                            )}\n                              <eox-itemfilter-${unsafeStatic(filterObject.type)}\n                                slot=\"filter\"\n                                data-type=\"filter\"\n                                data-filter=\"${filterObject.key}\"\n                                .filterObject=${filterObject}\n                                .unstyled=${this.unstyled}\n                                @filter=\"${() => this.search()}\"\n                              ></eox-itemfilter-${unsafeStatic(\n                                filterObject.type\n                              )}>\n                            </eox-itemfilter-expandcontainer>\n                        `\n                      }\n                    </li>\n                  `\n                    )}\n                  </ul>\n                  ${when(\n                    this._config.filterProperties &&\n                      Object.values(this.filters)\n                        .map((f) => f.dirty)\n                        .filter((f) => f).length > 0,\n                    () => html`\n                    <button\n                      id=\"filter-reset\"\n                      class=\"outline small icon-text reset-icon\"\n                      data-cy=\"filter-reset\"\n                      @click=${() => this.resetFilters()}\n                    >\n                      Reset all\n                    </a>\n                  `\n                  )}\n                </section>\n              `\n            )}\n            ${when(\n              this.config.showResults && this.results,\n              () => html`\n                <section id=\"section-results\">\n                  <div>\n                    <slot name=\"resultstitle\"\n                      ><h4 style=\"margin-top: 8px\">Results</h4></slot\n                    >\n                  </div>\n                  <div id=\"container-results\" class=\"scroll\">\n                    ${this.results.length < 1\n                      ? html`\n                          <small class=\"no-results\">No matching items</small>\n                        `\n                      : nothing}\n                    <ul id=\"results\" part=\"results\">\n                      ${this._config.aggregateResults\n                        ? map(\n                            this._resultAggregation.filter(\n                              (aggregationProperty) =>\n                                this.aggregateResults(\n                                  this.results,\n                                  aggregationProperty\n                                ).length\n                            ),\n                            (aggregationProperty) => html`<details\n                              class=\"details-results\"\n                              @toggle=${this.toggleAccordion}\n                              ?open=${this._config.expandResults ||\n                              (nothing as null)}\n                            >\n                              <summary>\n                                <span class=\"title\">\n                                  ${aggregationProperty}\n                                  <span class=\"count\"\n                                    >${this.aggregateResults(\n                                      this.results,\n                                      aggregationProperty\n                                    ).length}</span\n                                  >\n                                </span>\n                              </summary>\n                              <ul>\n                                ${repeat(\n                                  this.aggregateResults(\n                                    this.results,\n                                    aggregationProperty\n                                  ),\n                                  (item: Item) => item.id,\n                                  (item: Item) => html`\n                                    <li\n                                      class=${this.selectedResult?.[\n                                        this._config.titleProperty\n                                      ] === item[this._config.titleProperty]\n                                        ? \"highlighted\"\n                                        : (nothing as null)}\n                                    >\n                                      <label>\n                                        <input\n                                          data-cy=\"result-radio\"\n                                          type=\"radio\"\n                                          class=\"result-radio\"\n                                          name=\"result\"\n                                          id=\"${<string>item.id}\"\n                                          ?checked=${this.selectedResult?.[\n                                            this._config.titleProperty\n                                          ] ===\n                                            item[this._config.titleProperty] ||\n                                          (nothing as null)}\n                                          @click=${() => {\n                                            this.selectedResult = item;\n                                            this._config.onSelect(item);\n                                          }}\n                                        />\n                                        ${when(\n                                          this.hasTemplate(\"result\"),\n                                          () =>\n                                            this.renderTemplate(\n                                              \"result\",\n                                              item,\n                                              `result-${item.id}`\n                                            ),\n                                          () => html`\n                                            <span class=\"title\"\n                                              >${unsafeHTML(\n                                                <string>(\n                                                  item[\n                                                    this._config.titleProperty\n                                                  ]\n                                                )\n                                              )}</span\n                                            >\n                                          `\n                                        )}\n                                      </label>\n                                    </li>\n                                  `\n                                )}\n                              </ul>\n                            </details>`\n                          )\n                        : map(\n                            this.results,\n                            (item: Item) =>\n                              html`<li part=\"result\">\n                                <label>\n                                  <input\n                                    type=\"radio\"\n                                    name=\"result\"\n                                    id=\"${<string>item.id}\"\n                                    @click=${() => {\n                                      this.selectedResult = item;\n                                      this._config.onSelect(item);\n                                    }}\n                                  />\n                                  ${when(\n                                    this.hasTemplate(\"result\"),\n                                    () =>\n                                      this.renderTemplate(\n                                        \"result\",\n                                        item,\n                                        `result-${item.id}`\n                                      ),\n                                    () => html`\n                                      <span class=\"title\"\n                                        >${unsafeHTML(\n                                          <string>(\n                                            item[this._config.titleProperty]\n                                          )\n                                        )}</span\n                                      >\n                                    `\n                                  )}\n                                </label>\n                              </li>`\n                          )}\n                    </ul>\n                  </div>\n                </section>\n              `\n            )}\n          `\n        )}\n      </form>\n    `;\n  }\n}\n"],"names":["u","s","t","r","l","c","o","i","d","p","a","h","v","m","y","x","j","k","w","e","n","f","style","styleEOX","button","checkbox","radio","slider","EOxItemFilterExpandContainer","LitElement","event","html","nothing","__decorateClass","property","customElement","resetFilter","filterObject","filter","key","min","max","round","floor","createCoords","getSide","placement","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","getAlignmentAxis","rectToClientRect","rect","computeCoordsFromPlacement","_ref","rtl","reference","floating","sideAxis","alignmentAxis","alignLength","side","isVertical","commonX","commonY","commonAlign","coords","computePosition","config","strategy","middleware","platform","validMiddleware","rects","statefulPlacement","middlewareData","resetCount","name","fn","nextX","nextY","data","reset","getNodeName","node","isNode","getWindow","_node$ownerDocument","getDocumentElement","value","isElement","isHTMLElement","isShadowRoot","isOverflowElement","element","overflow","overflowX","overflowY","display","getComputedStyle","isTableElement","isContainingBlock","webkit","isWebKit","css","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","getNodeScroll","result","getNearestOverflowAncestor","parentNode","getOverflowAncestors","list","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","getCssDimensions","width","height","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","getScale","domElement","$","noOffsets","getVisualOffsets","shouldAddVisualOffsets","isFixed","floatingOffsetParent","getBoundingClientRect","includeScale","isFixedStrategy","offsetParent","clientRect","scale","visualOffsets","offsetWin","currentIFrame","iframeScale","iframeRect","left","top","convertOffsetParentRelativeRectToViewportRelativeRect","isOffsetParentAnElement","documentElement","scroll","offsets","offsetRect","getClientRects","getWindowScrollBarX","getDocumentRect","body","getViewportRect","visualViewport","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","getClippingElementAncestors","cache","cachedResult","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingRect","boundary","rootBoundary","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getDimensions","getRectRelativeToOffsetParent","getTrueOffsetParent","polyfill","getOffsetParent","window","getElementRects","getOffsetParentFn","getDimensionsFn","isRTL","observeMove","onMove","io","timeoutId","root","cleanup","refresh","skip","threshold","insetTop","insetRight","insetBottom","insetLeft","options","isFirstUpdate","handleObserve","entries","ratio","autoUpdate","update","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","cleanupIo","reobserveFrame","resizeObserver","firstEntry","frameId","prevRefRect","frameLoop","nextRefRect","mergedOptions","platformWithCache","computePosition$1","EOxDropdown","code","trigger","dropdown","updatePosition","changedProperties","EOxItemFilterChips","textValue","highlightedChip","lastChip","highlightedChipIndex","map","item","evt","chip","when","EOxAutocomplete","_a","_b","_d","_c","items","updatedProperties","state","EOxSelectionlist","currentlyHighlighted","currentItem","listItems","currentIndex","currentListItem","selected","firstItem","repeat","EOxItemFilterMultiselect","b","selectedItems","FUNC_ERROR_TEXT","NAN","symbolTag","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","freeGlobal","global","freeSelf","objectProto","objectToString","nativeMax","nativeMin","now","debounce","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","toNumber","isObject","invokeFunc","time","args","thisArg","leadingEdge","timerExpired","remainingWait","timeSinceLastCall","timeSinceLastInvoke","shouldInvoke","trailingEdge","cancel","flush","debounced","isInvoking","type","isObjectLike","isSymbol","other","isBinary","lodash_debounce","EOxItemFilterRange","dayjs","_debounce","EOxItemFilterSelect","earthRadius","factors","unitsFactors","areaFactors","feature","geom","properties","feat","geometry","coordinates","_options","point","lineString","polygon","multiPoint","multiLineString","multiPolygon","isNumber","points","featureCollection","_i","coordinates_1","ring","polygons","lineStrings","features","fc","geometryCollection","geometries","num","precision","multiplier","radiansToLength","radians","units","factor","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","degrees","degreesToRadians","convertLength","length","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","input","validateBBox","bbox","validateId","id","getCoord","coord","getCoords","getGeom","geojson","booleanPointInPolygon","pt","polys","inBBox","insidePoly","inRing","inHole","ignoreBoundary","isInside","xi","yi","xj","yj","onBoundary","intersect","coordEach","callback","excludeWrapCoord","stopG","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","coordReduce","initialValue","previousValue","currentCoord","propEach","propReduce","currentProperties","featureEach","featureReduce","currentFeature","coordAll","geomEach","g","featureProperties","featureBBox","featureId","geomReduce","currentGeometry","flattenEach","coordinate","flattenReduce","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","featureIndexCoord","multiPartIndexCoord","currentSegment","segmentReduce","started","lineEach","lineReduce","currentLine","findSegment","findPoint","lineSegment","results","lineSegmentFeature","segments","createSegments","segment","currentCoords","coords1","coords2","x1","y1","x2","y2","west","south","east","north","rbush","require$$0","helpers","require$$1","meta","require$$2","turfBBox","require$$3","geojsonRbush","maxEntries","tree","load","equals","json","geojsonRbushModule","lineIntersect","line1","line2","unique","intersects","match","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","polygonToLine","poly","multiPolygonToLine","coordsToLine","multiPoly","lines","booleanDisjoint","feature1","feature2","bool","flatten1","flatten2","disjoint","geom1","geom2","compareCoords","isPointOnLine","isLineOnLine","isLineInPoly","isPolyInPoly","isPointOnLineSegment","lineString1","lineString2","doLinesIntersect","coord1","coord2","lineSegmentStart","lineSegmentEnd","dxc","dyc","dxl","dyl","cross","pair1","pair2","booleanIntersects","booleanPointOnLine","line","ptCoords","lineCoords","excludeBoundary","epsilon","booleanWithin","type1","type2","isPointInMultiPoint","isMultiPointInMultiPoint","isMultiPointOnLine","isMultiPointInPoly","output","multiPoint1","multiPoint2","anyMatch","i2","foundInsidePoint","linestring","polyBbox","calcBbox","lineBbox","doBBoxOverlap","midpoint","getMidpoint","geometry1","geometry2","poly1Bbox","poly2Bbox","bbox1","bbox2","itemGeometry","filterGeometry","within","EOxItemFilterSpatial","mode","SpatialFilter","mapLayers","updateGeometryFilter","source","EOxItemFilterText","searchInput","EOxItemFilterInline","inProgressItem","textInProgress","inputEl","highlightedLiItem","_f","_e","foundInput","found","staticHTML","unsafeStatic","isArray","getTag","INFINITY","baseToString","toString","isString","isBoolean","isDefined","isBlank","INCORRECT_INDEX_TYPE","LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY","PATTERN_LENGTH_TOO_LARGE","MISSING_KEY_PROPERTY","INVALID_KEY_WEIGHT_VALUE","hasOwn","KeyStore","keys","totalWeight","obj","createKey","keyId","path","src","weight","getFn","createKeyPath","createKeyId","get","arr","deepGet","index","len","MatchOptions","BasicOptions","FuzzyOptions","AdvancedOptions","Config","SPACE","norm","mantissa","numTokens","FuseIndex","fieldNormWeight","docs","records","idx","doc","docIndex","record","keyIndex","subRecords","stack","nestedArrIndex","subRecord","createIndex","myIndex","parseIndex","computeScore$1","pattern","errors","currentLocation","expectedLocation","ignoreLocation","accuracy","proximity","convertMaskToIndices","matchmask","minMatchCharLength","indices","start","end","MAX_BITS","search","text","patternAlphabet","location","findAllMatches","includeMatches","patternLen","textLen","currentThreshold","bestLocation","computeMatches","matchMask","score","lastBitArr","finalScore","binMax","mask","binMin","binMid","finish","bitArr","charMatch","createPatternAlphabet","char","BitapSearch","isCaseSensitive","addChunk","startIndex","remainder","allIndices","totalScore","hasMatches","alphabet","isMatch","BaseMatch","getMatch","exp","matches","ExactMatch","InverseExactMatch","PrefixExactMatch","InversePrefixExactMatch","SuffixExactMatch","InverseSuffixExactMatch","FuzzyMatch","IncludeMatch","searchers","searchersLen","SPACE_RE","OR_TOKEN","parseQuery","query","queryItem","searcher","token","MultiMatchSet","ExtendedSearch","_","numMatches","qLen","pLen","registeredSearchers","register","createSearcher","searcherClass","LogicalOperator","KeyType","isExpression","isPath","isLeaf","convertToExplicit","parse","auto","next","isQueryPath","computeScore","ignoreFieldNorm","transformMatches","transformScore","format","includeScore","transformers","transformer","Fuse","predicate","limit","shouldSort","sortFn","expression","evaluate","res","child","resultMap","expResults","highlight","fuseSearchResult","highlightClassName","matchKey","set","pathValue","generateHighlightedText","inputText","regions","content","nextUnhighlightedRegionStartingIndex","region","lastRegionNextIndex","highlightedItem","_fuse","indexItems","fuseConfig","filters","parsedFilters","store","operator","holding","createProperty","pKey","pVal","parameters","response","rangeFilters","acc","filteredResults","pass","parseValue","spatialFilters","ElementConfig","EOxItemFilter","TemplateElement","filterProperty","filterKeys","currentValues","currentValue","prop","fuseKeys","oldValue","filterExternal","filterClient","aggregation","currentFilter","detailsElement","container","details","aggregationProperty","unsafeHTML"],"mappings":"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","x_google_ignoreList":[0,5,6,7,8,14,17,18,19,20,21,22,23,24,25,26,27,28,29,33]}