function s(o,n){let t=o.length-n,a=0;do{for(let r=n;r>0;r--)o[a+n]+=o[a],a++;t-=n}while(t>0)}function h(o,n,t){let a=0,r=o.length;const l=r/t;for(;r>n;){for(let e=n;e>0;--e)o[a+n]+=o[a],++a;r-=n}const i=o.slice();for(let e=0;e<l;++e)for(let c=0;c<t;++c)o[t*e+c]=i[(t-c-1)*l+e]}function d(o,n,t,a,r,l){if(!n||n===1)return o;for(let c=0;c<r.length;++c){if(r[c]%8!==0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(r[c]!==r[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const i=r[0]/8,e=l===2?1:r.length;for(let c=0;c<a&&!(c*e*t*i>=o.byteLength);++c){let f;if(n===2){switch(r[0]){case 8:f=new Uint8Array(o,c*e*t*i,e*t*i);break;case 16:f=new Uint16Array(o,c*e*t*i,e*t*i/2);break;case 32:f=new Uint32Array(o,c*e*t*i,e*t*i/4);break;default:throw new Error(`Predictor 2 not allowed with ${r[0]} bits per sample.`)}s(f,e)}else n===3&&(f=new Uint8Array(o,c*e*t*i,e*t*i),h(f,e,i))}return o}class u{constructor(n){this.parameters=n}decodeBlock(n){throw new Error("decodeBlock not implemented")}async decode(n){const t=await this.decodeBlock(n),{tileWidth:a,tileHeight:r,predictor:l,bitsPerSample:i,planarConfiguration:e}=this.parameters;return l!==1?d(t,l,a,r,i,e):t}}export{u as B};
