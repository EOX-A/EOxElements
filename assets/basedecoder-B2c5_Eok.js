function l(o,n){let t=o.length-n,s=0;do{for(let a=n;a>0;a--)o[s+n]+=o[s],s++;t-=n}while(t>0)}function d(o,n,t){let s=0,a=o.length;const i=a/t;for(;a>n;){for(let e=n;e>0;--e)o[s+n]+=o[s],++s;a-=n}const r=o.slice();for(let e=0;e<i;++e)for(let c=0;c<t;++c)o[t*e+c]=r[(t-c-1)*i+e]}function f(o,n,t,s,a,i){if(n===1)return o;for(let c=0;c<a.length;++c){if(a[c]%8!==0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(a[c]!==a[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const r=a[0]/8,e=i===2?1:a.length;for(let c=0;c<s&&!(c*e*t*r>=o.byteLength);++c){let h;if(n===2){switch(a[0]){case 8:h=new Uint8Array(o,c*e*t*r,e*t*r);break;case 16:h=new Uint16Array(o,c*e*t*r,e*t*r/2);break;case 32:h=new Uint32Array(o,c*e*t*r,e*t*r/4);break;default:throw new Error(`Predictor 2 not allowed with ${a[0]} bits per sample.`)}l(h,e)}else n===3&&(h=new Uint8Array(o,c*e*t*r,e*t*r),d(h,e,r))}return o}class g{async decode(n,t){const s=await this.decodeBlock(t),a=n.Predictor||1;if(a!==1){const i=!n.StripOffsets,r=i?n.TileWidth:n.ImageWidth,e=i?n.TileLength:n.RowsPerStrip||n.ImageLength;return f(s,a,r,e,n.BitsPerSample,n.PlanarConfiguration)}return s}}export{g as B};
